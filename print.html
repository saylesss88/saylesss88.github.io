<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>nix-book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A collection of Nix insights">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">nix-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-1"><a class="header" href="#chapter-1">Chapter 1</a></h1>
<h2 id="getting-started-with-the-nix-language"><a class="header" href="#getting-started-with-the-nix-language">Getting Started with the Nix Language</a></h2>
<p><img src="images/gruv13.png" alt="window_view" /></p>
<p>Welcome to the world of Nix, a powerful tool for reproducible and declarative
software management. In this chapter, we’ll explore the basics of the Nix
programming language, a pure, functional, and declarative language that
underpins Nix’s package manager and operating system. By the end, you’ll
understand Nix’s core concepts, syntax, and how to write simple expressions
and derivations.</p>
<blockquote>
<p>[!TIP]
If you’re new to Nix, think of it as a recipe book for software: you describe
what you want (declarative), and Nix ensures it’s built the same way every
time (reproducible).</p>
</blockquote>
<h2 id="why-learn-nix"><a class="header" href="#why-learn-nix">Why Learn Nix?</a></h2>
<p>Nix is unique because it guarantees reproducible builds, isolates dependencies,
and allows you to describe complex systems declaratively. Whether you’re
managing packages, configuring servers, or developing software, Nix’s language
is the foundation for creating reliable and repeatable environments. This
chapter lays the groundwork for using Nix effectively.</p>
<h2 id="nix-language-at-a-glance"><a class="header" href="#nix-language-at-a-glance">Nix Language at a Glance</a></h2>
<p>Nix is often described as “JSON with functions.” It’s a declarative language
where you define outcomes, not step-by-step instructions. Instead of writing
sequential code, you create expressions that describe data structures,
functions, and dependencies. These expressions are evaluated lazily, meaning
Nix computes values only when needed, making it efficient for managing large
systems.</p>
<p>Let’s dive into the key characteristics of Nix:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Concept</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td><strong>Pure</strong></td><td>Functions have no side effects, ensuring predictable results.</td></tr>
<tr><td><strong>Functional</strong></td><td>Functions can be passed as arguments or returned, enabling flexible composition.</td></tr>
<tr><td><strong>Lazy</strong></td><td>Expressions are evaluated only when their results are needed.</td></tr>
<tr><td><strong>Declarative</strong></td><td>You describe the desired outcome, not how to achieve it.</td></tr>
<tr><td><strong>Reproducible</strong></td><td>The same inputs always produce the same outputs, ensuring consistency.</td></tr>
</tbody></table>
</div>
<blockquote>
<p>❗ Important: In Nix, everything is an expression, there are no statements.</p>
<p>❗ Important: Values in Nix are immutable.</p>
</blockquote>
<h2 id="syntax-basics"><a class="header" href="#syntax-basics">Syntax Basics</a></h2>
<p>Let’s explore the building blocks of Nix’s syntax. We’ll cover identifiers,
strings, attribute sets, and basic expressions, with examples to illustrate
each concept.</p>
<p><img src="images/lambda1.png" alt="window_view" /></p>
<ul>
<li>
<p><a href="https://nix.dev/manual/nix/2.24/language/">Nix Language Overview</a></p>
</li>
<li>
<p><a href="https://nixos.org/guides/nix-pills/04-basics-of-language">Basics of the Language Pill</a></p>
</li>
<li>
<p>Dashes are allowed as identifiers:</p>
</li>
</ul>
<pre><code class="language-nix">nix-repl&gt; a-b
error: undefined variable `a-b' at (string):1:1
nix-repl&gt; a - b
error: undefined variable `a' at (string):1:1
</code></pre>
<blockquote>
<p><strong>Warning</strong>: <code>a-b</code> is parsed as an identifier, not as subtraction.</p>
</blockquote>
<ul>
<li><strong>Strings</strong>: Strings are enclosed in double quotes (<code>"</code>) or two single quotes
(<code>''</code>).</li>
</ul>
<pre><code class="language-nix">nix-repl&gt; "stringDaddy"
"stringDaddy"
nix-repl&gt; ''stringMoma''
"stringMoma"
</code></pre>
<p><strong>String Interpolation</strong>: allows you to embed expressions in strings using <code>${}</code>
<a href="https://nix.dev/manual/nix/2.24/language/string-interpolation">string interpolation</a>.</p>
<p>Rather than writing:</p>
<pre><code class="language-nix">let path = "/usr/local"; in "--prefix=${path}"
</code></pre>
<ul>
<li>
<p>This evaluates to <code>"--prefix=/usr/local"</code>. Interpolated expressions must
evaluate to a string, path, or an attribute set with an <code>outPath</code> or
<code>__toString</code> attribute.</p>
</li>
<li>
<p><strong>Attribute sets</strong> are all over Nix code, they are name-value pairs wrapped
in curly braces, where the names must be unique:</p>
</li>
</ul>
<pre><code class="language-nix">{
  string = "hello";
  int = 8;
}
</code></pre>
<ul>
<li>Attribute names usually don't need quotes.</li>
</ul>
<p>You can access attributes using dot notation:</p>
<pre><code class="language-nix">let person = { name = "Alice"; age = 30; }; in person.name
"Alice"
</code></pre>
<p>You will sometimes see attribute sets with <code>rec</code> prepended. This allows access
to attributes within the set:</p>
<pre><code class="language-nix">rec {
  one = 1;
  two = one + 1;
  three = two + 1;
}
</code></pre>
<ul>
<li>Without <code>rec</code>, this command would fail because we are trying to use an attribute that is defined within this attribute set. You would get an undefined variable 'one' error.</li>
</ul>
<p><strong>Inheriting Attributes</strong></p>
<pre><code class="language-nix">let x = 123; in
{
  inherit x;
  y = 456;
}
</code></pre>
<p>is equivalent to</p>
<pre><code class="language-nix">let x = 123; in
{
  x = x;
  y = 456;
}
</code></pre>
<p>Both evaluate to:</p>
<pre><code class="language-nix">{ x = 123; y = 456; }
</code></pre>
<blockquote>
<p>❗: This works because <code>x</code> is added to the lexical scope by the <code>let</code> construct.</p>
</blockquote>
<h2 id="control-flow-with-expressions"><a class="header" href="#control-flow-with-expressions">Control Flow with Expressions</a></h2>
<p><strong>If expressions</strong>:</p>
<pre><code class="language-nix">nix-repl&gt; a = 6
nix-repl&gt; b = 10
nix-repl&gt; if a &gt; b then "yes" else "no"
"no"
</code></pre>
<p><strong>Let expressions</strong>:</p>
<pre><code class="language-nix">let a = "foo"; b = "fighter"; in a + b
"foofighter"
</code></pre>
<pre><code class="language-nix"># flake.nix
outputs = my-inputs @ {
  self,
  nixpkgs,
  treefmt-nix,
  ...
}: let
     system = "x86_64-linux";
     host = "magic";
in {
  ## Outputs go here
}
</code></pre>
<pre><code class="language-nix"># nvf.nix
{ pkgs, inputs, config, lib, ... }: let
  cfg = config.custom.nvfModule;
in {
  options.custom.nvfModule.enable = lib.mkOption {
    type = lib.types.bool;
    default = false;
    description = "Enable the nvf nvim configuration";
  };
}
</code></pre>
<p><strong>With expressions</strong>:</p>
<pre><code class="language-nix">nix-repl&gt; longName = { a = 3; b = 4; }
nix-repl&gt; longName.a + longName.b
7
nix-repl&gt; with longName; a + b
7
</code></pre>
<pre><code class="language-nix"># utils.nix
{ pkgs, ... }: {
  environment.systemPackages = with pkgs; [
    rustup
    evcxr
    nix-prefetch-git
  ];
}
</code></pre>
<p><strong>Laziness</strong>:</p>
<ul>
<li>Nix evaluates expressions only when needed. This is a great feature when working
with packages.</li>
</ul>
<pre><code class="language-nix">nix-repl&gt; let a = builtins.div 4 0; b = 6; in b
6
</code></pre>
<ul>
<li>Since <code>a</code> isn't needed, there's no error about division by zero, because the
expression is not in need to be evaluated. That's why we can have all the
packages defined on demand, yet have acces to specific packages very quickly.
Some of these examples came from the Nix pill series.</li>
</ul>
<h2 id="functions"><a class="header" href="#functions">Functions:</a></h2>
<p>The code below calls a function called <code>my_function</code> with the parameters <code>2</code> and
<code>3</code>, and assigns its output to the <code>my_value</code> field:</p>
<pre><code class="language-nix">{
  my_value = my_function 2 3;
}
</code></pre>
<p>Functions are defined using this syntax, where <code>x</code> and <code>y</code> are attributes passed
into the function:</p>
<pre><code class="language-nix">{
  my_function = x: y: x + y;
}
</code></pre>
<ul>
<li>The body of the function automatically returns the result of the function.
Functions are called by spaces between it and its parameters. No commas are
needed to separate parameters.</li>
</ul>
<pre><code class="language-nix">let negate = x: !x;
    concat = x: y: x + y;
in if negate true then concat "foo" "bar" else ""

negate = x: !x;
</code></pre>
<p>This defines a function named <code>negate</code> that takes one argument <code>x</code> and returns
its logical negation (using <code>!</code>)</p>
<ul>
<li>
<p><code>concat = x: y: x + y</code> defines a function that takes two arguments, <code>x</code> and
<code>y</code>, and returns their string concatenation. Notice how Nix handles
multi-argument functions through currying -- it's a function that returns
another function. This was a little confusing to me, I'm thinking how does
it return a function if <code>concat 1 2</code> returns <code>3</code>...</p>
<ul>
<li>
<p><code>x: ...</code>: This part says that <code>concat</code> takes one argument, which we've
named <code>x</code>.</p>
</li>
<li>
<p><code>y: x + y</code>: The result of the first part isn't the final value. Instead,
it's another function. This inner function takes one argument, which we've
named <code>y</code>, and then it adds <code>x</code> and <code>y</code>.</p>
</li>
<li>
<p>When you do <code>concat 1</code> you're applying the <code>concat</code> function to the argument
<code>1</code>. This returns the inner function, where <code>x</code> is now fixed as <code>1</code>. The
inner function is essentially waiting for its <code>y</code> argument to be provided.</p>
</li>
<li>
<p>It's when you apply the second argument, <code>2</code>, to this resulting function
<code>(concat 1) 2</code> that the addition <code>1 + 2</code> finally happens, giving us <code>3</code>.</p>
</li>
</ul>
</li>
</ul>
<p>It's like a chain of function applications:</p>
<ul>
<li>
<p><code>concat</code> takes <code>x</code> and returns a new function.</p>
</li>
<li>
<p>This new function takes <code>y</code> and returns the result of <code>x + y</code>.</p>
</li>
</ul>
<h2 id="inheriting-attributes"><a class="header" href="#inheriting-attributes">Inheriting Attributes</a></h2>
<pre><code class="language-nix">inherit x y z;
inherit (src-set) a b c;
</code></pre>
<p>is equivalent to:</p>
<pre><code class="language-nix">x = x; y = y; z = z;
a = src-set.a; b = src-set.b; c = src-set.c
</code></pre>
<p>In a <code>let</code> expression, <code>inherit</code> can be used to selectively bring specific attributes of a set into scope:</p>
<pre><code class="language-nix">let
  x = { a = 1; b = 2; };
  inherit (builtins) attrNames;
in
{
  names = attrNames x;
}
</code></pre>
<p>is equivalent to:</p>
<pre><code class="language-nix">let
  x = { a = 1; b = 2; };
in
{
  names = builtins.attrNames x;
}
</code></pre>
<p>Both evaluate to:</p>
<pre><code class="language-nix">{ names [ "a" "b" ]; }
</code></pre>
<h3 id="derivations"><a class="header" href="#derivations">Derivations</a></h3>
<p><img src="images/nix99.png" alt="nix99" /></p>
<ul>
<li>
<p>In Nix, the process of managing software starts with package definitions.
These are files written in the Nix language that describe how a particular
piece of software should be built. These package definitions, when processed
by Nix, are translated into derivations.</p>
</li>
<li>
<p>At its core, a derivation in Nix is a blueprint or a recipe that describes how
to build a specific software package or any other kind of file or directory.
It's a declarative specification of:</p>
</li>
<li>
<p><strong>Inputs</strong>: What existing files or other derivations are needed as dependencies.</p>
</li>
<li>
<p><strong>Build Steps</strong>: The commands that need to be executed to produce the desired
output.</p>
</li>
<li>
<p><strong>Environment</strong>: The specific environment (e.g., build tools, environment
variables) required for the build process.</p>
</li>
<li>
<p><strong>Outputs</strong>: The resulting files or directories that the derivation produces.</p>
</li>
</ul>
<p>Think of a package definition as the initial instructions, and the derivation as
the detailed, low-level plan that Nix uses to actually perform the build."</p>
<p>Again, a derivation is like a blueprint that describes how to build a specific
software package or any other kind of file or directory.</p>
<p><strong>Key Characteristics of Derivations:</strong></p>
<ul>
<li>
<p><strong>Declarative</strong>: You describe the desired outcome and the inputs, not the exact
sequence of imperative steps. Nix figures out the necessary steps based on the
builder and args.</p>
</li>
<li>
<p><strong>Reproducible</strong>: Given the same inputs and build instructions, a derivation will
always produce the same output. This is a cornerstone of Nix's reproducibility.</p>
</li>
<li>
<p><strong>Tracked by Nix</strong>: Nix keeps track of all derivations and their outputs in the
Nix store. This allows for efficient management of dependencies and ensures
that different packages don't interfere with each other.</p>
</li>
<li>
<p><strong>Content-Addressed</strong>: The output of a derivation is stored in the Nix store under
a unique path that is derived from the hash of all its inputs and build
instructions. This means that if anything changes in the derivation, the
output will have a different path.</p>
</li>
</ul>
<p><strong>Hello World Derivation Example</strong>:</p>
<pre><code class="language-nix">{ pkgs ? import &lt;nixpkgs&gt; {} }:

pkgs.stdenv.mkDerivation {
  name = "hello-world";
  src = null; # No source code needed

  buildPhase = ''
    echo "Hello, World!" &gt; $out
  '';

  installPhase = ''
    mkdir -p $out/bin
    cp $out $out/bin/hello
    chmod +x $out/bin/hello
  '';

  meta = {
    description = "A simple Hello World program built with Nix";
    homepage = null;
    license = lib.licenses.unfree; # For simplicity
    maintainers = [];
  };
}
</code></pre>
<ul>
<li>
<p><code>{ pkgs ? import &lt;nixpkgs&gt; {} }</code>: This is a function that takes an optional
argument <code>pkgs</code>. We need Nixpkgs to access standard build environments like
<code>stdenv</code>.</p>
</li>
<li>
<p><code>pkgs.stdenv.mkDerivation { ... }:</code> This calls the mkDerivation function from
the standard environment (stdenv). mkDerivation is the most common way to
define software packages in Nix.</p>
</li>
<li>
<p><code>name = "hello-world";</code>: Human-readable name of the derivation</p>
</li>
<li>
<p><code>src = null</code>: No external source code for this simple example</p>
</li>
<li>
<p>The rest are the build phases and package metadata.</p>
</li>
</ul>
<p>To use the above derivation, save it as a <code>.nix</code> file (e.g. <code>hello.nix</code>). Then
build the derivation using:</p>
<pre><code class="language-bash">nix build ./hello.nix
</code></pre>
<ul>
<li>
<p>Nix will execute the <code>buildPhase</code> and <code>installPhase</code></p>
</li>
<li>
<p>After a successful build, the output will be in the Nix store. You can find
the exact path by looking at the output of the nix build command (it will be
something like <code>/nix/store/your-hash-hello-world</code>).</p>
</li>
</ul>
<p>Run the "installed" program:</p>
<pre><code class="language-bash">./result/bin/hello
</code></pre>
<ul>
<li>This will execute the <code>hello</code> file from the Nix store and print "Hello, World!".</li>
</ul>
<p>Here's a simple Nix derivation that creates a file named hello in the Nix store
containing the text "Hello, World!":</p>
<h3 id="evaluating-nix-files"><a class="header" href="#evaluating-nix-files">Evaluating Nix Files</a></h3>
<p>Use <code>nix-instantiate --eval</code> to evaluate the expression in a Nix file:</p>
<pre><code class="language-bash">echo 1 + 2 &gt; file.nix
nix-instantiate --eval file.nix
3
</code></pre>
<blockquote>
<p><strong>Note:</strong> <code>--eval</code> is required to evaluate the file and do nothing else. If
<code>--eval</code> is omitted, <code>nix-instantiate</code> expects the expression in the given file
to evaluate to a derivation.</p>
</blockquote>
<p>If you don't specify an argument, <code>nix-instantiate --eval</code> will try to read from
<code>default.nix</code> in the current directory.</p>
<h3 id="resources"><a class="header" href="#resources">Resources</a></h3>
<ul>
<li>
<p><a href="https://nix.dev/tutorials/nix-language.html">nix.dev nixlang-basics</a></p>
</li>
<li>
<p><a href="https://learnxinyminutes.com/nix/">learn nix in y minutes</a></p>
</li>
<li>
<p><a href="https://github.com/tazjin/nix-1p">nix onepager</a></p>
</li>
<li>
<p><a href="https://github.com/nix-community/awesome-nix">awesome-nix</a></p>
</li>
<li>
<p><a href="https://zero-to-nix.com/concepts/nix-language/">zero-to-nix nix lang</a></p>
</li>
<li>
<p><a href="https://nixos.org/guides/nix-pills/04-basics-of-language.html">nix-pills basics of nixlang</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2"><a class="header" href="#chapter-2">Chapter 2</a></h1>
<h2 id="understanding-nix-functions"><a class="header" href="#understanding-nix-functions">Understanding Nix Functions</a></h2>
<p><img src="images/nixLogo.png" alt="NixFlakeLogo" /></p>
<p>Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.</p>
<h2 id="the-single-argument-nature-of-nix-functions"><a class="header" href="#the-single-argument-nature-of-nix-functions">The Single-Argument Nature of Nix Functions</a></h2>
<p>A key concept to understand is that in Nix, every function conceptually takes <strong>exactly one argument</strong>. What might appear as multi-argument functions are actually achieved through a technique called <strong>currying</strong>, where a series of nested single-argument functions are used.</p>
<h2 id="identifying-function-structure-the-colon"><a class="header" href="#identifying-function-structure-the-colon">Identifying Function Structure The Colon</a></h2>
<p>The colon (<code>:</code>) acts as a clear separator within a function definition:</p>
<ul>
<li><strong>Left of the Colon:</strong> This is the function's <strong>argument</strong>. It's a placeholder name for a value that will be provided when the function is called.</li>
<li><strong>Right of the Colon:</strong> This is the <strong>function body</strong>. It's the expression that will be evaluated when the function is invoked.</li>
</ul>
<p><strong>Think of function arguments as naming values that aren't known in advance.</strong> These names are placeholders that get filled with specific values when the function is used.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-nix">greet = personName: "Hello, ${personName}!";
</code></pre>
<ul>
<li>
<p>Here, <code>personName</code> is the <strong>argument</strong> (the placeholder).</p>
</li>
<li>
<p><code>"Hello, ${personName}!"</code>, is the <strong>function body</strong> (the expression that
uses the placeholder).</p>
</li>
</ul>
<p>When you call the function:</p>
<pre><code class="language-nix">greet "Anonymous"  # Evaluates to "Hello, Anonymous!"
</code></pre>
<p>The value <code>"Anonymous"</code> is substituted for the <code>personName</code> placeholder within
the function body.</p>
<h2 id="function-declarations-single-and-multiple-arguments"><a class="header" href="#function-declarations-single-and-multiple-arguments">Function Declarations Single and "Multiple" Arguments</a></h2>
<p><strong>Single-Argument Functions</strong></p>
<p>The simplest form of a Nix function takes a single argument:</p>
<pre><code class="language-nix">inc = x: x + 1;
inc 5  # Evaluates to 6
</code></pre>
<ul>
<li>
<p><code>x</code> is the argument.</p>
</li>
<li>
<p><code>x + 1</code> is the function body.</p>
</li>
</ul>
<p><strong>Simulating Multiple Arguments: Currying</strong></p>
<p>To create functions that appear to take multiple arguments, Nix uses currying.
This involves nesting single-argument functions, where each function takes one
argument and returns another function that takes the next argument, and so on.</p>
<pre><code class="language-nix">concat = x: y: x + y;
concat 6 6    # Evaluates to 12
</code></pre>
<p>Nix interprets the colons as separators for this chain of single-argument
functions.</p>
<p><strong>Understanding the Chain:</strong></p>
<p>Consider the <code>greeting</code> function:</p>
<pre><code class="language-nix">greeting = prefix: name: "${prefix}, ${name}!";
</code></pre>
<p>This is effectively a chain:</p>
<ol>
<li><strong>Outer Function</strong>: <code>prefix: (name: "${prefix}, ${name}!")</code></li>
</ol>
<ul>
<li>
<p>Takes one argument: <code>prefix</code>.</p>
</li>
<li>
<p>Its body is another function definition: name: <code>"${prefix}, ${name}!"</code>.</p>
</li>
</ul>
<p>2 <strong>Inner Function:</strong> <code>name: "${prefix}, ${name}!"</code></p>
<ul>
<li>
<p>Takes one argument: <code>name</code>.</p>
</li>
<li>
<p>Its body uses both its own argument (<code>name</code>) and the argument from the
outer function's scope (prefix).</p>
</li>
</ul>
<p><strong>Step-by-Step Evaluation:</strong></p>
<p>When you call <code>greeting "Hello" "Alice"</code>:</p>
<ol>
<li><code>greeting "Hello"</code>:</li>
</ol>
<ul>
<li>
<p>The <code>greeting</code> function is called with <code>"Hello"</code> as the <code>prefix</code>.</p>
</li>
<li>
<p>The outer function returns the inner function:
<code>name: "Hello, ${name}!"</code> (where <code>prefix</code> is now fixed as `"Hello"`` in its
scope).</p>
</li>
</ul>
<ol start="2">
<li><code>(greeting "Hello") "Alice"</code>:</li>
</ol>
<ul>
<li>
<p>The resulting inner function is then called with <code>"Alice"</code> as the <code>name</code>.</p>
</li>
<li>
<p>The inner function evaluates its body: <code>"Hello, ${"Alice"}!"</code>, resulting in
<code>"Hello, Alice!"</code>.</p>
</li>
</ul>
<p><strong>Key Insight</strong>: Every colon in a function definition separates a single
argument from its function body, even if that body is another function
definition.</p>
<p><strong>Partial Application: Using Functions Incrementally</strong></p>
<p>Because of currying, you can apply arguments to a Nix function one at a time.
This is called partial application. When you provide only some of the expected
arguments, you get a new function that "remembers" the provided arguments and
waits for the rest.</p>
<p><strong>Example:</strong></p>
<p>Using our <code>greeting</code> function again:</p>
<pre><code class="language-nix">greeting = prefix: name: "${prefix}, ${name}!";
</code></pre>
<p>If we only provide the prefix:</p>
<pre><code class="language-nix">helloGreeting = greeting "Hello";
</code></pre>
<ul>
<li><code>helloGreeting</code> is now a new function. It has already received the <code>prefix</code>
argument (<code>"Hello"</code>) and is waiting for the <code>name</code> argument.</li>
</ul>
<p>Calling <code>helloGreeting</code>:</p>
<pre><code class="language-nix">helloGreeting "Sally" # Evaluates to "Hello, Sally!"
</code></pre>
<p><strong>Benefits of Partial Application:</strong></p>
<ul>
<li>
<p><strong>Creating Specialized Functions</strong>: You can create more specific functions
from general ones by fixing some of their parameters.</p>
</li>
<li>
<p><strong>Adapting to Higher-Order Functions</strong>: Many functions that operate on other
functions (like <code>map</code> and <code>filter</code>) expect functions with a certain number of
arguments. Partial application allows you to adapt existing functions to fit
these requirements.</p>
</li>
</ul>
<h3 id="the-function-nature-of-nixos-and-home-manager-modules"><a class="header" href="#the-function-nature-of-nixos-and-home-manager-modules">The Function Nature of NixOS and Home Manager Modules</a></h3>
<p>It's crucial to understand that most NixOS and Home Manager modules are
fundamentally <strong>functions</strong>.</p>
<ul>
<li>These module functions typically accept a single argument: an
<strong>attribute set</strong>.</li>
</ul>
<p><strong>Example</strong>:</p>
<p>A simplified Nginx service module:</p>
<pre><code class="language-nix">{ config, lib, pkgs, ... }: {
services.nginx.enable = true;
services.nginx.package = pkgs.nginx;
services.nginx.settings."http-port" = "8080";
}
</code></pre>
<ul>
<li>
<p>The entire module definition is a function that takes one argument:
<code>{ config, lib, pkgs, ... }</code>.</p>
</li>
<li>
<p>When this module is included in your configuration, the NixOS module system
calls this function with a specific attribute set. This attribute set contains
the current system configuration (<code>config</code>), the Nix standard library (<code>lib</code>),
the available packages (<code>pkgs</code>), and other relevant information. The module
then uses these values to define parts of your system.</p>
</li>
</ul>
<h3 id="resources-1"><a class="header" href="#resources-1">Resources</a></h3>
<ul>
<li>
<p><a href="https://nix.dev/tutorials/nix-language.html">nix.dev Nix Lang Basics</a></p>
</li>
<li>
<p><a href="https://nixos.org/guides/nix-pills/05-functions-and-imports.html">nix pills Functions and Imports</a></p>
</li>
<li>
<p><a href="https://zero-to-nix.com/concepts/nix-language/">zero-to-nix Nix Lang</a></p>
</li>
<li>
<p><a href="https://nixcloud.io/tour/?id=functions%2Fintroduction">A tour of Nix "Functions"</a></p>
</li>
<li>
<p><a href="https://learnxinyminutes.com/nix/">learn Nix in y minutes</a></p>
</li>
<li>
<p><a href="https://noogle.dev/">noogle function library</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3"><a class="header" href="#chapter-3">Chapter 3</a></h1>
<h2 id="nixos-modules-explained"><a class="header" href="#nixos-modules-explained">NixOS Modules Explained</a></h2>
<p><img src="images/gruv3.png" alt="gruv3" /></p>
<p>TL;DR: In this post I break down the NixOS module system and explain how to
define options. As well as how to test modules with the repl.</p>
<ul>
<li>Most modules are functions that take an attribute set and return an attribute
set.</li>
</ul>
<p><strong>Refresher</strong>:</p>
<ul>
<li>An <strong>attribute set</strong> is a collection of name-value pairs wrapped in curly
braces:</li>
</ul>
<pre><code class="language-nix">{
  string = "hello";
  int = 3;
}
</code></pre>
<ul>
<li>A <strong>function</strong> with an attribute set argument:</li>
</ul>
<pre><code class="language-nix">{ a, b }: a + b
</code></pre>
<ul>
<li>The simplest possible <strong>NixOS Module</strong>:</li>
</ul>
<pre><code class="language-nix">{ ... }:
{
}
</code></pre>
<p>NixOS produces a full system configuration by combining smaller, more isolated
and reusable components: <strong>Modules</strong>. In my opinion modules are one of the
first things you should understand when learning about NixOS.</p>
<ul>
<li>
<p>A NixOS module defines configuration options and behaviors for system
components, allowing users to extend, customize, and compose configurations
declaratively.</p>
</li>
<li>
<p>A <strong>module</strong> is a file containing a Nix expression with a specific structure.
It <em>declares</em> options for other modules to define (give a value). Modules were
introduced to allow extending NixOS without modifying its source code.</p>
</li>
<li>
<p>To define any values, the module system first has to know which ones are
allowed. This is done by declaring options that specify which attributes can
be set and used elsewhere.</p>
</li>
<li>
<p>If you want to write your own modules, I recommend setting up
<a href="https://github.com/nix-community/nixd?tab=readme-ov-file">nixd</a>
or <a href="https://github.com/oxalica/nil">nil</a> with your editor of choice.
This will allow your editor to warn you about missing arguments and
dependencies as well as syntax errors.</p>
</li>
</ul>
<h2 id="declaring-options"><a class="header" href="#declaring-options">Declaring Options</a></h2>
<p>The following is <code>nixpkgs/nixos/modules/programs/vim.nix</code>:</p>
<pre><code class="language-nix">{
  config,
  lib,
  pkgs,
  ...
}:

let
  cfg = config.programs.vim;
in
{
  options.programs.vim = {
    enable = lib.mkEnableOption "Vi IMproved, an advanced text";

    defaultEditor = lib.mkEnableOption "vim as the default editor";

    package = lib.mkPackageOption pkgs "vim" { example = "vim-full"; };
  };

  # TODO: convert it into assert after 24.11 release
  config = lib.mkIf (cfg.enable || cfg.defaultEditor) {
    warnings = lib.mkIf (cfg.defaultEditor &amp;&amp; !cfg.enable) [
      "programs.vim.defaultEditor will only work if programs.vim.enable is
       enabled, which will be enforced after the 24.11 release"
    ];
    environment = {
      systemPackages = [ cfg.package ];
      variables.EDITOR = lib.mkIf cfg.defaultEditor (lib.mkOverride 900 "vim");
      pathsToLink = [ "/share/vim-plugins" ];
    };
  };
}
</code></pre>
<ul>
<li>It provides options to enable Vim, set it as the default editor, and specify
the Vim package to use.</li>
</ul>
<ol>
<li>Module Inputs and Structure:</li>
</ol>
<pre><code class="language-nix">{
  config,
  lib,
  pkgs,
  ...
}
</code></pre>
<ul>
<li>
<p>Inputs: The module takes the above inputs and <code>...</code> (catch-all for other args)</p>
<ul>
<li>
<p><code>config</code>: Allows the module to read option values (e.g.
<code>config.programs.vim.enable</code>). It provides access to the evaluated
configuration.</p>
</li>
<li>
<p><code>lib</code>: The Nixpkgs library, giving us helper functions like <code>mkEnableOption</code>
, <code>mkIf</code>, and <code>mkOverride</code>.</p>
</li>
<li>
<p><code>pkgs</code>: The Nixpkgs package set, used to access packages like <code>pkgs.vim</code></p>
</li>
<li>
<p><code>...</code>: Allows the module to accept additional arguments, making it flexible
for extension in the future.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Key Takeaways: A NixOS module is typically a function that can include
<code>config</code>, <code>lib</code>, and <code>pkgs</code>, but it doesn’t require them. The <code>...</code>
argument ensures flexibility, allowing a module to accept extra inputs
without breaking future compatibility. Using <code>lib</code> simplifies handling
options (mkEnableOption, mkIf, mkOverride) and helps follow best practices.
Modules define options, which users can set in their configuration, and
<code>config</code>, which applies changes based on those options.</p>
</blockquote>
<ol start="2">
<li>Local Configuration Reference:</li>
</ol>
<pre><code class="language-nix">let
  cfg = config.programs.vim;
in
</code></pre>
<ul>
<li>This is a local alias. Instead of typing <code>config.programs.vim</code> over and over,
the module uses <code>cfg</code>.</li>
</ul>
<ol start="3">
<li>Option Declaration</li>
</ol>
<pre><code class="language-nix">options.programs.vim = {
  enable = lib.mkEnableOption "Vi IMproved, an advanced text";
  defaultEditor = lib.mkEnableOption "vim as the default editor";
  package = lib.mkPackageOption pkgs "vim" { example = "vim-full"; };
};
</code></pre>
<p>This defines three user-configurable options:</p>
<ul>
<li>
<p><code>enable</code>: Turns on Vim support system-wide.</p>
</li>
<li>
<p><code>defaultEditor</code>: Sets Vim as the system's default <code>$EDITOR</code>.</p>
</li>
<li>
<p><code>package</code>: lets the user override which Vim package is used.</p>
</li>
</ul>
<blockquote>
<p><code>mkPackageOption</code> is a helper that defines a package-typed option with a
default (<code>pkgs.vim</code>) and provides docs + example.</p>
</blockquote>
<ol start="4">
<li>Conditional Configuration</li>
</ol>
<pre><code class="language-nix">config = lib.mkIf (cfg.enable || cfg.defaultEditor) {
</code></pre>
<ul>
<li>This block is only activated if <em>either</em> <code>programs.vim.enable</code> or
<code>defaultEditor</code> is set.</li>
</ul>
<ol start="5">
<li>Warnings</li>
</ol>
<pre><code class="language-nix">warnings = lib.mkIf (cfg.defaultEditor &amp;&amp; !cfg.enable) [
  "programs.vim.defaultEditor will only work if programs.vim.enable is enabled,
   which will be enforced after the 24.11 release"
];
</code></pre>
<ul>
<li>Gives you a soft warning if you try to set <code>defaultEditor = true</code> without
also enabling Vim.</li>
</ul>
<ol start="6">
<li>Actual System Config Changes</li>
</ol>
<pre><code class="language-nix">environment = {
  systemPackages = [ cfg.package ];
  variables.EDITOR = lib.mkIf cfg.defaultEditor (lib.mkOverride 900 "vim");
  pathsToLink = [ "/share/vim-plugins" ];
};
</code></pre>
<ul>
<li>It adds Vim to your <code>systemPackages</code>, sets <code>$EDITOR</code> if <code>defaultEditor</code> is
true, and makes <code>/share/vim-plugins</code> available in the environment.</li>
</ul>
<p>The following is a bat home-manager module that I wrote:</p>
<pre><code class="language-nix"># bat.nix
{
  pkgs,
  config,
  lib,
  ...
}: let
  cfg = config.custom.batModule;
in {
  options.custom.batModule.enable = lib.mkOption {
    type = lib.types.bool;
    default = false;
    description = "Enable bat module";
  };

  config = lib.mkIf cfg.enable {
    programs.bat = {
      enable = true;
      themes = {
        dracula = {
          src = pkgs.fetchFromGitHub {
            owner = "dracula";
            repo = "sublime"; # Bat uses sublime syntax for its themes
            rev = "26c57ec282abcaa76e57e055f38432bd827ac34e";
            sha256 = "019hfl4zbn4vm4154hh3bwk6hm7bdxbr1hdww83nabxwjn99ndhv";
          };
          file = "Dracula.tmTheme";
        };
      };
      extraPackages = with pkgs.bat-extras; [
        batdiff
        batman
        prettybat
        batgrep
      ];
    };
  };
}
</code></pre>
<p>Now I could add this to my <code>home.nix</code> to enable it:</p>
<pre><code class="language-nix"># home.nix
custom = {
  batModule.enable = true;
}
</code></pre>
<ul>
<li>
<p>If I set this option to true the bat configuration is dropped in place. If
it's not set to true, it won't put the bat configuration in the system. Same
as with options defined in modules within the Nixpkgs repository.</p>
</li>
<li>
<p>If I had set the default to <code>true</code>, it would automatically enable the module
without requiring an explicit <code>custom.batModule.enable = true;</code> call in my
<code>home.nix</code>.</p>
</li>
</ul>
<h3 id="module-composition"><a class="header" href="#module-composition">Module Composition</a></h3>
<ul>
<li>
<p>NixOS achieves its full system configuration by combining the configurations
defined in various modules. This composition is primarily handled through the
<code>imports</code> mechanism.</p>
</li>
<li>
<p><code>imports</code>: This is a standard option within a NixOS or Home Manager
configuration (often found in your configuration.nix or home.nix). It takes
a list of paths to other Nix modules. When you include a module in the imports
list, the options and configurations defined in that module become part of
your overall system configuration.</p>
</li>
<li>
<p>You declaratively state the desired state of your system by setting options
across various modules. The NixOS build system then evaluates and merges these
option settings. The culmination of this process, which includes building the
entire system closure, is represented by the derivation built by
<code>config.system.build.toplevel</code>.</p>
</li>
</ul>
<h3 id="nixos-modules-and-dependency-locking-with-npins"><a class="header" href="#nixos-modules-and-dependency-locking-with-npins">NixOS Modules and Dependency Locking with npins</a></h3>
<p>This is the file structure:</p>
<pre><code class="language-bash">❯ tree
.
├── configuration.nix
├── default.nix
├── desktop.nix
└── npins
    ├── default.nix
    └── sources.json
</code></pre>
<p>This uses <code>npins</code> for dependency locking. Install it and run this in the project</p>
<p>directory:</p>
<pre><code class="language-bash">npins init
</code></pre>
<p>Create a <code>default.nix</code> with the following:</p>
<pre><code class="language-nix"># default.nix
{ system ? builtins.currentSystem, sources ? import ./npins, }:
let
  pkgs = import sources.nixpkgs {
    config = { };
    overlays = [ ];
  };
  inherit (pkgs) lib;
in lib.makeScope pkgs.newScope (self: {

  shell = pkgs.mkShell { packages = [ pkgs.npins self.myPackage ]; };

    # inherit lib;

  nixosSystem = import (sources.nixpkgs + "/nixos") {
    configuration = ./configuration.nix;
  };

  moduleEvale = lib.evalModules {
    modules = [
      # ...
    ];
  };
})
</code></pre>
<p>A <code>configuration.nix</code> with the following:</p>
<pre><code class="language-nix"># configuration.nix
{
  boot.loader.grub.device = "nodev";
  fileSystems."/".device = "/devst";
  system.stateVersion = "25.05";

  # declaring options means to declare a new option
  # defining options means to define a value of an option
  imports = [
    # ./main.nix
     ./desktop.nix # Files
    # ./minimal.nix
  ];

  # mine.desktop.enable = true;
}
</code></pre>
<p>And a <code>desktop.nix</code> with the following:</p>
<pre><code class="language-nix"># desktop.nix
{ pkgs, lib, config, ... }:

{
  imports = [];

  # Define an option to enable or disable desktop configuration
  options.mine.desktop.enable = lib.mkEnableOption "desktop settings";

  # Configuration that applies when the option is enabled
  config = lib.mkIf config.mine.desktop.enable {
    environment.systemPackages = [ pkgs.git ];
  };
}
</code></pre>
<p><code>mkEnableOption</code> defaults to false. Now in your <code>configuration.nix</code> you can
uncomment <code>mine.desktop.enable = true;</code> to enable the desktop config and
vice-versa.</p>
<p>You can test that this works by running:</p>
<pre><code class="language-bash">nix-instantiate -A nixosSystem.system
</code></pre>
<ul>
<li><code>nix-instantiate</code> performs only the evaluation phase of Nix expressions.
During this phase, Nix interprets the Nix code, resolves all dependencies, and
constructs derivations but does not execute any build actions. Useful for
testing.</li>
</ul>
<p>To check if this worked and <code>git</code> is installed in systemPackages you can
load it into <code>nix repl</code> but first you'll want <code>lib</code> to be available so uncomment
this in your <code>default.nix</code>:</p>
<pre><code class="language-nix"># default.nix
inherit lib;
</code></pre>
<p>Rerun <code>nix-instantiate -A nixosSystem.system</code></p>
<p>Then load the repl and check that <code>git</code> is in <code>systemPackages</code>:</p>
<pre><code class="language-bash">nix repl -f .
nix-repl&gt; builtins.filter (pkg: lib.hasPrefix "git" pkg.name) nixosSystem.config.environment.systemPackages
</code></pre>
<p>This shows the path to the derivation</p>
<p>Check that mine.desktop.enable is true</p>
<pre><code class="language-nix">nix-repl&gt; nixosSystem.config.mine.desktop.enable
true
</code></pre>
<h3 id="resources-on-modules"><a class="header" href="#resources-on-modules">Resources on Modules</a></h3>
<ul>
<li>
<p><a href="https://nixos.org/manual/nixos/stable/#sec-writing-modules">WritingNixOsModules</a></p>
</li>
<li>
<p><a href="https://nixos.wiki/wiki/NixOS_modules">NixWikiNixOSModules</a></p>
</li>
<li>
<p><a href="https://nix.dev/tutorials/module-system/a-basic-module/index.html">nix.dev A basic module</a></p>
</li>
<li>
<p><a href="https://nix.dev/tutorials/module-system/deep-dive#module-system-deep-dive">ModuleSystemDeepDive</a></p>
</li>
<li>
<p><a href="https://xeiaso.net/talks/asg-2023-nixos/">MakingNixOSModulesForFun</a></p>
</li>
<li>
<p><a href="https://xeiaso.net/talks/asg-2023-nixos/">xeiaso Nixos Modules for fun &amp; profit</a></p>
</li>
<li>
<p><a href="https://nixos-and-flakes.thiscute.world/other-usage-of-flakes/module-system">NixOS Flakes Book Module System</a></p>
</li>
</ul>
<h1 id="videos"><a class="header" href="#videos">Videos</a></h1>
<p><a href="https://www.youtube.com/watch?v=N7hFP_40DJo&amp;t=17s">NixHour Writing NixOS modules</a>
-- This example is from this video
<a href="https://infinisil.com/modules.mp4">infinisilModules</a></p>
<p><a href="https://www.youtube.com/watch?v=cZjOzOHb2ow">tweagModuleSystemRecursion</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4"><a class="header" href="#chapter-4">Chapter 4</a></h1>
<h2 id="nix-flakes-explained"><a class="header" href="#nix-flakes-explained">Nix Flakes Explained</a></h2>
<p><img src="images/gruv3.png" alt="gruv3" /></p>
<p>This explanation highlights common areas of confusion for those new to Nix
Flakes, aiming to clarify concepts rather than serve as a comprehensive guide.</p>
<h2 id="what-is-a-nix-flake"><a class="header" href="#what-is-a-nix-flake">What is a Nix Flake?</a></h2>
<ul>
<li>
<p>At its core, a flake is a source tree (like a Git repository) that contains
a <code>flake.nix</code> file. This file provides a standardized way to access Nix
artifacts such as packages and modules.</p>
</li>
<li>
<p>Think of <code>flake.nix</code> as the central entry point of a flake. It not only
defines what the flake produces but also declares its dependencies.</p>
</li>
</ul>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<p>** <code>flake.nix</code>: The Heart of a Flake**</p>
<ul>
<li>The <code>flake.nix</code> file is mandatory for any flake. It must contain an attribute
set with at least one required attribute: <code>outputs</code>. It can also optionally
include <code>description</code> and <code>inputs</code>.</li>
<li><strong>Basic Structure:</strong></li>
</ul>
<pre><code class="language-nix">{
  description = "Package description";
  inputs = { /* Dependencies go here */ };
  outputs = { /* What the flake produces */ };
  nixConfig = { /* Advanced configuration options */ };
}
</code></pre>
<h2 id="attribute-sets-the-building-blocks"><a class="header" href="#attribute-sets-the-building-blocks">Attribute Sets: The Building Blocks</a></h2>
<ul>
<li>
<p>Attribute sets are fundamental in Nix. They are simply collections of
name-value pairs wrapped in curly braces <code>{}</code>.</p>
<ul>
<li>Example:</li>
</ul>
<pre><code class="language-nix">let
  my_attrset = { foo = "bar"; };
in
my_attrset.foo
</code></pre>
<ul>
<li>Output:</li>
</ul>
<pre><code class="language-nix">"bar"
</code></pre>
</li>
<li>
<p><strong>Top-Level Attributes of a Flake</strong>:</p>
<ul>
<li>Flakes have specific top-level attributes that can be accessed directly
(without dot notation). The most common ones are inputs, outputs,
and nixConfig.</li>
</ul>
</li>
</ul>
<h3 id="anatomy-of-flakenix"><a class="header" href="#anatomy-of-flakenix">Anatomy of <code>flake.nix</code></a></h3>
<p><img src="images/Flakes.png" alt="Flakes" /></p>
<p><strong><code>inputs</code>: Declaring Dependencies</strong></p>
<ul>
<li>
<p>The <strong><code>inputs</code></strong> attribute set specifies the other flakes that your current
flake depends on.</p>
</li>
<li>
<p>Each key in the <strong><code>inputs</code></strong> set is a name you choose for the dependency, and
the value is a reference to that flake (usually a URL or a Git Repo).</p>
</li>
<li>
<p>To access something from a dependency, you generally go through the <code>inputs</code>
attribute (e.g., <code>inputs.helix.packages</code>).</p>
<ul>
<li><strong>Example:</strong> This declares dependencies on the <code>nixpkgs</code> and <code>import-cargo</code>
flakes:</li>
</ul>
<pre><code class="language-nix">inputs = {
  import-cargo.url = "github:edolstra/import-cargo";
  nixpkgs.url = "nixpkgs";
};
</code></pre>
<ul>
<li>
<p>When Nix evaluates your flake, it fetches and evaluates each input. These
evaluated inputs are then passed as an attribute set to the outputs function,
with the keys matching the names you gave them in the inputs set.</p>
</li>
<li>
<p>The special input self is a reference to the outputs and the source tree of
the current flake itself.</p>
</li>
</ul>
</li>
</ul>
<p><strong><code>outputs</code>: Defining What Your Flake Provides</strong></p>
<ul>
<li>
<p>The <strong><code>outputs</code></strong> attribute defines what your flake makes available. This can
include packages, NixOS modules, development environments (<code>devShells</code>) and
other Nix derivations.</p>
</li>
<li>
<p>Flakes can output arbitrary Nix values. However, certain outputs have
specific meanings for Nix commands and must adhere to particular types
(often derivations, as described in the
<a href="https://nixos.wiki/wiki/Flakes">output schema</a>).</p>
</li>
<li>
<p>You can inspect the outputs of a flake using the command:</p>
</li>
</ul>
<pre><code class="language-nix">nix flake show
</code></pre>
<blockquote>
<p>This command takes a flake URI and displays its outputs in a tree structure,
showing the attribute paths and their corresponding types.</p>
</blockquote>
<p><strong>Understanding the <code>outputs</code> Function</strong></p>
<ul>
<li>
<p>Beginners often mistakenly think that self and nixpkgs within
<code>outputs = { self, nixpkgs, ... }: { ... }</code> are the outputs themselves.
Instead, they are the <em>input arguments</em> (often called <em>output arguments</em>)
to the outputs function.</p>
</li>
<li>
<p>The outputs function in <code>flake.nix</code> always takes a single argument,
which is an attribute set. The syntax <code>{ self, nixpkgs, ... }</code> is Nix's
way of destructuring this single input attribute set to extract the values
associated with the keys self and nixpkgs.</p>
</li>
</ul>
<p><strong>Referencing the Current Flake</strong> (<code>self</code>)</p>
<ul>
<li>
<p><code>self</code> provides a way to refer back to the current flake from within the
outputs function. You can use it to access other top-level attributes like
inputs (e.g., <code>self.inputs</code>).</p>
</li>
<li>
<p>The outputs function always receives an argument conventionally named self,
which represents the entire flake, including all its top-level attributes.
You'll typically use self to reference things defined within your own flake
(e.g., <code>self.packages.my-package</code>).</p>
</li>
</ul>
<p><strong>Variadic Attributes (...) and @-patterns</strong></p>
<ul>
<li>
<p>The <code>...</code> syntax in the input arguments of the outputs function indicates
variadic attributes, meaning the input attribute set can contain more
attributes than just those explicitly listed (like <code>self</code> and <code>nixpkgs</code>).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-nix">mul = { a, b, ... }: a \* b;
mul { a = 3; b = 4; c = 2; } # 'c' is an extra attribute
</code></pre>
<p>However, you cannot directly access these extra attributes within the
function body unless you use the @-pattern:</p>
<pre><code class="language-nix">mul = s@{ a, b, ... }: a _ b _ s.c; # 's' now refers to the entire input set
mul { a = 3; b = 4; c = 2; } # Output: 24
</code></pre>
<ul>
<li>
<p>When used in the outputs function argument list (e.g.,
<code>outputs = { pkgs, ... } @ inputs)</code>, the @-pattern binds the entire input
attribute set to a name (in this case, <code>inputs</code>) while also allowing you to
destructure specific attributes like pkgs.</p>
</li>
<li>
<p><strong>What <code>outputs = { pkgs, ... } @ inputs: { ... };</code> does:</strong></p>
</li>
</ul>
</li>
</ul>
<ol>
<li>
<p><strong>Destructuring:</strong> It tries to extract the value associated with the key
<code>pkgs</code> from the input attribute set and binds it to the variable <code>pkgs</code>.
The <code>...</code> allows for other keys in the input attribute set to be ignored
during this direct destructuring.</p>
</li>
<li>
<p><strong>Binding the Entire Set:</strong> It binds the entire input attribute set to the
variable inputs.</p>
<ul>
<li>Example <code>flake.nix</code>:</li>
</ul>
</li>
</ol>
<pre><code class="language-nix">{
inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
inputs.home-manager.url = "github:nix-community/home-manager";

outputs = { self, nixpkgs, ... } @ attrs: { # A `packages` output for the x86_64-linux platform
packages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello;

    # A `nixosConfigurations` output (for a NixOS system named "fnord")
    nixosConfigurations.fnord = nixpkgs.lib.nixosSystem {
      system = "x86_64-linux";
      specialArgs = attrs;
      modules = [ ./configuration.nix ];
    };

};
}
</code></pre>
<p><strong>Platform Specificity in Outputs</strong></p>
<ul>
<li>Flakes ensure that their outputs are consistent across different evaluation
environments. Therefore, any package-related output must explicitly specify
the target platform (a combination of architecture and OS, <code>x86_64-linux</code>).</li>
</ul>
<p><strong>legacyPackages Explained</strong></p>
<ul>
<li><code>legacyPackages</code> is a way for flakes to interact with the traditional,
less structured package organization of nixpkgs. Instead of packages being
directly at the top level (e.g., <code>pkgs.hello</code>), <code>legacyPackages</code> provides a
platform-aware way to access them within the flake's structured output format
(e.g., <code>nixpkgs.legacyPackages.x86_64-linux.hello</code>). It acts as a bridge
between the flake's expected output structure and nixpkgs's historical
organization.</li>
</ul>
<p><strong>The Sole Argument of outputs</strong></p>
<ul>
<li>It's crucial to remember that the outputs function accepts only one argument,
which is an attribute set. The <code>{ self, nixpkgs, ... }</code> syntax is simply
destructuring that single input attribute set.</li>
</ul>
<p><strong>Outputs of the Flake (Return Value)</strong></p>
<ul>
<li>The outputs of the flake refer to the attribute set that is returned by the
<code>outputs</code> function. This attribute set can contain various named outputs like
<code>packages</code>, <code>nixosConfigurations</code>, <code>devShells</code>, etc.</li>
</ul>
<p><strong>Imports: Including Other Nix Expressions</strong></p>
<ul>
<li>
<p>The <code>import</code> function in Nix is used to evaluate the Nix expression found at
a specified path (usually a file or directory) and return its value.</p>
</li>
<li>
<p>Basic Usage: import <code>./path/to/file.nix</code></p>
</li>
</ul>
<p><strong>Passing Arguments During Import</strong></p>
<ul>
<li>You can also pass an attribute set as an argument to the Nix expression being
imported:</li>
</ul>
<pre><code class="language-nix">let
myHelpers = import ./lib/my-helpers.nix { pkgs = nixpkgs; };
in
# ... use myHelpers
</code></pre>
<ul>
<li>In this case, the Nix expression in <code>./lib/my-helpers.nix</code> is likely a
function that expects an argument (often named <code>pkgs</code> by convention):</li>
</ul>
<pre><code class="language-nix"># ./lib/my-helpers.nix

{ pkgs }:
let
myPackage = pkgs.stdenv.mkDerivation {
name = "my-package"; # ...
};
in
myPackage
</code></pre>
<ul>
<li>By passing <code>{ pkgs = nixpkgs; }</code> during the import, you are providing the
nixpkgs value from your current <code>flake.nix</code> scope to the pkgs parameter
expected by the code in <code>./lib/my-helpers.nix</code>.</li>
</ul>
<p><strong>Importing Directories (<code>default.nix</code>)</strong></p>
<ul>
<li>When you use import with a path that points to a directory, Nix automatically
looks for a file named <code>default.nix</code> within that directory. If found, Nix
evaluates the expressions within <code>default.nix</code> as if you had specified its
path directly in the import statement.</li>
</ul>
<h4 id="further-resources"><a class="header" href="#further-resources">Further Resources</a></h4>
<ul>
<li>
<p><a href="https://serokell.io/blog/practical-nix-flakes">practical-nix-flakes</a></p>
</li>
<li>
<p><a href="https://www.tweag.io/blog/2020-07-31-nixos-flakes/">tweag nix-flakes</a></p>
</li>
<li>
<p><a href="https://nixos.wiki/wiki/Flakes">NixOS-wiki Flakes</a></p>
</li>
<li>
<p><a href="https://nix.dev/concepts/flakes.html">nix.dev flakes</a></p>
</li>
<li>
<p><a href="https://jade.fyi/blog/flakes-arent-real/">flakes-arent-real</a></p>
</li>
<li>
<p><a href="https://mhwombat.codeberg.page/nix-book/#_attribute_set_operations">wombats-book-of-nix</a></p>
</li>
<li>
<p><a href="https://zero-to-nix.com/concepts/flakes/">zero-to-nix flakes</a></p>
</li>
<li>
<p><a href="https://nixos-and-flakes.thiscute.world/">nixos-and-flakes-book</a></p>
</li>
<li>
<p><a href="https://flakehub.com/">FlakeHub</a></p>
</li>
</ul>
<p>{{&lt; figure src="/images/nixosnix.png" alt="FlakeHub" width="80%" &gt;}}
<img src="images/nixosnix.png" alt="FlakeHub" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-5"><a class="header" href="#chapter-5">Chapter 5</a></h1>
<h2 id="understanding-top-level-attributes-in-nixos-modules"><a class="header" href="#understanding-top-level-attributes-in-nixos-modules">Understanding Top-Level Attributes in NixOS Modules</a></h2>
<p><img src="images/gruv9.png" alt="gruv9" /></p>
<p>This explanation is based on insights from Infinisil, a prominent figure in the
Nix community, to help clarify the concept of top-level attributes within
NixOS modules.</p>
<h2 id="the-core-of-a-nixos-system-systembuildtoplevel"><a class="header" href="#the-core-of-a-nixos-system-systembuildtoplevel">The Core of a NixOS System: <code>system.build.toplevel</code></a></h2>
<p>In a NixOS system, everything is built from a single "system derivation." The
command <code>nix-build '&lt;nixpkgs/nixos&gt;' -A system</code> initiates this build process.</p>
<p>The <code>-A system</code> part tells Nix to focus on the <code>system</code> attribute defined in
the <code>'&lt;nixpkgs/nixos&gt;'</code> file (which is essentially <code>./default.nix</code> within the
Nixpkgs repository).</p>
<p>This <code>system</code> attribute is specifically the NixOS option <code>system.build.toplevel</code>
. Think of <code>system.build.toplevel</code> as the <strong>very top of the configuration
hierarchy</strong> for your entire NixOS system. Almost every setting you configure
eventually influences this top-level derivation, often through a series of
intermediate steps.</p>
<p><strong>Key Takeaway:</strong> <code>system.build.toplevel</code> is the ultimate output that defines your entire NixOS system.</p>
<h2 id="how-options-relate-a-chain-of-influence"><a class="header" href="#how-options-relate-a-chain-of-influence">How Options Relate: A Chain of Influence</a></h2>
<p>Options in NixOS are not isolated; they often build upon each other. Here's an example of how a high-level option can lead down to a low-level system configuration:</p>
<ul>
<li>You enable Nginx with <code>services.nginx.enable = true;</code>.</li>
<li>This setting influences the lower-level option <code>systemd.services.nginx</code>.</li>
<li>Which, in turn, affects the even lower-level option
<code>systemd.units."nginx.service"</code>.</li>
<li>Ultimately, this leads to the creation of a systemd unit file within
<code>environment.etc."systemd/system"</code>.</li>
<li>Finally, this unit file ends up as <code>result/etc/systemd/system/nginx.service</code>
within the final <code>system.build.toplevel</code> derivation.</li>
</ul>
<p><strong>Key Takeaway:</strong> Higher-level, user-friendly options are translated into
lower-level system configurations that are part of the final system build.</p>
<h2 id="the-nixos-module-system-evaluating-options"><a class="header" href="#the-nixos-module-system-evaluating-options">The NixOS Module System: Evaluating Options</a></h2>
<p>So, how do these options get processed and turned into the final system
configuration? That's the job of the <strong>NixOS module system</strong>, located in the
<code>./lib</code> directory of Nixpkgs (specifically in <code>modules.nix</code>, <code>options.nix</code>,
and <code>types.nix</code>).</p>
<p>Interestingly, the module system isn't exclusive to NixOS; you can use it to
manage option sets in your own Nix projects.</p>
<p>Here's a simplified example of using the module system outside of NixOS:</p>
<pre><code class="language-nix">let
  systemModule = { lib, config, ... }: {
    options.toplevel = lib.mkOption {
      type = lib.types.str;
    };

    options.enableFoo = lib.mkOption {
      type = lib.types.bool;
      default = false;
    };

    config.toplevel = ''
      Is foo enabled? ${lib.boolToString config.enableFoo}
    '';
  };

  userModule = {
    enableFoo = true;
  };

in (import &lt;nixpkgs/lib&gt;).evalModules {
  modules = [ systemModule userModule ];
}
</code></pre>
<p><strong>You can evaluate the <code>config.toplevel</code> option from this example using:</strong></p>
<pre><code class="language-bash">nix-instantiate --eval file.nix -A config.toplevel
</code></pre>
<p><strong>Key Takeaway</strong>: The NixOS module system is responsible for evaluating and
merging option configurations from different modules.</p>
<h2 id="how-the-module-system-works-a-simplified-overview"><a class="header" href="#how-the-module-system-works-a-simplified-overview">How the Module System Works: A Simplified Overview</a></h2>
<p>The module system processes a set of "modules" through these general steps:</p>
<ol>
<li>
<p><strong>Importing Modules</strong>: It recursively finds and includes all modules
specified in <code>imports = [ ... ];</code> statements.</p>
</li>
<li>
<p><strong>Declaring Options</strong>: It collects all option declarations defined using
<code>options = { ... };</code> from all the modules and merges them. If the same option
is declared in multiple modules, the module system handles this
(details omitted for simplicity).</p>
</li>
<li>
<p><strong>Defining Option Values</strong>: For each declared option, it gathers all the
value assignments (defined using <code>config = { ... };</code> or directly at the top
level if no <code>options</code> or <code>config</code> are present) from all modules and merges
them according to the option's defined type.</p>
</li>
</ol>
<blockquote>
<p><strong>Important Note</strong>: Option evaluation is lazy, meaning an option's value is
only computed when it's actually needed. It can also depend on the values of
other options.</p>
</blockquote>
<p><strong>Key Takeaway</strong>: The module system imports, declares, and then evaluates
option values from various modules to build the final configuration.</p>
<p><strong>Top-Level Attributes in a Module: <code>imports</code>, <code>options</code>, and <code>config</code></strong></p>
<p>Within a NixOS module (the files that define parts of your system configuration)
, the attributes defined directly at the top level of the module's function
have specific meanings:</p>
<ul>
<li>
<p><code>imports</code>: This attribute is a list of other module files to include. Their
options and configurations will also be part of the evaluation.</p>
</li>
<li>
<p><code>options</code>: This attribute is where you declare new configuration options. You
define their type, default value, description, etc., using functions like
<code>lib.mkOption</code> or <code>lib.mkEnableOption</code>.</p>
</li>
<li>
<p><code>config</code>: This attribute is where you assign values to the options that have
been declared (either in the current module or in imported modules).</p>
</li>
</ul>
<p><strong>Key Takeaway</strong>: The top-level attributes <code>imports</code>, <code>options</code>, and <code>config</code>
are the primary ways to structure a NixOS module.</p>
<p><strong>The Rule: Move Non-Option Attributes Under <code>config</code></strong></p>
<p>If you define either an <code>options</code> or a <code>config</code> attribute at the top level of
your module, any other attributes that are not option declarations must be
moved inside the config attribute.</p>
<p>Let's look at an example of what not to do:</p>
<pre><code class="language-nix">{ pkgs, lib, config, ... }:
{
imports = [];

# Defining an option at the top level

options.mine.desktop.enable = lib.mkEnableOption "desktop settings";

# This will cause an error because 'environment' and 'appstream'

# are not 'options' and 'config' is also present at the top level.

environment.systemPackages =
lib.mkIf config.appstream.enable [ pkgs.git ];

appstream.enable = true;
}
</code></pre>
<p>This will result in the error: <code>error: Module has an unsupported attribute 'appstream' This is caused by introducing a top-level 'config' or 'options' attribute. Add configuration attributes immediately on the top level instead, or move all of them into the explicit 'config' attribute</code>.</p>
<p><strong>Key Takeaway</strong>: When you have <code>options</code> or <code>config</code> at the top level, all
value assignments need to go inside the config block.</p>
<p><strong>The Correct Way</strong>): Using the <code>config</code> Attribute</p>
<p>To fix the previous example, you need to move the value assignments for
<code>environment.systemPackages</code> and <code>appstream.enable</code> inside the config attribute:</p>
<pre><code class="language-nix">{ pkgs, lib, config, ... }:
{
imports = [];

# Defining an option at the top level

options.mine.desktop.enable = lib.mkEnableOption "desktop settings";

config = {
environment.systemPackages =
lib.mkIf config.appstream.enable [ pkgs.git ];

    appstream.enable = true;

};
}
</code></pre>
<p>Now, Nix knows that you are declaring an option (<code>options.mine.desktop.enable</code>)
and then setting values for other options (<code>environment.systemPackages</code>,
<code>appstream.enable</code>) within the <code>config</code> block.</p>
<p><strong>Key Takeaway</strong>: The <code>config</code> attribute is used to define the values of
options.</p>
<p><strong>Implicit <code>config</code>: When <code>options</code> is Absent</strong></p>
<p>If your module does not define either <code>options</code> or <code>config</code> at the top level,
then any attributes you define directly at the top level are implicitly
treated as being part of the config.</p>
<p>For example, this is valid:</p>
<pre><code class="language-nix">{ pkgs, lib, config, ... }:
{
environment.systemPackages =
lib.mkIf config.appstream.enable [ pkgs.git ];

appstream.enable = true;
}
</code></pre>
<p>Nix will implicitly understand that <code>environment.systemPackages</code> and
<code>appstream.enable</code> are configuration settings.</p>
<p><strong>Key Takeaway</strong>: If no explicit options or config are present, top-level
attributes are automatically considered part of the configuration.</p>
<p><strong>Removing an Option: What Happens to <code>config</code></strong></p>
<p>Even if you remove the <code>options</code> declaration from a module that has a <code>config</code>
section, the <code>config = { environment.systemPackages = ... };</code> part will still
function correctly, assuming the option it's referencing (<code>appstream.enable</code>
in this case) is defined elsewhere (e.g., in an imported module).</p>
<p><strong>Key Takeaway</strong>: The <code>config</code> section defines values for options, regardless
of whether those options are declared in the same module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-6"><a class="header" href="#chapter-6">Chapter 6</a></h1>
<h2 id="introduction-to-nix-derivations"><a class="header" href="#introduction-to-nix-derivations">Introduction to Nix Derivations</a></h2>
<p><img src="images/gruv10.png" alt="gruv10" /></p>
<ul>
<li>
<p>A derivation in Nix is a fundamental concept that describes how to build a piece of software or a resource (e.g., a package, library, or configuration file). Think of it as a recipe for creating something within the Nix ecosystem.</p>
</li>
<li>
<p>For beginners, the analogy of a cooking recipe is helpful:</p>
<ul>
<li><strong>Ingredients (Dependencies):</strong> What other software or libraries are needed.</li>
<li><strong>Steps (Build Instructions):</strong> The commands to compile, configure, and install.</li>
<li><strong>Final Dish (Output):</strong> The resulting package or resource.</li>
</ul>
</li>
<li>
<p>A Nix derivation encapsulates all this information, telling Nix what inputs
to use, how to build it, and what the final output should be.</p>
</li>
</ul>
<h2 id="creating-derivations-in-nix"><a class="header" href="#creating-derivations-in-nix">Creating Derivations in Nix</a></h2>
<ul>
<li>
<p>The primary way to define packages in Nix is through the <code>mkDerivation</code> function, which is part of the standard environment (<code>stdenv</code>). While a
lower-level <code>derivation</code> function exists for advanced use cases,
<code>mkDerivation</code> simplifies the process by automatically managing dependencies
and the build environment.</p>
</li>
<li>
<p><code>mkDerivation</code> (and <code>derivation</code>) takes a set of attributes as its argument.
At a minimum, you'll often encounter these essential attributes:</p>
<ol>
<li><strong>name:</strong> A human-readable identifier for the derivation
(e.g., "foo", "hello.txt"). This helps you and Nix refer to the package.</li>
<li><strong>system:</strong> Specifies the target architecture for the build
(e.g., <code>builtins.currentSystem</code> for your current machine).</li>
<li><strong>builder:</strong> Defines the program that will execute the build instructions
(e.g., <code>bash</code>).</li>
</ol>
</li>
</ul>
<h2 id="our-first-simple-derivation-understanding-the-builder"><a class="header" href="#our-first-simple-derivation-understanding-the-builder">Our First Simple Derivation: Understanding the Builder</a></h2>
<ul>
<li>To understand how derivations work, let's create a very basic example using a
bash script as our <code>builder</code>.</li>
</ul>
<h3 id="why-a-builder-script"><a class="header" href="#why-a-builder-script">Why a Builder Script?</a></h3>
<ul>
<li>The <code>builder</code> attribute in a derivation tells Nix <em>how</em> to perform the build
steps. A simple and common way to define these steps is with a bash script.</li>
</ul>
<h3 id="the-challenge-with-shebangs-in-nix"><a class="header" href="#the-challenge-with-shebangs-in-nix">The Challenge with Shebangs in Nix</a></h3>
<ul>
<li>
<p>In typical Unix-like systems, you might start a bash script with a shebang
(<code>#!/bin/bash</code> or <code>#!/usr/bin/env bash</code>) to tell the system how to execute it.
However, in Nix derivations, we generally avoid this.</p>
</li>
<li>
<p><strong>Reason:</strong> Nix builds happen in an isolated environment where the exact path
to common tools like <code>bash</code> isn't known beforehand (it resides within the Nix
store). Hardcoding a path or relying on the system's <code>PATH</code> would break Nix's
stateless property.</p>
</li>
</ul>
<h3 id="the-importance-of-statelessness-in-nix"><a class="header" href="#the-importance-of-statelessness-in-nix">The Importance of Statelessness in Nix</a></h3>
<ul>
<li>
<p><strong>Stateful Systems (Traditional):</strong> When you install software traditionally,
it often modifies the core system environment directly. This can lead to
dependency conflicts and makes rollbacks difficult.</p>
</li>
<li>
<p><strong>Stateless Systems (Nix):</strong> Nix takes a different approach. When installing
a package, it creates a unique, immutable directory in the Nix store. This
means:</p>
<ul>
<li><strong>No Conflicts:</strong> Different versions of the same package can coexist
without interfering with each other.</li>
<li><strong>Reliable Rollback:</strong> You can easily switch back to previous versions
without affecting system-wide files.</li>
<li><strong>Reproducibility:</strong> Builds are more likely to produce the same result
across different machines if they are "pure" (don't rely on external
system state).</li>
</ul>
</li>
</ul>
<h4 id="our-builder-script"><a class="header" href="#our-builder-script">Our builder Script</a></h4>
<ul>
<li>For our first derivation, we'll create a simple <code>builder.sh</code> file in the current directory:</li>
</ul>
<pre><code class="language-bash"># builder.sh
declare -xp
echo foo &gt; $out
</code></pre>
<ul>
<li>
<p>The command <code>declare -xp</code> lists exported variables (it's a bash builtin
function).</p>
</li>
<li>
<p>Nix needs to know where the final built product (the "cake" in our earlier
analogy) should be placed. So, during the derivation process, Nix calculates
a unique output path within the Nix store. This path is then made available
to our builder script as an environment variable named <code>$out</code>. The <code>.drv</code>
file, which is the recipe, contains instructions for the builder, including
setting up this <code>$out</code> variable. Our builder script will then put the result
of its work (in this case, the "foo" file) into this specific <code>$out</code> directory.</p>
</li>
<li>
<p>As mentioned earlier we need to find the nix store path to the bash
executable, common way to do this is to load Nixpkgs into the repl
and check:</p>
</li>
</ul>
<pre><code class="language-bash">nix-repl&gt; :l &lt;nixpkgs&gt;
Added 3950 variables.
nix-repl&gt; "${bash}"
"/nix/store/ihmkc7z2wqk3bbipfnlh0yjrlfkkgnv6-bash-4.2-p45"
</code></pre>
<p>So, with this little trick we are able to refer to <code>bin/bash</code> and create
our derivation:</p>
<pre><code class="language-bash">nix-repl&gt; d = derivation { name = "foo"; builder = "${bash}/bin/bash";
 args = [ ./builder.sh ]; system = builtins.currentSystem; }
nix-repl&gt; :b d
[1 built, 0.0 MiB DL]

this derivation produced the following outputs:
  out -&gt; /nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo
</code></pre>
<ul>
<li>
<p>Boom! The contents of <code>/nix/store/w024zci0x1hh1wj6gjq0jagkc1sgrf5r-foo</code>
is really foo! We've built our first derivation.</p>
</li>
<li>
<p>Derivations are the primitive that Nix uses to define packages. “Package”
is a loosely defined term, but a derivation is simply the result of calling
<code>builtins.derivation</code>.</p>
</li>
</ul>
<h4 id="our-second-derivation"><a class="header" href="#our-second-derivation">Our Second Derivation</a></h4>
<p>The following is a simple <code>hello-drv</code> derivation:</p>
<pre><code class="language-nix">nix-repl&gt; hello-drv = nixpkgs.stdenv.mkDerivation {
            name = "hello.txt";
            unpackPhase = "true";
            installPhase = ''
              echo -n "Hello World!" &gt; $out
            '';
          }

nix-repl&gt; hello-drv
«derivation /nix/store/ad6c51ia15p9arjmvvqkn9fys9sf1kdw-hello.txt.drv»
</code></pre>
<ul>
<li>Derivations have a <code>.drv</code> suffix, as you can see the result of calling
<code>hello-drv</code> is the nix store path to a derivation.</li>
</ul>
<h4 id="links-to-articles-about-derivations"><a class="header" href="#links-to-articles-about-derivations">Links To Articles about Derivations</a></h4>
<ul>
<li>
<p><a href="https://nixos.org/guides/nix-pills/06-our-first-derivation">NixPillsOurFirstDerivation</a></p>
</li>
<li>
<p><a href="https://nixos.org/guides/nix-pills/07-working-derivation">NixPills-WorkingDerivation</a></p>
</li>
<li>
<p><a href="https://nix.dev/manual/nix/2.24/language/derivations">nix.dev-Derivations</a></p>
</li>
<li>
<p><a href="https://nix.dev/tutorials/packaging-existing-software">nix.dev-packagingExistingSoftware</a></p>
</li>
<li>
<p><a href="https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/">howToLearnNix-MyFirstDerivation</a></p>
</li>
<li>
<p><a href="https://ianthehenry.com/posts/how-to-learn-nix/derivations-in-detail/">howToLearnNix-DerivationsInDetail</a></p>
</li>
<li>
<p><a href="https://www.sam.today/blog/creating-a-super-simple-derivation-learning-nix-pt-3">Sparky/blog-creatingASuperSimpleDerivation</a> # How to learn Nix</p>
</li>
<li>
<p><a href="https://www.sam.today/blog/derivations-102-learning-nix-pt-4">Sparky/blog-Derivations102</a></p>
</li>
<li>
<p><a href="https://scrive.github.io/nix-workshop/04-derivations/01-derivation-basics.html">ScriveNixWorkshop-nixDerivationBasics</a></p>
</li>
<li>
<p><a href="https://zero-to-nix.com/concepts/derivations/">zeroToNix-Derivations</a></p>
</li>
<li>
<p><a href="https://www.tweag.io/blog/2021-02-17-derivation-outputs-and-output-paths/">Tweag-derivationOutputs</a></p>
</li>
<li>
<p><a href="https://ayats.org/blog/nix-tuto-2">theNixLectures-Derivations</a></p>
</li>
<li>
<p><a href="https://bmcgee.ie/posts/2023/02/nix-what-are-fixed-output-derivations-and-why-use-them/">bmcgee-whatAreFixed-OutputDerivations</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-7"><a class="header" href="#chapter-7">Chapter 7</a></h1>
<h2 id="comparing-flakes-to-traditional-nix"><a class="header" href="#comparing-flakes-to-traditional-nix">Comparing Flakes to Traditional Nix</a></h2>
<p><img src="images/nixWinter.png" alt="nixWinter" /></p>
<ul>
<li>This post is based on notes from Nix-Hour #4, comparing Traditional Nix and Flakes, focusing on achieving pure build results. See the <a href="https://www.youtube.com/watch?v=atmoYyBAhF4">YouTube video</a> for the original content. This guide adapts the information for clarity and ease of understanding.</li>
</ul>
<h2 id="what-is-purity-in-nix"><a class="header" href="#what-is-purity-in-nix">What is Purity in Nix?</a></h2>
<ul>
<li>
<p>A key benefit of Nix Flakes is their <em>default</em> enforcement of <strong>pure evaluation</strong>.</p>
</li>
<li>
<p>In Nix, an <strong>impure operation</strong> depends on something <em>outside</em> its explicit inputs. Examples include:</p>
<ul>
<li>User's system configuration</li>
<li>Environment variables</li>
<li>Current time</li>
</ul>
</li>
<li>
<p>Impurity leads to unpredictable builds that may differ across systems or time.</p>
</li>
</ul>
<h2 id="building-a-simple-hello-package-flakes-vs-traditional-nix"><a class="header" href="#building-a-simple-hello-package-flakes-vs-traditional-nix">Building a Simple "hello" Package: Flakes vs. Traditional Nix</a></h2>
<ul>
<li>We'll demonstrate building a basic "hello" package using both Flakes and Traditional Nix to highlight the differences in handling purity.</li>
</ul>
<h2 id="using-nix-flakes"><a class="header" href="#using-nix-flakes">Using Nix Flakes</a></h2>
<ol>
<li>
<p><strong>Setup:</strong></p>
<pre><code class="language-bash">mkdir hello &amp;&amp; cd hello/
</code></pre>
</li>
<li>
<p><strong>Create <code>flake.nix</code> (Initial Impure Example):</strong></p>
<pre><code class="language-nix"># flake.nix
{
  outputs = { self, nixpkgs }: {
    myHello = (import nixpkgs {}).hello;
  };
}
</code></pre>
<ul>
<li>Note: Flakes don't have access to <code>builtins.currentSystem</code> directly.</li>
</ul>
</li>
<li>
<p><strong>Impure Build (Fails):</strong></p>
<pre><code class="language-bash">nix build .#myHello
</code></pre>
<ul>
<li>This fails because Flakes enforce purity by default.</li>
</ul>
</li>
<li>
<p><strong>Force Impure Build:</strong></p>
<pre><code class="language-bash">nix build .#myHello --impure
</code></pre>
</li>
<li>
<p><strong>Making the Flake Pure:</strong></p>
<pre><code class="language-nix"># flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
      in {
        packages.myHello = pkgs.hello;
      }
    );
}
</code></pre>
<ul>
<li><code>flake-utils</code> simplifies making flakes system-agnostic and provides the <code>system</code> attribute.</li>
</ul>
</li>
<li>
<p><strong>Pure Build (Success):</strong></p>
<pre><code class="language-bash">nix build .#myHello
</code></pre>
</li>
</ol>
<h2 id="using-traditional-nix"><a class="header" href="#using-traditional-nix">Using Traditional Nix</a></h2>
<ol>
<li>
<p><strong>Setup:</strong></p>
<pre><code class="language-bash">mkdir hello2 &amp;&amp; cd hello2/
</code></pre>
</li>
<li>
<p><strong>Create <code>default.nix</code> (Initial Impure Example):</strong></p>
<pre><code class="language-nix"># default.nix
{ myHello = (import &lt;nixpkgs&gt; { }).hello; }
</code></pre>
</li>
<li>
<p><strong>Build (Impure):</strong></p>
<pre><code class="language-bash">nix-build -A myHello
</code></pre>
</li>
<li>
<p><strong>Impurity Explained:</strong></p>
<pre><code class="language-bash">nix repl
nix-repl&gt; &lt;nixpkgs&gt;
/nix/var/nix/profiles/per-user/root/channels/nixos
</code></pre>
<ul>
<li><code>&lt;nixpkgs&gt;</code> depends on the user's environment (Nixpkgs channel), making it impure. Even with channels disabled, it relies on a specific Nixpkgs version in the store.</li>
</ul>
</li>
<li>
<p><strong>Achieving Purity: Using <code>fetchTarball</code></strong></p>
<ul>
<li>
<p>GitHub allows downloading repository snapshots at specific commits, crucial for reproducibility.</p>
</li>
<li>
<p><strong>Get Nixpkgs Revision from <code>flake.lock</code> (from the Flake example):</strong></p>
</li>
</ul>
<pre><code class="language-nix"># flake.lock
"nixpkgs": {
  "locked": {
    "lastModified": 1746372124,
    "narHash": "sha256-n7W8Y6bL7mgHYW1vkXKi9zi/sV4UZqcBovICQu0rdNU=",
    "owner": "NixOS",
    "repo": "nixpkgs",
    "rev": "f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0",
    "type": "github"
  },
</code></pre>
</li>
<li>
<p><strong>Modify <code>default.nix</code> for Purity:</strong></p>
<pre><code class="language-nix"># default.nix
let
  nixpkgs = fetchTarball {
    url = "[https://github.com/NixOS/nixpkgs/archive/f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0.tar.gz](https://github.com/NixOS/nixpkgs/archive/f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0.tar.gz)";
    sha256 = "0000000000000000000000000000000000000000000000000000"; # Placeholder
  };
in {
  myHello = (import nixpkgs {}).hello;
}
</code></pre>
<ul>
<li>Replace <code>&lt;nixpkgs&gt;</code> with <code>fetchTarball</code> and a specific revision. A placeholder <code>sha256</code> is used initially.</li>
</ul>
</li>
<li>
<p><strong>Build (Nix provides the correct <code>sha256</code>):</strong></p>
<pre><code class="language-bash">nix-build -A myHello
</code></pre>
</li>
<li>
<p><strong>Verification:</strong> Both Flake and Traditional Nix builds now produce the same output path.</p>
</li>
<li>
<p><strong>Remaining Impurities in Traditional Nix:</strong></p>
<ul>
<li>Default arguments to <code>import &lt;nixpkgs&gt; {}</code> can introduce impurity:
<ul>
<li><code>overlays</code>: <code>~/.config/nixpkgs/overlays</code> (user-specific)</li>
<li><code>config</code>: <code>~/.config/nixpkgs/config.nix</code> (user-specific)</li>
<li><code>system</code>: <code>builtins.currentSystem</code> (machine-specific)</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Making Traditional Nix Fully Pure:</strong></p>
<pre><code class="language-nix"># default.nix
{system ? builtins.currentSystem}:
let
  nixpkgs = fetchTarball {
    url =
      "[https://github.com/NixOS/nixpkgs/archive/0243fb86a6f43e506b24b4c0533bd0b0de211c19.tar.gz](https://github.com/NixOS/nixpkgs/archive/0243fb86a6f43e506b24b4c0533bd0b0de211c19.tar.gz)";
    sha256 = "1qvdbvdza7hsqhra0yg7xs252pr1q70nyrsdj6570qv66vq0fjnh";
  };
in {
  myHello = (import nixpkgs {
    overlays = [];
    config = {};
    inherit system;
  }).hello;
}
</code></pre>
<ul>
<li>Override impure defaults for <code>overlays</code>, <code>config</code>, and make <code>system</code> an argument.</li>
</ul>
</li>
<li>
<p><strong>Building with a Specific System:</strong></p>
<pre><code class="language-bash">nix-build -A myHello --argstr system x86_64-linux
</code></pre>
</li>
<li>
<p><strong>Pure Evaluation Mode in Traditional Nix:</strong></p>
<pre><code class="language-bash">nix-instantiate --eval --pure-eval --expr 'fetchGit { url = ./.; rev = "b4fe677e255c6f89c9a6fdd3ddd9319b0982b1ad"; }'
</code></pre>
<ul>
<li>Example of using <code>--pure-eval</code>.</li>
</ul>
<pre><code class="language-bash">nix-build --pure-eval --expr '(import (fetchGit { url = ./.; rev = "b4fe677e255c6f89c9a6fdd3ddd9319b0982b1ad"; }) { system = "x86_64-linux"; }).myHello'
</code></pre>
<ul>
<li>Building with a specific revision and system.</li>
</ul>
</li>
</ol>
<h3 id="updating-nixpkgs"><a class="header" href="#updating-nixpkgs">Updating Nixpkgs</a></h3>
<pre><code class="language-bash">nix flake update
</code></pre>
<pre><code class="language-nix">nix build .#myHello --override-input nixpkgs github:NixOS/nixpkgs/nixos-24.11
</code></pre>
<h3 id="updating-traditional-nix-using-niv"><a class="header" href="#updating-traditional-nix-using-niv">Updating Traditional Nix (using <code>niv</code>)</a></h3>
<pre><code class="language-nix">nix-shell -p niv
niv init
</code></pre>
<pre><code class="language-nix"># default.nix
{ system ? builtins.currentSystem,
  sources ? import nix/sources.nix,
  nixpkgs ? sources.nixpkgs,
  pkgs ? import nixpkgs {
    overlays = [ ];
    config = { };
    inherit system;
  }, }: {
  myHello = pkgs.hello;
}
</code></pre>
<p>And build it with:</p>
<pre><code class="language-bash">nix-build -A myHello
</code></pre>
<pre><code class="language-bash">niv update nixpkgs --branch=nixos-unstable
nix-build -A myHello
</code></pre>
<h4 id="adding-home-manager-with-flakes"><a class="header" href="#adding-home-manager-with-flakes">Adding Home-Manager with Flakes</a></h4>
<pre><code class="language-nix"># flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
    home-manager.url = "github:nix-community/home-manager";
  };

  outputs = { self, nixpkgs, flake-utils, home-manager, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let pkgs = nixpkgs.legacyPackages.${system};
      in {
        packages.myHello = pkgs.hello;
        packages.x86_64-linux.homeManagerDocs =
          home-manager.packages.x86_64-linux.docs-html;
      });
}
</code></pre>
<pre><code class="language-bash">nix flake update
nix flake show github:nix-community/home-manager
</code></pre>
<pre><code class="language-nix">home-manager.inputs.follows = "nixpkgs";
</code></pre>
<h4 id="adding-home-manager-with-traditional-nix"><a class="header" href="#adding-home-manager-with-traditional-nix">Adding Home-Manager with Traditional Nix</a></h4>
<pre><code class="language-nix">niv add nix-community/home-manager
</code></pre>
<pre><code class="language-nix">nix repl
nix-repl&gt; s = import ./nix/sources.nix
nix-repl&gt; s.home-manager
</code></pre>
<pre><code class="language-nix">{ system ? builtins.currentSystem, sources ? import nix/sources.nix
  , nixpkgs ? sources.nixpkgs, pkgs ? import nixpkgs {
    overlays = [ ];
    config = { };
    inherit system;
  }, }: {
  homeManagerDocs = (import sources.home-manager { pkgs = pkgs; }).docs;

  myHello = pkgs.hello;
}
</code></pre>
<pre><code class="language-bash">nix-build -A homeManagerDocs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-8"><a class="header" href="#chapter-8">Chapter 8</a></h1>
<h1 id="debugging-and-tracing-nixos-modules"><a class="header" href="#debugging-and-tracing-nixos-modules">Debugging and Tracing NixOS Modules</a></h1>
<p><img src="images/gruv17.png" alt="gruv17" /></p>
<ul>
<li>
<p>Other related post if you haven't read my previous post on modules, that may
be helpful before reading this one:</p>
<ul>
<li>
<p><a href="https://saylesss88.github.io/posts/nix_modules_explained/">nix-modules-explained</a></p>
</li>
<li>
<p>This post is my notes following Nix Hour 40. If it seems a little chaotic,
try watching one. They are hard to follow if you're not extremely
familiar with the concepts.</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=aLy8id4wr-M&amp;t=2120s">Nix Hour 40</a></p>
</li>
</ul>
</li>
</ul>
<p>Nix Code is particularly hard to <strong>debug</strong> because of (e.g. lazy evaluation,
declarative nature, layered modules)</p>
<ul>
<li>The following simple Nix code snippet illustrates a basic NixOS module
definition and how options are declared and configured. We'll use this example
to demonstrate fundamental debugging techniques using <code>nix-instantiate</code>.</li>
</ul>
<pre><code class="language-nix">let
  lib = import &lt;nixpkgs/lib&gt;;
in
lib.evalModules {
  modules = [
    ({ lib, ... }: {
      options.foo = lib.mkOption {
        # type = lib.types.raw;
        type = lib.types.anything;
        # default = pkgs;
      };
      config.foo = {
        bar = 10;
        list = [1 2 3 ];
        baz = lib.mkDefault "baz";
      };
    })
    {
      foo.baz = "bar";
    }
  ];
}
</code></pre>
<ul>
<li>
<p>In the above code, adding <code>lib</code> to the function arguments isn't required but
if you were to move the module to another file it would fail without it
because <code>lib</code> comes from outside of it. So it's good practice to refer to <code>lib</code>
in the modules themselves.</p>
</li>
<li>
<p>You should <strong>always</strong> assign a type to your options, if you don't know which type
to use you could use <code>raw</code>. <code>raw</code> is a type that doesn't do any processing.
So if you were to assign the entire packages set to the option e.g.
<code>default = pkgs;</code> it wouldn't recurseinto all the packages and try to evaluate
them. There is also <code>anything</code>, that is useful if you do want to recurse into
the values.</p>
</li>
<li>
<p>The following is an example of how you would run this inside vim/neovim, the
rest of the examples will be from the command line:</p>
</li>
</ul>
<pre><code class="language-vim">:!nix-instantiate --eval -A config.foo --strict
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">{ bar = 10; baz = "bar"; list = [ 1 2 3 ]; }
</code></pre>
<p>To show the difference you could uncomment the <code>raw</code> type and comment the
<code>anything</code> type and run the above command again you'll see that you get an
error:</p>
<pre><code class="language-bash">error: The option 'foo' is defined multiple times while it's expected to be
unique
</code></pre>
<p>To execute this command on the command line:</p>
<pre><code class="language-bash">nix-instantiate --eval --strict -A config.foo
</code></pre>
<p>It will show you the start of a trace. To get the full trace add:</p>
<pre><code class="language-bash">nix-instantiate --eval --strict -A config.foo --show-trace
</code></pre>
<h2 id="example-2"><a class="header" href="#example-2">Example 2</a></h2>
<p>In the previous example, we looked at a simplified module. Now, let's examine a
more realistic scenario involving a basic NixOS configuration file
(<code>configuration.nix</code>).</p>
<p>This example will demonstrate how to use <code>nix-instantiate</code> to evaluate an entire
system configuration and how <code>--show-trace</code> helps in diagnosing errors within
this context.</p>
<p>Consider the following <code>configuration.nix</code> file:</p>
<pre><code class="language-nix"># configuration.nix
{ lib, ... }: {
  boot.loader.grub.device = "nodev";
  fileSystems."/".device = "/devst";
  system.stateVersion = "24.11";
}
</code></pre>
<ul>
<li>This configuration snippet sets the GRUB bootloader device, defines a root
filesystem, and specifies the expected NixOS state version. To evaluate this
entire system configuration, you can use <code>nix-instantiate</code> and point it to the
<code>&lt;nixpkgs/nixos&gt;</code> entrypoint, providing our <code>configuration.nix</code> file as an
argument. The <code>-A system</code> flag selects the top-level <code>system</code> attribute, which
represents the instantiated system configuration.</li>
</ul>
<p><strong>Run</strong> it in with:</p>
<pre><code class="language-bash">nix-instantiate '&lt;nixpkgs/nixos&gt;' --arg configuration ./configuration.nix -A system
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">/nix/store/kfcwvvpdbsb3xcks1s76id16i1mc3l5k-nixos-system-nixos-25.05pre-git.drv
</code></pre>
<p>Ok, we can see that this successfully <em>instantiates</em>. Let's introduce an error
to trace:</p>
<pre><code class="language-nix">{ lib, ... }: {
  boot.loader.grub.device = "nodev";
  fileSystems."/".device = "/devst";
  system.stateVersion = builtins.genList "24.11" null;
}
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">(stack trace truncated; use '--show-trace' to show the full, detailed trace)
error: expected an integer but found null: null
</code></pre>
<p>Rerun the command with <code>--show-trace</code> appended:</p>
<p>Or on the command line</p>
<pre><code class="language-bash">nix-instantiate '&lt;nixpkgs/nixos&gt;' --arg configuration ./configuration.nix -A system --show-trace
</code></pre>
<ul>
<li>This outputs a much longer trace than the first example. It shows you the file
the error occured in and you can see that in this case they are a lot of
internal functions. (e.g. <code>at /nix/store/ccfwxygjrarahgfv5865x2f828sjr5h0- source/lib/attrsets.nix:1529:14:</code>)</li>
</ul>
<p>To show your own error message you could do something like this:</p>
<pre><code class="language-nix">{lib, ...}: {
  boot.loader.grub.device = "nodev";
  fileSystems."/".device = "/devst";
  system.stateVersion = builtins.addErrorContext "AAAAAAAAAAAAAAAAA" (builtins.genList "24.11" null);
}
</code></pre>
<p>Run it:</p>
<pre><code class="language-bash">nix-instantiate '&lt;nixpkgs/nixos&gt;' --arg configuration ./configuration.nix -A system --show-trace`
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash"> … while evaluating the attribute 'value'
     at /nix/store/ccfwxygjrarahgfv5865x2f828sjr5h0-source/lib/modules.nix:770:21:
      769|             inherit (module) file;
      770|             inherit value;
         |                     ^
      771|           }) module.config

   … AAAAAAAAAAAAAAAAA

   … while calling the 'genList' builtin
     at /home/jr/tests/configuration.nix:4:71:
        3|   fileSystems."/".device = "/devst";
        4|   system.stateVersion = builtins.addErrorContext "AAAAAAAAAAAAAAAAA"
         (builtins.genList "24.11" null);
         |                                                                       ^
        5| }

   … while evaluating the second argument passed to builtins.genList

   error: expected an integer but found null: null
</code></pre>
<ul>
<li>In the latest nix they actually inverted the error messages so the most relevant
parts will be at the bottom.</li>
</ul>
<h2 id="example-3"><a class="header" href="#example-3">Example 3</a></h2>
<p>Let's consider another example, this time demonstrating the definition of
configuration options using <code>lib.mkOption</code> within a module structure.</p>
<pre><code class="language-nix"># default.nix
let
  lib = import &lt;nixpkgs/lib&gt;;
in
lib.evalModules {
  modules = [
    ({ lib, ... }: {
      options.ints = lib.mkOption {
        type = lib.types.attrsOf lib.types.int;
      };
      options.strings = lib.mkOption {
        type = lib.types.string;
        # type = lib.types.attrsOf lib.types.string;
        default = "foo";
      };
    })
  ];
}
</code></pre>
<p><strong>Instantiate</strong> this with:</p>
<pre><code class="language-bash">nix-instantiate --eval --strict -A config.strings
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">evaluation warning: The type `types.string` is deprecated.
See https://github.com/NixOS/nixpkgs/pull/66346 for better alternative types.
"foo"
</code></pre>
<ul>
<li>Unfortunately you won't get the same depreciation warning from <code>lib.attrsOf</code></li>
</ul>
<p>Below is an interesting way to provide nixpkgs run it on the command line:</p>
<pre><code class="language-bash">export NIX_PATH=nixpkgs=channel:nixpkgs-unstable
echo $NIX_PATH
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">nixpkgs=channel:nixpkgs-unstable
</code></pre>
<p>The next two commands are to check that after using the above way to provide
<code>nixpkgs-unstable</code> that they both point to the same store path, the following
command will fetch nixpkgs from the channel above:</p>
<pre><code class="language-bash">nix-instantiate --find-file nixpkgs
</code></pre>
<p><strong>Output</strong> 1️⃣</p>
<pre><code class="language-bash">/nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source
</code></pre>
<pre><code class="language-bash">nix-instantiate --eval channel:nixpkgs-unstable -A path
</code></pre>
<p><strong>Output</strong>: 2️⃣</p>
<pre><code class="language-bash">/nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source
</code></pre>
<ul>
<li>As you can see both commands produce the same store path</li>
</ul>
<h2 id="example-4"><a class="header" href="#example-4">Example 4</a></h2>
<p>In our previous example, we encountered a deprecation warning for
<code>lib.types.string</code>. This next example delves deeper into why that type was
deprecated and demonstrates the consequences of its behavior, along with the
recommended fix.</p>
<pre><code class="language-nix"># default.nix
let
  lib = import &lt;nixpkgs/lib&gt;;
in
  lib.evalModules {
    modules = [
      ({lib, ...}: {
        options.ints = lib.mkOption {
          type = lib.types.attrsOf lib.types.int;
        };
        options.strings = lib.mkOption {
          # type = lib.types.string;
          type = lib.types.attrsOf lib.types.string;
          default = {
            x = "foo";
          };
        };
        config = {
          strings = lib.mkOptionDefault {
            x = "bar";
          };
        };
      })
    ];
  }
</code></pre>
<p>Evaluate it with:</p>
<pre><code class="language-bash">nix-instantiate --eval --strict -A config.strings
</code></pre>
<ul>
<li>
<p><code>types.string</code> depricated because it silently concatenates strings</p>
</li>
<li>
<p>The above command has two options with the same priority level and evaluates
to <code>{ x = "foobar"; }</code></p>
</li>
</ul>
<p><strong>Output:</strong></p>
<pre><code class="language-bash">evaluation warning: The type `types.string` is deprecated. See https://github.
com/NixOS/nixpkgs/pull/66346 for better alternative types.
{ x = "foobar"; }
</code></pre>
<ul>
<li><code>types.str</code> was the replacement for the depricated <code>types.string</code>:</li>
</ul>
<pre><code class="language-nix"># default.nix
let
  lib = import &lt;nixpkgs/lib&gt;;
in
  lib.evalModules {
    modules = [
      ({lib, ...}: {
        options.ints = lib.mkOption {
          type = lib.types.attrsOf lib.types.int;
        };
        options.strings = lib.mkOption {
          # type = lib.types.string;
          type = lib.types.attrsOf lib.types.str;
          # Sets the value with a lower priority: lib.mkOptionDefault
          default = {
            x = "foo";
          };
        };
        config = {
          strings = lib.mkOptionDefault {
            x = "bar";
          };
        };
      })
    ];
  }
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-bash">error:
… while evaluating the attribute 'x'

… while evaluating the attribute 'value'
 at /nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source/lib/modules.nix:1148:41:
 1147|
 1148|     optionalValue = if isDefined then { value = mergedValue; } else { };
     |                                         ^
 1149|   };

… while calling the 'foldl'' builtin
 at /nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source/lib/options.nix:508:8:
  507|     else
  508|       (foldl' (
     |        ^
  509|         first: def:

(stack trace truncated; use '--show-trace' to show the full, detailed trace)

error: The option `strings.x' has conflicting definition values:
- In `&lt;unknown-file&gt;': "foo"
- In `&lt;unknown-file&gt;': "bar"
Use `lib.mkForce value` or `lib.mkDefault value` to change the priority on any of these definitions.

shell returned 1
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>
<p>So types in the module system aren't just types in the conventional sense
but they also specify the emerging behavior of these values.</p>
</li>
<li>
<p>If we switch the type in the above example to <code>types.lines</code> you get this
returned, <code>{ x = "foo\nbar"; }</code></p>
</li>
<li>
<p><code>mkOptionDefault</code> isn't typically something you should generally use, instead
options have a <code>default</code> setting</p>
</li>
<li>
<p>If you want to make sure that you set a default but if the user specifies it,
it shouldn't get overridden. You should not set it in the following:</p>
</li>
</ul>
<pre><code class="language-nix">options.strings = lib.mkOption {
  type = lib.types.attrsOf lib.types.lines;
  default = {
    x = "foo";
  };
}
</code></pre>
<p>Because the above uses <code>mkOptionDefault</code> but instead in under the <code>config</code>
attribute like the following:</p>
<pre><code class="language-nix"># ...snip...
options.strings = lib.mkOption {
  type = lib.types.attrsOf lib.types.lines;
  # default = {
    # x = "foo";
  # };
};
config = {
  strings = {
    x = lib.mkDefault "foo";
  };
};
# ...snip...
</code></pre>
<pre><code class="language-nix">let
  lib = import &lt;nixpkgs/lib&gt;;
in
  lib.evalModules {
    modules = [
      ({lib, ...}: {
        options.ints = lib.mkOption {
          type = lib.types.attrsOf lib.types.int;
        };
        options.strings = lib.mkOption {
          # type = lib.types.string;
          type = lib.types.attrsOf lib.types.str;
          # Sets the value with a lower priority: lib.mkOptionDefault
          #default = {
          #  x = "foo";
          #};
        };
        config.strings = {
          x = "foo";
        };
      })
      {
        config.strings = {
          y = "bar";
        };
      }
    ];
  }
</code></pre>
<p><strong>Output</strong>:</p>
<ul>
<li>This works now because there's no difference between <code>x</code> and <code>y</code></li>
</ul>
<pre><code class="language-bash">{ x = "foo"; y = "bar"; }
</code></pre>
<h2 id="more-functionality-between-modules"><a class="header" href="#more-functionality-between-modules">More Functionality between modules</a></h2>
<pre><code class="language-nix">let
  lib = import &lt;nixpkgs/lib&gt;;
in
  lib.evalModules {
    modules = [
      ({lib, ...}: {
        options.ints = lib.mkOption {
          type = lib.types.attrsOf lib.types.int;
        };
        options.strings = lib.mkOption {
          # type = lib.types.string;
          type = lib.types.attrsOf lib.types.str;
          # Sets the value with a lower priority: lib.mkOptionDefault
          #default = {
          #  x = "foo";
          #};
        };
        config.strings = {
          x = lib.mkDefault "foo";
        };
      })
      {
        config.strings = {
          x = "x";
          y = "bar";
        };
      }
    ];
  }
</code></pre>
<ul>
<li>The above command would cause a conflict without the <code>x = lib.mkDefault foo</code>
And this is typically what you want to do for defaults and modules in things
like nested configuration.</li>
</ul>
<p><strong>Output:</strong></p>
<pre><code class="language-bash">{ x = "x"; y = "bar"; }
</code></pre>
<h3 id="infinite-recursion-error"><a class="header" href="#infinite-recursion-error">Infinite recursion error</a></h3>
<ol>
<li>A common pitfall is to introduce a hard to debug error <code>infinite recursion</code>
when shadowing a name. The simplest example for this is:</li>
</ol>
<pre><code class="language-nix">let a = 1; in rec { a = a; }
</code></pre>
<blockquote>
<p>💡<strong>TIP</strong>: Avoid <code>rec</code>. Use <code>let ... in</code>
Example:</p>
<pre><code class="language-nix">let
 a = 1;
in {
 a = a;
 b = a + 2;
}
</code></pre>
</blockquote>
<p>We'll separate the logic for this example, this will be the <code>default.nix</code> this
is where having <code>lib</code> defined in your inline modules is helpful because you can
just delete the section and paste it into your <code>modules.nix</code>:</p>
<pre><code class="language-nix"># default.nix
let
  lib = import &lt;nixpkgs/lib&gt;;
in
  lib.evalModules {
    modules = [
      ./module.nix
    ];
  }
</code></pre>
<p>And in the <code>module.nix</code>:</p>
<pre><code class="language-nix"># module.nix
{ lib, pkgs, ...}: {
  options.etc = lib.mkOption {
    type = lib.types.attrsOf lib.types.path;
    default = { };
    description = ''
      Specifies which paths are is /etc/
    '';
  };

  config._module.args.pkgs = import &lt;nixpkgs&gt; {
    config = {};
    overlays = [];
  };
  config.etc.foo = pkgs.writeText "foo" ''
    foo configuration
  '';
}
</code></pre>
<ul>
<li>If you evaluate this with the following you will get an infinite recursion error.</li>
</ul>
<pre><code class="language-bash">nix-instantiate --eval --strict -A config.etc
</code></pre>
<ul>
<li>This happens because <code>--strict</code> evaluates the <code>etc</code>, then it goes into the
<code>attrsOf</code>, and the <code>path</code></li>
</ul>
<pre><code class="language-bash">nix repl
nix-repl&gt; :l &lt;nixpkgs&gt;
nix-repl&gt; hello.out.out.out
</code></pre>
<p>In this example:</p>
<ul>
<li>
<p><code>:l &lt;nixpkgs&gt;</code> loads the Nixpkgs library into the repl environment, making its
definitions available.</p>
</li>
<li>
<p><code>hello</code> refers to the <code>hello</code> package definition within Nixpkgs. Packages in
Nixpkgs are defined as <em>derivations</em>.</p>
</li>
<li>
<p><code>.out</code> is a common attribute name for the <em>main output</em> of a derivation
(e.g., the installed package). Some packages, especially those with complex
build processes or multiple outputs, might have nested output attributes.
In the case of <code>hello</code>, accessing <code>.out.out.out</code> ultimately leads us to the
<em>derivation</em> itself.</p>
</li>
</ul>
<p>The key takeaway here is that when you evaluate a package in the <code>nix repl</code>,
you're often interacting with its derivation or one of its output paths in the
Nix store. The <code>«derivation ...»</code> indicates that <code>hello.out.out.out</code> evaluates
to a derivation – the blueprint for building the <code>hello</code> package. This is in
contrast to <code>--eval --strict</code>, which tries to fully evaluate values, potentially
leading to infinite recursion if it encounters a derivation that refers back to
itself indirectly during attribute evaluation.</p>
<p><strong>Output:</strong></p>
<pre><code class="language-bash">«derivation /nix/store/b1vcpm321dwbwx6wj4n13l35f4y2wrfv-hello-2.12.1.drv»
</code></pre>
<ul>
<li>So it recurses through the entire thing and tries to evaluate its string.</li>
</ul>
<p>So we want to change the command from <code>--eval --strict</code> which is only based on
evaluation to at least <code>nix-instantiate</code> which is based on derivations:</p>
<pre><code class="language-bash">nix-instantiate -A config.etc
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-bash">warning: you did not specify '--add-root'; the result might be removed by the garbage collector
/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv
</code></pre>
<ul>
<li>We don't really have a derivation yet for example:</li>
</ul>
<pre><code class="language-nix"># module.nix
{
  lib,
  pkgs,
  ...
}: {
  options.etc = lib.mkOption {
    type = lib.types.attrsOf (lib.types.attrsOf lib.types.path);
    default = {};
    description = ''
      Specifies which paths are in /etc/
    '';
  };

  config._module.args.pkgs = import &lt;nixpkgs&gt; {
    config = {};
    overlays = [];
  };
  config.etc.foo.bar = pkgs.writeText "foo" ''
    foo configuration
  '';
}
</code></pre>
<p>Try to evaluate the above command with <code>nix-instantiate -A config.etc</code> and Nix
doesn't even try to build it. With nested <code>attrsOf</code></p>
<pre><code class="language-bash">nix repl -f default.nix
nix-repl&gt; config.etc
{
  foo = { ... };
}
nix-repl&gt; config.etc.foo
{
  bar = «derivation /nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv»;
}
</code></pre>
<ul>
<li>So <code>config.foo</code> is an attribute set and <code>config.etc.foo</code> is also an attribute
set but it's not a derivation by itself. So <code>nix-instantiate</code> does this one
level of recursion here and it would have built <code>foo</code> value if it were a
derivation.</li>
</ul>
<h3 id="example-5"><a class="header" href="#example-5">Example 5</a></h3>
<p>We'll use the same <code>module.nix</code> and <code>default.nix</code> from the previous example.</p>
<p>Building More Complex Configurations with Modules
In this next example, we'll focus on a common task in system configuration:
managing files within the <code>/etc/</code> directory. We'll define a module that allows
us to specify the content of arbitrary files in <code>/etc/</code> and then use a special
Nix function to combine these individual file definitions into a single,
manageable entity.</p>
<p>We'll introduce a new option, <code>options.etc</code>, which will allow us to define the
content of files within <code>/etc/</code>. Then, we'll use <code>pkgs.linkFarm</code> to create a
derivation that represents the entire <code>/etc/</code> directory as a collection of
symbolic links pointing to the individual file contents we've defined. This
demonstrates how modules can abstract away the details of creating complex
system configurations, providing a declarative and reproducible way to manage
even fundamental aspects of the operating system.</p>
<p>Let's show how we can use Nix modules to declaratively manage the <code>/etc/</code>
directory</p>
<pre><code class="language-nix"># default.nix
let
  lib = import &lt;nixpkgs/lib&gt;;
in
  lib.evalModules {
    modules = [
      ./module.nix
    ];
  }

</code></pre>
<pre><code class="language-nix"># module.nix
{
  lib,
  pkgs,
  config,
  ...
}: {
  options.etc = lib.mkOption {
    type = lib.types.attrsOf (lib.types.attrsOf lib.types.path);
    default = {};
    description = ''
      Specifies which paths are in /etc/
    '';
  };
  options.etcCombined = lib.mkOption {
    type = lib.types.package;
    default =
      pkgs.linkFarm "etc"
      (lib.mapAttrsToList (name: value: {
        name = name;
        path = value;
      }) config.etc);
  };

  config._module.args.pkgs = import &lt;nixpkgs&gt; {
    config = {};
    overlays = [];
  };
  config.etc.foo = pkgs.writeText "foo" ''
    foo configuration
  '';
  config.etc.bar = pkgs.writeText "bar" ''
    bar configuration
  '';
}

</code></pre>
<p>Run it with:</p>
<pre><code class="language-bash">nix-instantiate -A config.etcCombined
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv
</code></pre>
<ul>
<li>So we can see that it will instantiate, lets see if it will build:</li>
</ul>
<pre><code class="language-bash">nix-build -A config.etcCombined
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">these 3 derivations will be built:
/nix/store/41yfxq4af1vrs0rrgfk5gc36kmjc7270-bar.drv
/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv
/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv
building '/nix/store/41yfxq4af1vrs0rrgfk5gc36kmjc7270-bar.drv'...
building '/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv'...
building '/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv'...
/nix/store/ca3wyk5m3qhy8n1nbn0181m29qvp1klp-etc
</code></pre>
<pre><code class="language-bash">nix-build -A config.etcCombined &amp;&amp; ls result/ -laa
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">/nix/store/ca3wyk5m3qhy8n1nbn0181m29qvp1klp-etc
dr-xr-xr-x - root 31 Dec  1969  .
drwxrwxr-t - root 16 May 15:13  ..
lrwxrwxrwx - root 31 Dec  1969  bar -&gt; /nix/store/1fsjyc2hmilab1qw6jfkf6cb767kz858-bar
lrwxrwxrwx - root 31 Dec  1969  foo -&gt; /nix/store/wai5dycp0zx1lxg0rhpdxnydhiadpk05-foo
</code></pre>
<ul>
<li>
<p>We can see that <code>foo</code> and <code>bar</code> link to different derivations</p>
</li>
<li>
<p>When trying to figure out which <code>default</code> to use for <code>etcCombined</code> infinisil
went to the Nixpkgs Reference Manual. Make sure to go to the correct version.</p>
<ul>
<li>
<p><a href="https://nixos.org/manual/nixpkgs/stable/">24.11pre-git</a></p>
</li>
<li>
<p><a href="https://nixos.org/manual/nixpkgs/unstable/">25.05pre-git</a> (i.e. unstable)</p>
</li>
<li>
<p>Once at the website press <code>Ctrl+f</code> and type <code>symlinkjoin</code> and hit enter.</p>
</li>
</ul>
</li>
</ul>
<p>Or in your local copy of Nixpkgs you could go to <code>nixpkgs/pkgs/build-support/ trivial-builders/default.nix</code>. Then use your editors search feature, with nvim
and helix you press <code>/symlinkjoin</code> or <code>/linkFarm</code> hit enter then press <code>n</code> to
cycle to the next match. It will bring you to comments and up to date
information.</p>
<pre><code class="language-bash"># linkFarm "myexample" [ { name = "hello-test"; path = pkgs.hello; }
# { name = "foobar"; path = pkgs.stack; } ]
</code></pre>
<h3 id="tests"><a class="header" href="#tests">Tests</a></h3>
<ul>
<li>How to create a Derivation with <code>passthru.tests</code> outside of Nixpkgs
and then run tests available to your package set?</li>
</ul>
<pre><code class="language-bash">mkdir passthru-tests &amp;&amp; cd passthru-tests
</code></pre>
<p>Create a <code>default.nix</code> with the following:</p>
<pre><code class="language-nix"># default.nix
let
  pkgs = import &lt;nixpkgs&gt; {};

  package = pkgs.runCommand "foo" {
    passthru.tests.simple = pkgs.runCommand "foo-test" {} ''
      if [[ "$(cat ${package})" != "foo" ]]; then
        echo "Result is not foo"
        exit 1
      fi
      touch $out
  '';
  } ''
    echo foo &gt; $out
  '';
in
package
</code></pre>
<p>See if it will build:</p>
<pre><code class="language-bash">nix-build
</code></pre>
<p>Try running the test:</p>
<pre><code class="language-bash">nix-build -A passthru.tests
</code></pre>
<pre><code class="language-bash">this derivation will be built:
/nix/store/pqpqq9x1wnsabzbsb52z4g4y4zy6p7yx-foo-test.drv
building '/nix/store/pqpqq9x1wnsabzbsb52z4g4y4zy6p7yx-foo-test.drv'...
/nix/store/7bbw2ban0mgkh4d59yz3cnai4aavwvb6-foo-test
</code></pre>
<h3 id="test-2"><a class="header" href="#test-2">Test 2</a></h3>
<ul>
<li><code>passthru.tests</code> is the convention for defining tests associated with a
derivation. The attributes in <code>passthru</code> are preserved and accessible after
the derivation is built.</li>
</ul>
<pre><code class="language-nix">let
  pkgs = import &lt;nixpkgs&gt; {};

  package =
    pkgs.runCommand "foo" {
      passthru.tests.simple = pkgs.runCommand "foo-test" {} ''
        if [[ "$(cat ${package})" != "foo" ]]; then
          echo "Result is not foo"
          exit 1
        fi
        touch $out
      '';

      passthru.tests.version = pkgs.testers.testVersion {
         package = package;
         version = "1.2";
     };

      # pkgs.writeShellApplication
      script = ''
        #!${pkgs.runtimeShell}
        echo "1.2"
      '';
      passAsFiles = [ "script" ];

    } ''
      cp "$scriptPath" "$out"
    '';
in
  package
</code></pre>
<p>Try to build it:</p>
<pre><code class="language-bash">nix-build -A passthru.tests
</code></pre>
<ul>
<li>
<p><code>testers.testVersion</code> checks if an executable outputs a specific version string.</p>
</li>
<li>
<p><code>nix-build -A passthru.tests</code> specifically targets the derivations defined
within the tests attribute of the main derivation.</p>
</li>
</ul>
<pre><code class="language-bash">these 3 derivations will be built:
  /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv
  /nix/store/s4iawjy5zpv89dbkc3zz7z3ngz4jq2cv-foo-test.drv
  /nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z-foo-test-version.drv
building '/nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv'...
cp: cannot stat '': No such file or directory
error: builder for '/nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv'
 failed with exit code 1;
     last 1 log lines:
     &gt; cp: cannot stat '': No such file or directory
     For full logs, run:
       nix log /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv
error: 1 dependencies of derivation '/nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z
-foo-test-version.drv' failed to build
error: build of '/nix/store/s4iawjy5zpv89dbkc3zz7z3ngz4jq2cv-foo-test.drv',
 '/nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z-foo-test-version.drv' failed
</code></pre>
<p>Run <code>nix-build</code> with no arguments:</p>
<pre><code class="language-bash">nix-build
</code></pre>
<pre><code class="language-bash">nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq '.[].env'
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-json">{
  "__structuredAttrs": "",
  "buildCommand": "cp \"$scriptPath\" \"$out\"\n",
  "buildInputs": "",
  "builder": "/nix/store/xg75pc4yyfd5n2fimhb98ps910q5lm5n-bash-5.2p37/bin/bash",
  "cmakeFlags": "",
  "configureFlags": "",
  "depsBuildBuild": "",
  "depsBuildBuildPropagated": "",
  "depsBuildTarget": "",
  "depsBuildTargetPropagated": "",
  "depsHostHost": "",
  "depsHostHostPropagated": "",
  "depsTargetTarget": "",
  "depsTargetTargetPropagated": "",
  "doCheck": "",
  "doInstallCheck": "",
  "enableParallelBuilding": "1",
  "enableParallelChecking": "1",
  "enableParallelInstalling": "1",
  "mesonFlags": "",
  "name": "foo",
  "nativeBuildInputs": "",
  "out": "/nix/store/9mcrnddb6lf1md14v4lj6s089i99l5k7-foo",
  "outputs": "out",
  "passAsFile": "buildCommand",
  "passAsFiles": "script",
  "patches": "",
  "propagatedBuildInputs": "",
  "propagatedNativeBuildInputs": "",
  "script": "#!/nix/store/xg75pc4yyfd5n2fimhb98ps910q5lm5n-bash-5.2p37/bin/bash\necho \"1.2\"\n",
  "stdenv": "/nix/store/lgydi1gl5wqcw6k4gyjbaxx7b40zxrsp-stdenv-linux",
  "strictDeps": "",
  "system": "x86_64-linux"
}
</code></pre>
<pre><code class="language-bash">nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq
 '.[].env.buildCommand'
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-bash">"cp \"$scriptPath\" \"$out\"\n"
</code></pre>
<ul>
<li>raw mode below</li>
</ul>
<pre><code class="language-bash">nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq
 '.[].env.buildCommand' -r
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">cp "$scriptPath" "$out"
</code></pre>
<ul>
<li>It turns out the correct command was <code>passAsFile</code> not <code>passAsFiles</code> but that
change wasn't enough to fix it. <code>passAsFiles</code> expects a list of files, not a
single file path. Running <code>nix-build -A passthru.tests</code> failed
saying <code>&gt; foo --version returned a non-zero exit code.</code></li>
</ul>
<pre><code class="language-nix">let
  pkgs = import &lt;nixpkgs&gt; {};

  package =
    pkgs.runCommand "foo" {
      #passthru.tests.simple = pkgs.runCommand "foo-test" {} ''
      #  if [[ "$(cat ${package})" != "foo" ]]; then
      #    echo "Result is not foo"
      #    exit 1
      #  fi
      #  touch $out
      #'';

      passthru.tests.version = pkgs.testers.testVersion {
        package = package;
        version = "1.2";
      };

      # pkgs.writeShellApplication
      script = ''
        #!${pkgs.runtimeShell}
        echo "1.2"
      '';
      passAsFile = ["script"];
    } ''
      mkdir -p "$out/bin"
      cp "$scriptPath" "$out/bin/foo"
      chmod +x "$out/bin/foo"
    '';
in
  package
</code></pre>
<p>Build it:</p>
<pre><code class="language-bash">nix-build -A passthru.tests
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-bash">these 2 derivations will be built:
  /nix/store/lqrlcd64dmpzkggcfzlnsnwjd339czd3-foo.drv
  /nix/store/c3kw4xbdlrig08jrdm5wis1dmv2gnqsd-foo-test-version.drv
building '/nix/store/lqrlcd64dmpzkggcfzlnsnwjd339czd3-foo.drv'...
building '/nix/store/c3kw4xbdlrig08jrdm5wis1dmv2gnqsd-foo-test-version.drv'...
1.2
/nix/store/zsbk5zawak68ailvkwi2gad2bqbqmdz9-foo-test-version
</code></pre>
<h3 id="key-takeaways-for-debugging-nixos-modules"><a class="header" href="#key-takeaways-for-debugging-nixos-modules">Key Takeaways for Debugging NixOS Modules</a></h3>
<ul>
<li>
<p><strong><code>nix-instantiate</code> is Your Friend:</strong> Use <code>nix-instantiate</code> to evaluate your
NixOS modules and pinpoint errors.</p>
</li>
<li>
<p><strong>Unlock Details with <code>--show-trace</code>:</strong> When errors occur, always append
<code>--show-trace</code> to get a comprehensive stack trace, revealing the origin of the
problem. Remember that in newer Nix versions, the most relevant parts of the
trace are often at the bottom.</p>
</li>
<li>
<p><strong>Understand Option Types:</strong> Nix option types (<code>raw</code>, <code>anything</code>, <code>string</code>/<code>str</code>,
<code>lines</code>, <code>attrsOf</code>) are not just about data types; they also dictate how values
are merged and processed within the module system.</p>
</li>
<li>
<p><strong>Be Mindful of <code>mkOptionDefault</code>:</strong> While useful in specific scenarios,
<code>mkOptionDefault</code> sets a lower priority default. For standard defaults that
can be overridden by user configuration, define them directly within the <code>config</code>
attribute using <code>lib.mkDefault</code>.</p>
</li>
<li>
<p><strong>Use <code>builtins.addErrorContext</code>:</strong> Enhance your custom error messages by
providing specific context relevant to your module's logic using
<code>builtins.addErrorContext</code>.</p>
</li>
<li>
<p><strong>Derivations vs. Evaluation:</strong> Be aware of the difference between evaluating
expressions (<code>--eval --strict</code>) and instantiating derivations (<code>nix-instantiate</code>).
Strict evaluation can trigger infinite recursion if it encounters unevaluated
derivations with cyclic dependencies during attribute access.</p>
</li>
<li>
<p><strong>Explore with <code>nix repl</code>:</strong> The <code>nix repl</code> allows you to interactively explore
Nix expressions and the outputs of derivations, providing insights into the
structure and values within Nixpkgs.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
