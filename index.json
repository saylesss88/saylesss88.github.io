[{"id":0,"title":"NixOS Blog","summary":"","content":"","tags":[],"date":"2025-05-16","permalink":"https://saylesss88.github.io/"},{"id":1,"title":"Posts","summary":"","content":"","tags":[],"date":"2025-05-16","permalink":"https://saylesss88.github.io/posts/"},{"id":2,"title":"Using_nushell_with_nixos","summary":"Nushell and NixOS I recently switched default shells from zsh to nushell, this post is about some of the challenges and advantages of using nushell with NixOS.\nNushell borrows concepts from many shells and languages and is itself both a programming language and a shell. Because of this, it has it\u0026rsquo;s own way of working with files, directories, websites, and more.\nNushell is powerful and has many essential commands built directly into the shell (\u0026ldquo;internal\u0026rdquo; commands) rather than a link to an executable. You can use this set of commands across different operating systems, having this consistency is helpful when creating cross-platform code.\n","content":"Nushell and NixOS I recently switched default shells from zsh to nushell, this post is about some of the challenges and advantages of using nushell with NixOS.\nNushell borrows concepts from many shells and languages and is itself both a programming language and a shell. Because of this, it has it\u0026rsquo;s own way of working with files, directories, websites, and more.\nNushell is powerful and has many essential commands built directly into the shell (\u0026ldquo;internal\u0026rdquo; commands) rather than a link to an executable. You can use this set of commands across different operating systems, having this consistency is helpful when creating cross-platform code.\nls # Internal command ^ls # External command (typically /usr/bin/ls) The Reedline-Editor is powerful and provides good vi-mode or emacs support built in.\nIt\u0026rsquo;s default Ctrl+r history command is nice and structured.\nNushell has helpful rust like error messages\nVariables are Immutable by Default: Nushell\u0026rsquo;s commands are based on a functional-style of programming which requires immutability, sound familiar?\nNushell\u0026rsquo;s Environment is Scoped: Nushell takes many design cues from compiled languages, one is that languages should avoid global mutable state. Shells have commonly used global mutation to update the environment, Nushell attempts to steer clear of this increasing reproducability.\nSingle-use Environment Variables:\nFOO=BAR $env.FOO # =\u0026gt; BAR Permanent Environment Variables: In your config.nu # config.nu $env.FOO = \u0026#39;BAR\u0026#39; Coming-From-Bash The Challenges There are many similarities so it can be easy to forget that some Bash (and POSIX in general) style constructs just won\u0026rsquo;t work in Nushell. Considering that NixOS seems to have been designed for bash, even Zsh isn\u0026rsquo;t fully compatable you may want to think twice before you choose Nushell as your default.\nThe documentation is incomplete, it\u0026rsquo;s not as mature as other shells including fish.\n\u0026amp;\u0026amp; doesn\u0026rsquo;t work use ; instead.\n\u0026gt; is used as the greater-than operator for comparisons:\n\u0026#34;hello\u0026#34; | save output.txt is equivalent to the following in bash:\necho \u0026#34;hello\u0026#34; \u0026gt; output.txt If you notice above the nushell command doesn\u0026rsquo;t require an echo prefix, this is because Nushell has Implicit Return: \u0026#34;Hello, World\u0026#34; == (echo \u0026#34;Hello, World\u0026#34;) # =\u0026gt; true The above example shows that the string, \u0026quot;Hello, World\u0026quot; is equivalent to the output value from echo \u0026quot;Hello, World\u0026quot;\nEvery Command Returns a Value:\nlet p = 7 print $p # 7 $p * 6 # 42 Multi-Line Editing:\nWhen writing a long command you can press Enter to add a newline and move to the next line. For example:\nls | # press enter where name =~ | # press enter, comments after pipe ok get name | # press enter mv ...$in ./backups/ This allows you to cycle through the entire multi-line command using the up and down arrow keys and then customize different lines or sections of the command.\nYou can manually insert a newline using Alt+Enter or Shift+Enter.\nKey Differences Between Nushell \u0026amp; Bash\nFeature Bash (Dynamic) Nushell (Static) Code Execution Line-by-line Whole script parsed first Error Detection Runtime errors only Catches errors before running Support for eval ✅ Allowed ❌ Not supported Custom Parsing Limited Built-in semantic analysis IDE Features Basic syntax highlighting Advanced integration, linting, and formatting Nushell Showcase Ctrl+t List Commands with carapace and fzf:\nCarapace Carapace-Bin Install:\nCarapace man example:\nCustom Nushell Commands\nThe following command allows you to choose which input to update interactively with fzf. # nix.nu # upgrade system packages # `nix-upgrade` or `nix-upgrade -i` def nix-upgrade [ flake_path: string = \u0026#34;/home/jr/flake\u0026#34;, # path that contains a flake.nix --interactive (-i) # select packages to upgrade interactively ]: nothing -\u0026gt; nothing { let working_path = $flake_path | path expand if not ($working_path | path exists) { echo \u0026#34;path does not exist: $working_path\u0026#34; exit 1 } let pwd = $env.PWD cd $working_path if $interactive { let selections = nix flake metadata . --json | from json | get locks.nodes | columns | str join \u0026#34;\\n\u0026#34; | fzf --multi --tmux center,20% | lines # Debug: Print selections to verify print $\u0026#34;Selections: ($selections)\u0026#34; # Check if selections is empty if ($selections | is-empty) { print \u0026#34;No selections made.\u0026#34; cd $pwd return } # Use spread operator to pass list items as separate arguments nix flake update ...$selections } else { nix flake update } cd $pwd nh os switch $working_path } The ns command is designed to search for Nix packages using nix search and present the results in a cleaner format, specifically removing the architecture and operating system prefix that nix search often includes. def ns [ term: string # Search target. ] { let info = ( sysctl -n kernel.arch kernel.ostype | lines | {arch: ($in.0|str downcase), ostype: ($in.1|str downcase)} ) nix search --json nixpkgs $term | from json | transpose package description | flatten | select package description version | update package {|row| $row.package | str replace $\u0026#34;legacyPackages.($info.arch)-($info.ostype).\u0026#34; \u0026#34;\u0026#34;} } nufetch command: # `nufetch` `(nufetch).packages` def nufetch [] { { \u0026#34;kernel\u0026#34;: $nu.os-info.kernel_version, \u0026#34;nu\u0026#34;: $env.NU_VERSION, \u0026#34;packages\u0026#34;: (ls /etc/profiles/per-user | select name | prepend [[name];[\u0026#34;/run/current-system/sw\u0026#34;]] | each { insert \u0026#34;number\u0026#34; (nix path-info --recursive ($in | get name) | lines | length) | insert \u0026#34;size\u0026#34; ( nix path-info -S ($in | get name) | parse -r \u0026#39;\\s(.*)\u0026#39; | get capture0.0 | into filesize) | update \u0026#34;name\u0026#34; ($in | get name | parse -r \u0026#39;.*/(.*)\u0026#39; | get capture0.0 | if $in == \u0026#34;sw\u0026#34; {\u0026#34;system\u0026#34;} else {$in}) | rename \u0026#34;environment\u0026#34;}), \u0026#34;uptime\u0026#34;: (sys host).uptime } } duf command, I have mine aliased to df: ps command: Adding the following to your configuration.nix will show you the diff of the closures on rebuild: # configuration.nix # During system activation, compare the closure size difference between the # current and new system and display a formatted table if significant changes are # detected. system.activationScripts.diff = \u0026#39;\u0026#39; if [[ -e /run/current-system ]]; then ${pkgs.nushell}/bin/nu -c \u0026#34;let diff_closure = (${pkgs.nix}/bin/nix store diff-closures /run/current-system \u0026#39;$systemConfig\u0026#39;); let table = (\\$diff_closure | lines | where \\$it =~ KiB | where \\$it =~ → | parse -r \u0026#39;^(?\u0026lt;Package\u0026gt;\\S+): (?\u0026lt;Old\u0026gt;[^,]+)(?:.*) → (?\u0026lt;New\u0026gt;[^,]+)(?:.*), (?\u0026lt;DiffBin\u0026gt;.*)$\u0026#39; | insert Diff { get DiffBin | ansi strip | into filesize } | sort-by -r Diff | reject DiffBin); if (\\$table | get Diff | is-not-empty) { print \\\u0026#34;\\\u0026#34;; \\$table | append [[Package Old New Diff]; [\\\u0026#34;\\\u0026#34; \\\u0026#34;\\\u0026#34; \\\u0026#34;\\\u0026#34; \\\u0026#34;\\\u0026#34;]] | append [[Package Old New Diff]; [\\\u0026#34;\\\u0026#34; \\\u0026#34;\\\u0026#34; \\\u0026#34;Total:\\\u0026#34; (\\$table | get Diff | math sum) ]] | print; print \\\u0026#34;\\\u0026#34; }\u0026#34; fi \u0026#39;\u0026#39;; nix-list-system command lists all installed packages: # list all installed packages def nix-list-system []: nothing -\u0026gt; list\u0026lt;string\u0026gt; { ^nix-store -q --references /run/current-system/sw | lines | filter { not ($in | str ends-with \u0026#39;man\u0026#39;) } | each { $in | str replace -r \u0026#39;^[^-]*-\u0026#39; \u0026#39;\u0026#39; } | sort } Using Just and Justfiles The following is my justfile that I keep right next to my flake.nix it simplifies some commands and makes things work that weren\u0026rsquo;t working with nushell for my case, you\u0026rsquo;ll have to change it to match your configuration. It\u0026rsquo;s not perfect but works for my use case, take whats useful and leave the rest.\nYou\u0026rsquo;ll first need to install just to make use of justfiles.\n# nix shell nixpkgs#just nixpkgs#nushell set shell := [\u0026#34;nu\u0026#34;, \u0026#34;-c\u0026#34;] flake_path := \u0026#34;/home/jr/flake\u0026#34; hostname := \u0026#34;magic\u0026#34; home_manager_output := \u0026#34;jr@magic\u0026#34; utils_nu := absolute_path(\u0026#34;utils.nu\u0026#34;) default: @just --list # Rebuild [group(\u0026#39;nix\u0026#39;)] fr: nh os switch --hostname {{hostname}} {{flake_path}} # Flake Update [group(\u0026#39;nix\u0026#39;)] fu: nh os switch --hostname {{hostname}} --update {{flake_path}} # Update specific input # Usage: just upp nixpkgs [group(\u0026#39;nix\u0026#39;)] upp input: nix flake update {{input}} # Test [group(\u0026#39;nix\u0026#39;)] ft: nh os test --hostname {{hostname}} {{flake_path}} # Collect Garbage [group(\u0026#39;nix\u0026#39;)] ncg: nix-collect-garbage --delete-old ; sudo nix-collect-garbage -d ; sudo /run/current-system/bin/switch-to-configuration boot [group(\u0026#39;nix\u0026#39;)] cleanup: nh clean all # Clean [group(\u0026#39;nix\u0026#39;)] clean: sudo nix profile wipe-history --profile /nix/var/nix/profiles/system --older-than 3d # Upgrade [group(\u0026#39;nix\u0026#39;)] upd: nh os switch -u {{flake_path}} ; nh os switch --hostname {{hostname}} {{flake_path}} [group(\u0026#39;nix\u0026#39;)] eval: nix-instantiate --eval --json --strict | jq # Nix Repl flake:nixpkgs [group(\u0026#39;nix\u0026#39;)] repl: nix repl -f flake:nixpkgs # format the nix files in this repo [group(\u0026#39;nix\u0026#39;)] fmt: nix fmt # Show all the auto gc roots in the nix store [group(\u0026#39;nix\u0026#39;)] gcroot: ls -al /nix/var/nix/gcroots/auto/ # Verify all store entries [group(\u0026#39;nix\u0026#39;)] verify-store: nix store verify --all [group(\u0026#39;nix\u0026#39;)] repair-store *paths: nix store repair {{paths}} # Usage: `./result/bin/run-*-vm` # may need to set initialHashedPassword first [group(\u0026#39;nix\u0026#39;)] vm: sudo nixos-rebuild build-vm system-info: \u0026#34;This is an {{arch()}} machine\u0026#34; running: ps | where status == Running help: help commands | explore # ================================================= # # Other useful commands # # ================================================= [group(\u0026#39;common\u0026#39;)] path: $env.PATH | split row \u0026#34;:\u0026#34; [group(\u0026#39;common\u0026#39;)] trace-access app *args: strace -f -t -e trace=file {{app}} {{args}} | complete | $in.stderr | lines | find -v -r \u0026#34;(/nix/store|/newroot|/proc)\u0026#34; | parse --regex \u0026#39;\u0026#34;(/.+)\u0026#34;\u0026#39; | sort | uniq [linux] [group(\u0026#39;common\u0026#39;)] penvof pid: sudo cat $\u0026#34;/proc/($pid)/environ\u0026#34; | tr \u0026#39;\\0\u0026#39; \u0026#39;\\n\u0026#39; # Remove all reflog entries and prune unreachable objects [group(\u0026#39;git\u0026#39;)] ggc: git reflog expire --expire-unreachable=now --all git gc --prune=now # Amend the last commit without changing the commit message [group(\u0026#39;git\u0026#39;)] game: git commit --amend -a --no-edit [group(\u0026#39;git\u0026#39;)] push: git push -u origin main # Delete all failed pods [group(\u0026#39;k8s\u0026#39;)] del-failed: kubectl delete pod --all-namespaces --field-selector=\u0026#34;status.phase==Failed\u0026#34; [linux] [group(\u0026#39;services\u0026#39;)] list-inactive: systemctl list-units -all --state=inactive [linux] [group(\u0026#39;services\u0026#39;)] list-failed: systemctl list-units -all --state=failed [linux] [group(\u0026#39;services\u0026#39;)] list-systemd: systemctl list-units systemd-* # List journal [linux] [group(\u0026#39;services\u0026#39;)] jctl: ^jctl = \u0026#34;journalctl -p 5 -xb\u0026#34;; To list available commands type, (you must be in the same directory as the justfile): just So just list-failed will list any failed systemd services for example.\nA lot of the .nu files came from this repo by BlindFS:\nmodern-dot-files he uses Nix Darwin so there are many changes for NixOS.\nmy-nu-config Warning, it\u0026rsquo;s very complex and hard to understand. Just know that from my shells directory I import the nushell directory which contains a default.nix which is the entrypoint for this configuration. The default.nix has configFile.source = ./config.nu; which integrates all the .nu files. I know it\u0026rsquo;s a mess, I\u0026rsquo;ll refactor shortly.\nThe examples use my-starship-config the logic at the end works for bash, zsh, and nushell.\nIf you wan\u0026rsquo;t to use my config you\u0026rsquo;ll have to enable the experimental-feature pipe-operators in the same place you enable flakes and nix-command.\nThere are still situations where I need to switch to zsh or bash to get something to work i.e. nix-shell and a few others.\nResources Nushell-Book\nNushell-Cookbook\nnu_scripts some of the custom commands came from here.\nnushell sample-config\nawesome-nu repo\nnu showcase-repo\ndiscord You can find custom commands, configurations, etc here.\n","tags":[],"date":"2025-05-16","permalink":"https://saylesss88.github.io/posts/using_nushell_with_nixos/"},{"id":3,"title":"Nixpkgs_pull_requests","summary":"Nixpkgs Pull Requests Pull requests communicate changes to a branch in a repository. Once a pull request is opened, you can review changes with collaborators and add follow-up commits.\nA pull request is a proposal to merge a set of changes from one branch into another. In a pull request, collaborators can review and discuss the proposed set of changes before they integrate the changes into the main codebase.\n","content":"Nixpkgs Pull Requests Pull requests communicate changes to a branch in a repository. Once a pull request is opened, you can review changes with collaborators and add follow-up commits.\nA pull request is a proposal to merge a set of changes from one branch into another. In a pull request, collaborators can review and discuss the proposed set of changes before they integrate the changes into the main codebase.\nPull requests display the differences, or diffs, between the content in the source branch and the content in the target branch.\ngraph LR A[Your Local Repository] --\u0026gt; B(Feature Branch); B --\u0026gt; C{GitHub Repository}; C -- \u0026#34;Open Pull Request\u0026#34; --\u0026gt; D[Pull Request on GitHub]; D -- \u0026#34;Review \u0026amp; Discussion\u0026#34; --\u0026gt; D; D -- \u0026#34;Merge\u0026#34; --\u0026gt; E(Main Branch on GitHub); E --\u0026gt; F[Nixpkgs Users]; Explanation of the Diagram:\nA[Your Local Repository]: This represents the copy of the Nixpkgs repo on your computer where you make changes.\nB (Feature Branch): You create a dedicated branch (e.g.my-pack-update) to isolate your changes.\nC {GitHub Repository}: This is the central online repo for Nixpkgs on Github. You push your feature branch to this repo.\nC \u0026ndash; \u0026ldquo;Open Pull Request\u0026rdquo; \u0026ndash; D [Pull Request on Github]: You initiate a pull request from your feature branch to the main branch (usually master or main) through the GitHub interface.\nD [Pull Request on GitHub]: This is where collaborators can see your proposed changes, discuss them, and provide feedback.\nD \u0026ndash; \u0026ldquo;Review \u0026amp; Discussion\u0026rdquo; \u0026ndash;\u0026gt; D: The pull request facilitates communication and potential revisions based on the review.\nD \u0026ndash; \u0026ldquo;Merge\u0026rdquo; \u0026ndash;\u0026gt; E (Main Branch on GitHub): Once the changes are approved, they are merged into the main branch of the Nixpkgs repository.\nE (Main Branch on GitHub): The main branch now contains the integrated changes.\nE \u0026ndash;\u0026gt; F [Nixpkgs Users]): Eventually, these changes become available to all Nixpkgs users through updates to their Nix installations.\nFlakes often rely on having access to the full history of the Git repository to correctly determine dependencies, identify specific revisions of inputs, and evaluate the flake. Not in all situations will a shallow clone work and this is one of them.\nIf you have any changes to your local copy of Nixpkgs make sure to stash them before the following:\ngit stash -u This command saves your uncommited changes (including staged files) temporarily. You can restore them later with git stash pop Step 1 Clone Nixpkgs Locally\nIf you don\u0026rsquo;t have Nixpkgs locally, you\u0026rsquo;ll need to clone it:\ngit clone https://github.com/NixOS/nixpkgs.git Step 2 Find a Relevant Pull Request\nTo find a relevant PR you can go to:\nnixos-pr\nIn the Filters enter stack trace for this example.\nThe pull request I chose was 8623\nStep 3 Add the Remote Repository (if necessary)\nIf the pull request is from a different repository than your local clone (as in the case of the nix PR while working in a nixpkgs clone), you need to add that repository as a remote. It\u0026rsquo;s common to name the main Nixpkgs remote origin and other related repositories like nix as upstream.\nAssuming you are in your nixpkgs clone and want to test a PR from the nix repository:\ngit remote add upstream https://github.com/NixOS/nix.git Step 4 Fetch the Pull Request Changes\nFetch the Pull Request Information:\ngit fetch upstream refs/pull/8623/head:pr-8623 This command fetches the branch named head from the pull request 8623 in the upstream remote and creates a local branch named pr-8623 that tracks it. Output:\nremote: Enumerating objects: 104651, done. remote: Counting objects: 100% (45/45), done. remote: Compressing objects: 100% (27/27), done. remote: Total 104651 (delta 33), reused 20 (delta 18), pack-reused 104606 (from 1) Receiving objects: 100% (104651/104651), 61.64 MiB | 12.56 MiB/s, done. Resolving deltas: 100% (74755/74755), done. From https://github.com/NixOS/nix * [new ref] refs/pull/8623/head -\u0026gt; pr-8623 * [new tag] 1.0 -\u0026gt; 1.0 * [new tag] 1.1 -\u0026gt; 1.1 * [new tag] 1.10 -\u0026gt; 1.10 * [new tag] 1.11 -\u0026gt; 1.11 * [new tag] 1.11.1 -\u0026gt; 1.11.1 * [new tag] 1.2 -\u0026gt; 1.2 * [new tag] 1.3 -\u0026gt; 1.3 * [new tag] 1.4 -\u0026gt; 1.4 * [new tag] 1.5 -\u0026gt; 1.5 * [new tag] 1.5.1 -\u0026gt; 1.5.1 * [new tag] 1.5.2 -\u0026gt; 1.5.2 * [new tag] 1.5.3 -\u0026gt; 1.5.3 * [new tag] 1.6 -\u0026gt; 1.6 * [new tag] 1.6.1 -\u0026gt; 1.6.1 * [new tag] 1.7 -\u0026gt; 1.7 * [new tag] 1.8 -\u0026gt; 1.8 * [new tag] 1.9 -\u0026gt; 1.9 * [new tag] 2.0 -\u0026gt; 2.0 * [new tag] 2.2 -\u0026gt; 2.2 Step 5 Checkout the Local Branch:\ngit checkout pr-8623 Or with the gh cli:\ngh pr checkout 8623 Build and Test the Changes Now we want to see if the code changes introduced by the pull request actually build correctly within the Nix ecosystem. nix build Output:\nerror: builder for \u0026#39;/nix/store/rk86daqgf6a9v6pdx6vcc5b580lr9f09-nix-2.20.0pre20240115_20b4959.drv\u0026#39; failed with exit code 2; last 25 log lines: \u0026gt; \u0026gt; _NIX_TEST_ACCEPT=1 make tests/functional/lang.sh.test \u0026gt; \u0026gt; to regenerate the files containing the expected output, \u0026gt; and then view the git diff to decide whether a change is \u0026gt; good/intentional or bad/unintentional. \u0026gt; If the diff contains arbitrary or impure information, \u0026gt; please improve the normalization that the test applies to the output. \u0026gt; make: *** [mk/lib.mk:90: tests/functional/lang.sh.test] Error 1 \u0026gt; make: *** Waiting for unfinished jobs.... \u0026gt; ran test tests/functional/selfref-gc.sh... [PASS] \u0026gt; ran test tests/functional/store-info.sh... [PASS] \u0026gt; ran test tests/functional/suggestions.sh... [PASS] \u0026gt; ran test tests/functional/path-from-hash-part.sh... [PASS] \u0026gt; ran test tests/functional/gc-auto.sh... [PASS] \u0026gt; ran test tests/functional/path-info.sh... [PASS] \u0026gt; ran test tests/functional/flakes/show.sh... [PASS] \u0026gt; ran test tests/functional/fetchClosure.sh... [PASS] \u0026gt; ran test tests/functional/completions.sh... [PASS] \u0026gt; ran test tests/functional/build.sh... [PASS] \u0026gt; ran test tests/functional/impure-derivations.sh... [PASS] \u0026gt; ran test tests/functional/build-delete.sh... [PASS] \u0026gt; ran test tests/functional/build-remote-trustless-should-fail-0.sh... [PASS] \u0026gt; ran test tests/functional/build-remote-trustless-should-pass-2.sh... [PASS] \u0026gt; ran test tests/functional/nix-profile.sh... [PASS] For full logs, run: nix log /nix/store/rk86daqgf6a9v6pdx6vcc5b580lr9f09-nix-2.20.0pre20240115_20b4959.drv nix build (Part of the Nix Unified CLI):\nDeclarative: when used within a Nix flake (flake.nix), nix build is a bit more declarative. It understands the outputs defined in your flake.\nClearer Output Paths: nix build typically places build outputs in the ./result directory by default (similar to nix-build\u0026rsquo;s result symlink)\nBetter Error Reporting: It gives more informative error messages.\nFuture Direction\nBenefits of using nix build:\nFlake Integration: nix build naturally understands the flake\u0026rsquo;s outputs.\nDevelopment Shells: When you are in a nix develop shell, nix build is the more idiomatic way to build packages defined in your dev environment.\nConsistency: Using the unified CLI promotes a more consistent workflow.\nNext Steps As you can see this build failed, as for why the build failed, the key part of the error message is:\nmake: *** [mk/lib.mk:90: tests/functional/lang.sh.test] Error 1 This suggests that one of the functional tests (lang.sh.test) failed. This happens when the expected output of the test doesn\u0026rsquo;t match the actual output. This can heppen when:\nThe test expectations are outdated due to changes in the codebase.\nThe test captures environment-specific or transient outputs that are not properly normalized.\nThe test includes impure or non-deterministic information, making it hard to verify.\nTo address this, _NIX_TEST_ACCEPT=1 is used as an override mechanism that tells the test framework: \u0026gt; \u0026ldquo;Accept whatever output is generated as the new expected result.\u0026rdquo;\nThe message advises running:\n_NIX_TEST_ACCEPT=1 make tests/functional/lang.sh.test This will regenerate the expected output files, allowing you to inspect what changed with git diff: git diff tests/functional/lang.sh.test Verifies if Changes are Intentional: If the difference is reasonable and expected (due to a legitimate update in the logic), you can commit these changes to update the test suit. If not, you have to refine the test normalization process further. If the changes seem valid, commit them:\ngit add tests/functional/lang.sh.test git commit -m \u0026#34;Update expected test output for lang.sh.test\u0026#34; Running the following will provide the full logs:\nnix log /nix/store/rk86daqgf6a9v6pdx6vcc5b580lr9f09-nix-2.20.0pre20240115_20b4959.drv Conclusion Testing Nixpkgs pull requests is a vital part of contributing to a healthy and reliable Nix ecosystem. By following these steps, you can help ensure that changes are well-vetted before being merged, ultimately benefiting all Nix users. Your efforts in testing contribute significantly to the quality and stability of Nixpkgs.\n","tags":[],"date":"2025-05-15","permalink":"https://saylesss88.github.io/posts/nixpkgs_pull_requests/"},{"id":4,"title":"Debugging_and_tracing_modules","summary":"Debugging and Tracing NixOS Modules Other related post if you haven\u0026rsquo;t read my previous post on modules, that may be helpful before reading this one:\nnix-modules-explained\nThis post is my notes following Nix Hour 40. If it seems a little chaotic, try watching one. They are hard to follow if you\u0026rsquo;re not extremely familiar with the concepts.\nNix Hour 40\nNix Code is particularly hard to debug because of (e.g. lazy evaluation, declarative nature, layered modules)\n","content":"Debugging and Tracing NixOS Modules Other related post if you haven\u0026rsquo;t read my previous post on modules, that may be helpful before reading this one:\nnix-modules-explained\nThis post is my notes following Nix Hour 40. If it seems a little chaotic, try watching one. They are hard to follow if you\u0026rsquo;re not extremely familiar with the concepts.\nNix Hour 40\nNix Code is particularly hard to debug because of (e.g. lazy evaluation, declarative nature, layered modules)\nThe following simple Nix code snippet illustrates a basic NixOS module definition and how options are declared and configured. We\u0026rsquo;ll use this example to demonstrate fundamental debugging techniques using nix-instantiate. let lib = import \u0026lt;nixpkgs/lib\u0026gt;; in lib.evalModules { modules = [ ({ lib, ... }: { options.foo = lib.mkOption { # type = lib.types.raw; type = lib.types.anything; # default = pkgs; }; config.foo = { bar = 10; list = [1 2 3 ]; baz = lib.mkDefault \u0026#34;baz\u0026#34;; }; }) { foo.baz = \u0026#34;bar\u0026#34;; } ]; } In the above code, adding lib to the function arguments isn\u0026rsquo;t required but if you were to move the module to another file it would fail without it because lib comes from outside of it. So it\u0026rsquo;s good practice to refer to lib in the modules themselves.\nYou should always assign a type to your options, if you don\u0026rsquo;t know which type to use you could use raw. raw is a type that doesn\u0026rsquo;t do any processing. So if you were to assign the entire packages set to the option e.g. default = pkgs; it wouldn\u0026rsquo;t recurseinto all the packages and try to evaluate them. There is also anything, that is useful if you do want to recurse into the values.\nThe following is an example of how you would run this inside vim/neovim, the rest of the examples will be from the command line:\n:!nix-instantiate --eval -A config.foo --strict Output:\n{ bar = 10; baz = \u0026#34;bar\u0026#34;; list = [ 1 2 3 ]; } To show the difference you could uncomment the raw type and comment the anything type and run the above command again you\u0026rsquo;ll see that you get an error:\nerror: The option \u0026#39;foo\u0026#39; is defined multiple times while it\u0026#39;s expected to be unique To execute this command on the command line:\nnix-instantiate --eval --strict -A config.foo It will show you the start of a trace. To get the full trace add:\nnix-instantiate --eval --strict -A config.foo --show-trace Example 2 In the previous example, we looked at a simplified module. Now, let\u0026rsquo;s examine a more realistic scenario involving a basic NixOS configuration file (configuration.nix).\nThis example will demonstrate how to use nix-instantiate to evaluate an entire system configuration and how --show-trace helps in diagnosing errors within this context.\nConsider the following configuration.nix file:\n# configuration.nix { lib, ... }: { boot.loader.grub.device = \u0026#34;nodev\u0026#34;; fileSystems.\u0026#34;/\u0026#34;.device = \u0026#34;/devst\u0026#34;; system.stateVersion = \u0026#34;24.11\u0026#34;; } This configuration snippet sets the GRUB bootloader device, defines a root filesystem, and specifies the expected NixOS state version. To evaluate this entire system configuration, you can use nix-instantiate and point it to the \u0026lt;nixpkgs/nixos\u0026gt; entrypoint, providing our configuration.nix file as an argument. The -A system flag selects the top-level system attribute, which represents the instantiated system configuration. Run it in with:\nnix-instantiate \u0026#39;\u0026lt;nixpkgs/nixos\u0026gt;\u0026#39; --arg configuration ./configuration.nix -A system Output:\n/nix/store/kfcwvvpdbsb3xcks1s76id16i1mc3l5k-nixos-system-nixos-25.05pre-git.drv Ok, we can see that this successfully instantiates. Let\u0026rsquo;s introduce an error to trace:\n{ lib, ... }: { boot.loader.grub.device = \u0026#34;nodev\u0026#34;; fileSystems.\u0026#34;/\u0026#34;.device = \u0026#34;/devst\u0026#34;; system.stateVersion = builtins.genList \u0026#34;24.11\u0026#34; null; } Output:\n(stack trace truncated; use \u0026#39;--show-trace\u0026#39; to show the full, detailed trace) error: expected an integer but found null: null Rerun the command with --show-trace appended:\nOr on the command line\nnix-instantiate \u0026#39;\u0026lt;nixpkgs/nixos\u0026gt;\u0026#39; --arg configuration ./configuration.nix -A system --show-trace This outputs a much longer trace than the first example. It shows you the file the error occured in and you can see that in this case they are a lot of internal functions. (e.g. at /nix/store/ccfwxygjrarahgfv5865x2f828sjr5h0- source/lib/attrsets.nix:1529:14:) To show your own error message you could do something like this:\n{lib, ...}: { boot.loader.grub.device = \u0026#34;nodev\u0026#34;; fileSystems.\u0026#34;/\u0026#34;.device = \u0026#34;/devst\u0026#34;; system.stateVersion = builtins.addErrorContext \u0026#34;AAAAAAAAAAAAAAAAA\u0026#34; (builtins.genList \u0026#34;24.11\u0026#34; null); } Run it:\nnix-instantiate \u0026#39;\u0026lt;nixpkgs/nixos\u0026gt;\u0026#39; --arg configuration ./configuration.nix -A system --show-trace` Output:\n… while evaluating the attribute \u0026#39;value\u0026#39; at /nix/store/ccfwxygjrarahgfv5865x2f828sjr5h0-source/lib/modules.nix:770:21: 769| inherit (module) file; 770| inherit value; | ^ 771| }) module.config … AAAAAAAAAAAAAAAAA … while calling the \u0026#39;genList\u0026#39; builtin at /home/jr/tests/configuration.nix:4:71: 3| fileSystems.\u0026#34;/\u0026#34;.device = \u0026#34;/devst\u0026#34;; 4| system.stateVersion = builtins.addErrorContext \u0026#34;AAAAAAAAAAAAAAAAA\u0026#34; (builtins.genList \u0026#34;24.11\u0026#34; null); | ^ 5| } … while evaluating the second argument passed to builtins.genList error: expected an integer but found null: null In the latest nix they actually inverted the error messages so the most relevant parts will be at the bottom. Example 3 Let\u0026rsquo;s consider another example, this time demonstrating the definition of configuration options using lib.mkOption within a module structure.\n# default.nix let lib = import \u0026lt;nixpkgs/lib\u0026gt;; in lib.evalModules { modules = [ ({ lib, ... }: { options.ints = lib.mkOption { type = lib.types.attrsOf lib.types.int; }; options.strings = lib.mkOption { type = lib.types.string; # type = lib.types.attrsOf lib.types.string; default = \u0026#34;foo\u0026#34;; }; }) ]; } Instantiate this with:\nnix-instantiate --eval --strict -A config.strings Output:\nevaluation warning: The type `types.string` is deprecated. See https://github.com/NixOS/nixpkgs/pull/66346 for better alternative types. \u0026#34;foo\u0026#34; Unfortunately you won\u0026rsquo;t get the same depreciation warning from lib.attrsOf Below is an interesting way to provide nixpkgs run it on the command line:\nexport NIX_PATH=nixpkgs=channel:nixpkgs-unstable echo $NIX_PATH Output:\nnixpkgs=channel:nixpkgs-unstable The next two commands are to check that after using the above way to provide nixpkgs-unstable that they both point to the same store path, the following command will fetch nixpkgs from the channel above:\nnix-instantiate --find-file nixpkgs Output 1️⃣\n/nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source nix-instantiate --eval channel:nixpkgs-unstable -A path Output: 2️⃣\n/nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source As you can see both commands produce the same store path Example 4 In our previous example, we encountered a deprecation warning for lib.types.string. This next example delves deeper into why that type was deprecated and demonstrates the consequences of its behavior, along with the recommended fix.\n# default.nix let lib = import \u0026lt;nixpkgs/lib\u0026gt;; in lib.evalModules { modules = [ ({lib, ...}: { options.ints = lib.mkOption { type = lib.types.attrsOf lib.types.int; }; options.strings = lib.mkOption { # type = lib.types.string; type = lib.types.attrsOf lib.types.string; default = { x = \u0026#34;foo\u0026#34;; }; }; config = { strings = lib.mkOptionDefault { x = \u0026#34;bar\u0026#34;; }; }; }) ]; } Evaluate it with:\nnix-instantiate --eval --strict -A config.strings types.string depricated because it silently concatenates strings\nThe above command has two options with the same priority level and evaluates to { x = \u0026quot;foobar\u0026quot;; }\nOutput:\nevaluation warning: The type `types.string` is deprecated. See https://github. com/NixOS/nixpkgs/pull/66346 for better alternative types. { x = \u0026#34;foobar\u0026#34;; } types.str was the replacement for the depricated types.string: # default.nix let lib = import \u0026lt;nixpkgs/lib\u0026gt;; in lib.evalModules { modules = [ ({lib, ...}: { options.ints = lib.mkOption { type = lib.types.attrsOf lib.types.int; }; options.strings = lib.mkOption { # type = lib.types.string; type = lib.types.attrsOf lib.types.str; # Sets the value with a lower priority: lib.mkOptionDefault default = { x = \u0026#34;foo\u0026#34;; }; }; config = { strings = lib.mkOptionDefault { x = \u0026#34;bar\u0026#34;; }; }; }) ]; } Output:\nerror: … while evaluating the attribute \u0026#39;x\u0026#39; … while evaluating the attribute \u0026#39;value\u0026#39; at /nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source/lib/modules.nix:1148:41: 1147| 1148| optionalValue = if isDefined then { value = mergedValue; } else { }; | ^ 1149| }; … while calling the \u0026#39;foldl\u0026#39;\u0026#39; builtin at /nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source/lib/options.nix:508:8: 507| else 508| (foldl\u0026#39; ( | ^ 509| first: def: (stack trace truncated; use \u0026#39;--show-trace\u0026#39; to show the full, detailed trace) error: The option `strings.x\u0026#39; has conflicting definition values: - In `\u0026lt;unknown-file\u0026gt;\u0026#39;: \u0026#34;foo\u0026#34; - In `\u0026lt;unknown-file\u0026gt;\u0026#39;: \u0026#34;bar\u0026#34; Use `lib.mkForce value` or `lib.mkDefault value` to change the priority on any of these definitions. shell returned 1 Summary So types in the module system aren\u0026rsquo;t just types in the conventional sense but they also specify the emerging behavior of these values.\nIf we switch the type in the above example to types.lines you get this returned, { x = \u0026quot;foo\\nbar\u0026quot;; }\nmkOptionDefault isn\u0026rsquo;t typically something you should generally use, instead options have a default setting\nIf you want to make sure that you set a default but if the user specifies it, it shouldn\u0026rsquo;t get overridden. You should not set it in the following:\noptions.strings = lib.mkOption { type = lib.types.attrsOf lib.types.lines; default = { x = \u0026#34;foo\u0026#34;; }; } Because the above uses mkOptionDefault but instead in under the config attribute like the following:\n# ...snip... options.strings = lib.mkOption { type = lib.types.attrsOf lib.types.lines; # default = { # x = \u0026#34;foo\u0026#34;; # }; }; config = { strings = { x = lib.mkDefault \u0026#34;foo\u0026#34;; }; }; # ...snip... let lib = import \u0026lt;nixpkgs/lib\u0026gt;; in lib.evalModules { modules = [ ({lib, ...}: { options.ints = lib.mkOption { type = lib.types.attrsOf lib.types.int; }; options.strings = lib.mkOption { # type = lib.types.string; type = lib.types.attrsOf lib.types.str; # Sets the value with a lower priority: lib.mkOptionDefault #default = { # x = \u0026#34;foo\u0026#34;; #}; }; config.strings = { x = \u0026#34;foo\u0026#34;; }; }) { config.strings = { y = \u0026#34;bar\u0026#34;; }; } ]; } Output:\nThis works now because there\u0026rsquo;s no difference between x and y { x = \u0026#34;foo\u0026#34;; y = \u0026#34;bar\u0026#34;; } More Functionality between modules let lib = import \u0026lt;nixpkgs/lib\u0026gt;; in lib.evalModules { modules = [ ({lib, ...}: { options.ints = lib.mkOption { type = lib.types.attrsOf lib.types.int; }; options.strings = lib.mkOption { # type = lib.types.string; type = lib.types.attrsOf lib.types.str; # Sets the value with a lower priority: lib.mkOptionDefault #default = { # x = \u0026#34;foo\u0026#34;; #}; }; config.strings = { x = lib.mkDefault \u0026#34;foo\u0026#34;; }; }) { config.strings = { x = \u0026#34;x\u0026#34;; y = \u0026#34;bar\u0026#34;; }; } ]; } The above command would cause a conflict without the x = lib.mkDefault foo And this is typically what you want to do for defaults and modules in things like nested configuration. Output:\n{ x = \u0026#34;x\u0026#34;; y = \u0026#34;bar\u0026#34;; } Infinite recursion error A common pitfall is to introduce a hard to debug error infinite recursion when shadowing a name. The simplest example for this is: let a = 1; in rec { a = a; } 💡TIP: Avoid rec. Use let ... in Example:\nlet a = 1; in { a = a; b = a + 2; } We\u0026rsquo;ll separate the logic for this example, this will be the default.nix this is where having lib defined in your inline modules is helpful because you can just delete the section and paste it into your modules.nix:\n# default.nix let lib = import \u0026lt;nixpkgs/lib\u0026gt;; in lib.evalModules { modules = [ ./module.nix ]; } And in the module.nix:\n# module.nix { lib, pkgs, ...}: { options.etc = lib.mkOption { type = lib.types.attrsOf lib.types.path; default = { }; description = \u0026#39;\u0026#39; Specifies which paths are is /etc/ \u0026#39;\u0026#39;; }; config._module.args.pkgs = import \u0026lt;nixpkgs\u0026gt; { config = {}; overlays = []; }; config.etc.foo = pkgs.writeText \u0026#34;foo\u0026#34; \u0026#39;\u0026#39; foo configuration \u0026#39;\u0026#39;; } If you evaluate this with the following you will get an infinite recursion error. nix-instantiate --eval --strict -A config.etc This happens because --strict evaluates the etc, then it goes into the attrsOf, and the path nix repl nix-repl\u0026gt; :l \u0026lt;nixpkgs\u0026gt; nix-repl\u0026gt; hello.out.out.out In this example:\n:l \u0026lt;nixpkgs\u0026gt; loads the Nixpkgs library into the repl environment, making its definitions available.\nhello refers to the hello package definition within Nixpkgs. Packages in Nixpkgs are defined as derivations.\n.out is a common attribute name for the main output of a derivation (e.g., the installed package). Some packages, especially those with complex build processes or multiple outputs, might have nested output attributes. In the case of hello, accessing .out.out.out ultimately leads us to the derivation itself.\nThe key takeaway here is that when you evaluate a package in the nix repl, you\u0026rsquo;re often interacting with its derivation or one of its output paths in the Nix store. The «derivation ...» indicates that hello.out.out.out evaluates to a derivation – the blueprint for building the hello package. This is in contrast to --eval --strict, which tries to fully evaluate values, potentially leading to infinite recursion if it encounters a derivation that refers back to itself indirectly during attribute evaluation.\nOutput:\n«derivation /nix/store/b1vcpm321dwbwx6wj4n13l35f4y2wrfv-hello-2.12.1.drv» So it recurses through the entire thing and tries to evaluate its string. So we want to change the command from --eval --strict which is only based on evaluation to at least nix-instantiate which is based on derivations:\nnix-instantiate -A config.etc Output:\nwarning: you did not specify \u0026#39;--add-root\u0026#39;; the result might be removed by the garbage collector /nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv We don\u0026rsquo;t really have a derivation yet for example: # module.nix { lib, pkgs, ... }: { options.etc = lib.mkOption { type = lib.types.attrsOf (lib.types.attrsOf lib.types.path); default = {}; description = \u0026#39;\u0026#39; Specifies which paths are in /etc/ \u0026#39;\u0026#39;; }; config._module.args.pkgs = import \u0026lt;nixpkgs\u0026gt; { config = {}; overlays = []; }; config.etc.foo.bar = pkgs.writeText \u0026#34;foo\u0026#34; \u0026#39;\u0026#39; foo configuration \u0026#39;\u0026#39;; } Try to evaluate the above command with nix-instantiate -A config.etc and Nix doesn\u0026rsquo;t even try to build it. With nested attrsOf\nnix repl -f default.nix nix-repl\u0026gt; config.etc { foo = { ... }; } nix-repl\u0026gt; config.etc.foo { bar = «derivation /nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv»; } So config.foo is an attribute set and config.etc.foo is also an attribute set but it\u0026rsquo;s not a derivation by itself. So nix-instantiate does this one level of recursion here and it would have built foo value if it were a derivation. Example 5 We\u0026rsquo;ll use the same module.nix and default.nix from the previous example.\nBuilding More Complex Configurations with Modules In this next example, we\u0026rsquo;ll focus on a common task in system configuration: managing files within the /etc/ directory. We\u0026rsquo;ll define a module that allows us to specify the content of arbitrary files in /etc/ and then use a special Nix function to combine these individual file definitions into a single, manageable entity.\nWe\u0026rsquo;ll introduce a new option, options.etc, which will allow us to define the content of files within /etc/. Then, we\u0026rsquo;ll use pkgs.linkFarm to create a derivation that represents the entire /etc/ directory as a collection of symbolic links pointing to the individual file contents we\u0026rsquo;ve defined. This demonstrates how modules can abstract away the details of creating complex system configurations, providing a declarative and reproducible way to manage even fundamental aspects of the operating system.\nLet\u0026rsquo;s show how we can use Nix modules to declaratively manage the /etc/ directory\n# default.nix let lib = import \u0026lt;nixpkgs/lib\u0026gt;; in lib.evalModules { modules = [ ./module.nix ]; } # module.nix { lib, pkgs, config, ... }: { options.etc = lib.mkOption { type = lib.types.attrsOf (lib.types.attrsOf lib.types.path); default = {}; description = \u0026#39;\u0026#39; Specifies which paths are in /etc/ \u0026#39;\u0026#39;; }; options.etcCombined = lib.mkOption { type = lib.types.package; default = pkgs.linkFarm \u0026#34;etc\u0026#34; (lib.mapAttrsToList (name: value: { name = name; path = value; }) config.etc); }; config._module.args.pkgs = import \u0026lt;nixpkgs\u0026gt; { config = {}; overlays = []; }; config.etc.foo = pkgs.writeText \u0026#34;foo\u0026#34; \u0026#39;\u0026#39; foo configuration \u0026#39;\u0026#39;; config.etc.bar = pkgs.writeText \u0026#34;bar\u0026#34; \u0026#39;\u0026#39; bar configuration \u0026#39;\u0026#39;; } Run it with:\nnix-instantiate -A config.etcCombined Output:\n/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv So we can see that it will instantiate, lets see if it will build: nix-build -A config.etcCombined Output:\nthese 3 derivations will be built: /nix/store/41yfxq4af1vrs0rrgfk5gc36kmjc7270-bar.drv /nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv /nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv building \u0026#39;/nix/store/41yfxq4af1vrs0rrgfk5gc36kmjc7270-bar.drv\u0026#39;... building \u0026#39;/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv\u0026#39;... building \u0026#39;/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv\u0026#39;... /nix/store/ca3wyk5m3qhy8n1nbn0181m29qvp1klp-etc nix-build -A config.etcCombined \u0026amp;\u0026amp; ls result/ -laa Output:\n/nix/store/ca3wyk5m3qhy8n1nbn0181m29qvp1klp-etc dr-xr-xr-x - root 31 Dec 1969  . drwxrwxr-t - root 16 May 15:13  .. lrwxrwxrwx - root 31 Dec 1969  bar -\u0026gt; /nix/store/1fsjyc2hmilab1qw6jfkf6cb767kz858-bar lrwxrwxrwx - root 31 Dec 1969  foo -\u0026gt; /nix/store/wai5dycp0zx1lxg0rhpdxnydhiadpk05-foo We can see that foo and bar link to different derivations\nWhen trying to figure out which default to use for etcCombined infinisil went to the Nixpkgs Reference Manual. Make sure to go to the correct version.\n24.11pre-git\n25.05pre-git (i.e. unstable)\nOnce at the website press Ctrl+f and type symlinkjoin and hit enter.\nOr in your local copy of Nixpkgs you could go to nixpkgs/pkgs/build-support/ trivial-builders/default.nix. Then use your editors search feature, with nvim and helix you press /symlinkjoin or /linkFarm hit enter then press n to cycle to the next match. It will bring you to comments and up to date information.\n# linkFarm \u0026#34;myexample\u0026#34; [ { name = \u0026#34;hello-test\u0026#34;; path = pkgs.hello; } # { name = \u0026#34;foobar\u0026#34;; path = pkgs.stack; } ] Tests How to create a Derivation with passthru.tests outside of Nixpkgs and then run tests available to your package set? mkdir passthru-tests \u0026amp;\u0026amp; cd passthru-tests Create a default.nix with the following:\n# default.nix let pkgs = import \u0026lt;nixpkgs\u0026gt; {}; package = pkgs.runCommand \u0026#34;foo\u0026#34; { passthru.tests.simple = pkgs.runCommand \u0026#34;foo-test\u0026#34; {} \u0026#39;\u0026#39; if [[ \u0026#34;$(cat ${package})\u0026#34; != \u0026#34;foo\u0026#34; ]]; then echo \u0026#34;Result is not foo\u0026#34; exit 1 fi touch $out \u0026#39;\u0026#39;; } \u0026#39;\u0026#39; echo foo \u0026gt; $out \u0026#39;\u0026#39;; in package See if it will build:\nnix-build Try running the test:\nnix-build -A passthru.tests this derivation will be built: /nix/store/pqpqq9x1wnsabzbsb52z4g4y4zy6p7yx-foo-test.drv building \u0026#39;/nix/store/pqpqq9x1wnsabzbsb52z4g4y4zy6p7yx-foo-test.drv\u0026#39;... /nix/store/7bbw2ban0mgkh4d59yz3cnai4aavwvb6-foo-test Test 2 passthru.tests is the convention for defining tests associated with a derivation. The attributes in passthru are preserved and accessible after the derivation is built. let pkgs = import \u0026lt;nixpkgs\u0026gt; {}; package = pkgs.runCommand \u0026#34;foo\u0026#34; { passthru.tests.simple = pkgs.runCommand \u0026#34;foo-test\u0026#34; {} \u0026#39;\u0026#39; if [[ \u0026#34;$(cat ${package})\u0026#34; != \u0026#34;foo\u0026#34; ]]; then echo \u0026#34;Result is not foo\u0026#34; exit 1 fi touch $out \u0026#39;\u0026#39;; passthru.tests.version = pkgs.testers.testVersion { package = package; version = \u0026#34;1.2\u0026#34;; }; # pkgs.writeShellApplication script = \u0026#39;\u0026#39; #!${pkgs.runtimeShell} echo \u0026#34;1.2\u0026#34; \u0026#39;\u0026#39;; passAsFiles = [ \u0026#34;script\u0026#34; ]; } \u0026#39;\u0026#39; cp \u0026#34;$scriptPath\u0026#34; \u0026#34;$out\u0026#34; \u0026#39;\u0026#39;; in package Try to build it:\nnix-build -A passthru.tests testers.testVersion checks if an executable outputs a specific version string.\nnix-build -A passthru.tests specifically targets the derivations defined within the tests attribute of the main derivation.\nthese 3 derivations will be built: /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv /nix/store/s4iawjy5zpv89dbkc3zz7z3ngz4jq2cv-foo-test.drv /nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z-foo-test-version.drv building \u0026#39;/nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv\u0026#39;... cp: cannot stat \u0026#39;\u0026#39;: No such file or directory error: builder for \u0026#39;/nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv\u0026#39; failed with exit code 1; last 1 log lines: \u0026gt; cp: cannot stat \u0026#39;\u0026#39;: No such file or directory For full logs, run: nix log /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv error: 1 dependencies of derivation \u0026#39;/nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z -foo-test-version.drv\u0026#39; failed to build error: build of \u0026#39;/nix/store/s4iawjy5zpv89dbkc3zz7z3ngz4jq2cv-foo-test.drv\u0026#39;, \u0026#39;/nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z-foo-test-version.drv\u0026#39; failed Run nix-build with no arguments:\nnix-build nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq \u0026#39;.[].env\u0026#39; Output:\n{ \u0026#34;__structuredAttrs\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;buildCommand\u0026#34;: \u0026#34;cp \\\u0026#34;$scriptPath\\\u0026#34; \\\u0026#34;$out\\\u0026#34;\\n\u0026#34;, \u0026#34;buildInputs\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;builder\u0026#34;: \u0026#34;/nix/store/xg75pc4yyfd5n2fimhb98ps910q5lm5n-bash-5.2p37/bin/bash\u0026#34;, \u0026#34;cmakeFlags\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;configureFlags\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;depsBuildBuild\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;depsBuildBuildPropagated\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;depsBuildTarget\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;depsBuildTargetPropagated\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;depsHostHost\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;depsHostHostPropagated\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;depsTargetTarget\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;depsTargetTargetPropagated\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;doCheck\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;doInstallCheck\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;enableParallelBuilding\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;enableParallelChecking\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;enableParallelInstalling\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;mesonFlags\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;nativeBuildInputs\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;out\u0026#34;: \u0026#34;/nix/store/9mcrnddb6lf1md14v4lj6s089i99l5k7-foo\u0026#34;, \u0026#34;outputs\u0026#34;: \u0026#34;out\u0026#34;, \u0026#34;passAsFile\u0026#34;: \u0026#34;buildCommand\u0026#34;, \u0026#34;passAsFiles\u0026#34;: \u0026#34;script\u0026#34;, \u0026#34;patches\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;propagatedBuildInputs\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;propagatedNativeBuildInputs\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;script\u0026#34;: \u0026#34;#!/nix/store/xg75pc4yyfd5n2fimhb98ps910q5lm5n-bash-5.2p37/bin/bash\\necho \\\u0026#34;1.2\\\u0026#34;\\n\u0026#34;, \u0026#34;stdenv\u0026#34;: \u0026#34;/nix/store/lgydi1gl5wqcw6k4gyjbaxx7b40zxrsp-stdenv-linux\u0026#34;, \u0026#34;strictDeps\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;system\u0026#34;: \u0026#34;x86_64-linux\u0026#34; } nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq \u0026#39;.[].env.buildCommand\u0026#39; Output:\n\u0026#34;cp \\\u0026#34;$scriptPath\\\u0026#34; \\\u0026#34;$out\\\u0026#34;\\n\u0026#34; raw mode below nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq \u0026#39;.[].env.buildCommand\u0026#39; -r Output:\ncp \u0026#34;$scriptPath\u0026#34; \u0026#34;$out\u0026#34; It turns out the correct command was passAsFile not passAsFiles but that change wasn\u0026rsquo;t enough to fix it. passAsFiles expects a list of files, not a single file path. Running nix-build -A passthru.tests failed saying \u0026gt; foo --version returned a non-zero exit code. let pkgs = import \u0026lt;nixpkgs\u0026gt; {}; package = pkgs.runCommand \u0026#34;foo\u0026#34; { #passthru.tests.simple = pkgs.runCommand \u0026#34;foo-test\u0026#34; {} \u0026#39;\u0026#39; # if [[ \u0026#34;$(cat ${package})\u0026#34; != \u0026#34;foo\u0026#34; ]]; then # echo \u0026#34;Result is not foo\u0026#34; # exit 1 # fi # touch $out #\u0026#39;\u0026#39;; passthru.tests.version = pkgs.testers.testVersion { package = package; version = \u0026#34;1.2\u0026#34;; }; # pkgs.writeShellApplication script = \u0026#39;\u0026#39; #!${pkgs.runtimeShell} echo \u0026#34;1.2\u0026#34; \u0026#39;\u0026#39;; passAsFile = [\u0026#34;script\u0026#34;]; } \u0026#39;\u0026#39; mkdir -p \u0026#34;$out/bin\u0026#34; cp \u0026#34;$scriptPath\u0026#34; \u0026#34;$out/bin/foo\u0026#34; chmod +x \u0026#34;$out/bin/foo\u0026#34; \u0026#39;\u0026#39;; in package Build it:\nnix-build -A passthru.tests Output:\nthese 2 derivations will be built: /nix/store/lqrlcd64dmpzkggcfzlnsnwjd339czd3-foo.drv /nix/store/c3kw4xbdlrig08jrdm5wis1dmv2gnqsd-foo-test-version.drv building \u0026#39;/nix/store/lqrlcd64dmpzkggcfzlnsnwjd339czd3-foo.drv\u0026#39;... building \u0026#39;/nix/store/c3kw4xbdlrig08jrdm5wis1dmv2gnqsd-foo-test-version.drv\u0026#39;... 1.2 /nix/store/zsbk5zawak68ailvkwi2gad2bqbqmdz9-foo-test-version Key Takeaways for Debugging NixOS Modules nix-instantiate is Your Friend: Use nix-instantiate to evaluate your NixOS modules and pinpoint errors.\nUnlock Details with --show-trace: When errors occur, always append --show-trace to get a comprehensive stack trace, revealing the origin of the problem. Remember that in newer Nix versions, the most relevant parts of the trace are often at the bottom.\nUnderstand Option Types: Nix option types (raw, anything, string/str, lines, attrsOf) are not just about data types; they also dictate how values are merged and processed within the module system.\nBe Mindful of mkOptionDefault: While useful in specific scenarios, mkOptionDefault sets a lower priority default. For standard defaults that can be overridden by user configuration, define them directly within the config attribute using lib.mkDefault.\nUse builtins.addErrorContext: Enhance your custom error messages by providing specific context relevant to your module\u0026rsquo;s logic using builtins.addErrorContext.\nDerivations vs. Evaluation: Be aware of the difference between evaluating expressions (--eval --strict) and instantiating derivations (nix-instantiate). Strict evaluation can trigger infinite recursion if it encounters unevaluated derivations with cyclic dependencies during attribute access.\nExplore with nix repl: The nix repl allows you to interactively explore Nix expressions and the outputs of derivations, providing insights into the structure and values within Nixpkgs.\n","tags":[],"date":"2025-05-15","permalink":"https://saylesss88.github.io/posts/debugging_and_tracing_modules/"},{"id":5,"title":"Using_overlays_to_add_packages","summary":"Using Overlays to add Packages that aren\u0026rsquo;t in Nixpkgs It is very common to use overlays in Nix to install packages that aren\u0026rsquo;t available in the standard Nixpkgs repository.\nOverlays are one of the primary and recommended ways to extend and customize your Nix environment. It\u0026rsquo;s important to remember that Nix overlays are made to allow you to modify or extend the package set provided by Nixpkgs (or other Nix sources) without directly altering the original package definitions. This is crucial for maintaining reproducibility and avoiding conflicts. Overlays are essentially functions that take the previous package set and allow you to add, modify, or remove packages.\n","content":"Using Overlays to add Packages that aren\u0026rsquo;t in Nixpkgs It is very common to use overlays in Nix to install packages that aren\u0026rsquo;t available in the standard Nixpkgs repository.\nOverlays are one of the primary and recommended ways to extend and customize your Nix environment. It\u0026rsquo;s important to remember that Nix overlays are made to allow you to modify or extend the package set provided by Nixpkgs (or other Nix sources) without directly altering the original package definitions. This is crucial for maintaining reproducibility and avoiding conflicts. Overlays are essentially functions that take the previous package set and allow you to add, modify, or remove packages.\nIt may be helpful to first read my NixFlakesTips post first to understand the outputs in my flake.\nAdding the overlays output to your Flake I\u0026rsquo;ll show the process of adding the pokego package that is not in Nixpkgs:\nIn my flake.nix I have a custom inputs variable within my let block of my flake like so just showing the necessary parts for berevity: # flake.nix outputs = my-inputs @ { self, nixpkgs, treefmt-nix, ... }: let system = \u0026#34;x86_64-linux\u0026#34;; host = \u0026#34;magic\u0026#34;; userVars = { username = \u0026#34;jr\u0026#34;; gitUsername = \u0026#34;saylesss88\u0026#34;; editor = \u0026#34;hx\u0026#34;; term = \u0026#34;ghostty\u0026#34;; keys = \u0026#34;us\u0026#34;; browser = \u0026#34;firefox\u0026#34;; flake = builtins.getEnv \u0026#34;HOME\u0026#34; + \u0026#34;/flake\u0026#34;; }; inputs = my-inputs // { pkgs = import inputs.nixpkgs { inherit system; }; lib = { overlays = import ./lib/overlay.nix; nixOsModules = import ./nixos; homeModules = import ./home; inherit system; }; }; # ... snip ... The Actual Overlay In the overlay.nix I have this helper function and the defined package: # overlay.nix _final: prev: let # Helper function to import a package callPackage = prev.lib.callPackageWith (prev // packages); # Define all packages packages = { # Additional packages pokego = callPackage ./pac_defs/pokego.nix {}; }; in packages _final: prev:: This is the function definition of the overlay. _final: This argument represents the final, merged package set after all overlays have been applied. It\u0026rsquo;s often unused within a single overlay, hence the _ prefix (a Nix convention for unused variables).\nprev: This is the crucial argument. It represents the package set before this overlay is applied. This allows you to refer to existing packages and functions from Nixpkgs.\nlet ... in packages: This introduces a let expression, which defines local variables within the scope of this overlay function. The in packages part means that the overlay function will ultimately return the packages attribute set defined within the let block.\ncallPackage = prev.lib.callPackageWith (prev // packages): This line defines a helper function called callPackage.\nprev.lib.callPackageWith Is a function provided by Nixpkgs\u0026rsquo; lib. callPackageWith is like prev.lib.callPackage, but allows the passing of additional arguments that will then be passed to the package definition.\n(prev // packages): This is an attribute set merge operation. It takes the prev package set (Nixpkgs before this overlay) and merges it with the packages attribute set defined later in this overlay.\nBy using callPackageWith with this merged attribute set, the callPackage function defined here is set up to correctly import package definitions, ensuring they have access to both the original Nixpkgs and any other packages defined within this overlay.\npackages = { ... };: This defines an attribute set named packages. This set will contain all the new or modified packages introduced by this overlay.\npokego = callPackages ./pac_defs/pokego.nix { };: This is the core of how the pokego package is added.\npokego =: This defines a new attribute named pokego within the packages attribute set. This name will be used to refer to the pokego package later.\ncallPackage ./pac_defs/pokego.nix {}: This calls the callPackage helper function defined earlier.\n./pac_defs/pokego.nix: This is the path to another Nix file(pokego.nix) that contains the actual package definition for pokego. This file would define how to fetch, build, and install the pokego software\n{}: This is an empty attribute set passed as additional arguments to the pokego.nix package definition. If pokego.nix expected any specific parameters (like versions or dependencies), you would provide them here. Since it\u0026rsquo;s empty, it implies pokego.nix either has no required arguments or uses default values.\nin packages: As mentioned earlier, the overlay function returns the packages attribute set. When this overlay is applied, the packages defined within this packages set (including pokego) will be added to the overall Nix package set. The pokego Package definition The following is the ./pac_defs/pokego.nix, it may be helpful to first read my PackageDefinition post to better understand the following:\n# pokego.nix { lib, buildGoModule, fetchFromGitHub, }: buildGoModule rec { pname = \u0026#34;pokego\u0026#34;; version = \u0026#34;0.3.0\u0026#34;; src = fetchFromGitHub { owner = \u0026#34;rubiin\u0026#34;; repo = \u0026#34;pokego\u0026#34;; rev = \u0026#34;v${version}\u0026#34;; hash = \u0026#34;sha256-cFpEi8wBdCzAl9dputoCwy8LeGyK3UF2vyylft7/1wY=\u0026#34;; }; vendorHash = \u0026#34;sha256-7SoKHH+tDJKhUQDoVwAzVZXoPuKNJEHDEyQ77BPEDQ0=\u0026#34;; # Install shell completions postInstall = \u0026#39;\u0026#39; install -Dm644 completions/pokego.bash \u0026#34;$out/share/bash-completion/completions/pokego\u0026#34; install -Dm644 completions/pokego.fish \u0026#34;$out/share/fish/vendor_completions.d/pokego.fish\u0026#34; install -Dm644 completions/pokego.zsh \u0026#34;$out/share/zsh/site-functions/_pokego\u0026#34; \u0026#39;\u0026#39;; meta = with lib; { description = \u0026#34;Command-line tool that lets you display Pokémon sprites in color directly in your terminal\u0026#34;; homepage = \u0026#34;https://github.com/rubiin/pokego\u0026#34;; license = licenses.gpl3Only; maintainers = with maintainers; [ rubiin jameskim0987 vinibispo ]; mainProgram = \u0026#34;pokego\u0026#34;; platforms = platforms.all; }; } Adding the overlay to your configuration There are a few places you could choose to put the following, I choose to use my configuration.nix because of my setup:\n# configuration.nix nixpkgs.overlays = [inputs.lib.overlays] Installing Pokego If you are managing your entire system configuration with NixOS, you would typically add pokego to your environment.systemPackages. # configuration.nix environment.systemPackages = with pkgs; [ pokego ] If you prefer home-manager you can install pokego with home-manager also: # home.nix home.packages = [ pkgs.pokego ] Another Overlay Example { inputs = { nixpkgs.url = \u0026#34;https://flakehub.com/NixOS/nixpkgs/*.tar.gz\u0026#34;; nix.url = \u0026#34;https://flakehub.com/f/NixOS/nix/2.17.0.tar.gz\u0026#34;; }; outputs = { self, nixpkgs, nix }: let system = \u0026#34;aarch64-darwin\u0026#34;; pkgs = import nixpkgs { inherit system; overlays = [ nix.overlays.default ]; }; in { # `pkgs` is nixpkgs for the system, with nix\u0026#39;s overlay applied }; } Normally, pkgs = import nixpkgs { }`` imports Nixpkgs with default settings. However, the example above customizes this import by passing arguments: pkgs = import nixpkgs { inherit system; overlays = [ nix.overlays.default];}. This makes the pkgs variable represent nixpkgs specifically for the aarch64-darwin` system, with the overlay from the nix flake applied.\nConsequently, any packages built using this customized pkgs will now depend on or use the specific nix version (2.17.0) provided by the nix flake, instead of the version that comes with the fetched nixpkgs. This technique can be useful for ensuring a consistent environment or testing specific package versions.\n","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/using_overlays_to_add_packages/"},{"id":6,"title":"Nix_lang_basics","summary":"The Nix Language Nix as a programming language can be thought of as a kind of \u0026ldquo;JSON, but with functions\u0026rdquo;.\nAll statements are declarative, meaning that there\u0026rsquo;s no sequential flow of instructions that makes up a Nix package. Instead, functions are called that assign values to fields in attribute sets, which in turn may get assigned to other values.\nHow does Nix work Nix is a pure, functional, lazy, declarative, and reproducible programming language.\n","content":"The Nix Language Nix as a programming language can be thought of as a kind of \u0026ldquo;JSON, but with functions\u0026rdquo;.\nAll statements are declarative, meaning that there\u0026rsquo;s no sequential flow of instructions that makes up a Nix package. Instead, functions are called that assign values to fields in attribute sets, which in turn may get assigned to other values.\nHow does Nix work Nix is a pure, functional, lazy, declarative, and reproducible programming language.\nConcept Description Pure Functions don\u0026rsquo;t cause side effects. Functional Functions can be passed as arguments and returned as results. Lazy Not evaluated until needed to complete a computation. Declarative Describing a system outcome. Reproducible Operations that are performed twice return same results In Nix, the process of managing software starts with package definitions. These are files written in the Nix language that describe how a particular piece of software should be built. These package definitions, when processed by Nix, are translated into derivations.\nAt its core, a derivation in Nix is a blueprint or a recipe that describes how to build a specific software package or any other kind of file or directory. It\u0026rsquo;s a declarative specification of:\nInputs: What existing files or other derivations are needed as dependencies.\nBuild Steps: The commands that need to be executed to produce the desired output.\nEnvironment: The specific environment (e.g., build tools, environment variables) required for the build process.\nOutputs: The resulting files or directories that the derivation produces.\nThink of a package definition as the initial instructions, and the derivation as the detailed, low-level plan that Nix uses to actually perform the build.\u0026quot;\nSyntax Basics Dashes are allowed as identifiers: nix-repl\u0026gt; a-b error: undefined variable `a-b\u0026#39; at (string):1:1 nix-repl\u0026gt; a - b error: undefined variable `a\u0026#39; at (string):1:1 a-b is parsed as an identifier, not as subtraction.\nStrings: Strings are enclosed in double quotes (\u0026quot;) or two single quotes ('').\nnix-repl\u0026gt; \u0026#34;stringDaddy\u0026#34; \u0026#34;stringDaddy\u0026#34; nix-repl\u0026gt; \u0026#39;\u0026#39;stringMoma\u0026#39;\u0026#39; \u0026#34;stringMoma\u0026#34; String Interpolation: Is a language feature where a string, path, or attribute name can contain expressions enclosed in ${ }. This construct is called interpolated string, and the expression inside is an interpolated expression.string interpolation.\nRather than writing:\n\u0026#34;--with-freetype2-library=\u0026#34; + freetype + \u0026#34;/lib\u0026#34; where freetype is a derivation, you could instead write:\n\u0026#34;--with-freetype2-library=${freetype}/lib\u0026#34; And the above expression will be translated to the former.\nInterpolated Expression: An expression that is interpolated must evaluate to one of the following:\na string\na path\nan attribute set that has a __toString attribute or an outPath attribute.\n__toString must be a function that takes an attribute set itself and returns a string.\noutPath must be a string\nThis includes derivations or flake inputs.\nA path in an interpolated expression is first copied into the Nix store, and the resulting string is the store path of the newly created store object.\nmkdir foo reference the empty directory in an interpolated expression:\n\u0026#34;${./foo}\u0026#34; Output: \u0026quot;/nix/store/2hhl2nz5v0khbn06ys82nrk99aa1xxdw-foo\u0026quot;\nAttribute sets are all over Nix code, they are name-value pairs wrapped in curly braces, where the names must be unique: { string = \u0026#34;hello\u0026#34;; int = 8; } Attribute names usually don\u0026rsquo;t need quotes.\nList elements are separated by white space.\nprograms = { bat.enable = true; } The bat.enable is called dot notation. The above command can be written a few ways: programs.bat.enable = true; # using dot notation # or programs = { # using nested attribut sets. bat = { enable = true; } } You will sometimes see attribute sets with rec prepended. This allows access to attributes within the set:\nrec { one = 1; two = one + 1; three = two + 1; } Without rec, this command would fail because we are trying to use an attribute that is defined within this attribute set. You would get an undefined variable \u0026lsquo;one\u0026rsquo; error. Inheriting Attributes\nlet x = 123; in { inherit x; y = 456; } is equivalent to\nlet x = 123; in { x = x; y = 456; } Both evaluate to:\n{ x = 123; y = 456; } ❗: This works because x is added to the lexical scope by the let construct.\ninherit x y z; inherit (src-set) a b c; is equivalent to:\nx = x; y = y; z = z; a = src-set.a; b = src-set.b; c = src-set.c In a let expression, inherit can be used to selectively bring specific attributes of a set into scope:\nlet x = { a = 1; b = 2; }; inherit (builtins) attrNames; in { names = attrNames x; } is equivalent to:\nlet x = { a = 1; b = 2; }; in { names = builtins.attrNames x; } Both evaluate to:\n{ names [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; ]; } Functions:\nThe code below calls a function called my_function with the parameters 2 and 3, and assigns its output to the my_value field:\n{ my_value = my_function 2 3; } Functions are defined using this syntax, where x and y are attributes passed into the function:\n{ my_function = x: y: x + y; } The body of the function automatically returns the result of the function. Functions are called by spaces between it and its parameters. No commas are needed to separate parameters. let negate = x: !x; concat = x: y: x + y; in if negate true then concat \u0026#34;foo\u0026#34; \u0026#34;bar\u0026#34; else \u0026#34;\u0026#34; negate = x: !x; This defines a function named negate that takes one argument x and returns its logical negation (using !)\nconcat = x: y: x + y defines a function that takes two arguments, x and y, and returns their string concatenation. Notice how Nix handles multi-argument functions through currying \u0026ndash; it\u0026rsquo;s a function that returns another function. This was a little confusing to me, I\u0026rsquo;m thinking how does it return a function if concat 1 2 returns 3\u0026hellip;\nx: ...: This part says that concat takes one argument, which we\u0026rsquo;ve named x.\ny: x + y: The result of the first part isn\u0026rsquo;t the final value. Instead, it\u0026rsquo;s another function. This inner function takes one argument, which we\u0026rsquo;ve named y, and then it adds x and y.\nWhen you do concat 1 you\u0026rsquo;re applying the concat function to the argument 1. This returns the inner function, where x is now fixed as 1. The inner function is essentially waiting for its y argument to be provided.\nIt\u0026rsquo;s when you apply the second argument, 2, to this resulting function (concat 1) 2 that the addition 1 + 2 finally happens, giving us 3.\nIt\u0026rsquo;s like a chain of function applications:\nconcat takes x and returns a new function.\nThis new function takes y and returns the result of x + y.\nDerivations Again, a derivation is like a blueprint that describes how to build a specific software package or any other kind of file or directory.\nKey Characteristics of Derivations:\nDeclarative: You describe the desired outcome and the inputs, not the exact sequence of imperative steps. Nix figures out the necessary steps based on the builder and args.\nReproducible: Given the same inputs and build instructions, a derivation will always produce the same output. This is a cornerstone of Nix\u0026rsquo;s reproducibility.\nTracked by Nix: Nix keeps track of all derivations and their outputs in the Nix store. This allows for efficient management of dependencies and ensures that different packages don\u0026rsquo;t interfere with each other.\nContent-Addressed: The output of a derivation is stored in the Nix store under a unique path that is derived from the hash of all its inputs and build instructions. This means that if anything changes in the derivation, the output will have a different path.\nHello World Derivation Example:\n{ pkgs ? import \u0026lt;nixpkgs\u0026gt; {} }: pkgs.stdenv.mkDerivation { name = \u0026#34;hello-world\u0026#34;; src = null; # No source code needed buildPhase = \u0026#39;\u0026#39; echo \u0026#34;Hello, World!\u0026#34; \u0026gt; $out \u0026#39;\u0026#39;; installPhase = \u0026#39;\u0026#39; mkdir -p $out/bin cp $out $out/bin/hello chmod +x $out/bin/hello \u0026#39;\u0026#39;; meta = { description = \u0026#34;A simple Hello World program built with Nix\u0026#34;; homepage = null; license = lib.licenses.unfree; # For simplicity maintainers = []; }; } { pkgs ? import \u0026lt;nixpkgs\u0026gt; {} }: This is a function that takes an optional argument pkgs. We need Nixpkgs to access standard build environments like stdenv.\npkgs.stdenv.mkDerivation { ... }: This calls the mkDerivation function from the standard environment (stdenv). mkDerivation is the most common way to define software packages in Nix.\nname = \u0026quot;hello-world\u0026quot;;: Human-readable name of the derivation\nsrc = null: No external source code for this simple example\nThe rest are the build phases and package metadata.\nTo use the above derivation, save it as a .nix file (e.g. hello.nix). Then build the derivation using:\nnix build ./hello.nix Nix will execute the buildPhase and installPhase\nAfter a successful build, the output will be in the Nix store. You can find the exact path by looking at the output of the nix build command (it will be something like /nix/store/your-hash-hello-world).\nRun the \u0026ldquo;installed\u0026rdquo; program:\n./result/bin/hello This will execute the hello file from the Nix store and print \u0026ldquo;Hello, World!\u0026rdquo;. Here\u0026rsquo;s a simple Nix derivation that creates a file named hello in the Nix store containing the text \u0026ldquo;Hello, World!\u0026rdquo;:\nEvaluating Nix Files Use nix-instantiate --eval to evaluate the expression in a Nix file:\necho 1 + 2 \u0026gt; file.nix nix-instantiate --eval file.nix 3 Note: --eval is required to evaluate the file and do nothing else. If --eval is omitted, nix-instantiate expects the expression in the given file to evaluate to a derivation.\nIf you don\u0026rsquo;t specify an argument, nix-instantiate --eval will try to read from default.nix in the current directory.\nResources nix.dev nixlang-basics\nlearn nix in y minutes\nnix onepager\nawesome-nix\nzero-to-nix nix lang\nnix-pills basics of nixlang\n","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/nix_lang_basics/"},{"id":7,"title":"Comparing_flakes_to_traditional_nix","summary":"Introduction: Flakes and Traditional Nix This post is based on notes from Nix-Hour #4, comparing Traditional Nix and Flakes, focusing on achieving pure build results. See the YouTube video for the original content. This guide adapts the information for clarity and ease of understanding. What is Purity in Nix? A key benefit of Nix Flakes is their default enforcement of pure evaluation.\nIn Nix, an impure operation depends on something outside its explicit inputs. Examples include:\n","content":"Introduction: Flakes and Traditional Nix This post is based on notes from Nix-Hour #4, comparing Traditional Nix and Flakes, focusing on achieving pure build results. See the YouTube video for the original content. This guide adapts the information for clarity and ease of understanding. What is Purity in Nix? A key benefit of Nix Flakes is their default enforcement of pure evaluation.\nIn Nix, an impure operation depends on something outside its explicit inputs. Examples include:\nUser\u0026rsquo;s system configuration Environment variables Current time Impurity leads to unpredictable builds that may differ across systems or time.\nBuilding a Simple \u0026ldquo;hello\u0026rdquo; Package: Flakes vs. Traditional Nix We\u0026rsquo;ll demonstrate building a basic \u0026ldquo;hello\u0026rdquo; package using both Flakes and Traditional Nix to highlight the differences in handling purity. Using Nix Flakes Setup:\nmkdir hello \u0026amp;\u0026amp; cd hello/ Create flake.nix (Initial Impure Example):\n# flake.nix { outputs = { self, nixpkgs }: { myHello = (import nixpkgs {}).hello; }; } Note: Flakes don\u0026rsquo;t have access to builtins.currentSystem directly. Impure Build (Fails):\nnix build .#myHello This fails because Flakes enforce purity by default. Force Impure Build:\nnix build .#myHello --impure Making the Flake Pure:\n# flake.nix { inputs = { nixpkgs.url = \u0026#34;github:NixOS/nixpkgs\u0026#34;; flake-utils.url = \u0026#34;github:numtide/flake-utils\u0026#34;; }; outputs = { self, nixpkgs, flake-utils }: flake-utils.lib.eachDefaultSystem (system: let pkgs = nixpkgs.legacyPackages.${system}; in { packages.myHello = pkgs.hello; } ); } flake-utils simplifies making flakes system-agnostic and provides the system attribute. Pure Build (Success):\nnix build .#myHello Using Traditional Nix Setup:\nmkdir hello2 \u0026amp;\u0026amp; cd hello2/ Create default.nix (Initial Impure Example):\n# default.nix { myHello = (import \u0026lt;nixpkgs\u0026gt; { }).hello; } Build (Impure):\nnix-build -A myHello Impurity Explained:\nnix repl nix-repl\u0026gt; \u0026lt;nixpkgs\u0026gt; /nix/var/nix/profiles/per-user/root/channels/nixos \u0026lt;nixpkgs\u0026gt; depends on the user\u0026rsquo;s environment (Nixpkgs channel), making it impure. Even with channels disabled, it relies on a specific Nixpkgs version in the store. Achieving Purity: Using fetchTarball\nGitHub allows downloading repository snapshots at specific commits, crucial for reproducibility.\nGet Nixpkgs Revision from flake.lock (from the Flake example):\n# flake.lock \u0026#34;nixpkgs\u0026#34;: { \u0026#34;locked\u0026#34;: { \u0026#34;lastModified\u0026#34;: 1746372124, \u0026#34;narHash\u0026#34;: \u0026#34;sha256-n7W8Y6bL7mgHYW1vkXKi9zi/sV4UZqcBovICQu0rdNU=\u0026#34;, \u0026#34;owner\u0026#34;: \u0026#34;NixOS\u0026#34;, \u0026#34;repo\u0026#34;: \u0026#34;nixpkgs\u0026#34;, \u0026#34;rev\u0026#34;: \u0026#34;f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;github\u0026#34; }, Modify default.nix for Purity:\n# default.nix let nixpkgs = fetchTarball { url = \u0026#34;[https://github.com/NixOS/nixpkgs/archive/f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0.tar.gz](https://github.com/NixOS/nixpkgs/archive/f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0.tar.gz)\u0026#34;; sha256 = \u0026#34;0000000000000000000000000000000000000000000000000000\u0026#34;; # Placeholder }; in { myHello = (import nixpkgs {}).hello; } Replace \u0026lt;nixpkgs\u0026gt; with fetchTarball and a specific revision. A placeholder sha256 is used initially. Build (Nix provides the correct sha256):\nnix-build -A myHello Verification: Both Flake and Traditional Nix builds now produce the same output path.\nRemaining Impurities in Traditional Nix:\nDefault arguments to import \u0026lt;nixpkgs\u0026gt; {} can introduce impurity: overlays: ~/.config/nixpkgs/overlays (user-specific) config: ~/.config/nixpkgs/config.nix (user-specific) system: builtins.currentSystem (machine-specific) Making Traditional Nix Fully Pure:\n# default.nix {system ? builtins.currentSystem}: let nixpkgs = fetchTarball { url = \u0026#34;[https://github.com/NixOS/nixpkgs/archive/0243fb86a6f43e506b24b4c0533bd0b0de211c19.tar.gz](https://github.com/NixOS/nixpkgs/archive/0243fb86a6f43e506b24b4c0533bd0b0de211c19.tar.gz)\u0026#34;; sha256 = \u0026#34;1qvdbvdza7hsqhra0yg7xs252pr1q70nyrsdj6570qv66vq0fjnh\u0026#34;; }; in { myHello = (import nixpkgs { overlays = []; config = {}; inherit system; }).hello; } Override impure defaults for overlays, config, and make system an argument. Building with a Specific System:\nnix-build -A myHello --argstr system x86_64-linux Pure Evaluation Mode in Traditional Nix:\nnix-instantiate --eval --pure-eval --expr \u0026#39;fetchGit { url = ./.; rev = \u0026#34;b4fe677e255c6f89c9a6fdd3ddd9319b0982b1ad\u0026#34;; }\u0026#39; Example of using --pure-eval. nix-build --pure-eval --expr \u0026#39;(import (fetchGit { url = ./.; rev = \u0026#34;b4fe677e255c6f89c9a6fdd3ddd9319b0982b1ad\u0026#34;; }) { system = \u0026#34;x86_64-linux\u0026#34;; }).myHello\u0026#39; Building with a specific revision and system. Updating Nixpkgs nix flake update nix build .#myHello --override-input nixpkgs github:NixOS/nixpkgs/nixos-24.11 Updating Traditional Nix (using niv) nix-shell -p niv niv init # default.nix { system ? builtins.currentSystem, sources ? import nix/sources.nix, nixpkgs ? sources.nixpkgs, pkgs ? import nixpkgs { overlays = [ ]; config = { }; inherit system; }, }: { myHello = pkgs.hello; } And build it with:\nnix-build -A myHello niv update nixpkgs --branch=nixos-unstable nix-build -A myHello Adding Home-Manager with Flakes # flake.nix { inputs = { nixpkgs.url = \u0026#34;github:NixOS/nixpkgs\u0026#34;; flake-utils.url = \u0026#34;github:numtide/flake-utils\u0026#34;; home-manager.url = \u0026#34;github:nix-community/home-manager\u0026#34;; }; outputs = { self, nixpkgs, flake-utils, home-manager, ... }: flake-utils.lib.eachDefaultSystem (system: let pkgs = nixpkgs.legacyPackages.${system}; in { packages.myHello = pkgs.hello; packages.x86_64-linux.homeManagerDocs = home-manager.packages.x86_64-linux.docs-html; }); } nix flake update nix flake show github:nix-community/home-manager home-manager.inputs.follows = \u0026#34;nixpkgs\u0026#34;; Adding Home-Manager with Traditional Nix niv add nix-community/home-manager nix repl nix-repl\u0026gt; s = import ./nix/sources.nix nix-repl\u0026gt; s.home-manager { system ? builtins.currentSystem, sources ? import nix/sources.nix , nixpkgs ? sources.nixpkgs, pkgs ? import nixpkgs { overlays = [ ]; config = { }; inherit system; }, }: { homeManagerDocs = (import sources.home-manager { pkgs = pkgs; }).docs; myHello = pkgs.hello; } nix-build -A homeManagerDocs ","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/comparing_flakes_to_traditional_nix/"},{"id":8,"title":"Declarative_depinject","summary":"Declarative Dependency Injection in Nix Flakes This post explores a method for injecting dependencies into NixOS modules from a flake in a more declarative way, offering an alternative to specialArgs.\nThe Problem with specialArgs As mentioned in post, specialArgs and extraSpecialArgs can be used to pass dependencies and variables from flakes to modules.\nHowever, specialArgs injects values directly into every module\u0026rsquo;s argument list.\nThis approach deviates from NixOS\u0026rsquo;s typical declarative data flow model. Instead of explicit dependency passing, modules receive extra, unstructured variables that aren\u0026rsquo;t part of the standard module options.\n","content":"Declarative Dependency Injection in Nix Flakes This post explores a method for injecting dependencies into NixOS modules from a flake in a more declarative way, offering an alternative to specialArgs.\nThe Problem with specialArgs As mentioned in post, specialArgs and extraSpecialArgs can be used to pass dependencies and variables from flakes to modules.\nHowever, specialArgs injects values directly into every module\u0026rsquo;s argument list.\nThis approach deviates from NixOS\u0026rsquo;s typical declarative data flow model. Instead of explicit dependency passing, modules receive extra, unstructured variables that aren\u0026rsquo;t part of the standard module options.\nA Declarative Solution: Injecting via a Custom Option This post introduces a more declarative and centralized technique to share dependencies across modules by defining a custom option within your flake.nix . This method makes dependencies accessible to all importing modules without relying on explicit specialArgs in your flake\u0026rsquo;s outputs.\nDefining the dep-inject Module in flake.nix Within the outputs function\u0026rsquo;s let block in your flake.nix, define the following module:\n# flake.nix let # Module to inject dependencies depInject = { pkgs, lib, ... }: { options.dep-inject = lib.mkOption { # dep-inject is an attribute set of unspecified values type = with lib.types; attrsOf unspecified; default = { }; }; config.dep-inject = { # \u0026#39;inputs\u0026#39; comes from the outer environment of flake.nix # usually contains flake inputs, user-defined vars, system metadata \u0026#34;flake-inputs\u0026#34; = inputs; userVars = userVars; system = system; host = host; username = username; }; }; in { nixosModules.default = { pkgs, lib, ... }: { imports = [ depInject ]; }; } This code defines a reusable NixOS module (nixosModules.default).\nThis module creates a dep-inject option, which is an attribute set containing your flake\u0026rsquo;s inputs and other relevant variables.\nBy importing depInject, configurations automatically gain access to these dependencies.\nBenefits of this Approach Declarative Dependency Flow: Encourages a more declarative style by accessing dependencies through a well-defined option (config.dep-inject) rather than implicit arguments.\nCentralized Dependency Management: Defines dependencies in one place (flake.nix), making it easier to manage and update them.\nAutomatic Availability: Modules importing the configuration automatically have access to the injected dependencies.\nReduced Boilerplate: Avoids the need to explicitly include dependency arguments ({ inputs, userVars, ... }) in every module.\nExample Usage Here\u0026rsquo;s a practical example of how this dep-inject module is defined and used within a flake.nix:\n{ inputs = { nixpkgs.url = \u0026#34;github:NixOS/nixpkgs/nixos-unstable\u0026#34;; home-manager.url = \u0026#34;github:nix-community/home-manager/master\u0026#34;; home-manager.inputs.nixpkgs.follows = \u0026#34;nixpkgs\u0026#34;; stylix.url = \u0026#34;github:danth/stylix\u0026#34;; treefmt-nix.url = \u0026#34;github:numtide/treefmt-nix\u0026#34;; }; outputs = { self, nixpkgs, home-manager, stylix, treefmt-nix, ... } @ inputs: let system = \u0026#34;x86_64-linux\u0026#34;; host = \u0026#34;magic\u0026#34;; username = \u0026#34;jr\u0026#34;; userVars = { timezone = \u0026#34;America/New_York\u0026#34;; gitUsername = \u0026#34;TSawyer87\u0026#34;; locale = \u0026#34;en_US.UTF-8\u0026#34;; dotfilesDir = \u0026#34;~/.dotfiles\u0026#34;; wm = \u0026#34;hyprland\u0026#34;; browser = \u0026#34;firefox\u0026#34;; term = \u0026#34;ghostty\u0026#34;; editor = \u0026#34;hx\u0026#34;; keyboardLayout = \u0026#34;us\u0026#34;; }; pkgs = import nixpkgs { inherit system; config.allowUnfree = true; }; treefmtEval = treefmt-nix.lib.evalModule pkgs ./treefmt.nix; # Define dep-inject module depInject = { pkgs, lib, ... }: { options.dep-inject = lib.mkOption { type = with lib.types; attrsOf unspecified; default = { }; }; config.dep-inject = { flake-inputs = inputs; userVars = userVars; # Add userVars for convenience system = system; username = username; host = host; }; }; in { # Export dep-inject module nixosModules.default = { pkgs, lib, ... }: { imports = [ depInject ]; }; # here we don\u0026#39;t need imports = [ depInject { inherit inputs;}] # because the vars are captured from the surrounding let block # NixOS configuration nixosConfigurations = { ${host} = nixpkgs.lib.nixosSystem { inherit system; modules = [ # enable dep-inject self.nixosModules.default ./hosts/${host}/configuration.nix home-manager.nixosModules.home-manager stylix.nixosModules.stylix { home-manager.useGlobalPkgs = true; home-manager.useUserPackages = true; home-manager.users.${username} = import ./hosts/${host}/home.nix; home-manager.backupFileExtension = \u0026#34;backup\u0026#34;; # Still need extraSpecialArgs for Home Manager (see below) home-manager.extraSpecialArgs = { inherit username system host userVars; }; } ]; }; }; # Other outputs checks.x86_64-linux.style = treefmtEval.config.build.check self; formatter.x86_64-linux = treefmtEval.config.build.wrapper; devShells.${system}.default = import ./lib/dev-shell.nix { inherit inputs; }; }; } Using dep-inject in Modules\nOnce the dep-inject module is imported, you can access the injected dependencies within any module via config.dep-inject.\nExample: System Configuration Module (configuration.nix)\n# configuration.nix { config, pkgs, ... }: { environment.systemPackages = with config.dep-inject.flake-inputs.nixpkgs.legacyPackages.${pkgs.system}; [ firefox config.dep-inject.userVars.editor # e.g., helix ]; time.timeZone = config.dep-inject.userVars.timezone; system.stateVersion = \u0026#34;24.05\u0026#34;; } config.dep-inject.flake-inputs.nixpkgs: Accesses the nixpkgs input.\nconfig.dep-inject.userVars: Accesses your userVars.\nYou no longer need to explicitly declare { inputs, userVars, ... } in the module\u0026rsquo;s arguments.\nApplying dep-inject to Home Manager Modules By default, the dep-inject module is available to NixOS modules but not automatically to Home Manager modules. There are two main ways to make it accessible:\nUsing extraSpecialArgs (Less Ideal) home-manager.extraSpecialArgs = { inherit username system host userVars; depInject = config.dep-inject; # Pass dep-inject }; Then, in your Home Manager configuration (./hosts/${host}/home.nix):\n# home.nix { depInject, ... }: { programs.git = { enable = true; userName = depInject.userVars.gitUsername; }; home.packages = with depInject.flake-inputs.nixpkgs.legacyPackages.x86_64-linux; [ firefox ]; } Importing depInject into Home Manager Configuration (More Idiomatic) # flake.nix nixosConfigurations = { ${host} = nixpkgs.lib.nixosSystem { inherit system; modules = [ self.nixosModules.default # dep-inject for NixOS ./hosts/${host}/configuration.nix home-manager.nixosModules.home-manager stylix.nixosModules.stylix { home-manager.useGlobalPkgs = true; home-manager.useUserPackages = true; home-manager.backupFileExtension = \u0026#34;backup\u0026#34;; home-manager.users.${username} = { imports = [ self.nixosModules.default ]; # dep-inject for Home Manager # Your Home Manager config programs.git = { enable = true; userName = config.dep-inject.userVars.gitUsername; }; # note: depending on your setup you may need to tweak this # `legacyPackages.${pkgs.system}` might be needed # due to how home-manager handles `pkgs` home.packages = with config.dep-inject.flake-inputs.nixpkgs.legacyPackages.x86_64-linux; [ firefox ]; }; } ]; }; }; By adding imports = [ self.nixosModules.default ]; within the Home Manager user configuration, the dep-inject option becomes available under config.\nThis approach is generally considered more idiomatic and avoids the issues associated with specialArgs, as highlighted in resources like \u0026ldquo;flakes-arent-real\u0026rdquo;\nConclusion While specialArgs offers a seemingly straightforward way to inject dependencies, this declarative approach using a custom dep-inject option promotes a cleaner, more structured, and potentially more robust method for managing dependencies across your NixOS modules. It aligns better with NixOS\u0026rsquo;s declarative principles and can enhance the maintainability and understandability of your configuration.\nDisclaimer\nI don\u0026rsquo;t currently personally use this technique in my configuration, it adds complexity that specialArgs aimed to solve. However, presenting this alternative enhances understanding of different dependency injection methods in Nix Flakes. This example is inspired by and builds upon concepts discussed in flakes-arent-real ","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/declarative_depinject/"},{"id":9,"title":"Derivations_explained","summary":"Introduction to Nix Derivations A derivation in Nix is a fundamental concept that describes how to build a piece of software or a resource (e.g., a package, library, or configuration file). Think of it as a recipe for creating something within the Nix ecosystem.\nFor beginners, the analogy of a cooking recipe is helpful:\nIngredients (Dependencies): What other software or libraries are needed. Steps (Build Instructions): The commands to compile, configure, and install. Final Dish (Output): The resulting package or resource. A Nix derivation encapsulates all this information, telling Nix what inputs to use, how to build it, and what the final output should be.\n","content":"Introduction to Nix Derivations A derivation in Nix is a fundamental concept that describes how to build a piece of software or a resource (e.g., a package, library, or configuration file). Think of it as a recipe for creating something within the Nix ecosystem.\nFor beginners, the analogy of a cooking recipe is helpful:\nIngredients (Dependencies): What other software or libraries are needed. Steps (Build Instructions): The commands to compile, configure, and install. Final Dish (Output): The resulting package or resource. A Nix derivation encapsulates all this information, telling Nix what inputs to use, how to build it, and what the final output should be.\nCreating Derivations in Nix The primary way to define packages in Nix is through the mkDerivation function, which is part of the standard environment (stdenv). While a lower-level derivation function exists for advanced use cases, mkDerivation simplifies the process by automatically managing dependencies and the build environment.\nmkDerivation (and derivation) takes a set of attributes as its argument. At a minimum, you\u0026rsquo;ll often encounter these essential attributes:\nname: A human-readable identifier for the derivation (e.g., \u0026ldquo;foo\u0026rdquo;, \u0026ldquo;hello.txt\u0026rdquo;). This helps you and Nix refer to the package. system: Specifies the target architecture for the build (e.g., builtins.currentSystem for your current machine). builder: Defines the program that will execute the build instructions (e.g., bash). Our First Simple Derivation: Understanding the Builder To understand how derivations work, let\u0026rsquo;s create a very basic example using a bash script as our builder. Why a Builder Script? The builder attribute in a derivation tells Nix how to perform the build steps. A simple and common way to define these steps is with a bash script. The Challenge with Shebangs in Nix In typical Unix-like systems, you might start a bash script with a shebang (#!/bin/bash or #!/usr/bin/env bash) to tell the system how to execute it. However, in Nix derivations, we generally avoid this.\nReason: Nix builds happen in an isolated environment where the exact path to common tools like bash isn\u0026rsquo;t known beforehand (it resides within the Nix store). Hardcoding a path or relying on the system\u0026rsquo;s PATH would break Nix\u0026rsquo;s stateless property.\nThe Importance of Statelessness in Nix Stateful Systems (Traditional): When you install software traditionally, it often modifies the core system environment directly. This can lead to dependency conflicts and makes rollbacks difficult.\nStateless Systems (Nix): Nix takes a different approach. When installing a package, it creates a unique, immutable directory in the Nix store. This means:\nNo Conflicts: Different versions of the same package can coexist without interfering with each other. Reliable Rollback: You can easily switch back to previous versions without affecting system-wide files. Reproducibility: Builds are more likely to produce the same result across different machines if they are \u0026ldquo;pure\u0026rdquo; (don\u0026rsquo;t rely on external system state). Our builder Script For our first derivation, we\u0026rsquo;ll create a simple builder.sh file in the current directory: # builder.sh declare -xp echo foo \u0026gt; $out The command declare -xp lists exported variables (it\u0026rsquo;s a bash builtin function).\nNix needs to know where the final built product (the \u0026ldquo;cake\u0026rdquo; in our earlier analogy) should be placed. So, during the derivation process, Nix calculates a unique output path within the Nix store. This path is then made available to our builder script as an environment variable named $out. The .drv file, which is the recipe, contains instructions for the builder, including setting up this $out variable. Our builder script will then put the result of its work (in this case, the \u0026ldquo;foo\u0026rdquo; file) into this specific $out directory.\nAs mentioned earlier we need to find the nix store path to the bash executable, common way to do this is to load Nixpkgs into the repl and check:\nnix-repl\u0026gt; :l \u0026lt;nixpkgs\u0026gt; Added 3950 variables. nix-repl\u0026gt; \u0026#34;${bash}\u0026#34; \u0026#34;/nix/store/ihmkc7z2wqk3bbipfnlh0yjrlfkkgnv6-bash-4.2-p45\u0026#34; So, with this little trick we are able to refer to bin/bash and create our derivation:\nnix-repl\u0026gt; d = derivation { name = \u0026#34;foo\u0026#34;; builder = \u0026#34;${bash}/bin/bash\u0026#34;; args = [ ./builder.sh ]; system = builtins.currentSystem; } nix-repl\u0026gt; :b d [1 built, 0.0 MiB DL] this derivation produced the following outputs: out -\u0026gt; /nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo Boom! The contents of /nix/store/w024zci0x1hh1wj6gjq0jagkc1sgrf5r-foo is really foo! We\u0026rsquo;ve built our first derivation.\nDerivations are the primitive that Nix uses to define packages. “Package” is a loosely defined term, but a derivation is simply the result of calling builtins.derivation.\nOur Second Derivation The following is a simple hello-drv derivation:\nnix-repl\u0026gt; hello-drv = nixpkgs.stdenv.mkDerivation { name = \u0026#34;hello.txt\u0026#34;; unpackPhase = \u0026#34;true\u0026#34;; installPhase = \u0026#39;\u0026#39; echo -n \u0026#34;Hello World!\u0026#34; \u0026gt; $out \u0026#39;\u0026#39;; } nix-repl\u0026gt; hello-drv «derivation /nix/store/ad6c51ia15p9arjmvvqkn9fys9sf1kdw-hello.txt.drv» Derivations have a .drv suffix, as you can see the result of calling hello-drv is the nix store path to a derivation. Links To Articles about Derivations NixPillsOurFirstDerivation\nNixPills-WorkingDerivation\nnix.dev-Derivations\nnix.dev-packagingExistingSoftware\nhowToLearnNix-MyFirstDerivation\nhowToLearnNix-DerivationsInDetail\nSparky/blog-creatingASuperSimpleDerivation # How to learn Nix\nSparky/blog-Derivations102\nScriveNixWorkshop-nixDerivationBasics\nzeroToNix-Derivations\nTweag-derivationOutputs\ntheNixLectures-Derivations\nbmcgee-whatAreFixed-OutputDerivations\n","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/derivations_explained/"},{"id":10,"title":"Simple_nix_service","summary":"Building a Custom NixOS Service with Flakes and Overlays TL;DR NixOS\u0026rsquo;s declarative configuration and flakes make it easy to create custom services. This post shows how to build a minimal service using flakes and overlays for a \u0026ldquo;meow\u0026rdquo; command\nThis will be a complete minimal configuration for testing purposes. Create Project Directory Start by creating a directory to hold your project, I called mine meow:\nmkdir meow \u0026amp;\u0026amp; cd meow Create flake Create a flake.nix with the following:\n","content":"Building a Custom NixOS Service with Flakes and Overlays TL;DR NixOS\u0026rsquo;s declarative configuration and flakes make it easy to create custom services. This post shows how to build a minimal service using flakes and overlays for a \u0026ldquo;meow\u0026rdquo; command\nThis will be a complete minimal configuration for testing purposes. Create Project Directory Start by creating a directory to hold your project, I called mine meow:\nmkdir meow \u0026amp;\u0026amp; cd meow Create flake Create a flake.nix with the following:\n# flake.nix { inputs.nixpkgs.url = \u0026#34;github:nixos/nixpkgs/nixos-unstable\u0026#34;; outputs = { self, nixpkgs, ... }: { overlays.default = final: prev: { meow = final.writeShellScriptBin \u0026#34;meow\u0026#34; \u0026#39;\u0026#39; echo meow \u0026#39;\u0026#39;; }; nixosModules.default = { pkgs, config, lib, ... }: { imports = [ ./nixos-module.nix ]; # inject dependencies from flake.nix, and don\u0026#39;t do anything else config = lib.mkIf config.services.meow.enable { nixpkgs.overlays = [ self.overlays.default ]; services.meow.package = lib.mkDefault pkgs.meow; }; }; }; } Create Service Module Next we\u0026rsquo;ll create the nixos-module.nix in the same directory with the following content:\n# nixos-module.nix { pkgs, config, lib, ... }: let cfg = config.services.meow; in { options = { services.meow = { enable = lib.mkEnableOption \u0026#34;meow\u0026#34;; package = lib.mkOption { description = \u0026#34;meow package to use\u0026#34;; type = lib.types.package; }; }; }; config = lib.mkIf cfg.enable { systemd.services.meow = { description = \u0026#34;meow at the user on the console\u0026#34;; serviceConfig = { Type = \u0026#34;oneshot\u0026#34;; ExecStart = \u0026#34;${cfg.package}/bin/meow\u0026#34;; StandardOutput = \u0026#34;journal+console\u0026#34;; }; wantedBy = [ \u0026#34;multi-user.target\u0026#34; ]; }; }; } Add nixosConfigurations Output Lastly, we will add a nixosConfigurations output to the flake.nix\n# flake.nix nixosConfigurations.test = nixpkgs.lib.nixosSystem { system = \u0026#34;x86_64-linux\u0026#34;; modules = [ self.nixosModules.default ({ pkgs, lib, ... }: { fileSystems.\u0026#34;/\u0026#34; = { device = \u0026#34;/dev/sda1\u0026#34;; }; boot.loader.grub.enable = false; boot.initrd.enable = false; boot.kernel.enable = false; documentation.enable = false; services.meow.enable = true; system.stateVersion = \u0026#34;25.05\u0026#34;; }) ]; }; nixosConfigurations.test is simply the name we chose for this particular NixOS system configuration. The final product will look like this:\n# flake.nix { inputs.nixpkgs.url = \u0026#34;github:nixos/nixpkgs/nixos-unstable\u0026#34;; outputs = { self, nixpkgs, ... }: { overlays.default = final: prev: { meow = final.writeShellScriptBin \u0026#34;meow\u0026#34; \u0026#39;\u0026#39; echo meow \u0026#39;\u0026#39;; }; nixosModules.default = { pkgs, config, lib, ... }: { imports = [./nixos-module.nix]; # inject dependencies from flake.nix, and don\u0026#39;t do anything else config = lib.mkIf config.services.meow.enable { nixpkgs.overlays = [self.overlays.default]; services.meow.package = lib.mkDefault pkgs.meow; }; }; nixosConfigurations.test = nixpkgs.lib.nixosSystem { system = \u0026#34;x86_64-linux\u0026#34;; modules = [ self.nixosModules.default ({ pkgs, lib, ... }: { fileSystems.\u0026#34;/\u0026#34; = { device = \u0026#34;/dev/sda1\u0026#34;; }; boot.loader.grub.enable = false; boot.initrd.enable = false; boot.kernel.enable = false; documentation.enable = false; services.meow.enable = true; system.stateVersion = \u0026#34;25.05\u0026#34;; }) ]; }; }; } Build the System Configuration Then build the system configuration:\nnix build .#nixosConfigurations.test.config.system.build.toplevel\nIf this builds successfully you\u0026rsquo;ll see a result directory within your meow directory.\nI wouldn\u0026rsquo;t recommend actually switching to this configuration but you could build it to gain familiarity with it. If you were to switch to it you would run ./result/bin/switch-to-configuration\nTest in a NixOS Virtual Machine (Recommended):The safest way to see the \u0026ldquo;meow\u0026rdquo; output is to build the configuration and then run it in a NixOS virtual machine. You can do this using tools like nixos-generate-config and a virtualization tool (like VirtualBox, QEMU, or GNOME Boxes).\n","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/simple_nix_service/"},{"id":11,"title":"Nix_flakes_tips","summary":"Shallow Clone Nixpkgs Shallow clone nixpkgs, the full Git history isn\u0026rsquo;t always necessary and this can speed up build times. The only issue I\u0026rsquo;ve had is nix-index-database not working well with the shallow clone\u0026hellip; Other than that no issues after running for a few months. # flake.nix inputs = { nixpkgs.url = \u0026#34;git+https://github.com/NixOS/nixpkgs?shallow=1\u0026amp;ref=nixos-unstable\u0026#34;; }; Some times when you might need a full clone are debugging and working with repository history but those are rare. Import your Non-Flake Wallpaper Repo Importing your non-flake wallpapers repo: # flake.nix inputs = { wallpapers = { url = \u0026#34;github:saylesss88/wallpapers\u0026#34;; flake = false; }; } After adding the input I can access individual wallpapers by adding the inputs argument and something like path = \u0026quot;${inputs.wallpapers}/Aesthetic Scenery.jpg\u0026quot;; Understanding @-patterns Understanding @-patterns, being able to reference your outputs argument set as a whole. An @-pattern is a way for a function can access variadic attributes (i.e. varying number of arguments). # flake.nix inputs = { home-manager.url = \u0026#34;github:nix-community/home-manager/master\u0026#34;; home-manager.inputs.nixpkgs.follows = \u0026#34;nixpkgs\u0026#34;; stylix.url = \u0026#34;github:danth/stylix\u0026#34;; }; outputs = { self, nixpkgs, home-manager, } @ inputs: With the above example to add the modules to your nixosConfigurations you would add something like this:\n","content":"Shallow Clone Nixpkgs Shallow clone nixpkgs, the full Git history isn\u0026rsquo;t always necessary and this can speed up build times. The only issue I\u0026rsquo;ve had is nix-index-database not working well with the shallow clone\u0026hellip; Other than that no issues after running for a few months. # flake.nix inputs = { nixpkgs.url = \u0026#34;git+https://github.com/NixOS/nixpkgs?shallow=1\u0026amp;ref=nixos-unstable\u0026#34;; }; Some times when you might need a full clone are debugging and working with repository history but those are rare. Import your Non-Flake Wallpaper Repo Importing your non-flake wallpapers repo: # flake.nix inputs = { wallpapers = { url = \u0026#34;github:saylesss88/wallpapers\u0026#34;; flake = false; }; } After adding the input I can access individual wallpapers by adding the inputs argument and something like path = \u0026quot;${inputs.wallpapers}/Aesthetic Scenery.jpg\u0026quot;; Understanding @-patterns Understanding @-patterns, being able to reference your outputs argument set as a whole. An @-pattern is a way for a function can access variadic attributes (i.e. varying number of arguments). # flake.nix inputs = { home-manager.url = \u0026#34;github:nix-community/home-manager/master\u0026#34;; home-manager.inputs.nixpkgs.follows = \u0026#34;nixpkgs\u0026#34;; stylix.url = \u0026#34;github:danth/stylix\u0026#34;; }; outputs = { self, nixpkgs, home-manager, } @ inputs: With the above example to add the modules to your nixosConfigurations you would add something like this:\n# flake.nix nixosConfigurations.${host} = nixpkgs.lib.nixosSystem { inherit system; specialArgs = { inherit inputs username host email systemSettings; }; modules = [ ./hosts/${host}/config.nix inputs.stylix.nixosModules.stylix home-manager.nixosModules.home-manager # .. snip .. ]; Notice that since home-manager was explicitly listed in the outputs arguments: outputs = { self, nixpkgs, home-manager, }; the inputs prefix is unnecessary. If home-manager was removed from the outputs arguments: outputs = { self, ... } then you would need modules = [ inputs.home-manager.nixosModules.home-manager]; This can be confusing because many docs assume your not using an @-pattern so if you have one in your flake you need to prefix with inputs. I use this to reference my personal wallpapers repo mentioned earlier. Understanding specialArgs Understanding specialArgs (nixos) and extraSpecialArgs (home-manager). Building on the @-patterns, using specialArgs and extraSpecialArgs is a way to pass arguments from your flake to your NixOS and home-manager modules. For example, here is a snippet of some variables I set:\n# flake.nix outputs = { self, nixpkgs, home-manager, ... } @ inputs: let system = \u0026#34;x86_64-linux\u0026#34;; host = \u0026#34;magic\u0026#34;; username = \u0026#34;jr\u0026#34;; userVars = { timezone = \u0026#34;America/New_York\u0026#34;; locale = \u0026#34;en_US.UTF-8\u0026#34;; gitUsername = \u0026#34;TSawyer87\u0026#34;; dotfilesDir = \u0026#34;~/.dotfiles\u0026#34;; wm = \u0026#34;hyprland\u0026#34;; browser = \u0026#34;firefox\u0026#34;; term = \u0026#34;ghostty\u0026#34;; editor = \u0026#34;hx\u0026#34;; keyboardLayout = \u0026#34;us\u0026#34;; }; in Now I can pass them as special args like this:\n# flake.nix nixosConfigurations = { ${host} = nixpkgs.lib.nixosSystem { inherit system; specialArgs = { inherit inputs username system host userVars ; }; modules = [ ./hosts/${host}/configuration.nix home-manager.nixosModules.home-manager inputs.stylix.nixosModules.stylix { home-manager.useGlobalPkgs = true; home-manager.useUserPackages = true; home-manager.users.${username} = import ./hosts/${host}/home.nix; home-manager.backupFileExtension = \u0026#34;backup\u0026#34;; home-manager.extraSpecialArgs = { inherit inputs username system host userVars ; }; } ]; To access values in userVars for example: # git.nix { userVars, ... }: { programs = { git = { enable = true; userName = userVars.gitUsername; }; }; } Set up Flake Check and Formatter Outputs Set up checks and formatter outputs with treefmt-nix. Add treefmt-nix to your inputs and outputs arguments. Inside the let expression from tip 4 I would add: # flake.nix let # ... snip ... pkgs = import nixpkgs { inherit system; config.allowUnfree = true; }; treefmtEval = treefmt-nix.lib.evalModule pkgs ./treefmt.nix; in { checks.x86_64-linux.style = treefmtEval.config.build.check self; formatter.x86_64-linux = treefmtEval.config.build.wrapper; # ... snip ... } And in the treefmt.nix:\n# treefmt.nix { projectRootFile = \u0026#34;flake.nix\u0026#34;; programs = { deadnix.enable = true; statix.enable = true; keep-sorted.enable = true; nixfmt = { enable = true; strict = true; }; }; settings.excludes = [ \u0026#34;*.age\u0026#34; \u0026#34;*.jpg\u0026#34; \u0026#34;*.nu\u0026#34; \u0026#34;*.png\u0026#34; \u0026#34;.jj/*\u0026#34; \u0026#34;flake.lock\u0026#34; \u0026#34;justfile\u0026#34; ]; settings.formatter = { deadnix = { priority = 1; }; statix = { priority = 2; }; nixfmt = { priority = 3; }; }; } Use treefmt-nix to manage code formatters and linters as flake outputs. This ensures consistent styling and catches issues with tools like deadnix, statix, and nixfmt.\nUse nix fmt in the flake directory to format your whole configuration.\nNow you can run nix flake check to run your checks. Running nix flake show will list your outputs.\nTools like nix-fast-build rely on flake checks and can be used after setting this up.\nAdd a devShell Output Make a devShell output: in { checks.x86_64-linux.style = treefmtEval.config.build.check self; formatter.x86_64-linux = treefmtEval.config.build.wrapper; devShells.${system}.default = import ./lib/dev-shell.nix { inherit inputs; }; and in the dev-shell.nix you could put something like this:\n# dev-shell.nix { inputs, system ? \u0026#34;x86_64-linux\u0026#34;, }: let # Instantiate nixpkgs with the given system and allow unfree packages pkgs = import inputs.nixpkgs { inherit system; config.allowUnfree = true; overlays = [ # Add overlays if needed, e.g., inputs.neovim-nightly-overlay.overlays.default ]; }; in pkgs.mkShell { name = \u0026#34;nixos-dev\u0026#34;; packages = with pkgs; [ # Nix tools nixfmt-rfc-style # Formatter deadnix # Dead code detection nixd # Nix language server nil # Alternative Nix language server nh # Nix helper nix-diff # Compare Nix derivations nix-tree # Visualize Nix dependencies # Code editing helix # General utilities git ripgrep jq tree ]; shellHook = \u0026#39;\u0026#39; echo \u0026#34;Welcome to the NixOS development shell!\u0026#34; echo \u0026#34;System: ${system}\u0026#34; echo \u0026#34;Tools available: nixfmt, deadnix, nixd, nil, nh, nix-diff, nix-tree, helix, git, ripgrep, jq, tree\u0026#34; \u0026#39;\u0026#39;; } You can enter this devshell with nix develop or automatically with direnv. ","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/nix_flakes_tips/"},{"id":12,"title":"Working_with_nixpkgs_locally","summary":"Working with Nixpkgs Locally: Benefits and Best Practices Nixpkgs, the package repository for NixOS, is a powerful resource for building and customizing software. Working with a local copy enhances development, debugging, and contribution workflows. This post covers setting up a local Nixpkgs repository, searching for dependencies, and leveraging its advantages, incorporating tips from the Nix community. I. Why Work with Nixpkgs Locally? A local Nixpkgs repository offers significant advantages for Nix developers:\n","content":"Working with Nixpkgs Locally: Benefits and Best Practices Nixpkgs, the package repository for NixOS, is a powerful resource for building and customizing software. Working with a local copy enhances development, debugging, and contribution workflows. This post covers setting up a local Nixpkgs repository, searching for dependencies, and leveraging its advantages, incorporating tips from the Nix community. I. Why Work with Nixpkgs Locally? A local Nixpkgs repository offers significant advantages for Nix developers:\nA. Faster Development Cycle Local searches for packages and dependencies are significantly quicker than querying remote repositories or channels. This speedup is crucial for efficient debugging and rapid prototyping of Nix expressions. B. Enhanced Version Control By pinning your local repository to specific commits or branches (e.g., nixos-unstable), you ensure build reproducibility. This prevents unexpected issues arising from upstream changes in Nixpkgs. C. Flexible Debugging Capabilities You can directly test and modify package derivations within your local copy. This allows for quick fixes to issues like missing dependencies without waiting for upstream updates or releases. D. Streamlined Contribution Workflow Developing and testing new packages or patches locally is essential before submitting them as pull requests to Nixpkgs. A local setup provides an isolated environment for experimentation. E. Up-to-Date Documentation Source The source code and comments within the Nixpkgs repository often contain the most current information about packages. This can sometimes be more up-to-date than official, external documentation. F. Optimized Storage and Performance Employing efficient cloning strategies (e.g., shallow clones) and avoiding unnecessary practices (like directly using Nixpkgs as a flake for local development) minimizes disk usage and build times. II. Flake vs. Non-Flake Syntax for Local Nixpkgs When working with Nixpkgs locally, the choice between Flake and non-Flake syntax has implications for performance and storage:\nA. Flake Syntax (nix build .#\u0026lt;package\u0026gt;) Treats the current directory as a flake, requiring evaluation of flake.nix. For local Nixpkgs, this evaluates the flake definition in the repository root. Performance and Storage Overhead: Flakes copy the entire working directory (including Git history if present) to /nix/store for evaluation. This can be slow and storage-intensive for large repositories like Nixpkgs. B. Non-Flake Syntax (nix-build -f . \u0026lt;package\u0026gt; or nix build -f . \u0026lt;package\u0026gt;) -f . specifies the Nix expression (e.g., default.nix or a specific file) in the current directory. Efficiency: Evaluates the Nix expression directly without copying the entire worktree to /nix/store. This is significantly faster and more storage-efficient for local development on large repositories. III. Setting Up a Local Nixpkgs Repository Efficiently Cloning Nixpkgs requires careful consideration due to its size.\nA. Initial Clone: Shallow Cloning To avoid downloading the entire history, perform a shallow clone: git clone [https://github.com/NixOS/nixpkgs](https://github.com/NixOS/nixpkgs) --depth 1 cd nixpkgs B. Managing Branches with Worktrees Use Git worktrees to manage different branches efficiently: git fetch --all --prune --depth=1 git worktree add -b nixos-unstable nixos-unstable # For just unstable Explanation of git worktree: Allows multiple working directories attached to the same .git directory, sharing history and objects but with separate checked-out files. git worktree add: Creates a new working directory for the specified branch (nixos-unstable in this case). IV. Debugging Missing Dependencies: A Practical Example Let\u0026rsquo;s say you\u0026rsquo;re trying to build icat locally and encounter a missing dependency error:\nnix-build -A icat # ... (Error log showing \u0026#34;fatal error: X11/Xlib.h: No such file or directory\u0026#34;) The error fatal error: X11/Xlib.h: No such file or directory indicates a missing X11 dependency. A. Online Search with search.nixos.org The Nixpkgs package search website (https://search.nixos.org/packages) is a valuable first step. However, broad terms like \u0026ldquo;x11\u0026rdquo; can yield many irrelevant results. Tip: Utilize the left sidebar to filter by package sets (e.g., \u0026ldquo;xorg\u0026rdquo;). B. Local Source Code Search with rg (ripgrep) Familiarity with searching the Nixpkgs source code is crucial for finding dependencies.\nNavigate to your local nixpkgs/ directory and use rg:\nrg \u0026#34;x11 =\u0026#34; pkgs # Case-sensitive search Output:\npkgs/tools/X11/primus/default.nix 21: primus = if useNvidia then primusLib_ else primusLib_.override { nvidia_x11 = null; }; 22: primus_i686 = if useNvidia then primusLib_i686_ else primusLib_i686_.override { nvidia_x11 = null; }; pkgs/applications/graphics/imv/default.nix 38: x11 = [ libGLU xorg.libxcb xorg.libX11 ]; Refining the search (case-insensitive):\nrg -i \u0026#34;libx11 =\u0026#34; pkgs Output:\n# ... (Output showing \u0026#34;xorg.libX11\u0026#34;) The key result is xorg.libX11, which is likely the missing dependency.\nV. Local Derivation Search with nix-locate nix-locate (from the nix-index package) allows searching for derivations on the command line.\nNote: Install nix-index and run nix-index to create the initial index.\nnix-locate libx11 # ... (Output showing paths related to libx11) Combining online and local search tools (search.nixos.org, rg, nix-locate) provides a comprehensive approach to finding dependencies.\nVI. Key Benefits of Working with Nixpkgs Locally (Recap) Speed: Faster searches and builds compared to remote operations. Control: Full control over the Nixpkgs version. Up-to-Date Information: Repository source often has the latest details. VII. Best Practices and Tips from the Community Rebasing over Merging: Never merge upstream changes into your local branch. Always rebase your branch onto the upstream (e.g., master or nixos-unstable) to avoid accidental large-scale pings in pull requests (Tip from soulsssx3 on Reddit).\nTip from ElvishJErrico: Avoid using Nixpkgs directly as a flake for local development due to slow copying to /nix/store and performance issues with garbage collection on large numbers of small files. Use nix build -f . \u0026lt;package\u0026gt; instead of nix build .#\u0026lt;package\u0026gt;.\nEdge Cases for Flake Syntax: Flake syntax might be necessary in specific scenarios, such as NixOS installer tests where copying the Git history should be avoided.\nBase Changes on nixos-unstable: For better binary cache hits, base your changes on the nixos-unstable branch instead of master. Consider the merge-base for staging branches as well.\nConsider jujutsu: Explore jujutsu, a Git-compatible alternative that can offer a more intuitive workflow, especially for large monorepos like Nixpkgs. While it has a learning curve, it can significantly improve parallel work and branch management.\n","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/working_with_nixpkgs_locally/"},{"id":13,"title":"Building_your_config_as_a_package","summary":"Building your configuration as a Package TL;DR This post demonstrates other ways to modularize your config as well as going into more advanced outputs.\nThis allows you to build your configuration as a package allowing you to separate the process of creating a configuration artifact and applying it to the live system giving you a reusable artifact that can be used to deploy to different systems. This can make it easier to isolate it from other parts of your system making debugging easier.\n","content":"Building your configuration as a Package TL;DR This post demonstrates other ways to modularize your config as well as going into more advanced outputs.\nThis allows you to build your configuration as a package allowing you to separate the process of creating a configuration artifact and applying it to the live system giving you a reusable artifact that can be used to deploy to different systems. This can make it easier to isolate it from other parts of your system making debugging easier.\nThe following is a snip of my flake.nix:\n# flake.nix outputs = my-inputs @ { self, nixpkgs, treefmt-nix, ... }: let system = \u0026#34;x86_64-linux\u0026#34;; host = \u0026#34;magic\u0026#34;; userVars = { username = \u0026#34;jr\u0026#34;; gitUsername = \u0026#34;TSawyer87\u0026#34;; editor = \u0026#34;hx\u0026#34;; term = \u0026#34;ghostty\u0026#34;; keys = \u0026#34;us\u0026#34;; browser = \u0026#34;firefox\u0026#34;; flake = builtins.getEnv \u0026#34;HOME\u0026#34; + \u0026#34;/my-nixos\u0026#34;; }; inputs = my-inputs // { pkgs = import inputs.nixpkgs { inherit system; }; lib = { overlays = import ./lib/overlay.nix; nixOsModules = import ./nixos; homeModules = import ./home; inherit system; }; }; defaultConfig = import ./hosts/magic { inherit inputs; }; in { packages.${system} = { nixos = defaultConfig.config.system.build.toplevel; }; # NixOS configuration nixosConfigurations.${host} = lib.nixosSystem { inherit system; specialArgs = { inherit inputs system host userVars; }; modules = [ ./hosts/${host}/configuration.nix ]; }; }; } I didn\u0026rsquo;t want to change the name of inputs and effect other areas of my config so I first renamed @ inputs to @ my-inputs to make the merged attribute set use the original inputs name.\nNote, I\u0026rsquo;m still using home-manager as a module I just had to move it for all modules to be available inside the artifact built with nix build .#nixos\nBenefits of nixosConfiguration as a Package packages.x86_64-linux.nixos = self.nixosConfigurations.magic.config.system.build.toplevel;\nThe above expression exposes the toplevel derivation of nixosConfiguration.magic as a package, which is the complete system closure of your NixOS configuration. Here is the /hosts/magic/default.nix:\n# default.nix {inputs, ...}: inputs.nixpkgs.lib.nixosSystem { inherit (inputs.lib) system; specialArgs = {inherit inputs;}; modules = [./configuration.nix]; } Because we want all modules, not just NixOS modules this requires changing your configuration.nix to include your home-manager configuration. The core reason for this is that the packages.nixos output builds a NixOS system, and home-manager needs to be a part of that system\u0026rsquo;s definition to be included in the build. # configuration.nix { pkgs, inputs, host, system, userVars, ... }: { imports = [ ./hardware.nix ./security.nix ./users.nix inputs.lib.nixOsModules # inputs.nixos-hardware.nixosModules.common-gpu-amd inputs.nixos-hardware.nixosModules.common-cpu-amd inputs.stylix.nixosModules.stylix inputs.home-manager.nixosModules.home-manager ]; # Home-Manager Configuration needs to be here for home.packages to be available in the Configuration Package and VM i.e. `nix build .#nixos` home-manager = { useGlobalPkgs = true; useUserPackages = true; extraSpecialArgs = {inherit pkgs inputs host system userVars;}; users.jr = {...}: { imports = [ inputs.lib.homeModules ./home.nix ]; }; }; ############################################################################ nixpkgs.overlays = [inputs.lib.overlays]; [!NOTE]: inputs.lib.nixOsModules is equivalent to ../../home in my case and imports all of my nixOS modules. This comes from the flake.nix where I have nixOsModules = import ./nixos Which looks for a default.nix in the nixos directory.\nMy ~/my-nixos/nixos/default.nix looks like this:\n# default.nix {...}: { imports = [ ./drivers ./boot.nix ./utils.nix #..snip.. ]; } Usage and Deployment To build the package configuration run:\nnix build .#nixos sudo ./result/bin/switch-to-configuration switch Adding a Configuration VM Output Building on what we already have, add this under defaultConfig:\ndefaultConfig = import ./hosts/magic { inherit inputs; }; vmConfig = import ./lib/vms/nixos-vm.nix { nixosConfiguration = defaultConfig; inherit inputs; }; and under the line nixos = defaultConfig.config.system.build.toplevel add:\npackages.${system} = { # build and deploy with `nix build .#nixos` nixos = defaultConfig.config.system.build.toplevel; # Explicitly named Vm Configuration `nix build .#nixos-vm` nixos-vm = vmConfig.config.system.build.vm; } And in lib/vms/nixos-vm.nix:\n# nixos-vm.nix { inputs, nixosConfiguration, ... }: nixosConfiguration.extendModules { modules = [ ( {pkgs, ...}: { virtualisation.vmVariant = { virtualisation.forwardPorts = [ { from = \u0026#34;host\u0026#34;; host.port = 2222; guest.port = 22; } ]; imports = [ inputs.nixos-hardware.nixosModules.common-gpu-amd # hydenix-inputs.nixos-hardware.nixosModules.common-cpu-intel ]; virtualisation = { memorySize = 8192; cores = 6; diskSize = 20480; qemu = { options = [ \u0026#34;-device virtio-vga-gl\u0026#34; \u0026#34;-display gtk,gl=on,grab-on-hover=on\u0026#34; \u0026#34;-usb -device usb-tablet\u0026#34; \u0026#34;-cpu host\u0026#34; \u0026#34;-enable-kvm\u0026#34; \u0026#34;-machine q35,accel=kvm\u0026#34; \u0026#34;-device intel-iommu\u0026#34; \u0026#34;-device ich9-intel-hda\u0026#34; \u0026#34;-device hda-output\u0026#34; \u0026#34;-vga none\u0026#34; ]; }; }; #! you can set this to skip login for sddm # services.displayManager.autoLogin = { # enable = true; # user = \u0026#34;jr\u0026#34;; # }; services.xserver = { videoDrivers = [ \u0026#34;virtio\u0026#34; ]; }; system.stateVersion = \u0026#34;24.11\u0026#34;; }; # Enable SSH server services.openssh = { enable = true; settings = { PermitRootLogin = \u0026#34;no\u0026#34;; PasswordAuthentication = true; }; }; virtualisation.libvirtd.enable = true; environment.systemPackages = with pkgs; [ open-vm-tools spice-gtk spice-vdagent spice ]; services.qemuGuest.enable = true; services.spice-vdagentd = { enable = true; }; hardware.graphics.enable = true; # Enable verbose logging for home-manager # home-manager.verbose = true; } ) ]; } Uncomment and add your username to auto login. And an apps output that will build and deploy in one step with nix build .#deploy-nixos I\u0026rsquo;ll show packages and apps outputs for context:\n# flake.nix # Default package for tools packages.${system} = { default = pkgs.buildEnv { name = \u0026#34;default-tools\u0026#34;; paths = with pkgs; [helix git ripgrep nh]; }; # build and deploy with `nix build .#nixos` nixos = defaultConfig.config.system.build.toplevel; # Explicitly named Vm Configuration `nix build .#nixos-vm` nixos-vm = vmConfig.config.system.build.vm; }; apps.${system}.deploy-nixos = { type = \u0026#34;app\u0026#34;; program = toString (pkgs.writeScript \u0026#34;deploy-nixos\u0026#34; \u0026#39;\u0026#39; #!/bin/sh nix build .#nixos sudo ./result/bin/switch-to-configuration switch \u0026#39;\u0026#39;); meta = { description = \u0026#34;Build and deploy NixOS configuration using nix build\u0026#34;; license = lib.licenses.mit; maintainers = [ { name = userVars.gitUsername; email = userVars.gitEmail; } ]; }; }; Debugging Before switching configurations, verify what\u0026rsquo;s inside your built package: nix build .#nixos --dry-run nix build .#nixos-vm --dry-run nix show-derivation .#nixos Explore the Package Contents Once the build completes, you get a store path like /nix/store/...-nixos-system. You can explore the contents using:\nnix path-info -r .#nixos tree ./result ls -lh ./result/bin Instead of switching, test components:\nnix run .#nixos --help nix run .#nixos --version Load the flake into the repl:\nnixos-rebuild repl --flake . nix-repl\u0026gt; flake.inputs nix-repl\u0026gt; config.fonts.packages nix-repl\u0026gt; config.system.build.toplevel nix-repl\u0026gt; config.services.smartd.enable # true/false nix-repl\u0026gt; flake.nixosConfigurations.nixos # confirm the built package nix-repl\u0026gt; flake.nixosConfigurations.magic # Inspect host-specific config You can make a change to your configuration while in the repl and reload with :r Understanding Atomicity Atomicity means that a system update (e.g. changing configuration.nix or a flake-based toplevel package) either fully succeeds or leaves the system unchanged, preventing partial or inconsistent states.\nThe toplevel package is the entry point for your entire NixOS system, including the kernel, initrd, system services, and home-manager settings.\nBuilding with nix build .#nixos creates the toplevel derivation upfront, allowing you to inspect or copy it before activation:\nnix build .#nixos ls -l result In contrast, nixos-rebuild switch builds and activates in one step, similar to cargo run although both do involve the same toplevel derivation. The toplevel package can be copied to another NixOS machine:\nnix build .#nixos nix copy ./result --to ssh://jr@server # or for the vm nix build .#nixos-vm nix copy .#nixos-vm --to ssh://jr@server # activate the server ssh jr@server sudo /nix/store/...-nixos-system-magic/bin/switch-to-configuration switch I got the examples for building your configuration as a package and vm from the hydenix configuration and adapted them to my config.\nI got the examples for building your configuration as a package and vm from the hydenix configuration and adapted them to my config.\n","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/building_your_config_as_a_package/"},{"id":14,"title":"Conditional_configuration","summary":"Conditional Configuration With options it\u0026rsquo;s easy to conditionally install something based on if another program is enabled in your configuration.\nHyprland Module For example, if I have an option to enable or disable hyprland like this:\n# hyprland.nix { pkgs, lib, config, inputs, ... }: let cfg = config.custom.hyprland; in { options.custom.hyprland = { enable = lib.mkOption { type = lib.types.bool; default = false; description = \u0026#34;Enable hyprland module\u0026#34;; }; }; config = lib.mkIf cfg.enable { home.packages = with pkgs; [ # swww grim slurp wl-clipboard-rs cliphist swappy ydotool wpaperd wofi hyprpicker pavucontrol blueman # lxqt.lxqt-policykit brightnessctl polkit_gnome wlr-randr wtype rose-pine-cursor # nwg-look # yad # gtk-engine-murrine ]; # .. snip .. Since the above module is set to false, it is necessary to add custom.hyprland.enable = true to my home.nix to have Nix add it to my configuration. And since home.packages is wrapped in config = lib.mkIf cfg.enable Those packages will only be installed if the module is enabled.\n","content":"Conditional Configuration With options it\u0026rsquo;s easy to conditionally install something based on if another program is enabled in your configuration.\nHyprland Module For example, if I have an option to enable or disable hyprland like this:\n# hyprland.nix { pkgs, lib, config, inputs, ... }: let cfg = config.custom.hyprland; in { options.custom.hyprland = { enable = lib.mkOption { type = lib.types.bool; default = false; description = \u0026#34;Enable hyprland module\u0026#34;; }; }; config = lib.mkIf cfg.enable { home.packages = with pkgs; [ # swww grim slurp wl-clipboard-rs cliphist swappy ydotool wpaperd wofi hyprpicker pavucontrol blueman # lxqt.lxqt-policykit brightnessctl polkit_gnome wlr-randr wtype rose-pine-cursor # nwg-look # yad # gtk-engine-murrine ]; # .. snip .. Since the above module is set to false, it is necessary to add custom.hyprland.enable = true to my home.nix to have Nix add it to my configuration. And since home.packages is wrapped in config = lib.mkIf cfg.enable Those packages will only be installed if the module is enabled.\nif I used programs.hyprland.enable and added home.packages = [ pkgs.waybar ]; without conditionals, waybar would install even if hyprland was disabled.\nWlogout Module I can then have my default for something like wlogout be to install only if the custom.hyprland module is enabled:\n# wlogout.nix { config, lib, ... }: let cfg = config.custom.wlogout; in { options.custom.wlogout = { enable = lib.mkOption { type = lib.types.bool; default = config.custom.hyprland.enable; description = \u0026#34;Enable wlogout module\u0026#34;; }; }; config = lib.mkIf cfg.enable { programs.wlogout = { enable = true; } } # .. snip .. The default value of config.custom.wlogout.enable is set to config.custom.hyprland.enable. Therefore, if config.custom.hyprland.enable evaluates to true, the wlogout module will be enabled by default. Benefits of this Approach The lib.mkIf cfg.enable ensures that wlogout’s configuration (e.g., enabling programs.wlogout) is only applied when custom.wlogout.enable = true, which defaults to custom.hyprland.enable. This means wlogout is enabled by default only if Hyprland is enabled, but I can override this (e.g., custom.wlogout.enable = true without Hyprland). This conditional logic prevents wlogout from being installed unnecessarily when Hyprland is disabled, unlike a simpler approach like programs.wlogout. enable = config.programs.hyprland.enable, which hardcodes the dependency and offers less flexibility.\n","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/conditional_configuration/"},{"id":15,"title":"Top_level_attributes_explained","summary":"Understanding Top-Level Attributes in NixOS Modules This explanation is based on insights from Infinisil, a prominent figure in the Nix community, to help clarify the concept of top-level attributes within NixOS modules.\nThe Core of a NixOS System: system.build.toplevel In a NixOS system, everything is built from a single \u0026ldquo;system derivation.\u0026rdquo; The command nix-build '\u0026lt;nixpkgs/nixos\u0026gt;' -A system initiates this build process.\nThe -A system part tells Nix to focus on the system attribute defined in the '\u0026lt;nixpkgs/nixos\u0026gt;' file (which is essentially ./default.nix within the Nixpkgs repository).\n","content":"Understanding Top-Level Attributes in NixOS Modules This explanation is based on insights from Infinisil, a prominent figure in the Nix community, to help clarify the concept of top-level attributes within NixOS modules.\nThe Core of a NixOS System: system.build.toplevel In a NixOS system, everything is built from a single \u0026ldquo;system derivation.\u0026rdquo; The command nix-build '\u0026lt;nixpkgs/nixos\u0026gt;' -A system initiates this build process.\nThe -A system part tells Nix to focus on the system attribute defined in the '\u0026lt;nixpkgs/nixos\u0026gt;' file (which is essentially ./default.nix within the Nixpkgs repository).\nThis system attribute is specifically the NixOS option system.build.toplevel . Think of system.build.toplevel as the very top of the configuration hierarchy for your entire NixOS system. Almost every setting you configure eventually influences this top-level derivation, often through a series of intermediate steps.\nKey Takeaway: system.build.toplevel is the ultimate output that defines your entire NixOS system.\nHow Options Relate: A Chain of Influence Options in NixOS are not isolated; they often build upon each other. Here\u0026rsquo;s an example of how a high-level option can lead down to a low-level system configuration:\nYou enable Nginx with services.nginx.enable = true;. This setting influences the lower-level option systemd.services.nginx. Which, in turn, affects the even lower-level option systemd.units.\u0026quot;nginx.service\u0026quot;. Ultimately, this leads to the creation of a systemd unit file within environment.etc.\u0026quot;systemd/system\u0026quot;. Finally, this unit file ends up as result/etc/systemd/system/nginx.service within the final system.build.toplevel derivation. Key Takeaway: Higher-level, user-friendly options are translated into lower-level system configurations that are part of the final system build.\nThe NixOS Module System: Evaluating Options So, how do these options get processed and turned into the final system configuration? That\u0026rsquo;s the job of the NixOS module system, located in the ./lib directory of Nixpkgs (specifically in modules.nix, options.nix, and types.nix).\nInterestingly, the module system isn\u0026rsquo;t exclusive to NixOS; you can use it to manage option sets in your own Nix projects.\nHere\u0026rsquo;s a simplified example of using the module system outside of NixOS:\nlet systemModule = { lib, config, ... }: { options.toplevel = lib.mkOption { type = lib.types.str; }; options.enableFoo = lib.mkOption { type = lib.types.bool; default = false; }; config.toplevel = \u0026#39;\u0026#39; Is foo enabled? ${lib.boolToString config.enableFoo} \u0026#39;\u0026#39;; }; userModule = { enableFoo = true; }; in (import \u0026lt;nixpkgs/lib\u0026gt;).evalModules { modules = [ systemModule userModule ]; } You can evaluate the config.toplevel option from this example using:\nnix-instantiate --eval file.nix -A config.toplevel Key Takeaway: The NixOS module system is responsible for evaluating and merging option configurations from different modules.\nHow the Module System Works: A Simplified Overview The module system processes a set of \u0026ldquo;modules\u0026rdquo; through these general steps:\nImporting Modules: It recursively finds and includes all modules specified in imports = [ ... ]; statements.\nDeclaring Options: It collects all option declarations defined using options = { ... }; from all the modules and merges them. If the same option is declared in multiple modules, the module system handles this (details omitted for simplicity).\nDefining Option Values: For each declared option, it gathers all the value assignments (defined using config = { ... }; or directly at the top level if no options or config are present) from all modules and merges them according to the option\u0026rsquo;s defined type.\nImportant Note: Option evaluation is lazy, meaning an option\u0026rsquo;s value is only computed when it\u0026rsquo;s actually needed. It can also depend on the values of other options.\nKey Takeaway: The module system imports, declares, and then evaluates option values from various modules to build the final configuration.\nTop-Level Attributes in a Module: imports, options, and config\nWithin a NixOS module (the files that define parts of your system configuration) , the attributes defined directly at the top level of the module\u0026rsquo;s function have specific meanings:\nimports: This attribute is a list of other module files to include. Their options and configurations will also be part of the evaluation.\noptions: This attribute is where you declare new configuration options. You define their type, default value, description, etc., using functions like lib.mkOption or lib.mkEnableOption.\nconfig: This attribute is where you assign values to the options that have been declared (either in the current module or in imported modules).\nKey Takeaway: The top-level attributes imports, options, and config are the primary ways to structure a NixOS module.\nThe Rule: Move Non-Option Attributes Under config\nIf you define either an options or a config attribute at the top level of your module, any other attributes that are not option declarations must be moved inside the config attribute.\nLet\u0026rsquo;s look at an example of what not to do:\n{ pkgs, lib, config, ... }: { imports = []; # Defining an option at the top level options.mine.desktop.enable = lib.mkEnableOption \u0026#34;desktop settings\u0026#34;; # This will cause an error because \u0026#39;environment\u0026#39; and \u0026#39;appstream\u0026#39; # are not \u0026#39;options\u0026#39; and \u0026#39;config\u0026#39; is also present at the top level. environment.systemPackages = lib.mkIf config.appstream.enable [ pkgs.git ]; appstream.enable = true; } This will result in the error: error: Module has an unsupported attribute 'appstream' This is caused by introducing a top-level 'config' or 'options' attribute. Add configuration attributes immediately on the top level instead, or move all of them into the explicit 'config' attribute.\nKey Takeaway: When you have options or config at the top level, all value assignments need to go inside the config block.\nThe Correct Way): Using the config Attribute\nTo fix the previous example, you need to move the value assignments for environment.systemPackages and appstream.enable inside the config attribute:\n{ pkgs, lib, config, ... }: { imports = []; # Defining an option at the top level options.mine.desktop.enable = lib.mkEnableOption \u0026#34;desktop settings\u0026#34;; config = { environment.systemPackages = lib.mkIf config.appstream.enable [ pkgs.git ]; appstream.enable = true; }; } Now, Nix knows that you are declaring an option (options.mine.desktop.enable) and then setting values for other options (environment.systemPackages, appstream.enable) within the config block.\nKey Takeaway: The config attribute is used to define the values of options.\nImplicit config: When options is Absent\nIf your module does not define either options or config at the top level, then any attributes you define directly at the top level are implicitly treated as being part of the config.\nFor example, this is valid:\n{ pkgs, lib, config, ... }: { environment.systemPackages = lib.mkIf config.appstream.enable [ pkgs.git ]; appstream.enable = true; } Nix will implicitly understand that environment.systemPackages and appstream.enable are configuration settings.\nKey Takeaway: If no explicit options or config are present, top-level attributes are automatically considered part of the configuration.\nRemoving an Option: What Happens to config\nEven if you remove the options declaration from a module that has a config section, the config = { environment.systemPackages = ... }; part will still function correctly, assuming the option it\u0026rsquo;s referencing (appstream.enable in this case) is defined elsewhere (e.g., in an imported module).\nKey Takeaway: The config section defines values for options, regardless of whether those options are declared in the same module.\n","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/top_level_attributes_explained/"},{"id":16,"title":"Nix_flakes_explained","summary":"Nix Flakes Explained This explanation highlights common areas of confusion for those new to Nix Flakes, aiming to clarify concepts rather than serve as a comprehensive guide.\nWhat is a Nix Flake? At its core, a flake is a source tree (like a Git repository) that contains a flake.nix file. This file provides a standardized way to access Nix artifacts such as packages and modules.\nThink of flake.nix as the central entry point of a flake. It not only defines what the flake produces but also declares its dependencies.\n","content":"Nix Flakes Explained This explanation highlights common areas of confusion for those new to Nix Flakes, aiming to clarify concepts rather than serve as a comprehensive guide.\nWhat is a Nix Flake? At its core, a flake is a source tree (like a Git repository) that contains a flake.nix file. This file provides a standardized way to access Nix artifacts such as packages and modules.\nThink of flake.nix as the central entry point of a flake. It not only defines what the flake produces but also declares its dependencies.\nKey Concepts ** flake.nix: The Heart of a Flake**\nThe flake.nix file is mandatory for any flake. It must contain an attribute set with at least one required attribute: outputs. It can also optionally include description and inputs. Basic Structure: { description = \u0026#34;Package description\u0026#34;; inputs = { /* Dependencies go here */ }; outputs = { /* What the flake produces */ }; nixConfig = { /* Advanced configuration options */ }; } Attribute Sets: The Building Blocks Attribute sets are fundamental in Nix. They are simply collections of name-value pairs wrapped in curly braces {}.\nExample: let my_attrset = { foo = \u0026#34;bar\u0026#34;; }; in my_attrset.foo Output: \u0026#34;bar\u0026#34; Top-Level Attributes of a Flake:\nFlakes have specific top-level attributes that can be accessed directly (without dot notation). The most common ones are inputs, outputs, and nixConfig. Anatomy of flake.nix inputs: Declaring Dependencies\nThe inputs attribute set specifies the other flakes that your current flake depends on.\nEach key in the inputs set is a name you choose for the dependency, and the value is a reference to that flake (usually a URL or a Git Repo).\nTo access something from a dependency, you generally go through the inputs attribute (e.g., inputs.helix.packages).\nExample: This declares dependencies on the nixpkgs and import-cargo flakes: inputs = { import-cargo.url = \u0026#34;github:edolstra/import-cargo\u0026#34;; nixpkgs.url = \u0026#34;nixpkgs\u0026#34;; }; When Nix evaluates your flake, it fetches and evaluates each input. These evaluated inputs are then passed as an attribute set to the outputs function, with the keys matching the names you gave them in the inputs set.\nThe special input self is a reference to the outputs and the source tree of the current flake itself.\noutputs: Defining What Your Flake Provides\nThe outputs attribute defines what your flake makes available. This can include packages, NixOS modules, development environments (devShells) and other Nix derivations.\nFlakes can output arbitrary Nix values. However, certain outputs have specific meanings for Nix commands and must adhere to particular types (often derivations, as described in the output schema).\nYou can inspect the outputs of a flake using the command:\nnix flake show This command takes a flake URI and displays its outputs in a tree structure, showing the attribute paths and their corresponding types.\nUnderstanding the outputs Function\nBeginners often mistakenly think that self and nixpkgs within outputs = { self, nixpkgs, ... }: { ... } are the outputs themselves. Instead, they are the input arguments (often called output arguments) to the outputs function.\nThe outputs function in flake.nix always takes a single argument, which is an attribute set. The syntax { self, nixpkgs, ... } is Nix\u0026rsquo;s way of destructuring this single input attribute set to extract the values associated with the keys self and nixpkgs.\nReferencing the Current Flake (self)\nself provides a way to refer back to the current flake from within the outputs function. You can use it to access other top-level attributes like inputs (e.g., self.inputs).\nThe outputs function always receives an argument conventionally named self, which represents the entire flake, including all its top-level attributes. You\u0026rsquo;ll typically use self to reference things defined within your own flake (e.g., self.packages.my-package).\nVariadic Attributes (\u0026hellip;) and @-patterns\nThe ... syntax in the input arguments of the outputs function indicates variadic attributes, meaning the input attribute set can contain more attributes than just those explicitly listed (like self and nixpkgs).\nExample:\nmul = { a, b, ... }: a \\* b; mul { a = 3; b = 4; c = 2; } # \u0026#39;c\u0026#39; is an extra attribute However, you cannot directly access these extra attributes within the function body unless you use the @-pattern:\nmul = s@{ a, b, ... }: a _ b _ s.c; # \u0026#39;s\u0026#39; now refers to the entire input set mul { a = 3; b = 4; c = 2; } # Output: 24 When used in the outputs function argument list (e.g., outputs = { pkgs, ... } @ inputs), the @-pattern binds the entire input attribute set to a name (in this case, inputs) while also allowing you to destructure specific attributes like pkgs.\nWhat outputs = { pkgs, ... } @ inputs: { ... }; does:\nDestructuring: It tries to extract the value associated with the key pkgs from the input attribute set and binds it to the variable pkgs. The ... allows for other keys in the input attribute set to be ignored during this direct destructuring.\nBinding the Entire Set: It binds the entire input attribute set to the variable inputs.\nExample flake.nix: { inputs.nixpkgs.url = \u0026#34;github:NixOS/nixpkgs/nixos-unstable\u0026#34;; inputs.home-manager.url = \u0026#34;github:nix-community/home-manager\u0026#34;; outputs = { self, nixpkgs, ... } @ attrs: { # A `packages` output for the x86_64-linux platform packages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello; # A `nixosConfigurations` output (for a NixOS system named \u0026#34;fnord\u0026#34;) nixosConfigurations.fnord = nixpkgs.lib.nixosSystem { system = \u0026#34;x86_64-linux\u0026#34;; specialArgs = attrs; modules = [ ./configuration.nix ]; }; }; } Platform Specificity in Outputs\nFlakes ensure that their outputs are consistent across different evaluation environments. Therefore, any package-related output must explicitly specify the target platform (a combination of architecture and OS, x86_64-linux). legacyPackages Explained\nlegacyPackages is a way for flakes to interact with the traditional, less structured package organization of nixpkgs. Instead of packages being directly at the top level (e.g., pkgs.hello), legacyPackages provides a platform-aware way to access them within the flake\u0026rsquo;s structured output format (e.g., nixpkgs.legacyPackages.x86_64-linux.hello). It acts as a bridge between the flake\u0026rsquo;s expected output structure and nixpkgs\u0026rsquo;s historical organization. The Sole Argument of outputs\nIt\u0026rsquo;s crucial to remember that the outputs function accepts only one argument, which is an attribute set. The { self, nixpkgs, ... } syntax is simply destructuring that single input attribute set. Outputs of the Flake (Return Value)\nThe outputs of the flake refer to the attribute set that is returned by the outputs function. This attribute set can contain various named outputs like packages, nixosConfigurations, devShells, etc. Imports: Including Other Nix Expressions\nThe import function in Nix is used to evaluate the Nix expression found at a specified path (usually a file or directory) and return its value.\nBasic Usage: import ./path/to/file.nix\nPassing Arguments During Import\nYou can also pass an attribute set as an argument to the Nix expression being imported: let myHelpers = import ./lib/my-helpers.nix { pkgs = nixpkgs; }; in # ... use myHelpers In this case, the Nix expression in ./lib/my-helpers.nix is likely a function that expects an argument (often named pkgs by convention): # ./lib/my-helpers.nix { pkgs }: let myPackage = pkgs.stdenv.mkDerivation { name = \u0026#34;my-package\u0026#34;; # ... }; in myPackage By passing { pkgs = nixpkgs; } during the import, you are providing the nixpkgs value from your current flake.nix scope to the pkgs parameter expected by the code in ./lib/my-helpers.nix. Importing Directories (default.nix)\nWhen you use import with a path that points to a directory, Nix automatically looks for a file named default.nix within that directory. If found, Nix evaluates the expressions within default.nix as if you had specified its path directly in the import statement. Further Resources practical-nix-flakes\ntweag nix-flakes\nNixOS-wiki Flakes\nnix.dev flakes\nflakes-arent-real\nwombats-book-of-nix\nzero-to-nix flakes\nnixos-and-flakes-book\n","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/nix_flakes_explained/"},{"id":17,"title":"Understanding_package_definitions","summary":"Understanding Package Definitions in Nix In Nix, the concept of a package can refer to two things:\nA collection of files and data that constitute a piece of software or an artifact.\nA Nix expression that describes how to create such a collection. This expression acts as a blueprint before the package exists in a tangible form.\nThe process begins with writing a package definition using the Nix language. This definition contains the necessary instructions and metadata about the software you intend to \u0026ldquo;package.\u0026rdquo;\n","content":"Understanding Package Definitions in Nix In Nix, the concept of a package can refer to two things:\nA collection of files and data that constitute a piece of software or an artifact.\nA Nix expression that describes how to create such a collection. This expression acts as a blueprint before the package exists in a tangible form.\nThe process begins with writing a package definition using the Nix language. This definition contains the necessary instructions and metadata about the software you intend to \u0026ldquo;package.\u0026rdquo;\nThe Journey from Definition to Package Package Definition:\nThis is essentially a function written in the Nix language.\nNix language shares similarities with JSON but includes the crucial addition of functions.\nIt acts as the blueprint for creating a package.\nDerivation:\nWhen the package definition is evaluated by Nix, it results in a derivation.\nA derivation is a concrete and detailed build plan.\nIt outlines the exact steps Nix needs to take: fetching source code, building dependencies, compiling code, and ultimately producing the desired output (the package).\nRealization (Building the Package):\nYou don\u0026rsquo;t get a pre-built \u0026ldquo;package\u0026rdquo; directly from the definition or the derivation.\nThe package comes into being when Nix executes the derivation. This process is often referred to as \u0026ldquo;realizing\u0026rdquo; the derivation.\nAnalogy: Think of a package definition as an architectural blueprint, the derivation as the detailed construction plan, and the realized package as the finished building.\nSkeleton of a Derivation The most basic derivation structure in Nix looks like this:\n{ stdenv }: stdenv.mkDerivation { } This is a function that expects an attribute set containing stdenv as its argument.\nIt then calls stdenv.mkDerivation (a function provided by stdenv) to produce a derivation.\nCurrently, this derivation doesn\u0026rsquo;t specify any build steps or outputs.\nFurther Reading:\nThe Standard Environment\nFundamentals of Stdenv\nExample: A Simple \u0026ldquo;Hello\u0026rdquo; Package Definition Here\u0026rsquo;s a package definition for the classic \u0026ldquo;hello\u0026rdquo; program:\n# hello.nix { stdenv, fetchzip, }: stdenv.mkDerivation { pname = \u0026#34;hello\u0026#34;; version = \u0026#34;2.12.1\u0026#34;; src = fetchzip { url = \u0026#34;[https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz](https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz)\u0026#34;; sha256 = \u0026#34;\u0026#34;; }; } This is a Nix function that takes stdenv and fetchzip as arguments.\nIt uses stdenv.mkDerivation to define the build process for the \u0026ldquo;hello\u0026rdquo; package.\npname: The package name.\nversion: The package version.\nsrc: Specifies how to fetch the source code using fetchzip.\nHandling Dependencies: Importing Nixpkgs\nIf you try to build hello.nix directly with nix-build hello.nix, it will fail because stdenv and fetchzip are part of Nixpkgs, which isn\u0026rsquo;t included in this isolated file.\nTo make this package definition work, you need to pass the correct arguments (stdenv, fetchzip) to the function.\nThe recommended approach is to create a default.nix file in the same directory:\n# default.nix let nixpkgs = fetchTarball \u0026#34;[https://github.com/NixOS/nixpkgs/tarball/nixos-24.05](https://github.com/NixOS/nixpkgs/tarball/nixos-24.05)\u0026#34;; pkgs = import nixpkgs { config = {}; overlays = []; }; in { hello = pkgs.callPackage ./hello.nix { }; } This default.nix imports Nixpkgs.\nIt then uses pkgs.callPackage to call the function in hello.nix, passing the necessary dependencies from Nixpkgs.\nYou can now build the \u0026ldquo;hello\u0026rdquo; package using: nix-build -A hello. The -A flag tells Nix to build the attribute named hello from the top-level expression in default.nix.\nRealizing the Derivation and Handling sha256\nEvaluation vs. Realization: While \u0026ldquo;evaluate\u0026rdquo; refers to Nix processing an expression, \u0026ldquo;realize\u0026rdquo; often specifically means building a derivation and producing its output in the Nix store.\nWhen you first run nix-build -A hello, it will likely fail due to a missing sha256 hash for the source file. Nix needs this hash for security and reproducibility. The error message will provide the correct sha256 value.\nExample Error):\nnix-build -A hello error: hash mismatch in fixed-output derivation \u0026#39;/nix/store/pd2kiyfa0c06giparlhd1k31bvllypbb-source.drv\u0026#39;: specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= got: sha256-1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc= error: 1 dependencies of derivation \u0026#39;/nix/store/b4mjwlv73nmiqgkdabsdjc4zq9gnma1l-hello-2.12.1.drv\u0026#39; failed to build Replace the empty sha256 = \u0026quot;\u0026quot;; in hello.nix with the provided correct value: sha256 = \u0026quot;1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=\u0026quot;;. Building and Running the Result\nAfter updating the sha256, you can successfully build the package:\nnix-build -A hello The output will be a result symlink pointing to the built package in the Nix store. You can then run the \u0026ldquo;hello\u0026rdquo; program:\n./result/bin/hello Hello, world! Swaytools Package Definition Example: The swaytools Package Definition\nLet\u0026rsquo;s examine a more complex, real-world package definition from Nixpkgs: nixpkgs/pkgs/tools/wayland/swaytools/default.nix.\n# default.nix { lib, setuptools, buildPythonApplication, fetchFromGitHub, slurp, }: buildPythonApplication rec { pname = \u0026#34;swaytools\u0026#34;; version = \u0026#34;0.1.2\u0026#34;; format = \u0026#34;pyproject\u0026#34;; src = fetchFromGitHub { owner = \u0026#34;tmccombs\u0026#34;; repo = \u0026#34;swaytools\u0026#34;; rev = version; sha256 = \u0026#34;sha256-UoWK53B1DNmKwNLFwJW1ZEm9dwMOvQeO03+RoMl6M0Q=\u0026#34;; }; nativeBuildInputs = [ setuptools ]; propagatedBuildInputs = [ slurp ]; meta = with lib; { homepage = \u0026#34;https://github.com/tmccombs/swaytools\u0026#34;; description = \u0026#34;Collection of simple tools for sway (and i3)\u0026#34;; license = licenses.gpl3Only; maintainers = with maintainers; [ atila ]; platforms = platforms.linux; }; } Breakdown of the Above default.nix 1 Function Structure:\nThe file starts with a function taking an attribute set of dependencies from Nixpkgs: { lib, setuptools, buildPythonApplication, fetchFromGitHub, slurp } :. Derivation Creation: It calls buildPythonApplication, a specialized helper for Python packages (similar to stdenv.mkDerivation but pre-configured for Python). The rec keyword allows attributes within the derivation to refer to each other. Package Metadata: pname and version define the package\u0026rsquo;s name and version.\nThe meta attribute provides standard package information like the homepage, description, license, maintainers, and supported platforms.\nSource Specification: The src attribute uses fetchFromGitHub to download the source code from the specified repository and revision, along with its sha256 hash for verification. Build and Runtime Dependencies: nativeBuildInputs: Lists tools required during the build process (e.g., setuptools for Python).\npropagatedBuildInputs: Lists dependencies needed at runtime (e.g., slurp).\nBuild Format: format = \u0026quot;pyproject\u0026quot;; indicates that the package uses a pyproject.toml file for its Python build configuration. Integration within Nixpkgs\nLocation: The swaytools definition resides in pkgs/tools/wayland/swaytools/default.nix.\nTop-Level Inclusion: It\u0026rsquo;s made available as a top-level package in pkgs/top-level/all-packages.nix like this:\n# all-packages.nix swaytools = python3Packages.callPackage ../tools/wayland/swaytools { }; python3Packages.callPackage is used here because swaytools is a Python package, and it ensures the necessary Python-related dependencies are correctly passed to the swaytools definition. Resources Packaging Existing Software ","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/understanding_package_definitions/"},{"id":18,"title":"Nix_repl_tips","summary":"Nix Repl List available commands List available commands with :?:\nnix repl Nix 2.24.11 Type :? for help. nix-repl\u0026gt; :? The following commands are available: \u0026lt;expr\u0026gt; Evaluate and print expression \u0026lt;x\u0026gt; = \u0026lt;expr\u0026gt; Bind expression to variable :a, :add \u0026lt;expr\u0026gt; Add attributes from resulting set to scope :b \u0026lt;expr\u0026gt; Build a derivation :bl \u0026lt;expr\u0026gt; Build a derivation, creating GC roots in the working directory :e, :edit \u0026lt;expr\u0026gt; Open package or function in $EDITOR :i \u0026lt;expr\u0026gt; Build derivation, then install result into current profile :l, :load \u0026lt;path\u0026gt; Load Nix expression and add it to scope :lf, :load-flake \u0026lt;ref\u0026gt; Load Nix flake and add it to scope :p, :print \u0026lt;expr\u0026gt; Evaluate and print expression recursively Strings are printed directly, without escaping. :q, :quit Exit nix-repl :r, :reload Reload all files :sh \u0026lt;expr\u0026gt; Build dependencies of derivation, then start nix-shell :t \u0026lt;expr\u0026gt; Describe result of evaluation :u \u0026lt;expr\u0026gt; Build derivation, then start nix-shell :doc \u0026lt;expr\u0026gt; Show documentation of a builtin function :log \u0026lt;expr\u0026gt; Show logs for a derivation :te, :trace-enable [bool] Enable, disable or toggle showing traces for errors :?, :help Brings up this help menu Load Nix expressions Directly You can quickly evaluate a random Nix expression:\n","content":"Nix Repl List available commands List available commands with :?:\nnix repl Nix 2.24.11 Type :? for help. nix-repl\u0026gt; :? The following commands are available: \u0026lt;expr\u0026gt; Evaluate and print expression \u0026lt;x\u0026gt; = \u0026lt;expr\u0026gt; Bind expression to variable :a, :add \u0026lt;expr\u0026gt; Add attributes from resulting set to scope :b \u0026lt;expr\u0026gt; Build a derivation :bl \u0026lt;expr\u0026gt; Build a derivation, creating GC roots in the working directory :e, :edit \u0026lt;expr\u0026gt; Open package or function in $EDITOR :i \u0026lt;expr\u0026gt; Build derivation, then install result into current profile :l, :load \u0026lt;path\u0026gt; Load Nix expression and add it to scope :lf, :load-flake \u0026lt;ref\u0026gt; Load Nix flake and add it to scope :p, :print \u0026lt;expr\u0026gt; Evaluate and print expression recursively Strings are printed directly, without escaping. :q, :quit Exit nix-repl :r, :reload Reload all files :sh \u0026lt;expr\u0026gt; Build dependencies of derivation, then start nix-shell :t \u0026lt;expr\u0026gt; Describe result of evaluation :u \u0026lt;expr\u0026gt; Build derivation, then start nix-shell :doc \u0026lt;expr\u0026gt; Show documentation of a builtin function :log \u0026lt;expr\u0026gt; Show logs for a derivation :te, :trace-enable [bool] Enable, disable or toggle showing traces for errors :?, :help Brings up this help menu Load Nix expressions Directly You can quickly evaluate a random Nix expression:\nnix repl --expr \u0026#39;{a = { b = 3; c = 4; }; }\u0026#39; Welcome to Nix 2.11.0. Type :? for help. Loading installable \u0026#39;\u0026#39;... Added 1 variables. nix-repl\u0026gt; a { b = 3; c = 4; } The --expr flag is helpful to prime directly the Nix REPL with valuable data or values. Load Flakes We can use the --expr flag to load a random Nix Flake directly:\nnix repl --expr \u0026#39;builtins.getFlake \u0026#34;github:nix-community/ethereum.nix\u0026#34;\u0026#39; Also, you can load a flake directly inside the REPL with :load-flake or :lf:\nnix repl nix-repl\u0026gt; :lf github:nix-community/home-manager # or nix-repl\u0026gt; :lf /path/to/your/flake Debugging with a Flake REPL output One way to do this is to launch the repl with nix repl and inside the repl type :lf /path/to/flake. Or nixos-rebuild repl --flake /path/to/flake the latter provides a helpful welcome script showing what is loaded into your repl\u0026rsquo;s scope. I like to create a simple repl output to load your flake into the environment with nix repl .#repl.\nFirst, we\u0026rsquo;ll create a REPL environment to inspect and debug our flake\u0026rsquo;s outputs,packages, and configurations. Define a repl output in flake.nix for easy access with nix repl .#repl:\n# flake.nix outputs = { self, nixpkgs, ... }: let pkgs = import nixpkgs { system = \u0026#34;x86_64-linux\u0026#34;; }; in { repl = import ./repl.nix { inherit (pkgs) lib; flake = self; pkgs = pkgs; }; }; And in repl.nix:\n# repl.nix { lib, flake, pkgs, }: { inherit flake pkgs lib; configs = flake.nixosConfigurations; # inherit (flake.outputs) userVars; } # Accepts `lib`, `flake`, `pkgs` from `flake.nix` as arguments # Attributes: flake: all flake outputs (flake.outputs, flake.inputs) # run `nix repl .#repl` to load the REPL environment # :l \u0026lt;nixpkgs\u0026gt; # load additional Nixpkgs if needed # :p flake.inputs.nixpkgs.rev # nixpkgs revision # :p flake.inputs.home-manager.rev # flake.outputs.packages.x86_64-linux.default # inspect default package # pkgs.helix # access helix package # lib.version # check lib version # configs.magic.config.environment.systemPackages # list packages # configs.magic.config.home-manager.users.jr.home.packages # home packages # :p configs.magic.config.home-manager.users.jr.programs.git.userName # Debugging # :p builtins.typeOf configs.magic (should be `set`) # :p builtins.attrNames configs.magic # :p configs.magic.config # errors indicate issues # :p configs.magic.config.environment # isolate the module or issue # :p builtins.attrNames configs.magic.config.home-manager.users.jr # home attrs # :p configs.magic.config.home-manager.users.jr.programs.git.enable # true/false # :p lib.filterAttrs (n: v: lib.hasPrefix \u0026#34;firefox\u0026#34; n) pkgs # :p configs.magic.config.stylix # check theming # :p configs.magic.config.home-manager.users.jr.stylix # :p lib.mapAttrsToList (name: cfg: name) configs ❗: Replace magic with your host name\nUsage Load REPL environment with: nix repl .#repl\nAttributes:\nnix-repl\u0026gt; builtins.attrNames flake.inputs [ \u0026#34;dont-track-me\u0026#34; \u0026#34;helix\u0026#34; \u0026#34;home-manager\u0026#34; \u0026#34;hyprland\u0026#34; \u0026#34;neovim-nightly-overlay\u0026#34; \u0026#34;nixpkgs\u0026#34; \u0026#34;nvf\u0026#34; \u0026#34;rose-pine-hyprcursor\u0026#34; \u0026#34;stylix\u0026#34; \u0026#34;treefmt-nix\u0026#34; \u0026#34;wallpapers\u0026#34; \u0026#34;wezterm\u0026#34; \u0026#34;yazi\u0026#34; ] nix-repl\u0026gt; builtins.attrNames flake.outputs [ \u0026#34;checks\u0026#34; \u0026#34;devShells\u0026#34; \u0026#34;formatter\u0026#34; \u0026#34;nixosConfigurations\u0026#34; \u0026#34;packages\u0026#34; \u0026#34;repl\u0026#34; ] nix-repl\u0026gt; flake.outputs.formatter { x86_64-linux = «derivation /nix/store/q71q00wmh1gnjzdrw5nrvwbr6k414036-treefmt.drv»; } Inspect the default package output: nix-repl\u0026gt; flake.outputs.packages.x86_64-linux.default «derivation /nix/store/6kp660mm62saryskpa1f2p6zwfalcx2w-default-tools.drv» From here out I\u0026rsquo;ll leave out the nix-repl\u0026gt; prefix just know that it\u0026rsquo;s there.\nCheck lib version(Nixpkgs lib attribute):\nlib.version \u0026#34;25.05pre-git\u0026#34; List systemPackages and home.packages, my hostname is magic list yours in its place: configs.magic.config.environment.systemPackages # list home.packages configs.magic.config.home-manager.users.jr.home.packages Or an individual value: :p configs.magic.config.home-manager.users.jr.programs.git.userName TSawyer87 Debugging Check if the module system is fully evaluating, anything other than a \u0026ldquo;set\u0026rdquo; the configuration isn\u0026rsquo;t fully evaluated (e.g. \u0026ldquo;lambda\u0026rdquo; might indicate an unevaluated thunk): :p builtins.typeOf configs.magic set Debugging Module System:\nCheck if configs.magic is a valid configuration:\n:p builtins.attrNames configs.magic ","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/nix_repl_tips/"},{"id":19,"title":"Understanding_nix_functions","summary":"Understanding Nix Functions Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.\nThe Single-Argument Nature of Nix Functions A key concept to understand is that in Nix, every function conceptually takes exactly one argument. What might appear as multi-argument functions are actually achieved through a technique called currying, where a series of nested single-argument functions are used.\n","content":"Understanding Nix Functions Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.\nThe Single-Argument Nature of Nix Functions A key concept to understand is that in Nix, every function conceptually takes exactly one argument. What might appear as multi-argument functions are actually achieved through a technique called currying, where a series of nested single-argument functions are used.\nIdentifying Function Structure The Colon The colon (:) acts as a clear separator within a function definition:\nLeft of the Colon: This is the function\u0026rsquo;s argument. It\u0026rsquo;s a placeholder name for a value that will be provided when the function is called. Right of the Colon: This is the function body. It\u0026rsquo;s the expression that will be evaluated when the function is invoked. Think of function arguments as naming values that aren\u0026rsquo;t known in advance. These names are placeholders that get filled with specific values when the function is used.\nExample:\ngreet = personName: \u0026#34;Hello, ${personName}!\u0026#34;; Here, personName is the argument (the placeholder).\n\u0026quot;Hello, ${personName}!\u0026quot;, is the function body (the expression that uses the placeholder).\nWhen you call the function:\ngreet \u0026#34;Anonymous\u0026#34; # Evaluates to \u0026#34;Hello, Anonymous!\u0026#34; The value \u0026quot;Anonymous\u0026quot; is substituted for the personName placeholder within the function body.\nFunction Declarations Single and \u0026ldquo;Multiple\u0026rdquo; Arguments Single-Argument Functions\nThe simplest form of a Nix function takes a single argument:\ninc = x: x + 1; inc 5 # Evaluates to 6 x is the argument.\nx + 1 is the function body.\nSimulating Multiple Arguments: Currying\nTo create functions that appear to take multiple arguments, Nix uses currying. This involves nesting single-argument functions, where each function takes one argument and returns another function that takes the next argument, and so on.\nconcat = x: y: x + y; concat 6 6 # Evaluates to 12 Nix interprets the colons as separators for this chain of single-argument functions.\nUnderstanding the Chain:\nConsider the greeting function:\ngreeting = prefix: name: \u0026#34;${prefix}, ${name}!\u0026#34;; This is effectively a chain:\nOuter Function: prefix: (name: \u0026quot;${prefix}, ${name}!\u0026quot;) Takes one argument: prefix.\nIts body is another function definition: name: \u0026quot;${prefix}, ${name}!\u0026quot;.\n2 Inner Function: name: \u0026quot;${prefix}, ${name}!\u0026quot;\nTakes one argument: name.\nIts body uses both its own argument (name) and the argument from the outer function\u0026rsquo;s scope (prefix).\nStep-by-Step Evaluation:\nWhen you call greeting \u0026quot;Hello\u0026quot; \u0026quot;Alice\u0026quot;:\ngreeting \u0026quot;Hello\u0026quot;: The greeting function is called with \u0026quot;Hello\u0026quot; as the prefix.\nThe outer function returns the inner function: name: \u0026quot;Hello, ${name}!\u0026quot; (where prefix is now fixed as `\u0026ldquo;Hello\u0026rdquo;`` in its scope).\n(greeting \u0026quot;Hello\u0026quot;) \u0026quot;Alice\u0026quot;: The resulting inner function is then called with \u0026quot;Alice\u0026quot; as the name.\nThe inner function evaluates its body: \u0026quot;Hello, ${\u0026quot;Alice\u0026quot;}!\u0026quot;, resulting in \u0026quot;Hello, Alice!\u0026quot;.\nKey Insight: Every colon in a function definition separates a single argument from its function body, even if that body is another function definition.\nPartial Application: Using Functions Incrementally\nBecause of currying, you can apply arguments to a Nix function one at a time. This is called partial application. When you provide only some of the expected arguments, you get a new function that \u0026ldquo;remembers\u0026rdquo; the provided arguments and waits for the rest.\nExample:\nUsing our greeting function again:\ngreeting = prefix: name: \u0026#34;${prefix}, ${name}!\u0026#34;; If we only provide the prefix:\nhelloGreeting = greeting \u0026#34;Hello\u0026#34;; helloGreeting is now a new function. It has already received the prefix argument (\u0026quot;Hello\u0026quot;) and is waiting for the name argument. Calling helloGreeting:\nhelloGreeting \u0026#34;Sally\u0026#34; # Evaluates to \u0026#34;Hello, Sally!\u0026#34; Benefits of Partial Application:\nCreating Specialized Functions: You can create more specific functions from general ones by fixing some of their parameters.\nAdapting to Higher-Order Functions: Many functions that operate on other functions (like map and filter) expect functions with a certain number of arguments. Partial application allows you to adapt existing functions to fit these requirements.\nThe Function Nature of NixOS and Home Manager Modules It\u0026rsquo;s crucial to understand that most NixOS and Home Manager modules are fundamentally functions.\nThese module functions typically accept a single argument: an attribute set. Example:\nA simplified Nginx service module:\n{ config, lib, pkgs, ... }: { services.nginx.enable = true; services.nginx.package = pkgs.nginx; services.nginx.settings.\u0026#34;http-port\u0026#34; = \u0026#34;8080\u0026#34;; } The entire module definition is a function that takes one argument: { config, lib, pkgs, ... }.\nWhen this module is included in your configuration, the NixOS module system calls this function with a specific attribute set. This attribute set contains the current system configuration (config), the Nix standard library (lib), the available packages (pkgs), and other relevant information. The module then uses these values to define parts of your system.\nResources nix.dev Nix Lang Basics\nnix pills Functions and Imports\nzero-to-nix Nix Lang\nA tour of Nix \u0026ldquo;Functions\u0026rdquo;\nlearn Nix in y minutes\nnoogle function library\n","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/understanding_nix_functions/"},{"id":20,"title":"Intro_to_jujutsu","summary":"Intro to Jujutsu (Using jj in an existing Git Repo) You can use jujutsu (jj) with existing Git repositories with one command. jj git init --colocate or jj git init --git-repo /path/to/git_repository. The native repository format for jj is still a work in progress so people typically use a git repository for backend.\nUnlike git, jj has no index \u0026ldquo;staging area\u0026rdquo;. It treats the working copy as an actual commit. When you make changes to files, these changes are automatically recorded to the working commit. There\u0026rsquo;s no need to explicitly stage changes because they are already part of the commit that represents your current working state.\n","content":"Intro to Jujutsu (Using jj in an existing Git Repo) You can use jujutsu (jj) with existing Git repositories with one command. jj git init --colocate or jj git init --git-repo /path/to/git_repository. The native repository format for jj is still a work in progress so people typically use a git repository for backend.\nUnlike git, jj has no index \u0026ldquo;staging area\u0026rdquo;. It treats the working copy as an actual commit. When you make changes to files, these changes are automatically recorded to the working commit. There\u0026rsquo;s no need to explicitly stage changes because they are already part of the commit that represents your current working state.\nThis means that you don\u0026rsquo;t need to worry about making a change, running git add ., running git commit -m \u0026quot;commit message\u0026quot; because it\u0026rsquo;s already done for you. This is handy with flakes by preventing a \u0026ldquo;dirty working tree\u0026rdquo; and can instantly be rebuilt after making a change. Here\u0026rsquo;s an example Say I have my configuration flake in the ~/flakes/ directory that is an existing Git repository. To use JJ as the front-end I could do something like:\ncd ~/flakes jj git init --colocate jj describe -m \u0026#34;first jj commit\u0026#34; jj commit Or to do this in a directory that isn\u0026rsquo;t already a git repo you can do something like:\ncargo new hello-world --vcs=none cd hello-world jj git init Initialized repo in \u0026#34;.\u0026#34; JJ and Git Side by Side Or for example, with Git if you wanted to move to a different branch before running nix flake update to see if it introduced errors before merging with your main branch, you could do something like:\ngit checkout -b update-test nix flake update sudo nixos-rebuild test --flake . If you\u0026rsquo;re satisfied you can merge:\ngit checkout main git add . # Stage the change git commit -m \u0026#34;update\u0026#34; git branch -D update-test git merge update-test sudo nixos-rebuild switch --flake . With JJ a similar workflow could be:\njj new # Create a new child commit/start working on a new change nix flake update sudo nixos-rebuild test --flake . jj squash # equivalent to `git commit -a --amend` jj describe -m \u0026#34;update\u0026#34; # Similar to git commit -m jj commit # Only needed if finalizing an explicit commit sudo nixos-rebuild switch --flake . With jj you\u0026rsquo;re creating a new commit rather than a new branch.\nAmending vs. Squashing: Git\u0026rsquo;s git commit --amend updates the last commit. jj squash combines the current commit with its parent, effectively doing the same thing in terms of history.\nMerging: Git\u0026rsquo;s merge command is explicit. In jj, the concept is similar, but since there\u0026rsquo;s no branch, you\u0026rsquo;re \u0026ldquo;merging\u0026rdquo; by moving your working commit to include these changes. The jj squash here acts like merging the changes into the main line of development.\nNo need to delete branches: Since there are no branches in jj, there\u0026rsquo;s no equivalent to git branch -D to clean up. Instead commits that are no longer needed can be \u0026ldquo;abandoned\u0026rdquo; with jj abandon if you want to clean up your commit graph.\njj describe without a flag just opens $EDITOR where you can write your commit message save and exit.\nIn git, we finish a set of changes to our code by committing, but in jj we start new work by creating a change, and then make changes to our code. It\u0026rsquo;s more useful to write an initial description of your intended changes, and then refine it as you work, than it is creating a commit message after the fact.\nI have heard that jj can struggle with big repositories such as Nixpkgs and have noticed some issues here and there when using with NixOS. I\u0026rsquo;m hoping that as the project matures,it gets better on this front.\nThis is just the start of what is possible, here are some resources about it if you\u0026rsquo;re interested:\nResources jj_github\nofficial_tutorial\njj_init # very good article\nsteves_jj_tutorial\n","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/intro_to_jujutsu/"},{"id":21,"title":"Nix_modules_explained","summary":"NixOS Modules TL;DR: In this post I break down the NixOS module system and explain how to define options. As well as how to test modules with the repl.\nMost modules are functions that take an attribute set and return an attribute set. Refresher:\nAn attribute set is a collection of name-value pairs wrapped in curly braces: { string = \u0026#34;hello\u0026#34;; int = 3; } A function with an attribute set argument: { a, b }: a + b The simplest possible NixOS Module: { ... }: { } NixOS produces a full system configuration by combining smaller, more isolated and reusable components: Modules. In my opinion modules are one of the first things you should understand when learning about NixOS.\n","content":"NixOS Modules TL;DR: In this post I break down the NixOS module system and explain how to define options. As well as how to test modules with the repl.\nMost modules are functions that take an attribute set and return an attribute set. Refresher:\nAn attribute set is a collection of name-value pairs wrapped in curly braces: { string = \u0026#34;hello\u0026#34;; int = 3; } A function with an attribute set argument: { a, b }: a + b The simplest possible NixOS Module: { ... }: { } NixOS produces a full system configuration by combining smaller, more isolated and reusable components: Modules. In my opinion modules are one of the first things you should understand when learning about NixOS.\nA NixOS module defines configuration options and behaviors for system components, allowing users to extend, customize, and compose configurations declaratively.\nA module is a file containing a Nix expression with a specific structure. It declares options for other modules to define (give a value). Modules were introduced to allow extending NixOS without modifying its source code.\nTo define any values, the module system first has to know which ones are allowed. This is done by declaring options that specify which attributes can be set and used elsewhere.\nIf you want to write your own modules, I recommend setting up nixd or nil with your editor of choice. This will allow your editor to warn you about missing arguments and dependencies as well as syntax errors.\nDeclaring Options The following is nixpkgs/nixos/modules/programs/vim.nix:\n{ config, lib, pkgs, ... }: let cfg = config.programs.vim; in { options.programs.vim = { enable = lib.mkEnableOption \u0026#34;Vi IMproved, an advanced text\u0026#34;; defaultEditor = lib.mkEnableOption \u0026#34;vim as the default editor\u0026#34;; package = lib.mkPackageOption pkgs \u0026#34;vim\u0026#34; { example = \u0026#34;vim-full\u0026#34;; }; }; # TODO: convert it into assert after 24.11 release config = lib.mkIf (cfg.enable || cfg.defaultEditor) { warnings = lib.mkIf (cfg.defaultEditor \u0026amp;\u0026amp; !cfg.enable) [ \u0026#34;programs.vim.defaultEditor will only work if programs.vim.enable is enabled, which will be enforced after the 24.11 release\u0026#34; ]; environment = { systemPackages = [ cfg.package ]; variables.EDITOR = lib.mkIf cfg.defaultEditor (lib.mkOverride 900 \u0026#34;vim\u0026#34;); pathsToLink = [ \u0026#34;/share/vim-plugins\u0026#34; ]; }; }; } It provides options to enable Vim, set it as the default editor, and specify the Vim package to use. Module Inputs and Structure: { config, lib, pkgs, ... } Inputs: The module takes the above inputs and ... (catch-all for other args)\nconfig: Allows the module to read option values (e.g. config.programs.vim.enable). It provides access to the evaluated configuration.\nlib: The Nixpkgs library, giving us helper functions like mkEnableOption , mkIf, and mkOverride.\npkgs: The Nixpkgs package set, used to access packages like pkgs.vim\n...: Allows the module to accept additional arguments, making it flexible for extension in the future.\nKey Takeaways: A NixOS module is typically a function that can include config, lib, and pkgs, but it doesn’t require them. The ... argument ensures flexibility, allowing a module to accept extra inputs without breaking future compatibility. Using lib simplifies handling options (mkEnableOption, mkIf, mkOverride) and helps follow best practices. Modules define options, which users can set in their configuration, and config, which applies changes based on those options.\nLocal Configuration Reference: let cfg = config.programs.vim; in This is a local alias. Instead of typing config.programs.vim over and over, the module uses cfg. Option Declaration options.programs.vim = { enable = lib.mkEnableOption \u0026#34;Vi IMproved, an advanced text\u0026#34;; defaultEditor = lib.mkEnableOption \u0026#34;vim as the default editor\u0026#34;; package = lib.mkPackageOption pkgs \u0026#34;vim\u0026#34; { example = \u0026#34;vim-full\u0026#34;; }; }; This defines three user-configurable options:\nenable: Turns on Vim support system-wide.\ndefaultEditor: Sets Vim as the system\u0026rsquo;s default $EDITOR.\npackage: lets the user override which Vim package is used.\nmkPackageOption is a helper that defines a package-typed option with a default (pkgs.vim) and provides docs + example.\nConditional Configuration config = lib.mkIf (cfg.enable || cfg.defaultEditor) { This block is only activated if either programs.vim.enable or defaultEditor is set. Warnings warnings = lib.mkIf (cfg.defaultEditor \u0026amp;\u0026amp; !cfg.enable) [ \u0026#34;programs.vim.defaultEditor will only work if programs.vim.enable is enabled, which will be enforced after the 24.11 release\u0026#34; ]; Gives you a soft warning if you try to set defaultEditor = true without also enabling Vim. Actual System Config Changes environment = { systemPackages = [ cfg.package ]; variables.EDITOR = lib.mkIf cfg.defaultEditor (lib.mkOverride 900 \u0026#34;vim\u0026#34;); pathsToLink = [ \u0026#34;/share/vim-plugins\u0026#34; ]; }; It adds Vim to your systemPackages, sets $EDITOR if defaultEditor is true, and makes /share/vim-plugins available in the environment. The following is a bat home-manager module that I wrote:\n# bat.nix { pkgs, config, lib, ... }: let cfg = config.custom.batModule; in { options.custom.batModule.enable = lib.mkOption { type = lib.types.bool; default = false; description = \u0026#34;Enable bat module\u0026#34;; }; config = lib.mkIf cfg.enable { programs.bat = { enable = true; themes = { dracula = { src = pkgs.fetchFromGitHub { owner = \u0026#34;dracula\u0026#34;; repo = \u0026#34;sublime\u0026#34;; # Bat uses sublime syntax for its themes rev = \u0026#34;26c57ec282abcaa76e57e055f38432bd827ac34e\u0026#34;; sha256 = \u0026#34;019hfl4zbn4vm4154hh3bwk6hm7bdxbr1hdww83nabxwjn99ndhv\u0026#34;; }; file = \u0026#34;Dracula.tmTheme\u0026#34;; }; }; extraPackages = with pkgs.bat-extras; [ batdiff batman prettybat batgrep ]; }; }; } Now I could add this to my home.nix to enable it:\n# home.nix custom = { batModule.enable = true; } If I set this option to true the bat configuration is dropped in place. If it\u0026rsquo;s not set to true, it won\u0026rsquo;t put the bat configuration in the system. Same as with options defined in modules within the Nixpkgs repository.\nIf I had set the default to true, it would automatically enable the module without requiring an explicit custom.batModule.enable = true; call in my home.nix.\nModule Composition NixOS achieves its full system configuration by combining the configurations defined in various modules. This composition is primarily handled through the imports mechanism.\nimports: This is a standard option within a NixOS or Home Manager configuration (often found in your configuration.nix or home.nix). It takes a list of paths to other Nix modules. When you include a module in the imports list, the options and configurations defined in that module become part of your overall system configuration.\nYou declaratively state the desired state of your system by setting options across various modules. The NixOS build system then evaluates and merges these option settings. The culmination of this process, which includes building the entire system closure, is represented by the derivation built by config.system.build.toplevel.\nNixOS Modules and Dependency Locking with npins This is the file structure:\n❯ tree . ├── configuration.nix ├── default.nix ├── desktop.nix └── npins ├── default.nix └── sources.json This uses npins for dependency locking. Install it and run this in the project\ndirectory:\nnpins init Create a default.nix with the following:\n# default.nix { system ? builtins.currentSystem, sources ? import ./npins, }: let pkgs = import sources.nixpkgs { config = { }; overlays = [ ]; }; inherit (pkgs) lib; in lib.makeScope pkgs.newScope (self: { shell = pkgs.mkShell { packages = [ pkgs.npins self.myPackage ]; }; # inherit lib; nixosSystem = import (sources.nixpkgs + \u0026#34;/nixos\u0026#34;) { configuration = ./configuration.nix; }; moduleEvale = lib.evalModules { modules = [ # ... ]; }; }) A configuration.nix with the following:\n# configuration.nix { boot.loader.grub.device = \u0026#34;nodev\u0026#34;; fileSystems.\u0026#34;/\u0026#34;.device = \u0026#34;/devst\u0026#34;; system.stateVersion = \u0026#34;25.05\u0026#34;; # declaring options means to declare a new option # defining options means to define a value of an option imports = [ # ./main.nix ./desktop.nix # Files # ./minimal.nix ]; # mine.desktop.enable = true; } And a desktop.nix with the following:\n# desktop.nix { pkgs, lib, config, ... }: { imports = []; # Define an option to enable or disable desktop configuration options.mine.desktop.enable = lib.mkEnableOption \u0026#34;desktop settings\u0026#34;; # Configuration that applies when the option is enabled config = lib.mkIf config.mine.desktop.enable { environment.systemPackages = [ pkgs.git ]; }; } mkEnableOption defaults to false. Now in your configuration.nix you can uncomment mine.desktop.enable = true; to enable the desktop config and vice-versa.\nYou can test that this works by running:\nnix-instantiate -A nixosSystem.system nix-instantiate performs only the evaluation phase of Nix expressions. During this phase, Nix interprets the Nix code, resolves all dependencies, and constructs derivations but does not execute any build actions. Useful for testing. To check if this worked and git is installed in systemPackages you can load it into nix repl but first you\u0026rsquo;ll want lib to be available so uncomment this in your default.nix:\n# default.nix inherit lib; Rerun nix-instantiate -A nixosSystem.system\nThen load the repl and check that git is in systemPackages:\nnix repl -f . nix-repl\u0026gt; builtins.filter (pkg: lib.hasPrefix \u0026#34;git\u0026#34; pkg.name) nixosSystem.config.environment.systemPackages This shows the path to the derivation\nCheck that mine.desktop.enable is true\nnix-repl\u0026gt; nixosSystem.config.mine.desktop.enable true Resources on Modules WritingNixOsModules\nNixWikiNixOSModules\nnix.dev A basic module\nModuleSystemDeepDive\nMakingNixOSModulesForFun\nxeiaso Nixos Modules for fun \u0026amp; profit\nNixOS Flakes Book Module System\nVideos NixHour Writing NixOS modules \u0026ndash; This example is from this video infinisilModules\ntweagModuleSystemRecursion ","tags":[],"date":"2025-05-14","permalink":"https://saylesss88.github.io/posts/nix_modules_explained/"},{"id":22,"title":"Search","summary":"Search Here you can search for indexable pages, like posts and alike. There\u0026rsquo;s also support for URL param \u0026ldquo;q\u0026rdquo; which then auto searches upon page load event.\nIt\u0026#39;s necessary to enable Javascript\nLoading...\n","content":"Search Here you can search for indexable pages, like posts and alike. There\u0026rsquo;s also support for URL param \u0026ldquo;q\u0026rdquo; which then auto searches upon page load event.\nIt\u0026#39;s necessary to enable Javascript\nLoading...\n","tags":[],"date":"2025-03-24","permalink":"https://saylesss88.github.io/search/"},{"id":23,"title":"Categories","summary":"","content":"","tags":[],"date":"0001-01-01","permalink":"https://saylesss88.github.io/categories/"},{"id":24,"title":"Tags","summary":"","content":"","tags":[],"date":"0001-01-01","permalink":"https://saylesss88.github.io/tags/"}]