<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Intro to Nix Derivations - nix-book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <a href="#" class="top-link" id="back-to-top">↑</a>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">nix-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-7"><a class="header" href="#chapter-7">Chapter 7</a></h1>
<details>
<summary> ✔️ Click to Expand Table of Contents</summary>
<ul>
<li><a href="#introduction-to-nix-derivations">Introduction to Nix Derivations</a></li>
<li><a href="#creating-derivations-in-nix">Creating Derivations in Nix</a></li>
<li><a href="#the-hello-world-derivation">The Hello World Derivation</a></li>
<li><a href="#simple-rust-derivation">Simple Rust Derivation</a></li>
<li><a href="#when-derivations-are-built">When Derivations are Built</a></li>
<li><a href="#referring-to-other-derivations">Referring to other derivations</a></li>
<li><a href="#produce-a-development-shell-from-a-derivation">Produce a development shell from a derivation</a></li>
<li><a href="#our-second-derivation-understanding-the-builder">Our Second Derivation: Understanding the Builder</a>
<ul>
<li><a href="#why-a-builder-script">Why a Builder Script?</a></li>
<li><a href="#the-challenge-with-shebangs-in-nix">The Challenge with Shebangs in Nix</a></li>
<li><a href="#the-importance-of-statelessness-in-nix">The Importance of Statelessness in Nix</a></li>
<li><a href="#the-isolated-nix-build-environment-a-quick-overview">The Isolated Nix Build Environment: A Quick Overview</a></li>
</ul>
</li>
<li><a href="#our-builder-script">Our builder Script</a></li>
<li><a href="#our-last-derivation">Our Last Derivation</a></li>
<li><a href="#best-practices">Best Practices</a>
<ul>
<li><a href="#conclusion">Conclusion</a>
<ul>
<li><a href="#links-to-articles-about-derivations">Links To Articles about Derivations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</details>
<h2 id="introduction-to-nix-derivations"><a class="header" href="#introduction-to-nix-derivations">Introduction to Nix Derivations</a></h2>
<!-- ![gruv10](images/gruv10.png) -->
<p>Nix's build instructions, known as <strong>derivations</strong>, are defined using the Nix
Language. These derivations can describe anything from individual software
packages to complete system configurations. The Nix package manager then
deterministically "realizes" (builds) these derivations, ensuring consistency
because they rely solely on a predefined set of inputs.</p>
<p>Most things in NixOS are built around derivations. Your NixOS system is
described by such a single system derivation. When you want to apply a new
configuration, <code>nixos-rebuild</code> handles the process:</p>
<p>It first builds this derivation:</p>
<pre><code class="language-bash">nix-build '&lt;nixpkgs/nixos&gt;' -A system
</code></pre>
<p>Then, once the build is complete, it switches to that new system:</p>
<pre><code class="language-bash">result/bin/switch-to-configuration
</code></pre>
<p>After the build, <code>nixos-rebuild</code> updates a crucial symbolic link:
<code>/run/current-system</code> This symlink always points to the active, running version
of your system in the Nix store. In essence, the <code>/run/current-system</code> path is
the currently active system derivation. This design choice gives NixOS its
powerful atomic upgrade and rollback capabilities: changing your system involves
building a new system derivation and updating this symlink to point to the
latest version.</p>
<blockquote>
<pre><code class="language-nix"> ls -lsah /run/current-system
 0 lrwxrwxrwx 1 root root 85 May 23 12:11 /run/current-system -&gt; /nix/store/
 cy2c0kxpjrl7ajlg9v3zh898mhj4dyjv-nixos-system-magic-25.11.20250520.2795c50
</code></pre>
</blockquote>
<ul>
<li>
<p>The <code>-&gt;</code> indicates a symlink and it's pointing to a <strong>store path</strong> which is
the result of a derivation being built (the system closure)</p>
</li>
<li>
<p>For beginners, the analogy of a cooking recipe is helpful:</p>
<ul>
<li>
<p><strong>Ingredients (Dependencies):</strong> What other software or libraries are needed.</p>
</li>
<li>
<p><strong>Steps (Build Instructions):</strong> The commands to compile, configure, and
install.</p>
</li>
<li>
<p><strong>Final Dish (Output):</strong> The resulting package or resource.</p>
</li>
</ul>
</li>
</ul>
<p>A Nix derivation encapsulates all this information, telling Nix what inputs to
use, how to build it, and what the final output should be.</p>
<p>Nix derivations run in <strong>pure</strong>, <strong>isolated environments</strong>, meaning they
<strong>cannot</strong> access the internet during the build phase. This ensures that builds
are reproducible -- they don't depend on external sources that might change over
time.</p>
<p>There are <code>Fixed-output-derivations</code> that allow fetching resources during the
build process by explicitly specifying the expected hash upfront. Just keep this
in mind that normal derivations don't have network access.</p>
<h2 id="creating-derivations-in-nix"><a class="header" href="#creating-derivations-in-nix">Creating Derivations in Nix</a></h2>
<p>The primary way to define packages in Nix is through the <code>mkDerivation</code>
function, which is part of the standard environment (<code>stdenv</code>). While a
lower-level <code>derivation</code> function exists for advanced use cases, <code>mkDerivation</code>
simplifies the process by automatically managing dependencies and the build
environment.</p>
<p><code>mkDerivation</code> (and <code>derivation</code>) takes a set of attributes as its argument. At
a minimum, you'll often encounter these essential attributes:</p>
<ol>
<li>
<p><strong>name:</strong> A human-readable identifier for the derivation (e.g., "foo",
"hello.txt"). This helps you and Nix refer to the package.</p>
</li>
<li>
<p><strong>system:</strong> Specifies the target architecture for the build (e.g.,
<code>builtins.currentSystem</code> for your current machine).</p>
</li>
<li>
<p><strong>builder:</strong> Defines the program that will execute the build instructions
(e.g., <code>bash</code>).</p>
</li>
</ol>
<p><strong>How do we pass these required attributes to the <code>derivation</code> function?</strong></p>
<p>Functions in Nix often take a single argument which is an attribute set. For
<code>derivation</code> and <code>mkDerivation</code>, this takes the form
<code>functionName { attribute1 = value1; attribute2 = value2; ... }</code>, where the <code>{}</code>
encloses the set of attributes being passed as the function's argument.</p>
<p>Remember that <code>derivation</code> and <code>mkDerivation</code> take a set (i.e. <code>{}</code>) of
attributes as its first argument. So, in order to pass the required attributes
you would do something like this:</p>
<pre><code class="language-nix">nix-repl&gt; pkgs = import &lt;nixpkgs&gt; {}

nix-repl&gt; d = derivation {
            name = "mydrv";
            builder = "${pkgs.bash}/bin/bash";
            args = [
              "-c" # Tells bash to execute the following string as a command
              ''
                # Explicitly set PATH to include coreutils bin directory
                export PATH="${pkgs.coreutils}/bin:$PATH"
                mkdir $out
              ''
            ];
            system = builtins.currentSystem;
          }

nix-repl&gt; :b d
</code></pre>
<ul>
<li>When I was starting out, seeing the above written in the following format made
it clearer in my mental map that we were passing these attributes as arguments
but both accomplish the same thing.</li>
</ul>
<pre><code class="language-nix">d = derivation { name = "myname"; builder = "${coreutils}/bin/true"; system = builtins.currentSystem; }
</code></pre>
<ul>
<li>When you write <code>pkgs = import &lt;nixpkgs&gt; {};</code>, you are importing the Nixpkgs
<code>default.nix</code> file, which resolves to a function. Calling that function by
passing it an empty attribute set <code>{}</code> as its argument. The function then
evaluates and returns the entire <code>pkgs</code> attribute set. To specify a different
system for example, you could do something like:</li>
</ul>
<pre><code class="language-nix">pkgsForAarch64 = import &lt;nixpkgs&gt; { system = "aarch64-linux"; };
</code></pre>
<p>So when you see:</p>
<pre><code class="language-nix">import &lt;nixpkgs&gt; { overlays = []; config = {}; }
</code></pre>
<ul>
<li>
<p>Instead, these empty sets explicitly override any global or implicit
overlays/configurations that Nix might otherwise pick up from environment
variables (like <code>NIXPKGS_CONFIG</code>), default locations (like
<code>~/.config/nixpkgs/config.nix</code> or <code>~/.config/nixpkgs/overlays</code>), or other
mechanisms.</p>
</li>
<li>
<p>This is to prevent accidental partial application from other parts of your
configuration and is saying "Do not pass any custom configuration options for
this particular import"</p>
</li>
<li>
<p><code>derivation</code> is a pre-made, built-in function in the Nix language. Here, we
are passing it an attribute set as argument with the three required
attributes. (<code>name</code>, <code>builder</code>, <code>system</code>, and we added an extra argument
<code>args</code>.)</p>
</li>
</ul>
<h2 id="the-hello-world-derivation"><a class="header" href="#the-hello-world-derivation">The Hello World Derivation</a></h2>
<p>For this example, first create a <code>hello</code> directory and add the
<a href="https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz">Hello tarball</a> to said
directory.</p>
<p>Now lets create the classic Hello derivation:</p>
<pre><code class="language-nix"># hello.nix
let
  pkgs = import &lt;nixpkgs&gt; { };
in
derivation {
  name = "hello";
  builder = "${pkgs.bash}/bin/bash";
  args = [ ./hello_builder.sh ];
  inherit (pkgs)
    gnutar
    gzip
    gnumake
    gcc
    coreutils
    gawk
    gnused
    gnugrep
    ;
  bintools = pkgs.binutils.bintools;
  src = ./hello-2.12.1.tar.gz;
  system = builtins.currentSystem;
}
</code></pre>
<ul>
<li>As you can see, this isn't the only required file but is a recipe outlining
how to build the <code>hello</code> package. The <code>tar.gz</code> package can be found
<a href="https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz">here</a> You would just place
the tarball in the same directory as the derivation along with the following
<code>hello_builder.sh</code>:</li>
</ul>
<pre><code class="language-bash"># hello_builder.sh
export PATH="$gnutar/bin:$gcc/bin:$gnumake/bin:$coreutils/bin:$gawk/bin:$gzip/bin:$gnugrep/bin:$gnused/bin:$bintools/bin"
tar -xzf $src
cd hello-2.12.1
./configure --prefix=$out
make
make install
</code></pre>
<p>And build it with:</p>
<pre><code class="language-bash">nix-build hello.nix
</code></pre>
<p>Finally execute it with:</p>
<pre><code class="language-bash">./result/bin/hello
Hello, world!
</code></pre>
<h2 id="simple-rust-derivation"><a class="header" href="#simple-rust-derivation">Simple Rust Derivation</a></h2>
<p>Create a <code>simple.rs</code> with the following contents:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  println!("Simple Rust!")
}</code></pre></pre>
<p>And a <code>rust_builder.sh</code> like this (this is our builder script):</p>
<pre><code class="language-bash"># rust_builder.sh
# Set up the PATH to include rustc coreutils and gcc
export PATH="$rustc/bin:$coreutils/bin:$gcc/bin"

# IMPORTANT: Create the $out directory BEFORE rustc tries to write to it
mkdir -p "$out"

# Compile the Rust source code and place the executable inside $out
rustc -o "$out/simple_rust" "$src"
</code></pre>
<p>Now we'll enter the <code>nix repl</code> and build it:</p>
<pre><code class="language-bash">❯ nix repl
Nix 2.28.3
Type :? for help.

nix-repl&gt; :l &lt;nixpkgs&gt;
added 3950 variables.

# Define the variables for rustc, coreutils, bash, AND gcc from the loaded nixpkgs
nix-repl&gt; rustc = pkgs.rustc

nix-repl&gt; coreutils = pkgs.coreutils

nix-repl&gt; bash = pkgs.bash

nix-repl&gt; gcc = pkgs.gcc

# Now define the derivation
nix-repl&gt; simple_rust_program = derivation {
            name = "simple-rust-program";
            builder = "${bash}/bin/bash";
            args = [ ./rust_builder.sh ];
            rustc = rustc;
            coreutils = coreutils;
            gcc = gcc;
            src = ./simple.rs;
            system = builtins.currentSystem;
          }

nix-repl&gt; :b simple_rust_program
This derivation produced the following outputs:
out -&gt; /nix/store/fmyqr2d3ph0lpnxd0xppwvwyhv3iyb7y-simple-rust-program
</code></pre>
<pre><code class="language-bash">nix-store -r /nix/store/fmyqr2d3ph0lpnxd0xppwvwyhv3iyb7y-simple-rust-program

warning: you did not specify '--add-root'; the result might be removed by the garbage collector
/nix/store/fmyqr2d3ph0lpnxd0xppwvwyhv3iyb7y-simple-rust-program
</code></pre>
<p>This simple Rust example, built with a direct derivation call, illustrates:</p>
<ul>
<li>
<p>How Nix explicitly manages every single tool in your build environment
(<code>bash</code>, <code>rustc</code>, <code>gcc</code>, <code>coreutils</code>).</p>
</li>
<li>
<p>The strict isolation of Nix builds, where nothing is implicitly available.</p>
</li>
<li>
<p>The deterministic mapping of inputs to unique output paths in the Nix store.</p>
</li>
<li>
<p>The above example shows the fundamental structure of a Nix derivation, how
it's defined within the <code>nix-repl</code>.</p>
</li>
<li>
<p><code>.drv</code> files are intermediate files that describe how to build a derivation;
it's the bare minimum information.</p>
</li>
</ul>
<h2 id="when-derivations-are-built"><a class="header" href="#when-derivations-are-built">When Derivations are Built</a></h2>
<p>Nix doesn't build derivations during the evaluation of your Nix expressions.
Instead, it processes your code in two main phases (and why you need to use
<code>:b simple_rust_program</code> or <code>nix-store -r</code> to actually build or realize it):</p>
<ol>
<li>
<p>Evaluation/Instantiate Phase: This is when Nix parses and interprets your
.nix expression. The result is a precise derivation description (often
represented as a .drv file on disk), and the unique "out paths" where the
final built products will go are calculated. No actual code is compiled or
executed yet. Achieved with <code>nix-instantiate</code></p>
</li>
<li>
<p>Realize/Build Phase: Only after a derivation has been fully described does
Nix actually execute its build instructions. It first ensures all the
derivation's inputs (dependencies) are built, then runs the builder script
in an isolated environment, and places the resulting products into their
designated "out paths" in the Nix store. Achieved with <code>nix-store -r</code></p>
</li>
</ol>
<h2 id="referring-to-other-derivations"><a class="header" href="#referring-to-other-derivations">Referring to other derivations</a></h2>
<p>The way that we can refer to other packages/derivations is to use the <code>outPath</code>.</p>
<p>The <code>outPath</code> describes the location of the files of that derivation. Nix can
then convert the derivation set into a string:</p>
<pre><code class="language-bash">nix repl
nix-repl&gt; :l &lt;nixpkgs&gt;
nix-repl&gt; fzf
«derivation /nix/store/vw1zag9q4xvf10z24j1qybji7wfsz78v-fzf-0.62.0.drv»
nix-repl&gt; fzf.outPath
"/nix/store/z3ayhjslz72ldiwrv3mn5n7rs96p2g8a-fzf-0.62.0"
nix-repl&gt; builtins.toString fzf
"/nix/store/z3ayhjslz72ldiwrv3mn5n7rs96p2g8a-fzf-0.62.0"
</code></pre>
<ul>
<li>As long as there is an <code>outPath</code> attribute, Nix will do the "set to string
conversion".</li>
</ul>
<h2 id="produce-a-development-shell-from-a-derivation"><a class="header" href="#produce-a-development-shell-from-a-derivation">Produce a development shell from a derivation</a></h2>
<p>Building on the concept of a derivation as a recipe, let's create our first
practical derivation. This example shows how to define a temporary development
environment (a shell) using stdenv.mkDerivation, which is the primary function
for defining packages in Nix.</p>
<pre><code class="language-nix"># my-shell.nix
# We use a `let` expression to bring `pkgs` and `stdenv` into scope.
# This is a recommended practice over `with import &lt;nixpkgs&gt; {}`
# for clarity and to avoid potential name collisions.
let
  pkgs = import &lt;nixpkgs&gt; {};
  stdenv = pkgs.stdenv; # Access stdenv from the imported nixpkgs
in

# Make a new "derivation" that represents our shell
stdenv.mkDerivation {
  name = "my-environment";

  # The packages in the `buildInputs` list will be added to the PATH in our shell
  buildInputs = [
    # cowsay is an arbitrary package
    # see https://nixos.org/nixos/packages.html to search for more
    pkgs.cowsay
    pkgs.fortune
  ];
}
</code></pre>
<p><strong>Usage</strong></p>
<pre><code class="language-bash">nix-shell my-shell.nix
fortune | cowsay
 _________________________________________
/ "Lines that are parallel meet at        \
| Infinity!" Euclid repeatedly, heatedly, |
| urged.                                  |
|                                         |
| Until he died, and so reached that      |
| vicinity: in it he found that the       |
| damned things diverged.                 |
|                                         |
\ -- Piet Hein                            /
 -----------------------------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
</code></pre>
<ul>
<li>To exit type: <code>exit</code></li>
</ul>
<p>This Nix expression defines a temporary development shell. Let's break it down:</p>
<ul>
<li>
<p><code>pkgs = import &lt;nixpkgs&gt; {};</code>: Standard way to get access to all the packages
and helper functions (i.e. <code>nixpkgs.lib</code>)</p>
</li>
<li>
<p><code>stdenv = pkgs.stdenv;</code>: <code>stdenv</code> provides us <code>mkDerivation</code> and is from the
<code>nixpkgs</code> collection.</p>
</li>
<li>
<p><code>stdenv.mkDerivation { ... };</code>: This is the core function for creating
packages.</p>
<ul>
<li><code>stdenv</code> provides a set of common build tools and conventions.</li>
</ul>
</li>
<li>
<p><code>mkDerivation</code> takes an attribute set (a collection of key-value pairs) as its
argument.</p>
</li>
<li>
<p><code>name = "my-environment";</code>: This gives your derivation a human-readable name.</p>
</li>
<li>
<p><code>buildInputs = [ pkgs.cowsay ];</code>: This is a list of dependencies that will be
available in the build environment of this derivation (or in the <code>PATH</code> if you
enter the shell created by this derivation). <code>pkgs.cowsay</code> refers to the
<code>cowsay</code> package from the imported <code>pkgs</code> collection.</p>
</li>
</ul>
<p>The command <code>nix-instantiate --eval my-shell.nix</code> evaluates the Nix expression
in the file. It does not build the derivation. Instead, it returns the Nix value
that the expression evaluates to.</p>
<pre><code class="language-bash">nix-instantiate --eval my-shell.nix
</code></pre>
<p>This value is a structured data type that encapsulates all the attributes (like
<code>name</code>, <code>system</code>, <code>buildInputs</code>, etc.) required to build the derivation. Your
output shows this detailed internal representation of the derivation's "recipe"
as understood by Nix. This is useful for debugging and inspecting the
derivation's definition.</p>
<h2 id="our-second-derivation-understanding-the-builder"><a class="header" href="#our-second-derivation-understanding-the-builder">Our Second Derivation: Understanding the Builder</a></h2>
<details>
<summary> Understanding the Builder (Click to Expand) </summary>
<ul>
<li>To understand how derivations work, let's create a very basic example using a
bash script as our <code>builder</code>.</li>
</ul>
<h3 id="why-a-builder-script"><a class="header" href="#why-a-builder-script">Why a Builder Script?</a></h3>
<ul>
<li>The <code>builder</code> attribute in a derivation tells Nix <em>how</em> to perform the build
steps. A simple and common way to define these steps is with a bash script.</li>
</ul>
<h3 id="the-challenge-with-shebangs-in-nix"><a class="header" href="#the-challenge-with-shebangs-in-nix">The Challenge with Shebangs in Nix</a></h3>
<ul>
<li>
<p>In typical Unix-like systems, you might start a bash script with a shebang
(<code>#!/bin/bash</code> or <code>#!/usr/bin/env bash</code>) to tell the system how to execute it.
However, in Nix derivations, we generally avoid this.</p>
</li>
<li>
<p><strong>Reason:</strong> Nix builds happen in an isolated environment where the exact path
to common tools like <code>bash</code> isn't known beforehand (it resides within the Nix
store). Hardcoding a path or relying on the system's <code>PATH</code> would break Nix's
stateless property.</p>
</li>
</ul>
<h3 id="the-importance-of-statelessness-in-nix"><a class="header" href="#the-importance-of-statelessness-in-nix">The Importance of Statelessness in Nix</a></h3>
<ul>
<li>
<p><strong>Stateful Systems (Traditional):</strong> When you install software traditionally,
it often modifies the core system environment directly. This can lead to
dependency conflicts and makes rollbacks difficult.</p>
</li>
<li>
<p><strong>Stateless Systems (Nix):</strong> Nix takes a different approach. When installing a
package, it creates a unique, immutable directory in the Nix store. This
means:</p>
<ul>
<li>
<p><strong>No Conflicts:</strong> Different versions of the same package can coexist without
interfering with each other.</p>
</li>
<li>
<p><strong>Reliable Rollback:</strong> You can easily switch back to previous versions
without affecting system-wide files.</p>
</li>
<li>
<p><strong>Reproducibility:</strong> Builds are more likely to produce the same result
across different machines if they are "pure" (don't rely on external system
state).</p>
</li>
</ul>
</li>
</ul>
<h3 id="the-isolated-nix-build-environment-a-quick-overview"><a class="header" href="#the-isolated-nix-build-environment-a-quick-overview">The Isolated Nix Build Environment: A Quick Overview</a></h3>
<p>When Nix executes a builder script, it sets up a highly controlled and pristine
environment to ensure <strong>reproducibility</strong> and <strong>isolation</strong>. Here's what
happens:</p>
<ol>
<li>
<p><strong>Fresh Start:</strong> Nix creates a temporary, empty directory for the build and
makes it the current working directory.</p>
</li>
<li>
<p><strong>Clean Environment:</strong> It completely clears the environment variables from
your shell.</p>
</li>
<li>
<p><strong>Controlled Inputs:</strong> Nix then populates the environment with <em>only</em> the
variables essential for the build, such as:</p>
<ul>
<li>
<p><code>$NIX_BUILD_TOP</code>: The path to the temporary build directory.</p>
</li>
<li>
<p><code>$PATH</code>: Carefully set to include only the explicit <code>buildInputs</code> you've
specified, preventing reliance on arbitrary system tools.</p>
</li>
<li>
<p><code>$HOME</code>: Set to <code>/homeless-shelter</code> to prevent programs from reading
user-specific configuration files.</p>
</li>
<li>
<p>Variables for each declared output (<code>$out</code>, etc.), indicating where the
final results should be placed in the Nix store.</p>
</li>
</ul>
</li>
<li>
<p><strong>Execution &amp; Logging:</strong> The builder script is run with its specified
arguments. All its output (stdout/stderr) is captured in a log.</p>
</li>
<li>
<p><strong>Clean Up &amp; Registration:</strong> If successful, the temporary directory is
removed. Nix then scans the build outputs for references to other store
paths, ensuring all dependencies are correctly tracked for future use and
garbage collection. Finally, it normalizes file permissions and timestamps
in the output for consistent hashing.</p>
</li>
</ol>
<p>This meticulous setup ensures that your builds are independent of the machine
they run on and always produce the same result, given the same inputs.</p>
<h2 id="our-builder-script"><a class="header" href="#our-builder-script">Our builder Script</a></h2>
<ul>
<li>For our first derivation, we'll create a simple <code>builder.sh</code> file in the
current directory:</li>
</ul>
<pre><code class="language-bash"># builder.sh
declare -xp
echo foo &gt; $out
</code></pre>
<ul>
<li>
<p>The command <code>declare -xp</code> lists exported variables (it's a bash builtin
function).</p>
</li>
<li>
<p>Nix needs to know where the final built product (the "cake" in our earlier
analogy) should be placed. So, during the derivation process, Nix calculates a
unique output path within the Nix store. This path is then made available to
our builder script as an environment variable named <code>$out</code>. The <code>.drv</code> file,
which is the recipe, contains instructions for the builder, including setting
up this <code>$out</code> variable. Our builder script will then put the result of its
work (in this case, the "foo" file) into this specific <code>$out</code> directory.</p>
</li>
<li>
<p>As mentioned earlier we need to find the nix store path to the bash
executable, common way to do this is to load Nixpkgs into the repl and check:</p>
</li>
</ul>
<pre><code class="language-bash">nix-repl&gt; :l &lt;nixpkgs&gt;
Added 3950 variables.
nix-repl&gt; "${bash}"
"/nix/store/ihmkc7z2wqk3bbipfnlh0yjrlfkkgnv6-bash-4.2-p45"
</code></pre>
<p>So, with this little trick we are able to refer to <code>bin/bash</code> and create our
derivation:</p>
<pre><code class="language-bash">nix-repl&gt; d = derivation { name = "foo"; builder = "${bash}/bin/bash";
 args = [ ./builder.sh ]; system = builtins.currentSystem; }
nix-repl&gt; :b d
[1 built, 0.0 MiB DL]

this derivation produced the following outputs:
  out -&gt; /nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo
</code></pre>
<ul>
<li>
<p>The contents of the resulting store path (<code>/nix/store/...-foo</code>) now contain
the file <code>foo</code>, as intended. We have successfully built a derivation!</p>
</li>
<li>
<p>Derivations are the primitive that Nix uses to define packages. “Package” is a
loosely defined term, but a derivation is simply the result of calling
<code>builtins.derivation</code>.</p>
</li>
</ul>
</details>
<h2 id="our-last-derivation"><a class="header" href="#our-last-derivation">Our Last Derivation</a></h2>
<p>Create a new directory and a <code>hello.nix</code> with the following contents:</p>
<pre><code class="language-nix"># hello.nix
{
  stdenv,
  fetchzip,
}:

stdenv.mkDerivation {
  pname = "hello";
  version = "2.12.1";

  src = fetchzip {
    url = "https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz";
    sha256 = "";
  };
}
</code></pre>
<p>Save this file to <code>hello.nix</code> and run <code>nix-build</code> to observe the build failure:</p>
<ul>
<li>Click to expand output:</li>
</ul>
<pre><code class="language-nix">$ nix-build hello.nix
<span class="boring">error: cannot evaluate a function that has an argument without a value ('stdenv')
</span><span class="boring">       Nix attempted to evaluate a function as a top level expression; in
</span><span class="boring">       this case it must have its arguments supplied either by default
</span><span class="boring">       values, or passed explicitly with '--arg' or '--argstr'. See
</span><span class="boring">       https://nix.dev/manual/nix/stable/language/constructs.html#functions.
</span><span class="boring">
</span><span class="boring">       at /home/nix-user/hello.nix:3:3:
</span><span class="boring">
</span><span class="boring">            2| {
</span><span class="boring">            3|   stdenv,
</span><span class="boring">             |   ^
</span><span class="boring">            4|   fetchzip,
</span></code></pre>
<p><strong>Problem</strong>: The expression in <code>hello.nix</code> is a <em>function</em>, which only produces
it's intended output if it is passed the correct <em>arguments</em>.(i.e. <code>stdenv</code> is
available from <code>nixpkgs</code> so we need to import <code>nixpkgs</code> before we can use
<code>stdenv</code>):</p>
<p>The recommended way to do this is to create a <code>default.nix</code> file in the same
directory as the <code>hello.nix</code> with the following contents:</p>
<pre><code class="language-nix"># default.nix
let
  nixpkgs = fetchTarball "https://github.com/NixOS/nixpkgs/tarball/nixos-24.05";
  pkgs = import nixpkgs { config = {}; overlays = []; };
in
{
  hello = pkgs.callPackage ./hello.nix { };
}
</code></pre>
<p>This allows you to run <code>nix-build -A hello</code> to realize the derivation in
<code>hello.nix</code>, similar to the current convention used in Nixpkgs:</p>
<ul>
<li>Click to expand Output:</li>
</ul>
<pre><code class="language-nix">nix-build -A hello
<span class="boring">error: hash mismatch in fixed-output derivation '/nix/store/pd2kiyfa0c06giparlhd1k31bvllypbb-source.drv':
</span><span class="boring">         specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
</span><span class="boring">            got:    sha256-1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=
</span><span class="boring">error: 1 dependencies of derivation '/nix/store/b4mjwlv73nmiqgkdabsdjc4zq9gnma1l-hello-2.12.1.drv' failed to build
</span></code></pre>
<ul>
<li>Another way to do this is with
<a href="https://nix.dev/manual/nix/2.24/command-ref/nix-prefetch-url">nix-prefetch-url</a>
It is a utility to calculate the sha beforehand.</li>
</ul>
<pre><code class="language-bash">nix-prefetch-url https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz
path is '/nix/store/pa10z4ngm0g83kx9mssrqzz30s84vq7k-hello-2.12.1.tar.gz'
086vqwk2wl8zfs47sq2xpjc9k066ilmb8z6dn0q6ymwjzlm196cd
</code></pre>
<ul>
<li>When you use <code>nix-prefetch-url</code>, you get a Base32 hash when nix needs SRI
format.</li>
</ul>
<p>Run the following command to convert from Base32 to SRI:</p>
<pre><code class="language-bash">nix hash to-sri --type sha256 086vqwk2wl8zfs47sq2xpjc9k066ilmb8z6dn0q6ymwjzlm196cd
sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=
</code></pre>
<ul>
<li>This actually fetched a different sha than the Nix compiler returned in the
example where we replace the empty sha with the one Nix gives us. The
difference was that <code>fetchzip</code> automatically extracts archives before
computing the hash and slight differences in the metadata cause different
results. I had to switch from <code>fetchzip</code> to <code>fetchurl</code> to get the correct
results.
<ul>
<li>
<p>Extracted archives can differ in timestamps, permissions, or compression
details, causing different hash values.</p>
</li>
<li>
<p>A simple takeaway is to use <code>fetchurl</code> when you need an exact match, and
<code>fetchzip</code> when working with extracted contents.</p>
</li>
<li>
<p><a href="https://nixos.org/manual/nixpkgs/stable/#fetchurl">fetchurl</a></p>
</li>
<li>
<p><code>fetchurl</code> returns a <code>fixed-output derivation</code>(FOD): A derivation where a
cryptographic hash of the output is determined in advance using the
outputHash attribute, and where the builder executable has access to the
network.</p>
</li>
</ul>
</li>
</ul>
<p>Lastly replace the empty sha256 placeholder with the returned value from the
last command:</p>
<pre><code class="language-nix"># hello.nix
{
  stdenv,
  fetchzip,
}:

stdenv.mkDerivation {
  pname = "hello";
  version = "2.12.1";

  src = fetchzip {
    url = "https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz";
    sha256 = "sha256-1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=";
  };
}
</code></pre>
<p>Run <code>nix-build -A hello</code> again and you'll see the derivation successfully
builds.</p>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<p><strong>Reproducible source paths</strong>: If we built the following derivation in
<code>/home/myuser/myproject</code> then the store path of <code>src</code> will be
<code>/nix/store/&lt;hash&gt;-myproject</code> causing the build to no longer be reproducible:</p>
<pre><code class="language-nix">let pkgs = import &lt;nixpkgs&gt; {}; in

pkgs.stdenv.mkDerivation {
  name = "foo";
  src = ./.;
}
</code></pre>
<blockquote>
<p>❗ TIP: Use <code>builtins.path</code> with the <code>name</code> attribute set to something fixed.
This will derive the symbolic name of the store path from the <code>name</code> instead
of the working directory:</p>
<pre><code class="language-nix">let pkgs = import &lt;nixpkgs&gt; {}; in

pkgs.stdenv.mkDerivation {
  name = "foo";
  src = builtins.path { path = ./.; name = "myproject"; };
}
</code></pre>
</blockquote>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>In this chapter, we've laid the groundwork for understanding Nix derivations,
the fundamental recipes that define how software and other artifacts are built
within the Nix ecosystem. We've explored their key components – inputs, builder,
build phases, and outputs – and how they contribute to Nix's core principles of
reproducibility and isolated environments. Derivations are the workhorses behind
the packages and tools we use daily in Nix.</p>
<p>As you've learned, derivations offer a powerful and principled approach to
software management. However, the way we organize and manage these derivations,
along with other Nix expressions and dependencies, has evolved over time.
Traditionally, Nix projects often relied on patterns involving <code>default.nix</code>
files, channel subscriptions, and manual dependency management.</p>
<p>A more recent and increasingly popular approach to structuring Nix projects and
managing dependencies is through Nix Flakes. Flakes introduce a standardized
project structure, explicit input tracking, and a more robust way to ensure
reproducible builds across different environments.</p>
<p>In our next chapter,
<a href="https://saylesss88.github.io/Comparing_Flakes_and_Traditional_Nix_8.html">Comparing Flakes and Traditional Nix</a>,
we will directly compare and contrast these two approaches. We'll examine the
strengths and weaknesses of traditional Nix practices in contrast to the
benefits and features offered by Nix Flakes. This comparison will help you
understand the motivations behind Flakes and when you might choose one approach
over the other for your Nix projects.</p>
<p>As you can see below, there is a ton of information on derivations freely
available.</p>
<h4 id="links-to-articles-about-derivations"><a class="header" href="#links-to-articles-about-derivations">Links To Articles about Derivations</a></h4>
<details>
<summary> Click To Expand Resources </summary>
<ul>
<li>
<p><a href="https://nixos.org/guides/nix-pills/06-our-first-derivation">NixPillsOurFirstDerivation</a></p>
</li>
<li>
<p><a href="https://nixos.org/guides/nix-pills/07-working-derivation">NixPills-WorkingDerivation</a></p>
</li>
<li>
<p><a href="https://nix.dev/manual/nix/2.24/language/derivations">nix.dev-Derivations</a></p>
</li>
<li>
<p><a href="https://nix.dev/tutorials/packaging-existing-software">nix.dev-packagingExistingSoftware</a></p>
</li>
<li>
<p><a href="https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/">howToLearnNix-MyFirstDerivation</a></p>
</li>
<li>
<p><a href="https://ianthehenry.com/posts/how-to-learn-nix/derivations-in-detail/">howToLearnNix-DerivationsInDetail</a></p>
</li>
<li>
<p><a href="https://www.sam.today/blog/creating-a-super-simple-derivation-learning-nix-pt-3">Sparky/blog-creatingASuperSimpleDerivation</a> #
How to learn Nix</p>
</li>
<li>
<p><a href="https://www.sam.today/blog/derivations-102-learning-nix-pt-4">Sparky/blog-Derivations102</a></p>
</li>
<li>
<p><a href="https://scrive.github.io/nix-workshop/04-derivations/01-derivation-basics.html">ScriveNixWorkshop-nixDerivationBasics</a></p>
</li>
<li>
<p><a href="https://zero-to-nix.com/concepts/derivations/">zeroToNix-Derivations</a></p>
</li>
<li>
<p><a href="https://www.tweag.io/blog/2021-02-17-derivation-outputs-and-output-paths/">Tweag-derivationOutputs</a></p>
</li>
<li>
<p><a href="https://ayats.org/blog/nix-tuto-2">theNixLectures-Derivations</a></p>
</li>
<li>
<p><a href="https://bmcgee.ie/posts/2023/02/nix-what-are-fixed-output-derivations-and-why-use-them/">bmcgee-whatAreFixed-OutputDerivations</a></p>
</li>
</ul>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Package_Definitions_Explained_6.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="drv/builders_and_autotools.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Package_Definitions_Explained_6.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="drv/builders_and_autotools.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
