<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Debugging and Tracing NixOS Modules - nix-book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">nix-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-8"><a class="header" href="#chapter-8">Chapter 8</a></h1>
<h2 id="debugging-and-tracing-nixos-modules"><a class="header" href="#debugging-and-tracing-nixos-modules">Debugging and Tracing NixOS Modules</a></h2>
<p><img src="images/gruv17.png" alt="gruv17" /></p>
<ul>
<li>
<p>Other related post if you haven't read my previous post on modules, that may
be helpful before reading this one:</p>
<ul>
<li>
<p><a href="https://saylesss88.github.io/posts/nix_modules_explained/">nix-modules-explained</a></p>
</li>
<li>
<p>This post is my notes following Nix Hour 40. If it seems a little chaotic,
try watching one. They are hard to follow if you're not extremely
familiar with the concepts.</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=aLy8id4wr-M&amp;t=2120s">Nix Hour 40</a></p>
</li>
</ul>
</li>
</ul>
<p>Nix Code is particularly hard to <strong>debug</strong> because of (e.g. lazy evaluation,
declarative nature, layered modules)</p>
<ul>
<li>The following simple Nix code snippet illustrates a basic NixOS module
definition and how options are declared and configured. We'll use this example
to demonstrate fundamental debugging techniques using <code>nix-instantiate</code>.</li>
</ul>
<pre><code class="language-nix">let
  lib = import &lt;nixpkgs/lib&gt;;
in
lib.evalModules {
  modules = [
    ({ lib, ... }: {
      options.foo = lib.mkOption {
        # type = lib.types.raw;
        type = lib.types.anything;
        # default = pkgs;
      };
      config.foo = {
        bar = 10;
        list = [1 2 3 ];
        baz = lib.mkDefault "baz";
      };
    })
    {
      foo.baz = "bar";
    }
  ];
}
</code></pre>
<ul>
<li>
<p>In the above code, adding <code>lib</code> to the function arguments isn't required but
if you were to move the module to another file it would fail without it
because <code>lib</code> comes from outside of it. So it's good practice to refer to <code>lib</code>
in the modules themselves.</p>
</li>
<li>
<p>You should <strong>always</strong> assign a type to your options, if you don't know which type
to use you could use <code>raw</code>. <code>raw</code> is a type that doesn't do any processing.
So if you were to assign the entire packages set to the option e.g.
<code>default = pkgs;</code> it wouldn't recurseinto all the packages and try to evaluate
them. There is also <code>anything</code>, that is useful if you do want to recurse into
the values.</p>
</li>
<li>
<p>The following is an example of how you would run this inside vim/neovim, the
rest of the examples will be from the command line:</p>
</li>
</ul>
<pre><code class="language-vim">:!nix-instantiate --eval -A config.foo --strict
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">{ bar = 10; baz = "bar"; list = [ 1 2 3 ]; }
</code></pre>
<p>To show the difference you could uncomment the <code>raw</code> type and comment the
<code>anything</code> type and run the above command again you'll see that you get an
error:</p>
<pre><code class="language-bash">error: The option 'foo' is defined multiple times while it's expected to be
unique
</code></pre>
<p>To execute this command on the command line:</p>
<pre><code class="language-bash">nix-instantiate --eval --strict -A config.foo
</code></pre>
<p>It will show you the start of a trace. To get the full trace add:</p>
<pre><code class="language-bash">nix-instantiate --eval --strict -A config.foo --show-trace
</code></pre>
<h2 id="example-2"><a class="header" href="#example-2">Example 2</a></h2>
<p>In the previous example, we looked at a simplified module. Now, let's examine a
more realistic scenario involving a basic NixOS configuration file
(<code>configuration.nix</code>).</p>
<p>This example will demonstrate how to use <code>nix-instantiate</code> to evaluate an entire
system configuration and how <code>--show-trace</code> helps in diagnosing errors within
this context.</p>
<p>Consider the following <code>configuration.nix</code> file:</p>
<pre><code class="language-nix"># configuration.nix
{ lib, ... }: {
  boot.loader.grub.device = "nodev";
  fileSystems."/".device = "/devst";
  system.stateVersion = "24.11";
}
</code></pre>
<ul>
<li>This configuration snippet sets the GRUB bootloader device, defines a root
filesystem, and specifies the expected NixOS state version. To evaluate this
entire system configuration, you can use <code>nix-instantiate</code> and point it to the
<code>&lt;nixpkgs/nixos&gt;</code> entrypoint, providing our <code>configuration.nix</code> file as an
argument. The <code>-A system</code> flag selects the top-level <code>system</code> attribute, which
represents the instantiated system configuration.</li>
</ul>
<p><strong>Run</strong> it in with:</p>
<pre><code class="language-bash">nix-instantiate '&lt;nixpkgs/nixos&gt;' --arg configuration ./configuration.nix -A system
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">/nix/store/kfcwvvpdbsb3xcks1s76id16i1mc3l5k-nixos-system-nixos-25.05pre-git.drv
</code></pre>
<p>Ok, we can see that this successfully <em>instantiates</em>. Let's introduce an error
to trace:</p>
<pre><code class="language-nix">{ lib, ... }: {
  boot.loader.grub.device = "nodev";
  fileSystems."/".device = "/devst";
  system.stateVersion = builtins.genList "24.11" null;
}
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">(stack trace truncated; use '--show-trace' to show the full, detailed trace)
error: expected an integer but found null: null
</code></pre>
<p>Rerun the command with <code>--show-trace</code> appended:</p>
<p>Or on the command line</p>
<pre><code class="language-bash">nix-instantiate '&lt;nixpkgs/nixos&gt;' --arg configuration ./configuration.nix -A system --show-trace
</code></pre>
<ul>
<li>This outputs a much longer trace than the first example. It shows you the file
the error occured in and you can see that in this case they are a lot of
internal functions. (e.g. <code>at /nix/store/ccfwxygjrarahgfv5865x2f828sjr5h0- source/lib/attrsets.nix:1529:14:</code>)</li>
</ul>
<p>To show your own error message you could do something like this:</p>
<pre><code class="language-nix">{lib, ...}: {
  boot.loader.grub.device = "nodev";
  fileSystems."/".device = "/devst";
  system.stateVersion = builtins.addErrorContext "AAAAAAAAAAAAAAAAA" (builtins.genList "24.11" null);
}
</code></pre>
<p>Run it:</p>
<pre><code class="language-bash">nix-instantiate '&lt;nixpkgs/nixos&gt;' --arg configuration ./configuration.nix -A system --show-trace`
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash"> ‚Ä¶ while evaluating the attribute 'value'
     at /nix/store/ccfwxygjrarahgfv5865x2f828sjr5h0-source/lib/modules.nix:770:21:
      769|             inherit (module) file;
      770|             inherit value;
         |                     ^
      771|           }) module.config

   ‚Ä¶ AAAAAAAAAAAAAAAAA

   ‚Ä¶ while calling the 'genList' builtin
     at /home/jr/tests/configuration.nix:4:71:
        3|   fileSystems."/".device = "/devst";
        4|   system.stateVersion = builtins.addErrorContext "AAAAAAAAAAAAAAAAA"
         (builtins.genList "24.11" null);
         |                                                                       ^
        5| }

   ‚Ä¶ while evaluating the second argument passed to builtins.genList

   error: expected an integer but found null: null
</code></pre>
<ul>
<li>In the latest nix they actually inverted the error messages so the most relevant
parts will be at the bottom.</li>
</ul>
<h2 id="example-3"><a class="header" href="#example-3">Example 3</a></h2>
<p>Let's consider another example, this time demonstrating the definition of
configuration options using <code>lib.mkOption</code> within a module structure.</p>
<pre><code class="language-nix"># default.nix
let
  lib = import &lt;nixpkgs/lib&gt;;
in
lib.evalModules {
  modules = [
    ({ lib, ... }: {
      options.ints = lib.mkOption {
        type = lib.types.attrsOf lib.types.int;
      };
      options.strings = lib.mkOption {
        type = lib.types.string;
        # type = lib.types.attrsOf lib.types.string;
        default = "foo";
      };
    })
  ];
}
</code></pre>
<p><strong>Instantiate</strong> this with:</p>
<pre><code class="language-bash">nix-instantiate --eval --strict -A config.strings
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">evaluation warning: The type `types.string` is deprecated.
See https://github.com/NixOS/nixpkgs/pull/66346 for better alternative types.
"foo"
</code></pre>
<ul>
<li>Unfortunately you won't get the same depreciation warning from <code>lib.attrsOf</code></li>
</ul>
<p>Below is an interesting way to provide nixpkgs run it on the command line:</p>
<pre><code class="language-bash">export NIX_PATH=nixpkgs=channel:nixpkgs-unstable
echo $NIX_PATH
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">nixpkgs=channel:nixpkgs-unstable
</code></pre>
<p>The next two commands are to check that after using the above way to provide
<code>nixpkgs-unstable</code> that they both point to the same store path, the following
command will fetch nixpkgs from the channel above:</p>
<pre><code class="language-bash">nix-instantiate --find-file nixpkgs
</code></pre>
<p><strong>Output</strong> 1Ô∏è‚É£</p>
<pre><code class="language-bash">/nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source
</code></pre>
<pre><code class="language-bash">nix-instantiate --eval channel:nixpkgs-unstable -A path
</code></pre>
<p><strong>Output</strong>: 2Ô∏è‚É£</p>
<pre><code class="language-bash">/nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source
</code></pre>
<ul>
<li>As you can see both commands produce the same store path</li>
</ul>
<h2 id="example-4"><a class="header" href="#example-4">Example 4</a></h2>
<p>In our previous example, we encountered a deprecation warning for
<code>lib.types.string</code>. This next example delves deeper into why that type was
deprecated and demonstrates the consequences of its behavior, along with the
recommended fix.</p>
<pre><code class="language-nix"># default.nix
let
  lib = import &lt;nixpkgs/lib&gt;;
in
  lib.evalModules {
    modules = [
      ({lib, ...}: {
        options.ints = lib.mkOption {
          type = lib.types.attrsOf lib.types.int;
        };
        options.strings = lib.mkOption {
          # type = lib.types.string;
          type = lib.types.attrsOf lib.types.string;
          default = {
            x = "foo";
          };
        };
        config = {
          strings = lib.mkOptionDefault {
            x = "bar";
          };
        };
      })
    ];
  }
</code></pre>
<p>Evaluate it with:</p>
<pre><code class="language-bash">nix-instantiate --eval --strict -A config.strings
</code></pre>
<ul>
<li>
<p><code>types.string</code> depricated because it silently concatenates strings</p>
</li>
<li>
<p>The above command has two options with the same priority level and evaluates
to <code>{ x = "foobar"; }</code></p>
</li>
</ul>
<p><strong>Output:</strong></p>
<pre><code class="language-bash">evaluation warning: The type `types.string` is deprecated. See https://github.
com/NixOS/nixpkgs/pull/66346 for better alternative types.
{ x = "foobar"; }
</code></pre>
<ul>
<li><code>types.str</code> was the replacement for the depricated <code>types.string</code>:</li>
</ul>
<pre><code class="language-nix"># default.nix
let
  lib = import &lt;nixpkgs/lib&gt;;
in
  lib.evalModules {
    modules = [
      ({lib, ...}: {
        options.ints = lib.mkOption {
          type = lib.types.attrsOf lib.types.int;
        };
        options.strings = lib.mkOption {
          # type = lib.types.string;
          type = lib.types.attrsOf lib.types.str;
          # Sets the value with a lower priority: lib.mkOptionDefault
          default = {
            x = "foo";
          };
        };
        config = {
          strings = lib.mkOptionDefault {
            x = "bar";
          };
        };
      })
    ];
  }
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-bash">error:
‚Ä¶ while evaluating the attribute 'x'

‚Ä¶ while evaluating the attribute 'value'
 at /nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source/lib/modules.nix:1148:41:
 1147|
 1148|     optionalValue = if isDefined then { value = mergedValue; } else { };
     |                                         ^
 1149|   };

‚Ä¶ while calling the 'foldl'' builtin
 at /nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source/lib/options.nix:508:8:
  507|     else
  508|       (foldl' (
     |        ^
  509|         first: def:

(stack trace truncated; use '--show-trace' to show the full, detailed trace)

error: The option `strings.x' has conflicting definition values:
- In `&lt;unknown-file&gt;': "foo"
- In `&lt;unknown-file&gt;': "bar"
Use `lib.mkForce value` or `lib.mkDefault value` to change the priority on any of these definitions.

shell returned 1
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>
<p>So types in the module system aren't just types in the conventional sense
but they also specify the emerging behavior of these values.</p>
</li>
<li>
<p>If we switch the type in the above example to <code>types.lines</code> you get this
returned, <code>{ x = "foo\nbar"; }</code></p>
</li>
<li>
<p><code>mkOptionDefault</code> isn't typically something you should generally use, instead
options have a <code>default</code> setting</p>
</li>
<li>
<p>If you want to make sure that you set a default but if the user specifies it,
it shouldn't get overridden. You should not set it in the following:</p>
</li>
</ul>
<pre><code class="language-nix">options.strings = lib.mkOption {
  type = lib.types.attrsOf lib.types.lines;
  default = {
    x = "foo";
  };
}
</code></pre>
<p>Because the above uses <code>mkOptionDefault</code> but instead in under the <code>config</code>
attribute like the following:</p>
<pre><code class="language-nix"># ...snip...
options.strings = lib.mkOption {
  type = lib.types.attrsOf lib.types.lines;
  # default = {
    # x = "foo";
  # };
};
config = {
  strings = {
    x = lib.mkDefault "foo";
  };
};
# ...snip...
</code></pre>
<pre><code class="language-nix">let
  lib = import &lt;nixpkgs/lib&gt;;
in
  lib.evalModules {
    modules = [
      ({lib, ...}: {
        options.ints = lib.mkOption {
          type = lib.types.attrsOf lib.types.int;
        };
        options.strings = lib.mkOption {
          # type = lib.types.string;
          type = lib.types.attrsOf lib.types.str;
          # Sets the value with a lower priority: lib.mkOptionDefault
          #default = {
          #  x = "foo";
          #};
        };
        config.strings = {
          x = "foo";
        };
      })
      {
        config.strings = {
          y = "bar";
        };
      }
    ];
  }
</code></pre>
<p><strong>Output</strong>:</p>
<ul>
<li>This works now because there's no difference between <code>x</code> and <code>y</code></li>
</ul>
<pre><code class="language-bash">{ x = "foo"; y = "bar"; }
</code></pre>
<h2 id="more-functionality-between-modules"><a class="header" href="#more-functionality-between-modules">More Functionality between modules</a></h2>
<pre><code class="language-nix">let
  lib = import &lt;nixpkgs/lib&gt;;
in
  lib.evalModules {
    modules = [
      ({lib, ...}: {
        options.ints = lib.mkOption {
          type = lib.types.attrsOf lib.types.int;
        };
        options.strings = lib.mkOption {
          # type = lib.types.string;
          type = lib.types.attrsOf lib.types.str;
          # Sets the value with a lower priority: lib.mkOptionDefault
          #default = {
          #  x = "foo";
          #};
        };
        config.strings = {
          x = lib.mkDefault "foo";
        };
      })
      {
        config.strings = {
          x = "x";
          y = "bar";
        };
      }
    ];
  }
</code></pre>
<ul>
<li>The above command would cause a conflict without the <code>x = lib.mkDefault foo</code>
And this is typically what you want to do for defaults and modules in things
like nested configuration.</li>
</ul>
<p><strong>Output:</strong></p>
<pre><code class="language-bash">{ x = "x"; y = "bar"; }
</code></pre>
<h3 id="infinite-recursion-error"><a class="header" href="#infinite-recursion-error">Infinite recursion error</a></h3>
<ol>
<li>A common pitfall is to introduce a hard to debug error <code>infinite recursion</code>
when shadowing a name. The simplest example for this is:</li>
</ol>
<pre><code class="language-nix">let a = 1; in rec { a = a; }
</code></pre>
<blockquote>
<p>üí°<strong>TIP</strong>: Avoid <code>rec</code>. Use <code>let ... in</code>
Example:</p>
<pre><code class="language-nix">let
 a = 1;
in {
 a = a;
 b = a + 2;
}
</code></pre>
</blockquote>
<p>We'll separate the logic for this example, this will be the <code>default.nix</code> this
is where having <code>lib</code> defined in your inline modules is helpful because you can
just delete the section and paste it into your <code>modules.nix</code>:</p>
<pre><code class="language-nix"># default.nix
let
  lib = import &lt;nixpkgs/lib&gt;;
in
  lib.evalModules {
    modules = [
      ./module.nix
    ];
  }
</code></pre>
<p>And in the <code>module.nix</code>:</p>
<pre><code class="language-nix"># module.nix
{ lib, pkgs, ...}: {
  options.etc = lib.mkOption {
    type = lib.types.attrsOf lib.types.path;
    default = { };
    description = ''
      Specifies which paths are is /etc/
    '';
  };

  config._module.args.pkgs = import &lt;nixpkgs&gt; {
    config = {};
    overlays = [];
  };
  config.etc.foo = pkgs.writeText "foo" ''
    foo configuration
  '';
}
</code></pre>
<ul>
<li>If you evaluate this with the following you will get an infinite recursion error.</li>
</ul>
<pre><code class="language-bash">nix-instantiate --eval --strict -A config.etc
</code></pre>
<ul>
<li>This happens because <code>--strict</code> evaluates the <code>etc</code>, then it goes into the
<code>attrsOf</code>, and the <code>path</code></li>
</ul>
<pre><code class="language-bash">nix repl
nix-repl&gt; :l &lt;nixpkgs&gt;
nix-repl&gt; hello.out.out.out
</code></pre>
<p>In this example:</p>
<ul>
<li>
<p><code>:l &lt;nixpkgs&gt;</code> loads the Nixpkgs library into the repl environment, making its
definitions available.</p>
</li>
<li>
<p><code>hello</code> refers to the <code>hello</code> package definition within Nixpkgs. Packages in
Nixpkgs are defined as <em>derivations</em>.</p>
</li>
<li>
<p><code>.out</code> is a common attribute name for the <em>main output</em> of a derivation
(e.g., the installed package). Some packages, especially those with complex
build processes or multiple outputs, might have nested output attributes.
In the case of <code>hello</code>, accessing <code>.out.out.out</code> ultimately leads us to the
<em>derivation</em> itself.</p>
</li>
</ul>
<p>The key takeaway here is that when you evaluate a package in the <code>nix repl</code>,
you're often interacting with its derivation or one of its output paths in the
Nix store. The <code>¬´derivation ...¬ª</code> indicates that <code>hello.out.out.out</code> evaluates
to a derivation ‚Äì the blueprint for building the <code>hello</code> package. This is in
contrast to <code>--eval --strict</code>, which tries to fully evaluate values, potentially
leading to infinite recursion if it encounters a derivation that refers back to
itself indirectly during attribute evaluation.</p>
<p><strong>Output:</strong></p>
<pre><code class="language-bash">¬´derivation /nix/store/b1vcpm321dwbwx6wj4n13l35f4y2wrfv-hello-2.12.1.drv¬ª
</code></pre>
<ul>
<li>So it recurses through the entire thing and tries to evaluate its string.</li>
</ul>
<p>So we want to change the command from <code>--eval --strict</code> which is only based on
evaluation to at least <code>nix-instantiate</code> which is based on derivations:</p>
<pre><code class="language-bash">nix-instantiate -A config.etc
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-bash">warning: you did not specify '--add-root'; the result might be removed by the garbage collector
/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv
</code></pre>
<ul>
<li>We don't really have a derivation yet for example:</li>
</ul>
<pre><code class="language-nix"># module.nix
{
  lib,
  pkgs,
  ...
}: {
  options.etc = lib.mkOption {
    type = lib.types.attrsOf (lib.types.attrsOf lib.types.path);
    default = {};
    description = ''
      Specifies which paths are in /etc/
    '';
  };

  config._module.args.pkgs = import &lt;nixpkgs&gt; {
    config = {};
    overlays = [];
  };
  config.etc.foo.bar = pkgs.writeText "foo" ''
    foo configuration
  '';
}
</code></pre>
<p>Try to evaluate the above command with <code>nix-instantiate -A config.etc</code> and Nix
doesn't even try to build it. With nested <code>attrsOf</code></p>
<pre><code class="language-bash">nix repl -f default.nix
nix-repl&gt; config.etc
{
  foo = { ... };
}
nix-repl&gt; config.etc.foo
{
  bar = ¬´derivation /nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv¬ª;
}
</code></pre>
<ul>
<li>So <code>config.foo</code> is an attribute set and <code>config.etc.foo</code> is also an attribute
set but it's not a derivation by itself. So <code>nix-instantiate</code> does this one
level of recursion here and it would have built <code>foo</code> value if it were a
derivation.</li>
</ul>
<h3 id="example-5"><a class="header" href="#example-5">Example 5</a></h3>
<p>We'll use the same <code>module.nix</code> and <code>default.nix</code> from the previous example.</p>
<p>Building More Complex Configurations with Modules
In this next example, we'll focus on a common task in system configuration:
managing files within the <code>/etc/</code> directory. We'll define a module that allows
us to specify the content of arbitrary files in <code>/etc/</code> and then use a special
Nix function to combine these individual file definitions into a single,
manageable entity.</p>
<p>We'll introduce a new option, <code>options.etc</code>, which will allow us to define the
content of files within <code>/etc/</code>. Then, we'll use <code>pkgs.linkFarm</code> to create a
derivation that represents the entire <code>/etc/</code> directory as a collection of
symbolic links pointing to the individual file contents we've defined. This
demonstrates how modules can abstract away the details of creating complex
system configurations, providing a declarative and reproducible way to manage
even fundamental aspects of the operating system.</p>
<p>Let's show how we can use Nix modules to declaratively manage the <code>/etc/</code>
directory</p>
<pre><code class="language-nix"># default.nix
let
  lib = import &lt;nixpkgs/lib&gt;;
in
  lib.evalModules {
    modules = [
      ./module.nix
    ];
  }

</code></pre>
<pre><code class="language-nix"># module.nix
{
  lib,
  pkgs,
  config,
  ...
}: {
  options.etc = lib.mkOption {
    type = lib.types.attrsOf (lib.types.attrsOf lib.types.path);
    default = {};
    description = ''
      Specifies which paths are in /etc/
    '';
  };
  options.etcCombined = lib.mkOption {
    type = lib.types.package;
    default =
      pkgs.linkFarm "etc"
      (lib.mapAttrsToList (name: value: {
        name = name;
        path = value;
      }) config.etc);
  };

  config._module.args.pkgs = import &lt;nixpkgs&gt; {
    config = {};
    overlays = [];
  };
  config.etc.foo = pkgs.writeText "foo" ''
    foo configuration
  '';
  config.etc.bar = pkgs.writeText "bar" ''
    bar configuration
  '';
}

</code></pre>
<p>Run it with:</p>
<pre><code class="language-bash">nix-instantiate -A config.etcCombined
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv
</code></pre>
<ul>
<li>So we can see that it will instantiate, lets see if it will build:</li>
</ul>
<pre><code class="language-bash">nix-build -A config.etcCombined
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">these 3 derivations will be built:
/nix/store/41yfxq4af1vrs0rrgfk5gc36kmjc7270-bar.drv
/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv
/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv
building '/nix/store/41yfxq4af1vrs0rrgfk5gc36kmjc7270-bar.drv'...
building '/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv'...
building '/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv'...
/nix/store/ca3wyk5m3qhy8n1nbn0181m29qvp1klp-etc
</code></pre>
<pre><code class="language-bash">nix-build -A config.etcCombined &amp;&amp; ls result/ -laa
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">/nix/store/ca3wyk5m3qhy8n1nbn0181m29qvp1klp-etc
dr-xr-xr-x - root 31 Dec  1969 Óóø .
drwxrwxr-t - root 16 May 15:13 Óóø ..
lrwxrwxrwx - root 31 Dec  1969 ÔÄñ bar -&gt; /nix/store/1fsjyc2hmilab1qw6jfkf6cb767kz858-bar
lrwxrwxrwx - root 31 Dec  1969 ÔÄñ foo -&gt; /nix/store/wai5dycp0zx1lxg0rhpdxnydhiadpk05-foo
</code></pre>
<ul>
<li>
<p>We can see that <code>foo</code> and <code>bar</code> link to different derivations</p>
</li>
<li>
<p>When trying to figure out which <code>default</code> to use for <code>etcCombined</code> infinisil
went to the Nixpkgs Reference Manual. Make sure to go to the correct version.</p>
<ul>
<li>
<p><a href="https://nixos.org/manual/nixpkgs/stable/">24.11pre-git</a></p>
</li>
<li>
<p><a href="https://nixos.org/manual/nixpkgs/unstable/">25.05pre-git</a> (i.e. unstable)</p>
</li>
<li>
<p>Once at the website press <code>Ctrl+f</code> and type <code>symlinkjoin</code> and hit enter.</p>
</li>
</ul>
</li>
</ul>
<p>Or in your local copy of Nixpkgs you could go to <code>nixpkgs/pkgs/build-support/ trivial-builders/default.nix</code>. Then use your editors search feature, with nvim
and helix you press <code>/symlinkjoin</code> or <code>/linkFarm</code> hit enter then press <code>n</code> to
cycle to the next match. It will bring you to comments and up to date
information.</p>
<pre><code class="language-bash"># linkFarm "myexample" [ { name = "hello-test"; path = pkgs.hello; }
# { name = "foobar"; path = pkgs.stack; } ]
</code></pre>
<h3 id="tests"><a class="header" href="#tests">Tests</a></h3>
<ul>
<li>How to create a Derivation with <code>passthru.tests</code> outside of Nixpkgs
and then run tests available to your package set?</li>
</ul>
<pre><code class="language-bash">mkdir passthru-tests &amp;&amp; cd passthru-tests
</code></pre>
<p>Create a <code>default.nix</code> with the following:</p>
<pre><code class="language-nix"># default.nix
let
  pkgs = import &lt;nixpkgs&gt; {};

  package = pkgs.runCommand "foo" {
    passthru.tests.simple = pkgs.runCommand "foo-test" {} ''
      if [[ "$(cat ${package})" != "foo" ]]; then
        echo "Result is not foo"
        exit 1
      fi
      touch $out
  '';
  } ''
    echo foo &gt; $out
  '';
in
package
</code></pre>
<p>See if it will build:</p>
<pre><code class="language-bash">nix-build
</code></pre>
<p>Try running the test:</p>
<pre><code class="language-bash">nix-build -A passthru.tests
</code></pre>
<pre><code class="language-bash">this derivation will be built:
/nix/store/pqpqq9x1wnsabzbsb52z4g4y4zy6p7yx-foo-test.drv
building '/nix/store/pqpqq9x1wnsabzbsb52z4g4y4zy6p7yx-foo-test.drv'...
/nix/store/7bbw2ban0mgkh4d59yz3cnai4aavwvb6-foo-test
</code></pre>
<h3 id="test-2"><a class="header" href="#test-2">Test 2</a></h3>
<ul>
<li><code>passthru.tests</code> is the convention for defining tests associated with a
derivation. The attributes in <code>passthru</code> are preserved and accessible after
the derivation is built.</li>
</ul>
<pre><code class="language-nix">let
  pkgs = import &lt;nixpkgs&gt; {};

  package =
    pkgs.runCommand "foo" {
      passthru.tests.simple = pkgs.runCommand "foo-test" {} ''
        if [[ "$(cat ${package})" != "foo" ]]; then
          echo "Result is not foo"
          exit 1
        fi
        touch $out
      '';

      passthru.tests.version = pkgs.testers.testVersion {
         package = package;
         version = "1.2";
     };

      # pkgs.writeShellApplication
      script = ''
        #!${pkgs.runtimeShell}
        echo "1.2"
      '';
      passAsFiles = [ "script" ];

    } ''
      cp "$scriptPath" "$out"
    '';
in
  package
</code></pre>
<p>Try to build it:</p>
<pre><code class="language-bash">nix-build -A passthru.tests
</code></pre>
<ul>
<li>
<p><code>testers.testVersion</code> checks if an executable outputs a specific version string.</p>
</li>
<li>
<p><code>nix-build -A passthru.tests</code> specifically targets the derivations defined
within the tests attribute of the main derivation.</p>
</li>
</ul>
<pre><code class="language-bash">these 3 derivations will be built:
  /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv
  /nix/store/s4iawjy5zpv89dbkc3zz7z3ngz4jq2cv-foo-test.drv
  /nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z-foo-test-version.drv
building '/nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv'...
cp: cannot stat '': No such file or directory
error: builder for '/nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv'
 failed with exit code 1;
     last 1 log lines:
     &gt; cp: cannot stat '': No such file or directory
     For full logs, run:
       nix log /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv
error: 1 dependencies of derivation '/nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z
-foo-test-version.drv' failed to build
error: build of '/nix/store/s4iawjy5zpv89dbkc3zz7z3ngz4jq2cv-foo-test.drv',
 '/nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z-foo-test-version.drv' failed
</code></pre>
<p>Run <code>nix-build</code> with no arguments:</p>
<pre><code class="language-bash">nix-build
</code></pre>
<pre><code class="language-bash">nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq '.[].env'
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-json">{
  "__structuredAttrs": "",
  "buildCommand": "cp \"$scriptPath\" \"$out\"\n",
  "buildInputs": "",
  "builder": "/nix/store/xg75pc4yyfd5n2fimhb98ps910q5lm5n-bash-5.2p37/bin/bash",
  "cmakeFlags": "",
  "configureFlags": "",
  "depsBuildBuild": "",
  "depsBuildBuildPropagated": "",
  "depsBuildTarget": "",
  "depsBuildTargetPropagated": "",
  "depsHostHost": "",
  "depsHostHostPropagated": "",
  "depsTargetTarget": "",
  "depsTargetTargetPropagated": "",
  "doCheck": "",
  "doInstallCheck": "",
  "enableParallelBuilding": "1",
  "enableParallelChecking": "1",
  "enableParallelInstalling": "1",
  "mesonFlags": "",
  "name": "foo",
  "nativeBuildInputs": "",
  "out": "/nix/store/9mcrnddb6lf1md14v4lj6s089i99l5k7-foo",
  "outputs": "out",
  "passAsFile": "buildCommand",
  "passAsFiles": "script",
  "patches": "",
  "propagatedBuildInputs": "",
  "propagatedNativeBuildInputs": "",
  "script": "#!/nix/store/xg75pc4yyfd5n2fimhb98ps910q5lm5n-bash-5.2p37/bin/bash\necho \"1.2\"\n",
  "stdenv": "/nix/store/lgydi1gl5wqcw6k4gyjbaxx7b40zxrsp-stdenv-linux",
  "strictDeps": "",
  "system": "x86_64-linux"
}
</code></pre>
<pre><code class="language-bash">nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq
 '.[].env.buildCommand'
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-bash">"cp \"$scriptPath\" \"$out\"\n"
</code></pre>
<ul>
<li>raw mode below</li>
</ul>
<pre><code class="language-bash">nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq
 '.[].env.buildCommand' -r
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-bash">cp "$scriptPath" "$out"
</code></pre>
<ul>
<li>It turns out the correct command was <code>passAsFile</code> not <code>passAsFiles</code> but that
change wasn't enough to fix it. <code>passAsFiles</code> expects a list of files, not a
single file path. Running <code>nix-build -A passthru.tests</code> failed
saying <code>&gt; foo --version returned a non-zero exit code.</code></li>
</ul>
<pre><code class="language-nix">let
  pkgs = import &lt;nixpkgs&gt; {};

  package =
    pkgs.runCommand "foo" {
      #passthru.tests.simple = pkgs.runCommand "foo-test" {} ''
      #  if [[ "$(cat ${package})" != "foo" ]]; then
      #    echo "Result is not foo"
      #    exit 1
      #  fi
      #  touch $out
      #'';

      passthru.tests.version = pkgs.testers.testVersion {
        package = package;
        version = "1.2";
      };

      # pkgs.writeShellApplication
      script = ''
        #!${pkgs.runtimeShell}
        echo "1.2"
      '';
      passAsFile = ["script"];
    } ''
      mkdir -p "$out/bin"
      cp "$scriptPath" "$out/bin/foo"
      chmod +x "$out/bin/foo"
    '';
in
  package
</code></pre>
<p>Build it:</p>
<pre><code class="language-bash">nix-build -A passthru.tests
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-bash">these 2 derivations will be built:
  /nix/store/lqrlcd64dmpzkggcfzlnsnwjd339czd3-foo.drv
  /nix/store/c3kw4xbdlrig08jrdm5wis1dmv2gnqsd-foo-test-version.drv
building '/nix/store/lqrlcd64dmpzkggcfzlnsnwjd339czd3-foo.drv'...
building '/nix/store/c3kw4xbdlrig08jrdm5wis1dmv2gnqsd-foo-test-version.drv'...
1.2
/nix/store/zsbk5zawak68ailvkwi2gad2bqbqmdz9-foo-test-version
</code></pre>
<h3 id="key-takeaways-for-debugging-nixos-modules"><a class="header" href="#key-takeaways-for-debugging-nixos-modules">Key Takeaways for Debugging NixOS Modules</a></h3>
<ul>
<li>
<p><strong><code>nix-instantiate</code> is Your Friend:</strong> Use <code>nix-instantiate</code> to evaluate your
NixOS modules and pinpoint errors.</p>
</li>
<li>
<p><strong>Unlock Details with <code>--show-trace</code>:</strong> When errors occur, always append
<code>--show-trace</code> to get a comprehensive stack trace, revealing the origin of the
problem. Remember that in newer Nix versions, the most relevant parts of the
trace are often at the bottom.</p>
</li>
<li>
<p><strong>Understand Option Types:</strong> Nix option types (<code>raw</code>, <code>anything</code>, <code>string</code>/<code>str</code>,
<code>lines</code>, <code>attrsOf</code>) are not just about data types; they also dictate how values
are merged and processed within the module system.</p>
</li>
<li>
<p><strong>Be Mindful of <code>mkOptionDefault</code>:</strong> While useful in specific scenarios,
<code>mkOptionDefault</code> sets a lower priority default. For standard defaults that
can be overridden by user configuration, define them directly within the <code>config</code>
attribute using <code>lib.mkDefault</code>.</p>
</li>
<li>
<p><strong>Use <code>builtins.addErrorContext</code>:</strong> Enhance your custom error messages by
providing specific context relevant to your module's logic using
<code>builtins.addErrorContext</code>.</p>
</li>
<li>
<p><strong>Derivations vs. Evaluation:</strong> Be aware of the difference between evaluating
expressions (<code>--eval --strict</code>) and instantiating derivations (<code>nix-instantiate</code>).
Strict evaluation can trigger infinite recursion if it encounters unevaluated
derivations with cyclic dependencies during attribute access.</p>
</li>
<li>
<p><strong>Explore with <code>nix repl</code>:</strong> The <code>nix repl</code> allows you to interactively explore
Nix expressions and the outputs of derivations, providing insights into the
structure and values within Nixpkgs.</p>
</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This chapter has equipped you with essential techniques for debugging and tracing
NixOS modules. We've explored how to use <code>nix-instantiate</code> and <code>--show-trace</code> to
pinpoint errors, how to interpret Nix's often-verbose error messages, and how to
leverage the <code>nix repl</code> for interactive exploration. Understanding option types
and the nuances of <code>mkOptionDefault</code> is crucial for writing robust and
predictable modules. We've also touched upon the distinction between evaluation
and instantiation, and how that impacts debugging.</p>
<p>While these tools and techniques are invaluable for understanding and
troubleshooting your own Nix configurations, they also become essential
when you want to contribute to or modify the vast collection of packages
and modules within <strong>Nixpkgs</strong> itself. Nixpkgs is where the majority of Nix
packages and NixOS modules reside, and learning how to navigate and contribute
to it opens up a whole new level of control and customization within the Nix
ecosystem.</p>
<p>In the next chapter, <a href="https://saylesss88.github.io/chapter_9.html">Working with Nixpkgs Locally</a>,
we'll shift our focus to exploring and modifying Nixpkgs. We'll cover how to clone
Nixpkgs, how to make changes to package definitions, and how to test those changes
locally before contributing them back upstream. This chapter will empower you to
not just use existing Nix packages, but also to customize and extend them to fit
your specific needs.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Comparing_Flakes_and_Traditional_Nix_7.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="Working_with_Nixpkgs_Locally_9.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Comparing_Flakes_and_Traditional_Nix_7.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="Working_with_Nixpkgs_Locally_9.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
