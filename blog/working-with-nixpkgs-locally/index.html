<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>My-Nix-Blog</title>
    <link rel="stylesheet" href="https://saylesss88.github.io/style.css" />
    <script>
      (() => {
        const savedTheme = localStorage.getItem("theme") || "light";
        document.documentElement.setAttribute("data-theme", savedTheme);
      })();
      const baseUrl = "https://saylesss88.github.io";
    </script>
  </head>
  <body>
    <div class="container">
      <h1>Welcome to My-Nix-Blog</h1>

      <button id="dark-mode-toggle">Toggle Dark Mode</button>

      <a href="https://saylesss88.github.io/rss.xml" id="rss-button" role="button">
        ðŸ“¡ Subscribe via RSS
      </a>

      <div role="search">
        <input
          type="text"
          id="search"
          placeholder="Search..."
          aria-label="Search"
        />
        <div class="search-results" aria-live="polite">
          <ul class="search-results__items"></ul>
        </div>
      </div>

      
<h1 class="title">Working with Nixpkgs Locally: Benefits and Best Practices</h1>
<p class="subtitle"><strong>2025-05-07</strong></p>
<p><strong>TOC</strong></p>
<!--toc:start-->
<ul>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#working-with-nixpkgs-locally-benefits-and-best-practices">Working with Nixpkgs Locally: Benefits and Best Practices</a></li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#i-why-work-with-nixpkgs-locally">I. Why Work with Nixpkgs Locally?</a>
<ul>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#a-faster-development-cycle">A. Faster Development Cycle</a></li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#b-enhanced-version-control">B. Enhanced Version Control</a></li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#c-flexible-debugging-capabilities">C. Flexible Debugging Capabilities</a></li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#d-streamlined-contribution-workflow">D. Streamlined Contribution Workflow</a></li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#e-up-to-date-documentation-source">E. Up-to-Date Documentation Source</a></li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#f-optimized-storage-and-performance">F. Optimized Storage and Performance</a></li>
</ul>
</li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#ii-flake-vs-non-flake-syntax-for-local-nixpkgs">II. Flake vs. Non-Flake Syntax for Local Nixpkgs</a>
<ul>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#a-flake-syntax-nix-build-package">A. Flake Syntax (<code>nix build .#&lt;package&gt;</code>)</a></li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#b-non-flake-syntax-nix-build-f-package-or-nix-build-f-package">B. Non-Flake Syntax (<code>nix-build -f . &lt;package&gt;</code> or <code>nix build -f . &lt;package&gt;</code>)</a></li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#iii-setting-up-a-local-nixpkgs-repository-efficiently">III. Setting Up a Local Nixpkgs Repository Efficiently</a></li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#a-initial-clone-shallow-cloning">A. Initial Clone: Shallow Cloning</a></li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#b-managing-branches-with-worktrees">B. Managing Branches with Worktrees</a></li>
</ul>
</li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#iv-debugging-missing-dependencies-a-practical-example">IV. Debugging Missing Dependencies: A Practical Example</a>
<ul>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#b-local-source-code-search-with-rg-ripgrep">B. Local Source Code Search with <code>rg</code> (ripgrep)</a></li>
</ul>
</li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#v-local-derivation-search-with-nix-locate">V. Local Derivation Search with <code>nix-locate</code></a></li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#vi-key-benefits-of-working-with-nixpkgs-locally-recap">VI. Key Benefits of Working with Nixpkgs Locally (Recap)</a></li>
<li><a href="https://saylesss88.github.io/blog/working-with-nixpkgs-locally/#vii-best-practices-and-tips-from-the-community">VII. Best Practices and Tips from the Community</a></li>
</ul>
<!--toc:end-->
<img src="/images/gruv7.png" alt="Cyber" width="700">
<h1 id="working-with-nixpkgs-locally-benefits-and-best-practices">Working with Nixpkgs Locally: Benefits and Best Practices</h1>
<ul>
<li>Nixpkgs, the package repository for NixOS, is a powerful resource for building and customizing software.</li>
<li>Working with a local copy enhances development, debugging, and contribution workflows.</li>
<li>This post covers setting up a local Nixpkgs repository, searching for dependencies, and leveraging its advantages, incorporating tips from the Nix community.</li>
</ul>
<h1 id="i-why-work-with-nixpkgs-locally">I. Why Work with Nixpkgs Locally?</h1>
<ul>
<li>
<p>A local Nixpkgs repository offers significant advantages for Nix developers:</p>
<h2 id="a-faster-development-cycle">A. Faster Development Cycle</h2>
<ul>
<li>Local searches for packages and dependencies are significantly quicker than querying remote repositories or channels.</li>
<li>This speedup is crucial for efficient debugging and rapid prototyping of Nix expressions.</li>
</ul>
<h2 id="b-enhanced-version-control">B. Enhanced Version Control</h2>
<ul>
<li>By pinning your local repository to specific commits or branches (e.g., <code>nixos-unstable</code>), you ensure build reproducibility.</li>
<li>This prevents unexpected issues arising from upstream changes in Nixpkgs.</li>
</ul>
<h2 id="c-flexible-debugging-capabilities">C. Flexible Debugging Capabilities</h2>
<ul>
<li>You can directly test and modify package derivations within your local copy.</li>
<li>This allows for quick fixes to issues like missing dependencies without waiting for upstream updates or releases.</li>
</ul>
<h2 id="d-streamlined-contribution-workflow">D. Streamlined Contribution Workflow</h2>
<ul>
<li>Developing and testing new packages or patches locally is essential before submitting them as pull requests to Nixpkgs.</li>
<li>A local setup provides an isolated environment for experimentation.</li>
</ul>
<h2 id="e-up-to-date-documentation-source">E. Up-to-Date Documentation Source</h2>
<ul>
<li>The source code and comments within the Nixpkgs repository often contain the most current information about packages.</li>
<li>This can sometimes be more up-to-date than official, external documentation.</li>
</ul>
<h2 id="f-optimized-storage-and-performance">F. Optimized Storage and Performance</h2>
<ul>
<li>Employing efficient cloning strategies (e.g., shallow clones) and avoiding unnecessary practices (like directly using Nixpkgs as a flake for local development) minimizes disk usage and build times.</li>
</ul>
</li>
</ul>
<h1 id="ii-flake-vs-non-flake-syntax-for-local-nixpkgs">II. Flake vs. Non-Flake Syntax for Local Nixpkgs</h1>
<ul>
<li>
<p>When working with Nixpkgs locally, the choice between Flake and non-Flake syntax has implications for performance and storage:</p>
<h2 id="a-flake-syntax-nix-build-package">A. Flake Syntax (<code>nix build .#&lt;package&gt;</code>)</h2>
<ul>
<li>Treats the current directory as a flake, requiring evaluation of <code>flake.nix</code>.</li>
<li>For local Nixpkgs, this evaluates the flake definition in the repository root.</li>
<li><strong>Performance and Storage Overhead:</strong> Flakes copy the entire working directory (including Git history if present) to <code>/nix/store</code> for evaluation. This can be slow and storage-intensive for large repositories like Nixpkgs.</li>
</ul>
<h2 id="b-non-flake-syntax-nix-build-f-package-or-nix-build-f-package">B. Non-Flake Syntax (<code>nix-build -f . &lt;package&gt;</code> or <code>nix build -f . &lt;package&gt;</code>)</h2>
<ul>
<li><code>-f .</code> specifies the Nix expression (e.g., <code>default.nix</code> or a specific file) in the current directory.</li>
<li><strong>Efficiency:</strong> Evaluates the Nix expression directly <em>without</em> copying the entire worktree to <code>/nix/store</code>. This is significantly faster and more storage-efficient for local development on large repositories.</li>
</ul>
</li>
</ul>
<h2 id="iii-setting-up-a-local-nixpkgs-repository-efficiently">III. Setting Up a Local Nixpkgs Repository Efficiently</h2>
<ul>
<li>
<p>Cloning Nixpkgs requires careful consideration due to its size.</p>
<h2 id="a-initial-clone-shallow-cloning">A. Initial Clone: Shallow Cloning</h2>
<ul>
<li>To avoid downloading the entire history, perform a shallow clone:<pre data-lang="bash" style="background-color:#212733;color:#ccc9c2;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffd580;">git</span><span> clone </span><span style="color:#ffa759;">[</span><span>https://github.com/NixOS/nixpkgs</span><span style="color:#ffa759;">]</span><span>(https://github.com/NixOS/nixpkgs) </span><span style="color:#ffd580;">--depth</span><span> 1
</span><span style="color:#f28779;">cd</span><span> nixpkgs
</span></code></pre>
</li>
</ul>
<h2 id="b-managing-branches-with-worktrees">B. Managing Branches with Worktrees</h2>
<ul>
<li>Use Git worktrees to manage different branches efficiently:<pre data-lang="bash" style="background-color:#212733;color:#ccc9c2;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffd580;">git</span><span> fetch</span><span style="color:#ffcc66;"> --all --prune --depth</span><span style="color:#f29e74;">=</span><span>1
</span><span style="color:#ffd580;">git</span><span> worktree add</span><span style="color:#ffcc66;"> -b</span><span> nixos-unstable nixos-unstable </span><span style="font-style:italic;color:#5c6773;"># For just unstable
</span></code></pre>
</li>
<li><strong>Explanation of <code>git worktree</code>:</strong> Allows multiple working directories attached to the same <code>.git</code> directory, sharing history and objects but with separate checked-out files.</li>
<li><code>git worktree add</code>: Creates a new working directory for the specified branch (<code>nixos-unstable</code> in this case).</li>
</ul>
</li>
</ul>
<h1 id="iv-debugging-missing-dependencies-a-practical-example">IV. Debugging Missing Dependencies: A Practical Example</h1>
<ul>
<li>
<p>Let's say you're trying to build <code>icat</code> locally and encounter a missing dependency error:</p>
<pre data-lang="nix" style="background-color:#212733;color:#ccc9c2;" class="language-nix "><code class="language-nix" data-lang="nix"><span style="color:#ffcc66;">nix-build </span><span style="color:#f29e74;">-</span><span style="color:#ffcc66;">A icat
</span><span style="font-style:italic;color:#5c6773;"># ... (Error log showing &quot;fatal error: X11/Xlib.h: No such file or directory&quot;)
</span></code></pre>
<ul>
<li>The error <code>fatal error: X11/Xlib.h: No such file or directory</code> indicates a missing X11 dependency.</li>
</ul>
<h2 id="a-online-search-with-search-nixos-org">A. Online Search with <code>search.nixos.org</code></h2>
<ul>
<li>The Nixpkgs package search website (<a href="https://search.nixos.org/packages">https://search.nixos.org/packages</a>) is a valuable first step.</li>
<li>However, broad terms like "x11" can yield many irrelevant results.</li>
<li><strong>Tip:</strong> Utilize the left sidebar to filter by package sets (e.g., "xorg").</li>
</ul>
<h2 id="b-local-source-code-search-with-rg-ripgrep">B. Local Source Code Search with <code>rg</code> (ripgrep)</h2>
<ul>
<li>
<p>Familiarity with searching the Nixpkgs source code is crucial for finding dependencies.</p>
</li>
<li>
<p>Navigate to your local <code>nixpkgs/</code> directory and use <code>rg</code>:</p>
<pre data-lang="bash" style="background-color:#212733;color:#ccc9c2;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffd580;">rg </span><span style="color:#bae67e;">&quot;x11 =&quot;</span><span> pkgs </span><span style="font-style:italic;color:#5c6773;"># Case-sensitive search
</span></code></pre>
<p><strong>Output:</strong></p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>pkgs/tools/X11/primus/default.nix
</span><span>21:  primus = if useNvidia then primusLib_ else primusLib_.override { nvidia_x11 = null; };
</span><span>22:  primus_i686 = if useNvidia then primusLib_i686_ else primusLib_i686_.override { nvidia_x11 = null; };
</span><span>
</span><span>pkgs/applications/graphics/imv/default.nix
</span><span>38:    x11 = [ libGLU xorg.libxcb xorg.libX11 ];
</span></code></pre>
</li>
<li>
<p>Refining the search (case-insensitive):</p>
<pre data-lang="bash" style="background-color:#212733;color:#ccc9c2;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffd580;">rg</span><span style="color:#ffcc66;"> -i </span><span style="color:#bae67e;">&quot;libx11 =&quot;</span><span> pkgs
</span></code></pre>
<p><strong>Output:</strong></p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span># ... (Output showing &quot;xorg.libX11&quot;)
</span></code></pre>
</li>
<li>
<p>The key result is <code>xorg.libX11</code>, which is likely the missing dependency.</p>
</li>
</ul>
</li>
</ul>
<h1 id="v-local-derivation-search-with-nix-locate">V. Local Derivation Search with <code>nix-locate</code></h1>
<ul>
<li>
<p><code>nix-locate</code> (from the <code>nix-index</code> package) allows searching for derivations on the command line.</p>
<blockquote>
<p><strong>Note:</strong> Install <code>nix-index</code> and run <code>nix-index</code> to create the initial index.</p>
</blockquote>
<pre data-lang="bash" style="background-color:#212733;color:#ccc9c2;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffd580;">nix-locate</span><span> libx11
</span><span style="font-style:italic;color:#5c6773;"># ... (Output showing paths related to libx11)
</span></code></pre>
</li>
<li>
<p>Combining online and local search tools (<code>search.nixos.org</code>, <code>rg</code>, <code>nix-locate</code>) provides a comprehensive approach to finding dependencies.</p>
</li>
</ul>
<h1 id="vi-key-benefits-of-working-with-nixpkgs-locally-recap">VI. Key Benefits of Working with Nixpkgs Locally (Recap)</h1>
<ul>
<li><strong>Speed:</strong> Faster searches and builds compared to remote operations.</li>
<li><strong>Control:</strong> Full control over the Nixpkgs version.</li>
<li><strong>Up-to-Date Information:</strong> Repository source often has the latest details.</li>
</ul>
<h1 id="vii-best-practices-and-tips-from-the-community">VII. Best Practices and Tips from the Community</h1>
<ul>
<li>
<p><strong>Rebasing over Merging:</strong> Never merge upstream changes into your local branch. Always rebase your branch onto the upstream (e.g., <code>master</code> or <code>nixos-unstable</code>) to avoid accidental large-scale pings in pull requests (Tip from <code>soulsssx3</code> on Reddit).</p>
</li>
<li>
<p><strong>Tip from <code>ElvishJErrico</code>:</strong> Avoid using Nixpkgs directly as a flake for local development due to slow copying to <code>/nix/store</code> and performance issues with garbage collection on large numbers of small files. Use <code>nix build -f . &lt;package&gt;</code> instead of <code>nix build .#&lt;package&gt;</code>.</p>
</li>
<li>
<p><strong>Edge Cases for Flake Syntax:</strong> Flake syntax might be necessary in specific scenarios, such as NixOS installer tests where copying the Git history should be avoided.</p>
</li>
<li>
<p><strong>Base Changes on <code>nixos-unstable</code>:</strong> For better binary cache hits, base your changes on the <code>nixos-unstable</code> branch instead of <code>master</code>. Consider the merge-base for staging branches as well.</p>
</li>
<li>
<p><strong>Consider <code>jujutsu</code>:</strong> Explore <code>jujutsu</code>, a Git-compatible alternative that can offer a more intuitive workflow, especially for large monorepos like Nixpkgs. While it has a learning curve, it can significantly improve parallel work and branch management.</p>
</li>
</ul>
 
    </div>

    <script defer src="https://saylesss88.github.io/elasticlunr.min.js"></script>
    <script defer>
      let index;

      fetch(`${baseUrl}/search_index.en.json`)
        .then((response) => response.json())
        .then((data) => {
          index = elasticlunr.Index.load(data);

          const searchInput = document.getElementById("search");
          const resultsContainer = document.querySelector(".search-results");
          const resultsList = document.querySelector(".search-results__items");

          searchInput.addEventListener("input", (e) => {
            const query = e.target.value.trim(); // Ensure `query` is declared inside the listener
            console.log("Search triggered with term:", query);

            if (!query || !index) {
              resultsContainer.style.display = "none";
              resultsList.innerHTML = "";
              return;
            }

            const results = index.search(query, { expand: true });
            console.log("Search results:", results);

            if (results.length > 0) {
              resultsList.innerHTML = results
                .map((result) => {
                  const ref = index.documentStore.getDoc(result.ref);
                  return `<li><a href="${ref.permalink}">${ref.title}</a></li>`;
                })
                .join("");
              resultsContainer.style.display = "block";
            } else {
              resultsList.innerHTML = "<li>No results found.</li>";
              resultsContainer.style.display = "block";
            }
          });
        })
        .catch((err) => {
          console.error("Search index failed to load:", err);
        });
    </script>
  </body>
</html>
