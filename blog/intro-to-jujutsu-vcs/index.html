<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>My-Nix-Blog</title>
    <style>
      body {
        background-color: #282828; /* Dark background */
        color: #ebdbb2; /* Light text for readability */
      }
      ul li {
        margin-bottom: 0.75em; /* Add space below each link item */
      }
    </style>
  </head>

  <body>
    <section class="section">
      <div class="container">
<h1 class="title">Intro to Jujutsu VCS</h1>
<p class="subtitle"><strong>2025-05-07</strong></p>
<h2 id="intro-to-jujutsu">Intro to Jujutsu</h2>
<ul>
<li>
<p>You can use jujutsu (jj) with existing Git repositories with one command. <code>jj git init --colocate</code> or <code>jj git init --git-repo /path/to/git_repository</code>. The native repository format for jj is still a work in progress so people typically use a <code>git</code> repository for backend.</p>
</li>
<li>
<p>Unlike <code>git</code>, <code>jj</code> has no index "staging area". It treats the working copy as an actual commit. When you make changes to files, these changes are automatically recorded to the working commit. There's no need to explicitly stage changes because they are already part of the commit that represents your current working state.</p>
<ul>
<li>This means that you don't need to worry about making a change, running <code>git add .</code>, running <code>git commit -m "commit message"</code> because it's already done for you. This is handy with flakes by preventing a "dirty working tree" and can instantly be rebuilt after making a change.</li>
</ul>
</li>
</ul>
<p>Here's an example:</p>
<p>Say I have my configuration flake in the <code>~/flakes/</code> directory that is an existing Git repository. To use JJ as the front-end I could do something like:</p>
<pre data-lang="bash" style="background-color:#282828;color:#fdf4c1aa;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#fabd2f;">cd </span><span style="color:#fdf4c1;">~/flakes
</span><span style="color:#fdf4c1;">jj git init --colocate
</span><span style="color:#fdf4c1;">jj describe -m </span><span style="color:#b8bb26;">&quot;first jj commit&quot;
</span><span style="color:#fdf4c1;">jj commit
</span></code></pre>
<p>Or to do this in a directory that isn't already a git repo you can do something like:</p>
<pre data-lang="bash" style="background-color:#282828;color:#fdf4c1aa;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#fdf4c1;">cargo new hello-world --vcs</span><span style="color:#fe8019;">=</span><span style="color:#fdf4c1;">none
</span><span style="color:#fabd2f;">cd</span><span style="color:#fdf4c1;"> hello-world
</span><span style="color:#fdf4c1;">jj git init
</span><span style="color:#fdf4c1;">Initialized repo in </span><span style="color:#b8bb26;">&quot;.&quot;
</span></code></pre>
<p>Or for example, with Git if you wanted to move to a different branch before running <code>nix flake update</code> to see if it introduced errors before merging with your main branch, you could do something like:</p>
<pre data-lang="bash" style="background-color:#282828;color:#fdf4c1aa;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#fdf4c1;">git checkout -b update-test
</span><span>
</span><span style="color:#fdf4c1;">nix flake update
</span><span>
</span><span style="color:#fdf4c1;">sudo nixos-rebuild test --flake .
</span></code></pre>
<p>If you're satisfied you can merge:</p>
<pre data-lang="bash" style="background-color:#282828;color:#fdf4c1aa;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#fdf4c1;">git checkout main
</span><span style="color:#fdf4c1;">git add . </span><span style="font-style:italic;color:#928374;"># Stage the change
</span><span style="color:#fdf4c1;">git commit -m </span><span style="color:#b8bb26;">&quot;update&quot;
</span><span style="color:#fdf4c1;">git branch -D update-test
</span><span style="color:#fdf4c1;">git merge update-test
</span><span style="color:#fdf4c1;">sudo nixos-rebuild switch --flake .
</span></code></pre>
<p>With JJ a similar workflow could be:</p>
<pre data-lang="bash" style="background-color:#282828;color:#fdf4c1aa;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#fdf4c1;">jj new  </span><span style="font-style:italic;color:#928374;"># Create a new child commit/start working on a new change
</span><span style="color:#fdf4c1;">nix flake update
</span><span style="color:#fdf4c1;">sudo nixos-rebuild test --flake .
</span><span style="color:#fdf4c1;">jj squash </span><span style="font-style:italic;color:#928374;">#  equivalent to `git commit -a --amend`
</span><span style="color:#fdf4c1;">jj describe -m </span><span style="color:#b8bb26;">&quot;update&quot; </span><span style="font-style:italic;color:#928374;"># Similar to git commit -m
</span><span style="color:#fdf4c1;">jj commit </span><span style="font-style:italic;color:#928374;"># Finalize the commit
</span><span style="color:#fdf4c1;">sudo nixos-rebuild switch --flake .
</span></code></pre>
<ul>
<li>
<p>With <code>jj</code> you're creating a new commit rather than a new branch.</p>
</li>
<li>
<p>Amending vs. Squashing: Git's <code>git commit --amend</code> updates the last commit. <code>jj squash</code> combines the current commit with its parent, effectively doing the same thing in terms of history.</p>
</li>
<li>
<p>Merging: Git's merge command is explicit. In <code>jj</code>, the concept is similar, but since there's no branch, you're "merging" by moving your working commit to include these changes. The <code>jj squash</code> here acts like merging the changes into the main line of development.</p>
</li>
<li>
<p>No need to delete branches: Since there are no branches in <code>jj</code>, there's no equivalent to <code>git branch -D</code> to clean up. Instead commits that are no longer needed can be "abandoned" with <code>jj abandon</code> if you want to clean up your commit graph.</p>
</li>
<li>
<p><code>jj describe</code> without a flag just opens <code>$EDITOR</code> where you can write your commit message save and exit.</p>
</li>
<li>
<p>In <code>git</code>, we finish a set of changes to our code by committing, but in <code>jj</code> we start new work by creating a change, and <em>then</em> make changes to our code. It's more useful to write an initial description of your intended changes, and then refine it as you work, than it is creating a commit message after the fact.</p>
</li>
<li>
<p>I have heard that jj can struggle with big repositories such as Nixpkgs and have noticed
some issues here and there when using with NixOS. I'm hoping that as the project matures,
it gets better on this front.</p>
</li>
<li>
<p>This is just the start of what is possible, here are some resources about it if you're interested:</p>
</li>
<li>
<p><a href="https://github.com/jj-vcs/jj">jj_github</a></p>
</li>
<li>
<p><a href="https://jj-vcs.github.io/jj/latest/tutorial/">official_tutorial</a></p>
</li>
<li>
<p><a href="https://v5.chriskrycho.com/essays/jj-init/">jj_init</a> # very good article</p>
</li>
<li>
<p><a href="https://steveklabnik.github.io/jujutsu-tutorial/">steves_jj_tutorial</a> # this is recommended by the official docs.</p>
</li>
</ul>
 </div>
    </section>
  </body>
</html>
