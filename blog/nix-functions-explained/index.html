<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>My-Nix-Blog</title>
    <style>
      body {
        background-color: #282828; /* Dark background */
        color: #ebdbb2; /* Light text for readability */
      }
      ul li {
        margin-bottom: 0.75em; /* Add space below each link item */
      }

     /* style for inline code blocks */
      :not(pre) > code {
        font-family: monospace, monospace; /* Use a monospace font */
        font-size: 0.85em; /* Slightly smaller font size can help */
        background-color: #444444; /* A slightly lighter dark background */
        color: #f8f8f2; /* A common light code text color (like Monokai) */
        padding: 2px 5px; /* Add some padding around the text */
        border-radius: 3px; /* Slightly rounded corners */
        border: 1px solid #666666; /* Optional: Add a subtle border */
      }
    </style>
    <link rel="stylesheet" type="text/css" href="https://saylesss88.github.io/static/syntax-theme-dark.css" media="(prefers-color-scheme: dark)" />
    <link rel="stylesheet" type="text/css" href="https://saylesss88.github.io/static/syntax-theme-light.css" media="(prefers-color-scheme: light)" />
  </head>

  <body>
    <section class="section">
      <div class="container">
<h1 class="title">Nix Functions Explained</h1>
<p class="subtitle"><strong>2025-05-05</strong></p>
<h2 id="nix-functions">Nix Functions</h2>
<p>Functions are all over Nix Code and an important concept to grasp to start understanding Nix.</p>
<p>In Nix, all functions conceptually take exactly one argument. Multi-argument functions are done through a series of nested single-argument functions (currying).</p>
<p>Argument and function body are separated by a colon (<code>:</code>).</p>
<p>Wherever you find a colon (<code>:</code>) in Nix code:</p>
<ul>
<li>
<p>On its left is the function argument</p>
</li>
<li>
<p>On its right is the function body. The "function body" is the expression evaluated when the function is called.</p>
</li>
<li>
<p>Function arguments are another way to assign names to values. Values aren't known in advance: the names are placeholders that are filled when calling the function.</p>
</li>
</ul>
<p>For example:</p>
<pre data-lang="nix" style="background-color:#212733;color:#ccc9c2;" class="language-nix "><code class="language-nix" data-lang="nix"><span style="color:#ffcc66;">greet </span><span style="color:#ff3333;">= </span><span style="color:#ffcc66;">personName</span><span>: </span><span style="color:#bae67e;">&quot;Hello, </span><span style="font-style:italic;color:#ccc9c2;">${</span><span style="font-style:italic;color:#ffcc66;">personName</span><span style="font-style:italic;color:#ccc9c2;">}</span><span style="color:#bae67e;">!&quot;
</span></code></pre>
<ul>
<li>
<p>In the above example <code>personName</code> is a placeholder (the argument name).</p>
</li>
<li>
<p>The actual value for <code>personName</code> is provided when you call the function:</p>
</li>
</ul>
<pre data-lang="nix" style="background-color:#212733;color:#ccc9c2;" class="language-nix "><code class="language-nix" data-lang="nix"><span style="color:#ffcc66;">greet </span><span style="color:#bae67e;">&quot;Anonymous&quot;   </span><span style="font-style:italic;color:#5c6773;"># Evaluates to &quot;Hello, Anonymous!&quot;
</span></code></pre>
<h2 id="function-declarations">Function Declarations</h2>
<ul>
<li>Single argument</li>
</ul>
<pre data-lang="nix" style="background-color:#212733;color:#ccc9c2;" class="language-nix "><code class="language-nix" data-lang="nix"><span style="color:#ffcc66;">inc </span><span style="color:#ff3333;">= </span><span style="color:#ffcc66;">x</span><span>: </span><span style="color:#ffcc66;">x </span><span style="color:#f29e74;">+ </span><span style="color:#ffcc66;">1
</span><span style="color:#ffcc66;">inc 5  </span><span style="font-style:italic;color:#5c6773;"># Evaluates to 6
</span></code></pre>
<ul>
<li>
<p>Multiple arguments via nesting (currying)</p>
</li>
<li>
<p>Currying is the process of transforming a function with multiple arguments into a sequence of functions each taking a single argument.</p>
</li>
</ul>
<pre data-lang="nix" style="background-color:#212733;color:#ccc9c2;" class="language-nix "><code class="language-nix" data-lang="nix"><span style="color:#ffcc66;">concat </span><span style="color:#ff3333;">= </span><span style="color:#ffcc66;">x</span><span>: </span><span style="color:#ffcc66;">y</span><span>: </span><span style="color:#ffcc66;">x </span><span style="color:#f29e74;">+ </span><span style="color:#ffcc66;">y
</span><span style="color:#ffcc66;">concat 6 6   </span><span style="font-style:italic;color:#5c6773;"># Evaluates to 12
</span></code></pre>
<ul>
<li>Nix sees the colons as separators for single-argument functions that return other functions.</li>
</ul>
<pre data-lang="nix" style="background-color:#212733;color:#ccc9c2;" class="language-nix "><code class="language-nix" data-lang="nix"><span style="color:#ffcc66;">greeting </span><span style="color:#ff3333;">= </span><span style="color:#ffcc66;">prefix</span><span>: </span><span style="color:#ffcc66;">name</span><span>: </span><span style="color:#bae67e;">&quot;</span><span style="font-style:italic;color:#ccc9c2;">${</span><span style="font-style:italic;color:#ffcc66;">prefix</span><span style="font-style:italic;color:#ccc9c2;">}</span><span style="color:#bae67e;">, </span><span style="font-style:italic;color:#ccc9c2;">${</span><span style="font-style:italic;color:#ffcc66;">name</span><span style="font-style:italic;color:#ccc9c2;">}</span><span style="color:#bae67e;">!&quot;</span><span style="color:#ff3333;">;
</span></code></pre>
<p>Think of this as a chain of single-argument functions:</p>
<ol>
<li>Outer Function: <code>prefix: (name: "${prefix}, ${name}!")</code></li>
</ol>
<ul>
<li>
<p>This function takes one argument, <code>prefix</code>.</p>
</li>
<li>
<p>Its body is the definition of another function.</p>
</li>
</ul>
<ol start="2">
<li>Inner Function: <code>name: "${prefix}, ${name}!"</code></li>
</ol>
<ul>
<li>
<p>This function (which is the result of the outer function) takes one argument, <code>name</code>.</p>
</li>
<li>
<p>Its body is the string interpolation, which can still access the <code>prefix</code> from the outer function's scope.</p>
</li>
</ul>
<p>Step-by-Step Evaluation of this Multi-Argument Call:</p>
<p>When you write <code>greeting "Hello" "Alice"</code>, Nix evaluates it like this:</p>
<ol>
<li><code>greeting "Hello"</code></li>
</ol>
<ul>
<li>
<p>The <code>greeting</code> function is called with the argument <code>"Hello"</code>.</p>
</li>
<li>
<p>The outer function <code>prefix: ...</code> is executed, with <code>prefix</code> being assigned <code>"Hello"</code>.</p>
</li>
<li>
<p>The result of this execution is the <em>inner</em> function: <code>name: "Hello, ${name}!"</code></p>
</li>
</ul>
<ol start="2">
<li><code>(greeting "Hello") "Alice"</code>:</li>
</ol>
<ul>
<li>
<p>The result of the first step (the inner function) is now called with the argument <code>"Alice"</code>.</p>
</li>
<li>
<p>The inner function <code>name: "Hello, ${name}!"</code> is executed, with <code>name</code> being assigned <code>"Alice"</code>.</p>
</li>
<li>
<p>The body <code>"Hello, ${name}!"</code> is evaluated, resulting in <code>"Hello, Alice!"</code></p>
</li>
</ul>
<blockquote>
<p>Every colon you see in a function definition separates a single argument (on its left) from its corresponding function body (on its right). Even when the body is another function definition.</p>
</blockquote>
<ul>
<li>
<p>In <code>x: x + 1</code>: One argument <code>x</code>, One colon, &amp; one body <code>x + 1</code></p>
</li>
<li>
<p>In <code>prefix: name: "${prefix}, ${name}!"</code>: The first colon separates <code>prefix</code> from the rest (<code>name: "${prefix}, ${name}!"</code>), which is the body of the first function. The second colon separates <code>name</code> (the argument of the inner function) from its body (<code>"${prefix}, ${name}!"</code>).</p>
</li>
</ul>
<h3 id="partial-application">Partial Application</h3>
<p>Because Nix functions are curried, you can apply arguments one at a time. This is known as partial application. When you apply a function to some, but not all, of its expected arguments, you get a new function that "remembers" the arguments you've already provided and is waiting for the remaining ones.</p>
<p>Revisiting our <code>greeting</code> function:</p>
<pre data-lang="nix" style="background-color:#212733;color:#ccc9c2;" class="language-nix "><code class="language-nix" data-lang="nix"><span style="color:#ffcc66;">greeting </span><span style="color:#ff3333;">= </span><span style="color:#ffcc66;">prefix</span><span>: </span><span style="color:#ffcc66;">name</span><span>: </span><span style="color:#bae67e;">&quot;</span><span style="font-style:italic;color:#ccc9c2;">${</span><span style="font-style:italic;color:#ffcc66;">prefix</span><span style="font-style:italic;color:#ccc9c2;">}</span><span style="color:#bae67e;">, </span><span style="font-style:italic;color:#ccc9c2;">${</span><span style="font-style:italic;color:#ffcc66;">name</span><span style="font-style:italic;color:#ccc9c2;">}</span><span style="color:#bae67e;">!&quot;</span><span style="color:#ff3333;">;
</span></code></pre>
<p>If we only provide the <code>prefix</code>:</p>
<pre data-lang="nix" style="background-color:#212733;color:#ccc9c2;" class="language-nix "><code class="language-nix" data-lang="nix"><span style="color:#ffcc66;">helloGreeting </span><span style="color:#ff3333;">= </span><span style="color:#ffcc66;">greeting </span><span style="color:#bae67e;">&quot;Hello&quot;</span><span style="color:#ff3333;">;
</span></code></pre>
<ul>
<li><code>helloGreeting</code> is a new function that partially applies our <code>greeting</code> function. This new function only requires a single argument.</li>
</ul>
<pre data-lang="nix" style="background-color:#212733;color:#ccc9c2;" class="language-nix "><code class="language-nix" data-lang="nix"><span style="color:#ffcc66;">helloGreeting </span><span style="color:#bae67e;">&quot;Sally&quot;  </span><span style="font-style:italic;color:#5c6773;"># Evaluates to &quot;Hello, Sally!&quot;
</span></code></pre>
<ul>
<li>
<p>Partial application can be used for creating specialized functions. This allows you to create more specific functions from more general ones by fixing some of their arguments.</p>
</li>
<li>
<p>Many higher-order functions (functions that take other functions as arguments, like <code>map</code> or <code>filter</code>) expect functions with a specific number of arguments. Partial application allows you to adapt existing functions to fit these expectations by pre-filling some of their parameters.</p>
</li>
</ul>
<h3 id="most-nixos-and-home-manager-modules-are-actually-functions">Most NixOS and home-manager modules are actually functions</h3>
<p>It's important to recognize that the function paradigm is central to how NixOS and Home Manager modules are structured. Most NixOS and Home Manager modules are fundamentally functions.</p>
<ul>
<li>These module functions typically accept a single argument, an attribute set.</li>
</ul>
<p>For example, a simplified service module could be:</p>
<pre data-lang="nix" style="background-color:#212733;color:#ccc9c2;" class="language-nix "><code class="language-nix" data-lang="nix"><span>{ </span><span style="color:#ffcc66;">config</span><span style="color:#f29e74;">, </span><span style="color:#ffcc66;">lib</span><span style="color:#f29e74;">, </span><span style="color:#ffcc66;">pkgs</span><span style="color:#f29e74;">, ... </span><span>}: {
</span><span>  </span><span style="color:#ffd580;">services</span><span>.</span><span style="color:#ffd580;">nginx</span><span>.</span><span style="color:#ffd580;">enable </span><span style="color:#f29e74;">= </span><span style="color:#ffcc66;">true</span><span style="color:#ccc9c2cc;">;
</span><span>  </span><span style="color:#ffd580;">services</span><span>.</span><span style="color:#ffd580;">nginx</span><span>.</span><span style="color:#ffd580;">package </span><span style="color:#f29e74;">= </span><span style="color:#ffcc66;">pkgs</span><span style="color:#f29e74;">.</span><span style="color:#ffcc66;">nginx</span><span style="color:#ccc9c2cc;">;
</span><span>  </span><span style="color:#ffd580;">services</span><span>.</span><span style="color:#ffd580;">nginx</span><span>.</span><span style="color:#ffd580;">settings</span><span>.</span><span style="color:#ffd580;">http-port </span><span style="color:#f29e74;">= </span><span style="color:#bae67e;">&quot;8080&quot;</span><span style="color:#ccc9c2cc;">;
</span><span>}
</span></code></pre>
<ul>
<li>
<p>Here, the entire module is a function that takes one argument: <code>{ config, lib, pkgs, ... }</code>.</p>
</li>
<li>
<p>When you add this module to your configuration, the module system calls this function with a specific attribute set containing the current configuration, the Nix library (<code>lib</code>), the available packages (<code>pkgs</code>), and other relevant info.</p>
</li>
</ul>
<h4 id="resources">Resources</h4>
<ul>
<li>
<p><a href="https://nix.dev/tutorials/nix-language.html">nix.dev Nix Lang Basics</a></p>
</li>
<li>
<p><a href="https://nixos.org/guides/nix-pills/05-functions-and-imports.html">nix pills Functions and Imports</a></p>
</li>
<li>
<p><a href="https://zero-to-nix.com/concepts/nix-language/">zero-to-nix Nix Lang</a></p>
</li>
<li>
<p><a href="https://nixcloud.io/tour/?id=functions%2Fintroduction">A tour of Nix "Functions"</a></p>
</li>
<li>
<p><a href="https://learnxinyminutes.com/nix/">learn Nix in y minutes</a></p>
</li>
<li>
<p><a href="https://noogle.dev/">noogle function library</a></p>
</li>
</ul>
 </div>
    </section>
  </body>
</html>
