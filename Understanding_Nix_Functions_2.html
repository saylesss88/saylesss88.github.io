<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Understanding Nix Functions - nix-book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <a href="#" class="top-link" id="back-to-top">↑</a>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">nix-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-2"><a class="header" href="#chapter-2">Chapter 2</a></h1>
<!--toc:start-->
<ul>
<li><a href="#understanding-nix-functions">Understanding Nix Functions</a></li>
<li><a href="#what-are-nix-functions">What are Nix Functions?</a></li>
<li><a href="#understanding-function-structure-the-role-of-the-colon">Understanding Function Structure: The Role of the Colon</a></li>
<li><a href="#declaring-functions-single-and-simulated-multiple-arguments">Declaring Functions: Single and Simulated "Multiple" Arguments</a></li>
<li><a href="#nix-functions-being-first-class-citizens">Nix Functions being "first class citizens"</a>
<ul>
<li><a href="#the-function-nature-of-nixos-and-home-manager-modules">The Function Nature of NixOS and Home Manager Modules</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#resources">Resources</a></li>
</ul>
<!--toc:end-->
<h2 id="understanding-nix-functions"><a class="header" href="#understanding-nix-functions">Understanding Nix Functions</a></h2>
<img src="images/nixLogo.png" width="400" height="300">
<p><strong>Functions</strong> are the building blocks of Nix, appearing everywhere in Nix
expressions and configurations. Mastering them is essential for writing
effective Nix code and understanding tools like NixOS and Home Manager.
This chapter explores how Nix functions work, focusing on their single-argument
nature, currying, partial application, and their role in modules.</p>
<h2 id="what-are-nix-functions"><a class="header" href="#what-are-nix-functions">What are Nix Functions?</a></h2>
<p>A <strong>Nix Function</strong> is a rule that takes an input (called an <strong>argument</strong>) and
produces an output based on that input. Unlike many programming languages, Nix
functions are designed to take exactly one argument at a time. This unique
approach, combined with a technique called currying, allows Nix to simulate
multi-argument functions in a flexible and reusable way.</p>
<ul>
<li><a href="https://nix.dev/manual/nix/2.26/language/operators">nix.dev Function Reference</a></li>
</ul>
<h2 id="builtins"><a class="header" href="#builtins">Builtins</a></h2>
<details>
<summary> ✔️ Nix Builtin Functions (Click to Expand)</summary>
<p>The Nix expression evaluator has a bunch of functions and constants built in:</p>
<ul>
<li>
<p><code>toString e</code>: (Convert the expression <code>e</code> to a string)</p>
</li>
<li>
<p><code>import path</code>: (Load, parse and return the Nix expression in the file <code>path</code>)</p>
</li>
<li>
<p><code>throw x</code>: (Throw an error message <code>x</code>. Usually stops evaluation)</p>
</li>
<li>
<p><code>map f list</code>: (Apply the function <code>f</code> to each element in the <code>list</code>)</p>
</li>
<li>
<p><a href="https://nix.dev/manual/nix/2.18/language/builtins">Built-in Functions</a></p>
</li>
<li>
<p><a href="https://nix.dev/manual/nix/2.26/language/operators">Nix Operators</a></p>
</li>
</ul>
</details>
<p>First I wanted to explain the structure of Nix Functions, and then we will talk
about their "first-class" nature in Nix.</p>
<h2 id="understanding-function-structure-the-role-of-the-colon"><a class="header" href="#understanding-function-structure-the-role-of-the-colon">Understanding Function Structure: The Role of the Colon</a></h2>
<p>The colon (<code>:</code>) acts as a clear separator within a function definition:</p>
<details>
  <summary> ✔️ Click to expand this section</summary>
<ul>
<li>
<p><strong>Left of the Colon:</strong> This is the function's <strong>argument</strong>. It's a placeholder
name for a value that will be provided when the function is called.</p>
</li>
<li>
<p><strong>Right of the Colon:</strong> This is the <strong>function body</strong>. It's the expression
that will be evaluated when the function is invoked.</p>
</li>
</ul>
<p><strong>Think of function arguments as naming values that aren't known in advance.</strong>
These names are placeholders that get filled with specific values when the
function is used.</p>
</details>
<p><strong>Example:</strong></p>
<pre><code class="language-nix">greet = personName: "Hello, ${personName}!";
</code></pre>
<ul>
<li>
<p>Here, <code>personName</code> is the <strong>argument</strong> (the placeholder).</p>
</li>
<li>
<p><code>"Hello, ${personName}!"</code>, is the <strong>function body</strong> (which uses the placeholder
to create the greeting).</p>
</li>
</ul>
<p>When you call the function, (click to see Output):</p>
<pre><code class="language-nix">greet "Anonymous"
<span class="boring"> "Hello, Anonymous!"
</span></code></pre>
<ul>
<li>
<p>The value <code>"Anonymous"</code> is substituted for the <code>personName</code> placeholder within
the function body.</p>
</li>
<li>
<p>This structure is the foundation of all Nix functions, whether simple or
complex.</p>
</li>
</ul>
<h2 id="declaring-functions-single-and-simulated-multiple-arguments"><a class="header" href="#declaring-functions-single-and-simulated-multiple-arguments">Declaring Functions: Single and Simulated "Multiple" Arguments</a></h2>
<p><strong>Single-Argument Functions</strong>: The Basics</p>
<p>The simplest form of a Nix function takes a single argument. In Nix, function
definitions like <code>x: x + 1</code> or <code>personName: "Hello, ${personName}!";</code> are
<strong>anonymous lambda functions</strong>. They exist as values until they are assigned
to a variable.</p>
<ul>
<li>Click to see Output:</li>
</ul>
<pre><code class="language-nix"># This is an anonymous lambda function value:
# x: x + 1
inc = x: x + 1;          # here we assigned our lambda to a variable `inc`
inc 5
<span class="boring"> 6
</span></code></pre>
<ul>
<li>
<p><code>x</code> is the argument.</p>
</li>
<li>
<p><code>x + 1</code> is the function body.</p>
</li>
<li>
<p>This straightforward design makes single-argument functions easy to understand
and use. But what if you need a function that seems to take multiple arguments?
That's where <strong>currying</strong> comes in.</p>
</li>
</ul>
<p><strong>Simulating Multiple Arguments: Currying</strong></p>
<p>To create functions that appear to take multiple arguments, Nix uses currying.
This involves nesting single-argument functions, where each function takes one
argument and returns another function that takes the next argument, and so on.</p>
<ul>
<li>Click to see Output:</li>
</ul>
<pre><code class="language-nix"># concat is equivalent to:
# concat = x: (y: x + y);
concat = x: y: x + y;
concat 6 6    # Evaluates to 12
<span class="boring"> 12
</span></code></pre>
<p>Here, <code>concat</code> is actually <strong>two nested functions</strong></p>
<ol>
<li>
<p>The <strong>first function</strong> takes <code>x</code> and returns another function.</p>
</li>
<li>
<p>The <strong>second function</strong> takes <code>y</code> and performs <code>x + y</code></p>
</li>
</ol>
<p>Nix interprets the colons (<code>:</code>) as separators for this chain of single-argument
functions.</p>
<p>Here's how it works step by step:</p>
<ul>
<li>
<p>When you call <code>concat 6</code>, the outer function binds <code>x</code> to <code>6</code> and returns a
new function: <code>y: 6 + y</code>.</p>
</li>
<li>
<p>When you call that function with <code>6</code> (i.e., <code>concat 6 6</code>), it computes <code>6 + 6</code>,
resulting in <code>12</code>.</p>
</li>
</ul>
<p>This chaining is why Nix functions are so powerful—it allows you to build
flexible, reusable functions.</p>
<p><strong>A More Practical Example: Greetings</strong>:</p>
<p>Let's explore currying with a more relatable example in the <code>nix repl</code>:</p>
<pre><code class="language-nix">nix repl
nix-repl&gt; greeting = prefix: name: "${prefix}, ${name}!";

nix-repl&gt; greeting "Hello"
&lt;&lt;lambda @ &lt;&lt;string&gt;&gt;:1:10&gt;&gt; # partial application returns a lambda

nix-repl&gt; greeting "Hello" "Alice"
"Hello, Alice!"         # providing both arguments returns the expected result
</code></pre>
<p>This function is a chain of two single-argument functions:</p>
<ol>
<li>
<p>The outer function takes <code>prefix</code> (e.g. <code>"Hello"</code>) and returns a function that
expects <code>name</code>.</p>
</li>
<li>
<p>The inner function takes <code>name</code> (e.g. <code>"Alice"</code>) and combines it with <code>prefix</code>
to produce the final string.</p>
</li>
</ol>
<p>Thanks to <strong>lexical scope</strong> (where inner functions can access variables from
outer functions), the inner function "remembers" the <code>prefix</code> value.</p>
<p><strong>Why Currying Matters</strong></p>
<ul>
<li>
<p>You can partially apply arguments and reuse functions.</p>
</li>
<li>
<p>The "first-class" aspect of Nix Functions, explained further down.</p>
</li>
<li>
<p>It can help break down complex logic into smaller, manageable functions.</p>
</li>
</ul>
<p><strong>Key Insight</strong>: Every colon in a function definition separates a <strong>single
argument</strong> from its <strong>function body</strong>, even if that body is another function
definition.</p>
<p><strong>Partial Application: Using Functions Incrementally</strong></p>
<details>
<summary> ✔️ Partial Application (Click to Expand)</summary>
<p>Because of <strong>currying</strong>, you can apply arguments to a Nix function one at a time.
This is called <em>partial application</em>. When you provide only some of the expected
arguments, you get a new function that "remembers" the provided arguments and
waits for the rest.</p>
<p><strong>Example:</strong></p>
<p>Using our <code>greeting</code> function again:</p>
<pre><code class="language-nix">nix repl
nix-repl&gt; greeting = prefix: name: "${prefix}, ${name}!";
nix-repl&gt; helloGreeting = greeting "Hello";
nix-repl&gt; helloGreeting "Alice"
"Hello, Alice"
</code></pre>
<ul>
<li><code>helloGreeting</code> is now a new function. It has already received the <code>prefix</code>
argument (<code>"Hello"</code>), when we provide the second argument we get <code>"Hello, Alice!"</code></li>
</ul>
<p><strong>Benefits of Partial Application:</strong></p>
<ul>
<li>
<p><strong>Creating Specialized Functions</strong>: You can create more specific functions
from general ones by fixing some of their parameters.</p>
</li>
<li>
<p><strong>Adapting to Higher-Order Functions</strong>: Many functions that operate on other
functions (like <code>map</code> and <code>filter</code>) expect functions with a certain number of
arguments. Partial application allows you to adapt existing functions to fit
these requirements.</p>
</li>
</ul>
</details>
<h2 id="nix-functions-being-first-class-citizens"><a class="header" href="#nix-functions-being-first-class-citizens">Nix Functions being "first class citizens"</a></h2>
<p>In the context of Nix, the phrase "Nix treats functions as first-class citizens"
means that functions in Nix are treated as values, just like numbers, strings,
or lists. They can be manipulated, passed around, and used in the same flexible
ways as other data types. This concept comes from functional programming and
has specific implications in Nix.</p>
<p><strong>What It Means in Nix</strong></p>
<ol>
<li>Functions Can Be Assigned to Variables:</li>
</ol>
<ul>
<li>
<p>You can store a function in a variable, just like you would store a number
or string.</p>
</li>
<li>
<p>Example:</p>
</li>
</ul>
<pre><code class="language-nix">greet = name: "Hello, ${name}!";
Here, greet is a variable that holds a function.
</code></pre>
<ol start="2">
<li>Functions Can Be Passed as Arguments:</li>
</ol>
<ul>
<li>
<p>You can pass a function to another function as an argument, allowing for
higher-order functions (functions that operate on other functions).</p>
</li>
<li>
<p>Example:</p>
</li>
</ul>
<pre><code class="language-nix">applyTwice = f: x: f (f x);
inc = x: x + 1;
applyTwice inc 5 # Output: 7 (increments 5 twice: 5 → 6 → 7)
<span class="boring"> 7
</span></code></pre>
<ul>
<li>Here, applyTwice takes a function <code>f</code> (in this case, <code>inc</code>) and applies it to
<code>x</code> twice.</li>
</ul>
<ol start="3">
<li>Functions Can Be Returned from Functions:</li>
</ol>
<ul>
<li>
<p>Functions can produce other functions as their output, which is key to
currying in Nix.</p>
</li>
<li>
<p>Example:</p>
</li>
</ul>
<pre><code class="language-nix">greeting = prefix: name: "${prefix}, ${name}!";
helloGreeting = greeting "Hello";  # Returns a function
helloGreeting "Alice"  # Output: "Hello, Alice!"
<span class="boring"> "Hello, Alice!"
</span></code></pre>
<ul>
<li>The greeting function returns another function when partially applied with
prefix.</li>
</ul>
<ol start="4">
<li>Functions Are Values in Expressions:</li>
</ol>
<ul>
<li>
<p>Functions can be used anywhere a value is expected, such as in attribute sets or lists.</p>
</li>
<li>
<p>Example:</p>
</li>
</ul>
<pre><code class="language-nix">myFuncs = {
  add = x: y: x + y;
  multiply = x: y: x * y;
};
myFuncs.add 3 4  # Output: 7
<span class="boring"> 7
</span></code></pre>
<ul>
<li>
<p>Here, functions are stored as values in an attribute set.</p>
</li>
<li>
<p>To try this in the <code>repl</code> just remove the semi-colon (<code>;</code>)</p>
</li>
</ul>
<p><strong>Why This Matters in Nix</strong>:</p>
<ul>
<li>
<p>This functional approach is fundamental to Nix's unique build system. In Nix,
<strong>package builds (called derivations)</strong> are essentially functions. They take
specific inputs (source code, dependencies, build scripts) and deterministically
produce outputs (a built package).</p>
<ul>
<li>This design ensures <strong>atomicity</strong>: if a build does not succeed completely
and perfectly, it produces no output at all. This prevents situations common
in other package managers where partial updates or corrupted builds can leave
your system in an inconsistent or broken state.</li>
</ul>
</li>
<li>
<p>It increases the flexibility of Functions making them very powerful.</p>
</li>
<li>
<p>Many NixOS and Home Manager modules are functions, and their first-class
status means they can be combined, reused, or passed to other parts of the
configuration system.</p>
</li>
<li>
<p>Now that we understand the "first-class" nature of Nix Functions let's see how
they fit into NixOS and Home Manager modules.</p>
</li>
</ul>
<h3 id="the-function-nature-of-nixos-and-home-manager-modules"><a class="header" href="#the-function-nature-of-nixos-and-home-manager-modules">The Function Nature of NixOS and Home Manager Modules</a></h3>
<p>It's crucial to understand that most NixOS and Home Manager modules are
fundamentally <strong>functions</strong>.</p>
<ul>
<li>These module functions typically accept a single argument: an
<strong>attribute set</strong>.</li>
</ul>
<p><strong>Example</strong>:</p>
<p>A NixOS module to enable Thunar with some plugins that I'm actually using right
now:</p>
<pre><code class="language-nix">{pkgs, ...}: {
  programs = {
    thunar = {
      enable = true;
      plugins = with pkgs.xfce; [
        thunar-archive-plugin
        thunar-volman
      ];
    };
  };
}
</code></pre>
<ul>
<li>
<p>The entire module definition is a function that takes one argument (an
attribute set):
<code>{ pkgs, ... }</code>.</p>
</li>
<li>
<p>When this module is included in your configuration, the NixOS module system
calls this function with a specific attribute set. This attribute set contains
the available packages (<code>pkgs</code>), and other relevant information. The module
then uses these values to define parts of your system.</p>
</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Having explored the fundamental nature of functions in Nix, we can now see
this concept applies to more complex areas like NixOS configuration. In the next
chapter, <a href="https://saylesss88.github.io/NixOS_Modules_Explained_3.html">NixOS Modules Explained</a>.
We will learn about NixOS Modules which are themselves functions most of the
time.</p>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<details>
<summary> ✔️ Resources (Click to Expand) </summary>
<ul>
<li>
<p><a href="https://nix.dev/tutorials/nix-language.html">nix.dev Nix Lang Basics</a></p>
</li>
<li>
<p><a href="https://nixos.org/guides/nix-pills/05-functions-and-imports.html">nix pills Functions and Imports</a></p>
</li>
<li>
<p><a href="https://zero-to-nix.com/concepts/nix-language/">zero-to-nix Nix Lang</a></p>
</li>
<li>
<p><a href="https://nixcloud.io/tour/?id=functions%2Fintroduction">A tour of Nix "Functions"</a></p>
</li>
<li>
<p><a href="https://learnxinyminutes.com/nix/">learn Nix in y minutes</a></p>
</li>
<li>
<p><a href="https://noogle.dev/">noogle function library</a></p>
</li>
</ul>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Getting_Started_with_Nix_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="NixOS_Modules_Explained_3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Getting_Started_with_Nix_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="NixOS_Modules_Explained_3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
