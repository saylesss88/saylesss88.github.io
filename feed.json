{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "nix-book",
  "home_page_url": "https://saylesss88.github.io/",
  "feed_url": "https://saylesss88.github.io/feed.json",
  "description": "An mdBook-generated site",
  "items": [
    {
      "id": "https://saylesss88.github.io/index.html",
      "url": "https://saylesss88.github.io/index.html",
      "title": "index",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/nix/nix_language.html",
      "url": "https://saylesss88.github.io/nix/nix_language.html",
      "title": "nix_language",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/nix/nix_package_manager.html",
      "url": "https://saylesss88.github.io/nix/nix_package_manager.html",
      "title": "nix_package_manager",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/installation/index.html",
      "url": "https://saylesss88.github.io/installation/index.html",
      "title": "README",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/nix/encrypted_zfs.html",
      "url": "https://saylesss88.github.io/nix/encrypted_zfs.html",
      "title": "encrypted_zfs",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/nix/zfs_impermanence.html",
      "url": "https://saylesss88.github.io/nix/zfs_impermanence.html",
      "title": "zfs_impermanence",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/nix/hardening_NixOS.html",
      "url": "https://saylesss88.github.io/nix/hardening_NixOS.html",
      "title": "hardening_NixOS",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/nix/hardening_networking.html",
      "url": "https://saylesss88.github.io/nix/hardening_networking.html",
      "title": "hardening_networking",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/nix/browsing_security.html",
      "url": "https://saylesss88.github.io/nix/browsing_security.html",
      "title": "browsing_security",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/nix/gpg-agent.html",
      "url": "https://saylesss88.github.io/nix/gpg-agent.html",
      "title": "gpg-agent",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/nix/index.html",
      "url": "https://saylesss88.github.io/nix/index.html",
      "title": "README",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/nix/whonix_kvm.html",
      "url": "https://saylesss88.github.io/nix/whonix_kvm.html",
      "title": "whonix_kvm",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/installation/enc/lanzaboote.html",
      "url": "https://saylesss88.github.io/installation/enc/lanzaboote.html",
      "title": "lanzaboote",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/nix/secureboot_libvirt.html",
      "url": "https://saylesss88.github.io/nix/secureboot_libvirt.html",
      "title": "secureboot_libvirt",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/nix/kvm.html",
      "url": "https://saylesss88.github.io/nix/kvm.html",
      "title": "kvm",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/nix/cachix_devour.html",
      "url": "https://saylesss88.github.io/nix/cachix_devour.html",
      "title": "cachix_devour",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/vcs/index.html",
      "url": "https://saylesss88.github.io/vcs/index.html",
      "title": "README",
      "content_html": "",
      "date_published": "2026-01-20T12:11:31+00:00"
    },
    {
      "id": "https://saylesss88.github.io/nixos_containers.html",
      "url": "https://saylesss88.github.io/nixos_containers.html",
      "title": "NixOS Containers",
      "content_html": "<h1>NixOS Containers</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><img src=\"images/boxes.cleaned.png\" alt=\"boxes\" /></p>\n<p>NixOS containers are lightweight <code>systemd-nspawn</code> containers managed\ndeclaratively through your NixOS configuration. They allow you to run separate,\nminimal NixOS instances on the same machine, each with its own services,\npackages, and (optionally) network stack.</p>\n<ul>\n<li><a href=\"https://www.freedesktop.org/software/systemd/man/latest/systemd-nspawn.html?__goaway_challenge=meta-refresh&amp;__goaway_id=5497ebb54af7da76c7cff2e5210fe9ab&amp;__goaway_referer=https%3A%2F%2Fsearch.brave.com%2F\">freedesktop systemd-nspawn</a></li>\n</ul>\n<blockquote>\n<p>‚ùó NixOS‚Äô containers do not provide full security out of the box (just like\ndocker). They do give you a separate chroot, but a privileged user (root) in a\ncontainer can escape the container and become root on the host system.\n‚Äì<a href=\"https://blog.beardhatcode.be/2020/12/Declarative-Nixos-Containers.html\">beardhatcode Declarative-Nixos-Containers</a></p>\n</blockquote>\n<p><strong>Common Use Cases</strong></p>\n<ul>\n<li>\n<p><strong>Isolating services</strong>: Run a web server, database, or any service in its own\ncontainer, so it can‚Äôt interfere with the main system or other services</p>\n</li>\n<li>\n<p><strong>Testing and development</strong>: Try out new configurations, packages, or services\nin a sandboxed environment.</p>\n</li>\n<li>\n<p><strong>Reproducible deployments</strong>: Because containers are defined declaratively,\nyou can reproduce the exact same environment anywhere.</p>\n</li>\n<li>\n<p><strong>Running multiple versions of a service</strong>: For example, testing different\nversions of Git or HTTP servers side by side.</p>\n</li>\n</ul>\n<hr />\n<h2>Hosting mdBook</h2>\n<p>Let‚Äôs say you want to host your mdBook. You can define a NixOS container that\nruns only the necessary service, isolated from your main system:</p>\n<pre><code class=\"language-nix\">{\n  config,\n  lib,\n  ...\n}: {\n  containers.mdbook-host = {\n    autoStart = true;\n    ephemeral = true;\n    privateNetwork = false;  # Use the hosts network\n\n    bindMounts.\"/var/www/mdbook\" = {\n      hostPath = \"/home/jr/nix-book/book\";\n      isReadOnly = true;\n    };\n\n    config = {containerPkgs, ...}: {\n      networking.useDHCP = lib.mkDefault true;\n\n      services.httpd = {\n        enable = true;\n        adminAddr = \"yourEmail.com\";\n        virtualHosts.\"localhost\" = {\n          documentRoot = \"/var/www/mdbook\";\n          serverAliases = [];\n        };\n      };\n\n      networking.firewall.allowedTCPPorts = [80];\n      environment.systemPackages = with containerPkgs; [];\n      system.stateVersion = \"25.05\";\n    };\n  };\n}\n</code></pre>\n<ul>\n<li>\n<p><code>ephemeral</code>: if true, the container resets on each restart.</p>\n</li>\n<li>\n<p><code>autoStart</code>: Ensures the container starts automatically at boot.</p>\n</li>\n<li>\n<p><code>config</code>: Defines the containers NixOS configuration, just like a regular\nNixOS system.</p>\n</li>\n</ul>\n<p><strong>Mounts</strong></p>\n<pre><code class=\"language-nix\">    bindMounts.\"/var/www/mdbook\" = {\n      hostPath = \"/home/jr/nix-book/book\";\n      isReadOnly = true;\n    };\n</code></pre>\n<p>The <code>bindMount</code> settings above specify that <code>/var/www/mdbook</code> in the container\nshould be linked to <code>/home/jr/nix-book/book</code> on the host.</p>\n<p><code>hostPath</code> must exist, and <code>/var/www/mdbook</code> must not exist for this to work.</p>\n<p>The above container is fairly simple because its <code>ReadOnly</code>, things get more\ncomplicated when you need HTTPD to have write privileges.</p>\n<p>When you create and run a NixOS container like <code>mdbook-host</code>. NixOS stores the\ncontainer‚Äôs root filesystem and related container state data under:</p>\n<pre><code class=\"language-bash\">ls /var/lib/nixos-containers/\n‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ empty list ‚îÇ  # It's empty because we set ephemeral to true\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n</code></pre>\n<p>This directory holds the container‚Äôs own filesystem image, including system\nfiles, installed packages, configuration, and any data internal to the\ncontainer.</p>\n<hr />\n<h2>Check Container Status</h2>\n<pre><code class=\"language-bash\">nixos-container list\nmdbook-host\n</code></pre>\n<pre><code class=\"language-bash\">sudo systemctl status container@mdbook-host\n Main PID: 32938 (systemd-nspawn)\n     Status: \"Container running: Ready.\"\n</code></pre>\n<p><strong>Test HTTP server inside the container</strong></p>\n<p>We configured Apache (<code>httpd</code>) to serve <code>/var/www/mdbook</code> at <code>localhost</code></p>\n<p>Let‚Äôs check if Apache is running:</p>\n<pre><code class=\"language-bash\">sudo nixos-container run mdbook-host -- systemctl status httpd\n‚óè httpd.service - Apache HTTPD\n     Loaded: loaded (/etc/systemd/system/httpd.service; enabled; preset: ignored)\n     Active: active (running) since Fri 2025-08-15 10:14:39 EDT; 2min 18s ago\n</code></pre>\n<p>Check the Bind Mount:</p>\n<pre><code class=\"language-bash\">sudo nixos-container run mdbook-host -- ls -l /var/www/mdbook\n</code></pre>\n<ul>\n<li>You should see an <code>index.html</code> and any other files from <code>~/nix-book/book</code></li>\n</ul>\n<p>Test the Web Server:</p>\n<pre><code class=\"language-bash\">curl http://localhost\n</code></pre>\n<ul>\n<li>You should see your book in HTTP format as raw HTML.</li>\n</ul>\n<p>Test on the web, in your browser visit:</p>\n<pre><code class=\"language-text\">http://localhost/\n</code></pre>\n<ul>\n<li>You should see your book fully served</li>\n</ul>\n<hr />\n<h3>Troubleshooting</h3>\n<p>Make sure your book has the correct permissions to allow <code>hostPath</code> to read it:</p>\n<pre><code class=\"language-bash\">sudo chmod -R o+rX ~/nix-book/book\n</code></pre>\n<p>If needed restart the container:</p>\n<pre><code class=\"language-bash\">sudo nixos-container stop mdbook-host\nsudo nixos-container start mdbook-host\n</code></pre>\n<p>Ensure that <code>/var/www/mdbook</code> is being populated:</p>\n<pre><code class=\"language-bash\">sudo nixos-container run mdbook-host -- ls -l /var/www/mdbook\n</code></pre>\n<p>You should see an <code>index.html</code> and more</p>\n<pre><code class=\"language-bash\">sudo nixos-container run mdbook-host -- systemctl status httpd\n</code></pre>\n<ul>\n<li>You should see <code>enabled</code> &amp; <code>active (running)</code></li>\n</ul>\n<p>Check the containers status:</p>\n<pre><code class=\"language-bash\">sudo nixos-container status mdbook-host\nup\n</code></pre>\n<hr />\n<h2>Why Bother Serving your book to localhost?</h2>\n<ol>\n<li>Real-time updates without rebuilding the container</li>\n</ol>\n<ul>\n<li>Files added, changed, or removed from <code>~/nix-book/book</code> on the host are\nimmediately reflected inside the container. This allows for:\n<ul>\n<li>\n<p>Rapid iteration and testing of your books content without rebuilding</p>\n</li>\n<li>\n<p>Easier debugging and fixing content or config issues on the fly.</p>\n</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>Keeps container images small and immutable</li>\n</ol>\n<ul>\n<li>Instead of baking book files into the container image (which requires\nrebuilding every change), the container image remains clean and generic.</li>\n</ul>\n<ol start=\"3\">\n<li>Separation of concerns</li>\n</ol>\n<ul>\n<li>The container focuses on running the service, while the content is managed\nindependently on the host. This separation improves maintainability and more.</li>\n</ul>\n<ol start=\"4\">\n<li>Data persistence</li>\n</ol>\n<ul>\n<li>Since the files live on the host, they persist independently of the containers\nlifecycle: restarting, recreating, or destroying the container won‚Äôt lose your\ncontent.</li>\n</ul>\n<ol start=\"5\">\n<li>Security Control</li>\n</ol>\n<ul>\n<li>You can carefully set permissions on the host directory, control read/write\naccess, and isolate the container runtime from sensitive data.</li>\n</ul>\n<hr />\n<h2>Removing the State</h2>\n<p>To remove <code>/var/lib/nixos-containers/mdbook-host</code>, you need to remove the\ncontainer configuration, rebuild, and then run the following commands to remove\nthe immutable sticky bits that prevent deletion.</p>\n<pre><code class=\"language-bash\"># Forcibly remove all attributes\nsudo chattr -R -i mdbook-host/\nsudo rm -rf mdbook-host/\n</code></pre>\n<h2>OCI deployment pipeline building a Rust App</h2>\n<blockquote>\n<p>If you want to use <code>mdbook-nix-repl</code> check out the README, the following shows\nhow I tested locally before eventually adding a <code>flake.nix</code> to the repo\nstreamlining this for users of the project.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/saylesss88/mdbook-nix-repl\">mdbook-nix-repl README</a></li>\n</ul>\n<p>This documents how to work with a local Rust crate repository without a\n<code>flake.nix</code> for testing. The README above explains how to generate a token and\nuse the project, this is just for educational purposes if you wanted to\nimplement something similar:</p>\n<ol>\n<li><code>nix-repl-server.nix</code>, place this in the same dir as your\n<code>configuration.nix</code>:</li>\n</ol>\n<pre><code class=\"language-nix\">{\n  config,\n  lib,\n  pkgs,\n  inputs,\n  ...\n}:\n\nlet\n  cfg = config.custom.nix-repl-server;\n\n  serverSource = inputs.mdbook-nix-repl + \"/server\";\n\n  # 1. Build the binary using your package definition\n  # serverPkg = pkgs.callPackage ./server-pkg.nix { };\n  serverPkg = pkgs.callPackage ./server-pkg.nix {\n    src = serverSource;\n  };\n\n  # 2. Build a minimal container image containing just the server + nix + deps\n  nixReplImage = pkgs.dockerTools.buildLayeredImage {\n    name = \"nix-repl-server\";\n    tag = \"latest\";\n\n    # dependencies needed at runtime inside the container\n    contents = [\n      serverPkg\n      pkgs.nix\n      pkgs.bashInteractive\n      pkgs.cacert\n      pkgs.tini\n      pkgs.coreutils\n    ];\n\n    config = {\n      Entrypoint = [\n        \"${pkgs.tini}/bin/tini\"\n        \"--\"\n      ];\n      Cmd = [ \"${serverPkg}/bin/nix-repl-server\" ];\n      ExposedPorts = {\n        \"8080/tcp\" = { };\n      };\n      # Important: Container must see 0.0.0.0 to receive traffic from host port mapping\n      Env = [\n        \"NIX_REPL_BIND=0.0.0.0\"\n        \"NIX_CONFIG=experimental-features = nix-command flakes\"\n        \"SSL_CERT_FILE=${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt\"\n      ];\n    };\n  };\nin\n{\n  options.custom.nix-repl-server = {\n    enable = lib.mkEnableOption \"nix-repl-server container\";\n    port = lib.mkOption {\n      type = lib.types.port;\n      default = 8080;\n      description = \"Host port to map to the container\";\n    };\n    tokenFile = lib.mkOption {\n      type = lib.types.path;\n      default = \"/etc/nix-repl-server.env\";\n      description = \"Path to file containing NIX_REPL_TOKEN=...\";\n    };\n  };\n\n  config = lib.mkIf cfg.enable {\n    # Enable Podman backend\n    virtualisation.podman.enable = true;\n    virtualisation.oci-containers.backend = \"podman\";\n\n    # The OCI container definition\n    virtualisation.oci-containers.containers.nix-repl-server = {\n      image = \"nix-repl-server:latest\";\n\n      # This effectively \"loads\" the image into Podman on boot\n      imageFile = nixReplImage;\n\n      ports = [ \"127.0.0.1:${toString cfg.port}:8080\" ];\n\n      # Inject the token safely at runtime (not in Nix store)\n      environmentFiles = [ cfg.tokenFile ];\n\n      extraOptions = [\n        \"--cap-drop=ALL\"\n        \"--security-opt=no-new-privileges\"\n        \"--pull=never\" # Use the local loaded image\n      ];\n    };\n  };\n}\n</code></pre>\n<ol start=\"2\">\n<li><code>server-pkg.nix</code>, place this in the same dir as <code>nix-repl-server.nix</code>:</li>\n</ol>\n<pre><code class=\"language-nix\">{\n  lib,\n  rustPlatform,\n  nix,\n  pkg-config,\n  openssl,\n  makeWrapper,\n  inputs,\n  src,\n}:\n\nrustPlatform.buildRustPackage {\n  pname = \"nix-repl-server\";\n  version = \"0.1.0\";\n\n  # Point this to your actual source root (where Cargo.toml is)\n  # src = ./.;\n  inherit src;\n\n  # You must commit Cargo.lock for this to work\n  # cargoLock.lockFile = ../../../mdbook-nix-repl/server/Cargo.lock;\n  cargoLock.lockFile = \"${src}/Cargo.lock\";\n\n  postPatch = ''\n    cp Cargo.toml.inc Cargo.toml\n  '';\n\n  # Runtime dependencies (nix for evaluation)\n  nativeBuildInputs = [\n    pkg-config\n    makeWrapper\n  ];\n  buildInputs = [ openssl ];\n\n  doCheck = false;\n\n  # Ensure 'nix' is available in the path if your binary calls Command::new(\"nix\")\n  postInstall = ''\n    wrapProgram $out/bin/nix-repl-server --prefix PATH : ${lib.makeBinPath [ nix ]}\n  '';\n\n  meta = with lib; {\n    description = \"Secure Nix REPL server for mdbook-nix-repl\";\n    platforms = platforms.linux;\n  };\n}\n</code></pre>\n<ol start=\"3\">\n<li><code>flake.nix</code>, this URL leads to a Rust crate repo:</li>\n</ol>\n<pre><code class=\"language-nix\">inputs = {\n  mdbook-nix-repl = {\n    url = \"path:/home/jr/mdbook-nix-repl\";\n    flake = false;\n  };\n}\n</code></pre>\n<ol start=\"4\">\n<li><code>configuration.nix</code>:</li>\n</ol>\n<pre><code class=\"language-nix\">{ pkgs, inputs, ... }:\n{\n  imports = [\n    # Include the results of the hardware scan.\n    ./hardware-configuration.nix\n    ./users.nix\n    ./nix-repl-server.nix\n  ];\n\n  custom.nix-repl-server = {\n    enable = true;\n    port = 8080; # Optional, defaults to 8080\n    tokenFile = \"/etc/nix-repl-server.env\";\n  };\n# --snip--\n</code></pre>\n<hr />\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction#\">RedHat A Practical Intro to Container Technology</a></li>\n</ul>\n",
      "date_published": "2026-01-11T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/nixpkgs/rust_crate_to_nixpkgs.html",
      "url": "https://saylesss88.github.io/nixpkgs/rust_crate_to_nixpkgs.html",
      "title": "Packaging a Rust crate for Nixpkgs",
      "content_html": "<details>\n<summary> ‚úîÔ∏è Table of Contents</summary>\n<!-- toc -->\n</details>\n<h1>Packaging a Rust crate for Nixpkgs</h1>\n<blockquote>\n<p>NOTE: This example assumes you‚Äôre packaging a crate that‚Äôs already on\ncrates.io, or you‚Äôre packaging an existing Rust project for nixpkgs.</p>\n</blockquote>\n<p>Nixpkgs is a big repository, so it helps to start with a focused workflow:\ncreate a branch, add a package under <code>pkgs/by-name/</code>, build it, then open a PR.</p>\n<hr />\n<h2>Clone nixpkgs</h2>\n<ol>\n<li>Fork and clone <code>NixOS/nixpkgs</code>:</li>\n</ol>\n<pre><code class=\"language-bash\">git clone git@github.com:your-user/nixpkgs.git\ncd nixpkgs\ngit remote add upstream git@github.com:NixOS/nixpkgs.git\n</code></pre>\n<p>(SSH avoids HTTPS helper issues)</p>\n<ol start=\"2\">\n<li>If your clone is shallow, convert it to full history (doesn‚Äôt lose work):</li>\n</ol>\n<pre><code class=\"language-bash\">git fetch --unshallow --tags\n</code></pre>\n<hr />\n<h2>Create a branch and add package:</h2>\n<ol>\n<li>Create a branch before changes preferably:</li>\n</ol>\n<pre><code class=\"language-bash\">git switch -c mdbook-rss-feed\n</code></pre>\n<hr />\n<h2>Add the package under pkgs/by-name</h2>\n<p>New top-level packages should generally go under\n<code>pkgs/by-name/&lt;2 letters&gt;/&lt;name&gt;/package.nix</code> (e.g.\n<code>pkgs/by-name/md/mdbook-rss-feed/package.nix</code>). Packages in <code>pkgs/by-name</code> are\npicked up automatically and usually don‚Äôt require edits to <code>all-packages.nix</code>.</p>\n<hr />\n<h2>Write package.nix (Rust crate example)</h2>\n<p>Start with <code>rustPlatform.buildRustPackage</code> and <code>fetchCrate</code>:</p>\n<pre><code class=\"language-nix\">{\n  lib,\n  rustPlatform,\n  fetchCrate,\n  versionCheckHook,\n}:\nrustPlatform.buildRustPackage rec {\n  pname = \"mdbook-rss-feed\";\n  version = \"1.3.0\";\n\n  src = fetchCrate {\n    inherit pname version;\n    hash = \"output of `nix hash convert` shown below\";\n  };\n\n  cargoHash = lib.fakeHash;\n\n  nativeInstallCheckInuts = [\n    versionCheckHook\n  ];\n  doInstallCheck = true;\n\n  meta = {\n    description = \"mdBook preprocessor that generates RSS, Atom, and JSON feeds\";\n    mainProgram = \"mdbook-rss-feed\";\n    homePage = \"https://crates.io/crates/mdbook-rss-feed\";\n    license = lib.licenses.asl20;\n    maintainers = [ lib.maintainers.sayls88 ];\n  };\n}\n</code></pre>\n<hr />\n<h2>Prefetch the crate hash:</h2>\n<p>Use <code>fetchCrate</code> / <code>crate2nix</code> style workflow, or just prefetch the <code>crates.io</code>\ntarball:</p>\n<pre><code class=\"language-bash\">nix-prefetch-url \\\n  --unpack \\\n  https://crates.io/api/v1/crates/mdbook-rss-feed/1.3.0/download\n</code></pre>\n<p>That prints a base32 hash: <code>0932843lknasdlfkm2lkdnflaknldvdsvser</code></p>\n<p>Convert it to sri format:</p>\n<pre><code class=\"language-bash\">nix hash convert --hash-algo sha256 --from nix32 --to sri 0932843lknasdlfkm2lkdnflaknldvdsvser\n</code></pre>\n<p>The above commands output looks like: <code>sha256-...=</code></p>\n<p>Put the resulting <code>sha256-...</code> into <code>src.hash</code>:</p>\n<pre><code class=\"language-nix\">  src = fetchCrate {\n    inherit pname version;\n    hash = \"sha256-...\";\n  };\n</code></pre>\n<hr />\n<h2>Get cargoHash via a failing build</h2>\n<p>In the <code>nixpkgs</code> root (i.e., the <code>nixpkgs</code> directory), run:</p>\n<pre><code class=\"language-bash\">nix-build -A mdbook-rss-feed\n# OR nix3 format\nnix build .#mdbook-rss-feed\n</code></pre>\n<p>Nix will fail with a message like:</p>\n<pre><code class=\"language-text\">hash mismatch\nspecified: sha256-....\ngot: sha256-1...\n</code></pre>\n<p>Copy the <code>got</code> value into <code>cargoHash</code>, rebuild, and it should succeed.</p>\n<p>Sanity check: from <code>nixpkgs</code> root :</p>\n<pre><code class=\"language-bash\">./result/bin/mdbook-rss-feed --version\n</code></pre>\n<hr />\n<h2>Adding yourself as maintainer</h2>\n<p>Edit <code>nixpkgs/maintainers/maintainer-list.nix</code> add your user in alphabetical\norder:</p>\n<pre><code class=\"language-nix\">your-handle = {\n  email = \"you@example.com\";\n  name = \"Your Name\";\n  github = \"your-gh-handle\";\n  githubId = 12345678;\n};\n</code></pre>\n<p>If you specify <code>github</code>, nixpkgs expects <code>githubId</code> too. You can get it from:\n<code>https://api.github.com/users/&lt;user&gt;</code>.</p>\n<p>The nixpkgs maintainers prefer if you add the <code>maintainer-list.nix</code> as a\nseparate commit.</p>\n<pre><code class=\"language-bash\">git commit -m \"maintainers: add &lt;user&gt;\"\n</code></pre>\n<hr />\n<h2>Treefmt</h2>\n<p>Run treefmt the nixpkgs way, from the repo root. Run this right before you push,\nmy editors formatter does something different with single entry lists than what\nNixpkgs wants:</p>\n<pre><code class=\"language-bash\">nix develop --command treefmt\nnix fmt\n</code></pre>\n<hr />\n<h2>Rebase and push safely</h2>\n<p>From the <code>mdbook-rss-feed</code> branch:</p>\n<pre><code class=\"language-bash\">git fetch upstream --tags\ngit rebase upstream/master\n</code></pre>\n<p>Commit and push your PR branch:</p>\n<p><strong>Then commit and push</strong></p>\n<pre><code class=\"language-bash\">git commit -m \"mdbook-rss-feed: init at 1.3.0\"\n# First push\ngit push origin mdbook-rss-feed\n# Use `--force-with-lease` only if you rebased/amended and need to rewrite the PR branch.\n# git push --force-with-lease origin mdbook-rss-feed\n</code></pre>\n<p><code>--force-with-lease</code> is the recommended safe force-push for PR branches.</p>\n<p>If <code>--force-with-lease</code> says ‚Äústale info‚Äù, fetch the remote branch ref first,\nthen retry.</p>\n<p><strong>Then commit and push</strong></p>\n<pre><code class=\"language-bash\">git commit -m \"mdbook-rss-feed: init at 1.3.0\"\ngit push -u origin mdbook-rss-feed\n</code></pre>\n<p>Then:</p>\n<ol>\n<li>\n<p>Go to GitHub -&gt; your fork</p>\n</li>\n<li>\n<p>Click ‚ÄúCompare &amp; pull request‚Äù on the <code>mdbook-rss-feed</code> branch</p>\n</li>\n<li>\n<p>Fill out the PR template (why useful, tested on x86_64-linux, etc.)</p>\n</li>\n<li>\n<p>Submit!</p>\n</li>\n</ol>\n<p>The package will go through CI checks, and once green + approved by a\nmaintainer, it‚Äôll land in nixpkgs.</p>\n<hr />\n<h2>Recovering from Mistakes</h2>\n<p>You‚Äôre bound to make mistakes, if you learn some Git basics it will help you\nquite a bit.</p>\n<p>You should avoid adding new commits for small fixes like typos, formatting, or\nminor adjustments requested in review. For substantial changes that add\nfunctionality, a new commit may be more appropriate.</p>\n<p>Say that we pushed our PR and one of the maintainers gave us a suggested change,\n(they want us to follow conventions and remove a trailing period from our\npackages description for this example).</p>\n<ol>\n<li>\n<p>Make the edit locally (remove the trailing period in the file)</p>\n</li>\n<li>\n<p>Stage the change: <code>git add pkgs/by-name/xx/your-package/package.nix</code> (avoid\n<code>git add -A</code> as it stages everything, which can accidentally include\nunrelated files)</p>\n</li>\n<li>\n<p>Amend the commit: <code>git commit --amend --no-edit</code>(this preserves your original\ncommit message, if you want to change the commit message use\n<code>git commit --amend</code>)</p>\n</li>\n<li>\n<p>Force push: <code>git push --force-with-lease</code> (This is safer than just using\n<code>--force</code> because it will fail if someone else has pushed commits to your\nbranch that you don‚Äôt have locally)</p>\n</li>\n</ol>\n<p><strong>Alternative for Multiple Commits</strong></p>\n<p>Interactive rebase is useful when your PR has several ‚ÄúWIP‚Äù commits (or you\nadded a small review fix as a separate commit) and you want to present a cleaner\nhistory before merge.</p>\n<p>You can use interactive rebase to squash all your would be small fix commits\ninto a single commit they belong to.</p>\n<p>Avoid squashing if the commits represent distinct, reviewable changes that stand\non their own.</p>\n<p><strong>Basic Workflow (squash/fixup)</strong></p>\n<ol>\n<li>Decide how many commits back you want to edit (example: last 3 commits):</li>\n</ol>\n<pre><code class=\"language-bash\">git rebase -i HEAD~3\n</code></pre>\n<ol start=\"2\">\n<li>Your editor opens with a ‚Äútodo‚Äù list (oldest at top). Change later commits\nfrom <code>pick</code> to <code>fixup</code> or <code>squash</code>:</li>\n</ol>\n<ul>\n<li>\n<p><code>fixup</code> = combine into the previous commit, discard this commit message.</p>\n</li>\n<li>\n<p><code>squash</code> = combine, but keep/edit commit messages.</p>\n</li>\n</ul>\n<p>Example todo:</p>\n<pre><code class=\"language-text\">pick 1111111 mdbook-rss-feed: init at 0.1.0\npick 2222222 mdbook-rss-feed: fix trailing period\npick 3333333 mdbook-rss-feed: formatting\n</code></pre>\n<p>Change to:</p>\n<pre><code class=\"language-text\">pick 1111111 mdbook-rss-feed: init at 0.1.0\nfixup 2222222 mdbook-rss-feed: fix trailing period\nfixup 3333333 mdbook-rss-feed: formatting\n</code></pre>\n<ol start=\"3\">\n<li>Save/close: if you squashed, Git will prompt you to edit the final combined\nmessage.</li>\n</ol>\n<p><strong>Push updated history</strong></p>\n<p>You have to force-push because <code>rebase</code> rewrites commit SHAs:</p>\n<pre><code class=\"language-bash\">git push --force-with-lease\n# If something goes wrong\n# git rebase --abort\n# If you hit conflicts, fix the files, then:\n# git add &lt;files&gt;\n# git rebase --continue\n</code></pre>\n<p>If you have an unrelated change accidentally included (for example: you staged\nan extra file), it‚Äôs usually better to fix it via rebase/splitting before\nreviewers spend time re-reviewing noise.</p>\n<blockquote>\n<p>As of 01-13-26 I have been waiting for 2 weeks for the darwin checks to complete,\nI guess this <a href=\"https://discourse.nixos.org/t/ofborg-aarch64-darwin-builds-causing-bottleneck/55290\">bottleneck</a>\nhas gotten worse. I guess most PRs take about 6 weeks to resolve FYI.</p>\n</blockquote>\n",
      "date_published": "2025-12-31T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/vcs/jujutsu.html",
      "url": "https://saylesss88.github.io/vcs/jujutsu.html",
      "title": "Jujutsu (JJ)",
      "content_html": "<h1>Version Control with JJ</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><img src=\"../images/jujutsu.png\" alt=\"JJ Logo\" /></p>\n<div style=\"font-size: 0.8em; margin-top: 10px;\">\n  **Image Source:** This image is from the [Jujutsu VCS repository](https://github.com/jj-vcs/jj) and is licensed under the Apache 2.0 License.\n</div>\n<p>‚ö†Ô∏è <strong>Security Reminder</strong>: Never commit secrets (passwords, API keys, tokens,\netc.) in plain text to your Git repository. If you plan to publish your NixOS\nconfiguration, always use a secrets management tool like <code>sops-nix</code> or <code>agenix</code>\nto keep sensitive data safe. See the\n<a href=\"https://saylesss88.github.io/installation/enc/sops-nix.html\">Sops-Nix Guide</a>\nfor details.</p>\n<h2>Getting Started</h2>\n<p>Jujutsu (jj) is a modern, Git-compatible version control system designed to\nsimplify and improve the developer experience. It offers a new approach to\ndistributed version control, focusing on a more intuitive workflow, powerful\nundo capabilities, and a branchless model that reduces common pitfalls of Git.</p>\n<p><strong>Recommended resources</strong>:</p>\n<ul>\n<li>\n<p><a href=\"https://steveklabnik.github.io/jujutsu-tutorial/\">Steve‚Äôs Jujutsu Tutorial</a>\n(most up to date). Steve does an excellent job explaining the ins and outs of\nJujutsu.</p>\n</li>\n<li>\n<p><a href=\"https://zerowidth.com/2025/jj-tips-and-tricks/\">zerowidth jj-tips-and-tricks</a></p>\n</li>\n<li>\n<p>Official:</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">jj help -k tutorial\n</code></pre>\n<ul>\n<li>\n<p>Every time you run a <code>jj</code> command, it examines the working copy and takes a\nsnapshot.</p>\n</li>\n<li>\n<p>Command help:</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">jj &lt;command&gt; --help\njj git init --help\njj git push --help\n</code></pre>\n<h2>üîë Key Concepts</h2>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Key Concepts </summary>\n<ol>\n<li>Working Copy as Commit</li>\n</ol>\n<ul>\n<li>\n<p>In JJ your working copy is always a real commit. Any changes you make are\nautomatically recorded in this working commit. The working copy is always\n(<code>@</code>) and the Parent commit is always <code>(@-)</code> keep this in mind.</p>\n</li>\n<li>\n<p>There is <strong>no staging area</strong> (index) as in Git. You do not need to run\n<code>git add</code> or <code>git commit</code> for every change. Modifications are always tracked\nin the current commit.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>Branchless Workflow and Bookmarks</li>\n</ol>\n<ul>\n<li>\n<p>JJ does not have the concept of a ‚Äúcurrent branch.‚Äù Instead, use bookmarks,\nwhich are named pointers to specific commits.</p>\n</li>\n<li>\n<p>Bookmarks do not move automatically. Commands like <code>jj new</code> and <code>jj commit</code>\nmove the working copy, but the bookmark stays were it was. Use\n<code>jj bookmark move</code> to move bookmarks. (e.g., <code>jj bookmark move main</code>). You can\nalso use <code>jj bookmark set main -r @</code> to explicitly set the main bookmark to\npoint at the working copy commit.</p>\n</li>\n<li>\n<p>Only commits referenced by bookmarks are pushed to remotes, preventing\naccidental sharing of unfinished work.</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>Automatic Tracking and Simpler Workflow</li>\n</ol>\n<ul>\n<li>\n<p>Adding or removing files is automatically tracked, no need for explicit <code>add</code>\nor <code>rm</code> commands.</p>\n</li>\n<li>\n<p>The working copy acts as a live snapshot of your workspace. Commands first\nsync filesystem changes into this commit, then perform the requested\noperation, and finally update the working copy if needed.</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>Operation Log and Undo</li>\n</ol>\n<ul>\n<li>\n<p>JJ records every operation (commits, merges, rebases, etc.) in an <strong>operation\nlog</strong>. Inspect it with: <code>jj op log</code></p>\n</li>\n<li>\n<p>You can view and undo any previous operation, not just the most recent one,\nmaking it easy to recover from mistakes, a feature not present in Git‚Äôs core\nCLI.</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li>First-Class Conflict Handling</li>\n</ol>\n<p>Conflicts happen when JJ can‚Äôt figure out how to merge different changes made to\nthe same file.</p>\n<ul>\n<li>\n<p>Conflicts are stored inside commits, not just in the working directory. You\ncan resolve them at any time, not just during a merge or rebase.</p>\n</li>\n<li>\n<p>Conflict markers are inserted directly into files, and JJ can reconstruct the\nconflict state from these markers. You can resolve conflicts by editing the\nfiles or using <code>jj resolve</code>.</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li>Revsets and Filesets</li>\n</ol>\n<ul>\n<li>\n<p><strong>Revsets</strong>: JJ‚Äôs powerful query language for selecting sets of commits,\ninspired by Mercurial. For example, <code>jj log -r \"author(alice) &amp; file(*.py)\"</code>\nlists all commits by Alice that touch Python files.</p>\n</li>\n<li>\n<p><strong>Filesets</strong>:JJ supports a functional language for selecting sets of files,\nallowing advanced file-based queries and operations.</p>\n</li>\n</ul>\n<table><thead><tr><th style=\"text-align: left\">Feature</th><th style=\"text-align: left\">Git</th><th style=\"text-align: left\">Jujutsu (jj)</th></tr></thead><tbody>\n<tr><td style=\"text-align: left\">Staging Area</td><td style=\"text-align: left\">Yes (git add/index)</td><td style=\"text-align: left\">No, working copy is always a commit</td></tr>\n<tr><td style=\"text-align: left\">Commit Workflow</td><td style=\"text-align: left\">Stage ‚Üí Commit</td><td style=\"text-align: left\">All changes auto-recorded in working commit</td></tr>\n<tr><td style=\"text-align: left\">Branches</td><td style=\"text-align: left\">Central to workflow</td><td style=\"text-align: left\">Optional, bookmarks used for sharing</td></tr>\n<tr><td style=\"text-align: left\">Undo/Redo</td><td style=\"text-align: left\">Limited, complex</td><td style=\"text-align: left\">Easy, operation log for undo</td></tr>\n<tr><td style=\"text-align: left\">Conflict Handling</td><td style=\"text-align: left\">Manual, can be confusing</td><td style=\"text-align: left\">Conflicts tracked in commits, easier to fix</td></tr>\n<tr><td style=\"text-align: left\">Integration with Git</td><td style=\"text-align: left\">Native</td><td style=\"text-align: left\">Fully compatible, can switch back anytime</td></tr>\n</tbody></table>\n<ol start=\"7\">\n<li>Anonymous branches: In Git a branch is a pointer to a commit that needs a\nname.</li>\n</ol>\n<p>If you haven‚Äôt taken the time to deep dive Git, it may be a good time to learn\nabout a new way of doing Version Control that is actually less complex and\neasier to mentally map out in my opinion.</p>\n<p>Jujutsu is a new front-end to Git, and it‚Äôs a new design for distributed version\ncontrol. ‚Äìjj init</p>\n<p>You can use jujutsu (jj) with existing Git repositories with one command.\n<code>jj git init --colocate</code> or <code>jj git init --git-repo /path/to/git_repository</code>.\nThe native repository format for jj is still a work in progress so people\ntypically use a <code>git</code> repository for backend.</p>\n<p>Unlike <code>git</code>, <code>jj</code> has no index ‚Äústaging area‚Äù. It treats the working copy as an\nactual commit. When you make changes to files, these changes are automatically\nrecorded to the working commit. There‚Äôs no need to explicitly stage changes\nbecause they are already part of the commit that represents your current working\nstate.</p>\n</details>\n<p><strong>Simplified Workflow</strong></p>\n<p>Check where you‚Äôre at, JJ doesn‚Äôt care about commits without descriptions but\nGit and GitHub do:</p>\n<pre><code class=\"language-bash\">jj st\nWorking copy  (@) now at: zuknrzrx 8a20bfa7 (empty) (no description set)\nParent commit (@-)      : yzppulzo bdd64e8d main | (empty) \"Enable Rofi and update nu func for jj\"\n</code></pre>\n<p>We can see that the Working copy is <code>(empty)</code> and has <code>(no description set)</code>,\nlets give it a description:</p>\n<pre><code class=\"language-bash\">jj desc -m \"My feature\"\n# ...edit files...\n# Check where we're at again\njj st\nWorking copy changes:\nM home/jj.nix\nWorking copy  (@) : zuknrzrx bcd3d965 My feature\nParent commit (@-): yzppulzo bdd64e8d main | (empty) \"Enable Rofi and update nu func for jj\"\n\n# Tell JJ which branch we're interested in\njj bookmark set main\n# Push this change to main\njj git push\nChanges to push to origin:\n  Move forward bookmark main from bdd64e8d6ea5 to bcd3d96567f8\nremote: Resolving deltas: 100% (3/3), completed with 3 local objects.\nWarning: The working-copy commit in workspace 'default' became immutable, so a new commit has been created on top of it.\nWorking copy  (@) now at: ktlywzlx 8e88ddbe (empty) (no description set)\nParent commit (@-)      : zuknrzrx bcd3d965 main | My feature\n</code></pre>\n<h2>What is the Jujutsu Working Copy</h2>\n<details>\n<summary> ‚úîÔ∏è Click To Expand Working Copy Description </summary>\n<p>The <strong>working copy</strong> in Jujutsu is an actual <strong>commit</strong> that represents the\ncurrent state of the files you‚Äôre working on. Unlike Git, where the working copy\nis separate from commits and changes must be explicitly staged and committed, in\nJJ the working copy is a live commit that automatically records changes as you\nmodify files.</p>\n<p>Adding or removing files in the working copy implicitly tracks or untracks them\nwithout needing explicit commands like <code>git add</code></p>\n<p>The working copy commit acts as a snapshot of your current workspace. When you\nrun commands, Jujutsu first syncs the filesystem changes into this commit, then\nperforms the requested operation, and finally updates the working copy if needed</p>\n<p>To finalize your current changes and start a new set of changes, you use the\n<code>jj new</code> command, which creates a new working-copy commit on top of the current\none. This replaces the traditional Git workflow of staging and committing\nchanges separately.</p>\n<p>Conflicts in the working copy are represented by inserting conflict markers\ndirectly into the files. Jujutsu tracks the conflicting parts and can\nreconstruct the conflict state from these markers. You resolve conflicts by\nediting these markers and then committing the resolution in the working copy</p>\n<ul>\n<li>This means that you don‚Äôt need to worry about making a change, running\n<code>git add .</code>, running <code>git commit -m \"commit message\"</code> because it‚Äôs already\ndone for you. This is handy with flakes by preventing a ‚Äúdirty working tree‚Äù\nand can instantly be rebuilt after making a change.</li>\n</ul>\n</details>\n<h2>Example JJ Module</h2>\n<details>\n<summary> ‚úîÔ∏è Click to Expand JJ home-manager module example </summary>\n<ul>\n<li>\n<p>For <code>lazygit</code> fans, Nixpkgs has <code>lazyjj</code>. I‚Äôve seen that it‚Äôs recommended to\nuse jj with <code>meld</code>. I‚Äôll share my <code>jj.nix</code> here for an example:</p>\n</li>\n<li>\n<p>I got a lot of the aliases and such from the\n<a href=\"https://zerowidth.com/2025/jj-tips-and-tricks/\">zerowidth</a> post, this has\nbeen a game changer:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">{\n  lib,\n  config,\n  pkgs,\n  # userVars ? {},\n  #\n  #\n  #\n  ...\n}: let\n  cfg = config.custom.jj;\nin {\n  options.custom.jj = {\n    enable = lib.mkOption {\n      type = lib.types.bool;\n      default = true;\n      description = \"Enable the Jujutsu (jj) module\";\n    };\n\n    userName = lib.mkOption {\n      type = lib.types.nullOr lib.types.str;\n      default = \"sayls8\";\n      description = \"Jujutsu user name\";\n    };\n\n    userEmail = lib.mkOption {\n      type = lib.types.nullOr lib.types.str;\n      default = \"sayls8@proton.me\";\n      description = \"Jujutsu user email\";\n    };\n\n    packages = lib.mkOption {\n      type = lib.types.listOf lib.types.package;\n      default = with pkgs; [lazyjj meld];\n      description = \"Additional Jujutsu-related packages to install\";\n    };\n\n    settings = lib.mkOption {\n      type = lib.types.attrs;\n      default = {\n        ui = {\n          # default-command = \"log-recent\";\n          default-command = [\"status\" \"--no-pager\"];\n          diff-editor = \"gitpatch\";\n          # diff-editor = [\"nvim\" \"-c\" \"DiffEditor\" \"$left\" \"$right\" \"$output\"];\n          # diff-formatter = [\"meld\" \"$left\" \"$right\"];\n          merge-editor = \":builtin\";\n          conflict-marker-style = \"diff\";\n        };\n        git = {\n          # remove the need for `--allow-new` when pushing new bookmarks\n          auto-local-bookmark = true;\n          push-new-bookmarks = true;\n        };\n        revset-aliases = {\n          \"closest_bookmark(to)\" = \"heads(::to &amp; bookmarks())\";\n          \"immutable_heads()\" = \"builtin_immutable_heads() | remote_bookmarks()\";\n          # The following command is incorrect, TODO\n          # \"default()\" = \"coalesce(trunk(),root())::present(@) | ancestors(visible_heads() &amp; recent(), 2)\";\n          \"recent()\" = \"committer_date(after:'1 month ago')\";\n          trunk = \"main@origin\";\n        };\n        template-aliases = {\n          \"format_short_change_id(id)\" = \"id.shortest()\";\n        };\n        merge-tools.gitpatch = {\n          program = \"sh\";\n          edit-args = [\n            \"-c\"\n            ''\n              set -eu\n              rm -f \"$right/JJ-INSTRUCTIONS\"\n              git -C \"$left\" init -q\n              git -C \"$left\" add -A\n              git -C \"$left\" commit -q -m baseline --allow-empty\n              mv \"$left/.git\" \"$right\"\n              git -C \"$right\" add --intent-to-add -A\n              git -C \"$right\" add -p\n              git -C \"$right\" diff-index --quiet --cached HEAD &amp;&amp; { echo \"No changes done, aborting split.\"; exit 1; }\n              git -C \"$right\" commit -q -m split\n              git -C \"$right\" restore . # undo changes in modified files\n              git -C \"$right\" reset .   # undo --intent-to-add\n              git -C \"$right\" clean -q -df # remove untracked files\n            ''\n          ];\n        };\n        aliases = {\n          c = [\"commit\"];\n          ci = [\"commit\" \"--interactive\"];\n          e = [\"edit\"];\n          i = [\"git\" \"init\" \"--colocate\"];\n          tug = [\"bookmark\" \"move\" \"--from\" \"closest_bookmark(@-)\" \"--to\" \"@-\"];\n          log-recent = [\"log\" \"-r\" \"default() &amp; recent()\"];\n          nb = [\"bookmark\" \"create\" \"-r\" \"@-\"]; # new bookmark\n          upmain = [\"bookmark\" \"set\" \"main\"];\n          squash-desc = [\"squash\" \"::@\" \"-d\" \"@\"];\n          rebase-main = [\"rebase\" \"-d\" \"main\"];\n          amend = [\"describe\" \"-m\"];\n          pushall = [\"git\" \"push\" \"--all\"];\n          push = [\"git\" \"push\" \"--allow-new\"];\n          pull = [\"git\" \"fetch\"];\n          dmain = [\"diff\" \"-r\" \"main\"];\n          l = [\"log\" \"-T\" \"builtin_log_compact\"];\n          lf = [\"log\" \"-r\" \"all()\"];\n          r = [\"rebase\"];\n          s = [\"squash\"];\n          si = [\"squash\" \"--interactive\"];\n        };\n        revsets = {\n          # log = \"main@origin\";\n          # log = \"master@origin\";\n        };\n      };\n      description = \"Jujutsu configuration settings\";\n    };\n  };\n\n  config = lib.mkIf cfg.enable {\n    home.packages = cfg.packages;\n\n    programs.jujutsu = {\n      enable = true;\n      settings = lib.mergeAttrs cfg.settings {\n        user = {\n          name = cfg.userName;\n          email = cfg.userEmail;\n        };\n      };\n    };\n  };\n}\n</code></pre>\n<p>In my <code>home.nix</code> I have this to enable it:</p>\n<pre><code class=\"language-nix\">custom = {\n    jj = {\n        enable = true;\n        userName = \"sayls8\";\n        userEmail = \"sayls8@proton.me\";\n        packages = \"\";\n    };\n};\n</code></pre>\n</details>\n<p>The <code>custom.jj</code> module allows me to override the username, email, packages, and\nwhether jj is enabled from a single, centralized place within my Nix\nconfiguration. So only if jj is enabled, <code>lazyjj</code> and <code>meld</code> will be installed.</p>\n<p>With the above <code>gitpatch</code> setup, say you did more work than you want to commit\nwhich is common with jj since it automatically tracks everything. I can now run:</p>\n<pre><code class=\"language-bash\">jj commit -i\n</code></pre>\n<p>And an interactive diff will come up allowing you to choose what to include in\nthe current commit. This also works for <code>jj split -i</code> and <code>jj squash -i</code>.</p>\n<p>Example, using <code>jj commit -i</code>:</p>\n<p><img src=\"../images/jj-gitpatch.png\" alt=\"jj commit -i\" /></p>\n<p>You can also use the <code>jj tug</code> command to make pushing to a remote more\nstraightforward. Since JJ‚Äôs bookmarks don‚Äôt automatically move as they do with\nGit, you can use <code>jj tug</code> after you‚Äôve made a few commits to move the bookmark\nthat is closest to the parent commit of your current position to your current\ncommit:</p>\n<pre><code class=\"language-bash\">jj tug\njj git push\n</code></pre>\n<p>The <code>tug</code> alias works for both the squash and edit workflows. After running\n<code>jj tug</code>, <code>jj git push</code> should work. If you get an error saying no bookmarks to\nmove, you can run <code>jj new</code> and then run <code>jj tug</code>, this happens when the bookmark\nis already at the parent commit.</p>\n<pre><code class=\"language-nix\"># jj.nix\nmb = [\"bookmark\" \"set\" \"-r\" \"@\"];\n</code></pre>\n<p>Another option would be to run <code>jj mb main</code> before running <code>jj git push</code> in this\nsituation, but you will have to describe the commit first.</p>\n<h2>Issues I‚Äôve Noticed</h2>\n<p><img src=\"../images/jj2.png\" alt=\"jj tree\" /></p>\n<p>I have run into a few issues, such as every flake command reloading every single\ninput every time. <strong>What I mean by this is what you see when you run a flake\ncommand for the first time, it adds all of your flakes inputs.</strong> I believe the\nfix for this is deleting and regenerating your <code>flake.lock</code>. The same thing can\nhappen when you move your flake from one location to another.</p>\n<p>JJ doesn‚Äôt seem to automatically track completely new files, running\n<code>git add /file/path.nix</code> enables JJ to start tracking the new file.</p>\n<p>That said, I recommend doing just that after running something like\n<code>jj git init --colocate</code>. Delete your <code>flake.lock</code> and run <code>nix flake update</code>,\n<code>nix flake lock --recreate-lock-file</code> still works but is being depreciated.</p>\n<p>Sometimes the auto staging doesn‚Äôt pick up the changes in your configuration so\nrebuilding changes nothing, this has been more rare but happens occasionally.</p>\n<p>One of the most fundamental differences between Jujutsu and Git is how pushing\nworks. If you‚Äôre coming from Git, it‚Äôs important to understand this shift so you\ndon‚Äôt get tripped up by ‚Äúnothing happened‚Äù warnings or missing changes on your\nremote.</p>\n<ul>\n<li>\n<p>In Git, you‚Äôre always ‚Äúon‚Äù a branch (e.g., <code>main</code>).</p>\n</li>\n<li>\n<p>When you make a commit, the branch pointer automatically moves forward.</p>\n</li>\n<li>\n<p><code>git push</code> pushes the current branch‚Äôs new commits to the remote.</p>\n</li>\n<li>\n<p>If you forget to switch branches, you might accidentally push to the wrong\nplace, but you rarely have to think about ‚Äúmoving‚Äù the branch pointer\nyourself.</p>\n</li>\n</ul>\n<p><strong>The JJ Push Model</strong></p>\n<ul>\n<li>\n<p>JJ has no concept of a ‚Äúcurrrent branch‚Äù</p>\n</li>\n<li>\n<p>Bookmarks <strong>do not</strong> move automatically. When you make a new commit, the\nbookmark (e.g., <code>main</code>) stays where it was. You must explicitly move it to\nyour new commit with <code>jj bookmark set main</code> (or create a new one).</p>\n</li>\n<li>\n<p>JJ only pushes commits that are referenced by bookmarks. If your latest work\nisn‚Äôt pointed to by a bookmark, <code>jj git push</code> will do nothing and warn you.\nThis is to prevent accidental pushes and gives you more control over what gets\nshared.</p>\n</li>\n</ul>\n<p><strong>Typical JJ Push Workflow</strong></p>\n<ol>\n<li>Check out where your working copy and Parent commit are, you will notice that\njj highlights the minimal amount of characters needed to reference this\nchange:</li>\n</ol>\n<pre><code class=\"language-bash\">jj st\nWorking copy changes:\nM README.md\nWorking copy  (@) : mnkrokmt 7f0558f8 say hello and goodbye\nParent commit (@-): ywyvxrts 986d16f5 main | test3\n</code></pre>\n<ul>\n<li>We can see that <code>ywy</code> is the <code>main</code> branch so lets create our change on top of\nthat. We can also see that it‚Äôs (<code>@-</code>), and this is actually what <code>main</code> will\nalways be. Once I understood this everything came together.</li>\n</ul>\n<pre><code class=\"language-bash\">jj new @-\nWorking copy  (@) now at: kxwrsmmu bc7e8144 (empty) (no description set)\nParent commit (@-)      : ywyvxrts 986d16f5 main | test3\nAdded 0 files, modified 1 files, removed 0 files\njj desc @ -m \"Add a devShell\"\nWorking copy  (@) now at: kxwrsmmu eacafd73 (empty) Add a devShell\nParent commit (@-)      : ywyvxrts 986d16f5 main | test3\n</code></pre>\n<p>Being more explicit about your commands ensures both you and jj know where\neverything should go. (i.e. <code>jj desc @ -m</code> explicitly describes <code>@</code>, the working\ncopy.) This will save you some headaches.</p>\n<p>Our new change, the Working copy is now built off of <code>main</code>. The working copy\nwill always be (<code>@</code>).</p>\n<p>Make some changes</p>\n<pre><code class=\"language-bash\">jj st\nWorking copy changes:\nA dev/flake.lock\nA dev/flake.nix\nWorking copy  (@) : kxwrsmmu 42b011cd Add a devShell\nParent commit (@-): ywyvxrts 986d16f5 main | test3\n</code></pre>\n<p>Now I‚Äôm done, and since we built this change on top of <code>main</code> the following\ncommand will tell jj we know what we want to push:</p>\n<pre><code class=\"language-bash\">jj bookmark set main\njj git push\n</code></pre>\n<p>If you forget to move a bookmark, JJ will warn you and nothing will be pushed.\nThis is a safety feature, not a bug. That‚Äôs what the <code>mb</code> alias does, moves the\nbookmark to the working copy.</p>\n<pre><code class=\"language-nix\"># home-manager alias (move bookmark)\nmb = [\"bookmark\" \"set\" \"-r\" \"@\"];\n</code></pre>\n<p>If you really have problems, <code>jj git push --change @</code> explicitly pushes the\nworking copy.</p>\n<p>This is a bit different than Git and takes some getting used to but you don‚Äôt\nneed to move the bookmark after every commit, just when you want to push. I know\nI‚Äôve made the mistake of pushing to the wrong branch before this should prevent\nthat.</p>\n<h2>Here‚Äôs an example of using JJ in an existing Git repo</h2>\n<p>Say I have my configuration flake in the <code>~/flakes/</code> directory that is an\nexisting Git repository. To use JJ as the front-end I could do something like:</p>\n<pre><code class=\"language-bash\">cd ~/flakes\njj git init --colocate\nDone importing changes from the underlying Git repo.\nSetting the revset alias `trunk()` to `main@origin`\nInitialized repo in \".\"\n</code></pre>\n<ul>\n<li>By default, JJ defines <code>trunk()</code> as the main development branch of your remote\nrepository. This is usually set to <code>main@origin</code>, but could be named something\nelse. This means that whenever you use <code>trunk()</code> in JJ commands, it will\nresolve to the latest commit on <code>main@origin</code>. This makes it easier to refer\nto the main branch in scripts and commands without hardcoding the branch name.</li>\n</ul>\n<p><strong>Bookmarks</strong> in jj are named pointers to specific revisions, similar to\nbranches in Git. When you first run <code>jj git init --colocate</code> in a git repo, you\nwill likely get a Hint saying ‚ÄúRun the following command to keep local bookmarks\nupdated on future pulls‚Äù.:</p>\n<pre><code class=\"language-bash\">jj bookmark list\ntrack main@origin\n\njj st\nThe working copy has no changes.\nWorking copy  (@) : qzxomtxq 925eca75 (empty) (no description set)\nParent commit (@-): qnpnrklz bf291074 main | notes\n</code></pre>\n<p>This shows that running <code>jj git init --colocate</code> automatically started tracking\n<code>main</code> in this case. If it doesn‚Äôt, use <code>jj bookmark track main@origin</code>.</p>\n<p>I‚Äôll create a simple change in the <code>README.md</code>:</p>\n<pre><code class=\"language-bash\">jj st\nWorking copy changes:\nM README.md\nWorking copy  (@) : qzxomtxq b963dff0 (no description set)\nParent commit (@-): qnpnrklz bf291074 main | notes\n</code></pre>\n<p>We can see that the working copy now contains a modified file <code>M README.md</code> and\nhas no description set. Lets give it a description before pushing to github.</p>\n<pre><code class=\"language-bash\">jj desc @ -m \"Added to README\"\njj bookmark set main -r @\nMoved 1 bookmarks to pxwnopqo 1e6e08a2 main* | Added to README\n</code></pre>\n<p><code>jj bookmark set main -r @</code> moves the <code>main</code> bookmark to the current revision\n(the working copy), which is the explicit, recommended way to update bookmarks\nin JJ. Without this step, your bookmark will continue to point at the old\ncommit, not your latest work. This is a major difference from Git.</p>\n<p>And finally push to GitHub:</p>\n<pre><code class=\"language-bash\">jj git push\nChanges to push to origin:\n  Move forward bookmark main from bf291074125e to e2a75e45237b\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nWarning: The working-copy commit in workspace 'default' became immutable, so a new commit has been created on top of it.\nWorking copy  (@) now at: pxwnopqo 8311444b (empty) (no description set)\nParent commit (@-)      : qzxomtxq e2a75e45 main | Added to README\n</code></pre>\n<hr />\n<h2>Create a Repo without an existing Git Repo</h2>\n<p><strong>Or</strong> to do this in a directory that isn‚Äôt already a git repo you can do\nsomething like:</p>\n<pre><code class=\"language-bash\">cargo new hello-world --vcs=none\ncd hello-world\njj git init\nInitialized repo in \".\"\n</code></pre>\n<hr />\n<h3>JJ and Git Side by Side</h3>\n<p>Or for example, with Git if you wanted to move to a different branch before\nrunning <code>nix flake update</code> to see if it introduced errors before merging with\nyour main branch, you could do something like:</p>\n<pre><code class=\"language-bash\">git checkout -b update-test\n\nnix flake update\n\nsudo nixos-rebuild test --flake .\n</code></pre>\n<p>If you‚Äôre satisfied you can merge:</p>\n<pre><code class=\"language-bash\">git checkout main\ngit add . # Stage the change\ngit commit -m \"update\"\ngit merge update-test\ngit branch -D update-test\nsudo nixos-rebuild switch --flake .\n</code></pre>\n<p>With JJ a similar workflow could be:</p>\n<ol>\n<li>Run <code>jj st</code> to see what you have:</li>\n</ol>\n<pre><code class=\"language-bash\">jj st\nThe working copy has no changes.\nWorking copy  (@) : ttkstzzn 3f55c42c (empty) (no description set)\nParent commit (@-): wppknozq e3558ef5 main@origin | jj diff\n</code></pre>\n<p>If you don‚Äôt have a description set for the working copy set it now.</p>\n<pre><code class=\"language-bash\">jj desc @ -m \"enable vim\"\njj st\nThe working copy has no changes.\nWorking copy  (@) : ttkstzzn 63fda123 (empty) enable vim\nParent commit (@-): wppknozq e3558ef5 main@origin | jj diff\n</code></pre>\n<ol start=\"2\">\n<li>Start from the working copy (which is mutable). The working copy in JJ is\nitself a commit that you can edit and squash changes into. Since <code>main</code> is\nimmutable, you can create your new change by working on top of the working\ncopy commit.</li>\n</ol>\n<p>Create a new change off of the working copy:</p>\n<pre><code class=\"language-bash\">jj new @\n</code></pre>\n<ol start=\"3\">\n<li>Make your edits:</li>\n</ol>\n<pre><code class=\"language-bash\">jj st\nWorking copy changes:\nM home/editors/vim.nix\nWorking copy  (@) : qrsxltmt 494b5f18 (no description set)\nParent commit (@-): wytnnnto a07e775c (empty) enable vim\n</code></pre>\n<ol start=\"4\">\n<li>Squash your changes into the new change:</li>\n</ol>\n<pre><code class=\"language-bash\">jj squash\nThe working copy has no changes.\nWorking copy  (@) : tmlwppnu ba06bb99 (empty) (no description set)\nParent commit (@-): wytnnnto 52928ed9 enable vim\n</code></pre>\n<p>This moves your working copy changes into the new commit you just created.</p>\n<ol start=\"5\">\n<li>Describe the new change, this might feel weird but the <code>jj squash</code> command\ncreated a new commit that you have to describe again:</li>\n</ol>\n<pre><code class=\"language-bash\">jj desc @ -m \"Enabled Vim\"\nWorking copy  (@) : tmlwppnu 5c1569c3 (empty) Enabled Vim\nParent commit (@-): wytnnnto 52928ed9 enable vim\n</code></pre>\n<ol start=\"6\">\n<li>Set the bookmark to the Parent commit that was squashed into:</li>\n</ol>\n<pre><code class=\"language-bash\">jj bookmark set wyt\n</code></pre>\n<ol start=\"7\">\n<li>Finally Push to the remote repository:</li>\n</ol>\n<pre><code class=\"language-bash\">jj git push --allow-new\nChanges to push to origin:\n  Add bookmark wyt to 5c1569c35b22\nremote: Resolving deltas: 100% (4/4), completed with 4 local objects.\nremote:\nremote: Create a pull request for 'wyt' on GitHub by visiting:\nremote:      https://github.com/sayls8/flake/pull/new/wyt\nremote:\n</code></pre>\n<p>This command does the following:</p>\n<ul>\n<li>\n<p>Uploads your bookmark and the associated commit to the remote repository\n(e.g., GitHub).</p>\n</li>\n<li>\n<p>If the bookmark is new (not present on the remote), <code>--allow-new</code> tells JJ\nit‚Äôs okay to create it remotely.</p>\n</li>\n<li>\n<p>After pushing, GitHub (or your code host) will usually suggest creating a pull\nrequest for your new branch/bookmark, allowing you or your collaborators to\nreview and merge the change into main.</p>\n</li>\n</ul>\n<p><strong>Merging your Change into <code>main</code></strong></p>\n<p>Option 1. Go to the URL suggested in the output, visit in this case:</p>\n<pre><code class=\"language-bash\">https://github.com/sayls8/flake/pull/new/wyt\n</code></pre>\n<ul>\n<li>\n<p>Click Create PR</p>\n</li>\n<li>\n<p>Click Merge PR if it shows it can merge cleanly.</p>\n</li>\n</ul>\n<p>Option 2.</p>\n<ol>\n<li>Switch to <code>main</code> (if not already there):</li>\n</ol>\n<pre><code class=\"language-bash\">jj bookmark set main\n</code></pre>\n<ol start=\"2\">\n<li>Create a new change that combines the new change with <code>main</code>:</li>\n</ol>\n<pre><code class=\"language-bash\">jj new tml wyt -m \"Merge: enable vim\"\n</code></pre>\n<p>This creates a new commit with both <code>tml</code> and <code>wyt</code> as parents, which is how JJ\nhandles merges (since <code>jj merge</code> depreciated). JJ merges are additive and\nhistory-preserving by design especially for folks used to Git‚Äôs fast-forward and\nsquash options.</p>\n<hr />\n<h3>Summary</h3>\n<ul>\n<li>\n<p>With <code>jj</code> you‚Äôre creating a new commit rather than a new branch.</p>\n</li>\n<li>\n<p>Amending vs. Squashing: Git‚Äôs <code>git commit --amend</code> updates the last commit.\n<code>jj squash</code> combines the current commit with its parent, effectively doing the\nsame thing in terms of history.</p>\n</li>\n<li>\n<p>Merging: Git‚Äôs merge command is explicit. In <code>jj</code>, the concept is similar, but\nsince there‚Äôs no branch, you‚Äôre ‚Äúmerging‚Äù by moving your working commit to\ninclude these changes.</p>\n</li>\n<li>\n<p>No need to delete branches: Since there are no branches in <code>jj</code>, there‚Äôs no\nequivalent to <code>git branch -D</code> to clean up. Instead commits that are no longer\nneeded can be ‚Äúabandoned‚Äù with <code>jj abandon</code> if you want to clean up your\ncommit graph.</p>\n</li>\n<li>\n<p><code>jj describe</code> without a flag just opens <code>$EDITOR</code> where you can write your\ncommit message save and exit.</p>\n</li>\n<li>\n<p>In <code>git</code>, we finish a set of changes to our code by committing, but in <code>jj</code> we\nstart new work by creating a change, and <em>then</em> make changes to our code. It‚Äôs\nmore useful to write an initial description of your intended changes, and then\nrefine it as you work, than it is creating a commit message after the fact.</p>\n</li>\n<li>\n<p>I have heard that jj can struggle with big repositories such as Nixpkgs and\nhave noticed some issues here and there when using with NixOS. I‚Äôm hoping that\nas the project matures, it gets better on this front.</p>\n</li>\n</ul>\n<hr />\n<h2>The 2 main JJ Workflows</h2>\n<h3>The Squash Workflow</h3>\n<p>This workflow is the most similar to Git and Git‚Äôs index.</p>\n<p>The workflow:</p>\n<ol>\n<li>\n<p>Describe the work we want to do with <code>jj desc -m \"message\"</code></p>\n</li>\n<li>\n<p>We create a new empty change on top of that one with <code>jj new</code></p>\n</li>\n<li>\n<p>When we are done with a feature, we run <code>jj squash</code> to move the changes from\n<code>@</code> into the change we described in step 1. <code>@</code> is where your working copy is\npositioned currently.</p>\n</li>\n</ol>\n<p>For example, let‚Äôs say we just ran <code>jj git init --colocate</code> in our configuration\nFlake directory making it a <code>jj</code> repo as well using git for backend.</p>\n<pre><code class=\"language-bash\">cd flake\njj git init --colocate\njj log\n@  lnmmxwko sayls8@proton.me 2025-06-27 10:14:57 1eac6aa0\n‚îÇ  (empty) (no description set)\n‚óã  qnknltto sayls8@proton.me 2025-06-27 09:04:08 git_head() 5358483a\n‚îÇ  (empty) jj\n</code></pre>\n<p>The above log output shows that running <code>jj git init</code> creates an empty working\ncommit (<code>@</code>) on top of the <code>git_head()</code></p>\n<pre><code class=\"language-bash\">jj desc -m \"Switch from nixVim to NVF\"\njj new  # Create a new empty change\njj log\n@  nmnmznmm sayls8@proton.me 2025-06-27 10:16:30 52dd7ee0\n‚îÇ  (empty) (no description set)\n‚óã  lnmmxwko sayls8@proton.me 2025-06-27 10:16:24 git_head() 3e8f9f3a\n‚îÇ  (empty) Switch from nixVim to NVF\n‚óã  qnknltto sayls8@proton.me 2025-06-27 09:04:08 5358483a\n‚îÇ  (empty) jj\n</code></pre>\n<p>The above log shows that running <code>jj desc</code> changes the current (<code>@</code>) commits\ndescription, and then <code>jj new</code> creates a new empty commit on top of it, moving\n(<code>@</code>) to this new empty commit.</p>\n<p>The ‚ÄúSwitch from nixVim to NVF‚Äù commit is now the parent of (<code>@</code>).</p>\n<p>Now, we‚Äôd make the necessary changes and to add them to the commit we just\ndescribed in the previous steps.</p>\n<p>The changes are automatically ‚Äústaged‚Äù so theres no need to <code>git add</code> them, so\nwe just make the changes and squash them.</p>\n<pre><code class=\"language-bash\">jj squash  # Squash the commit into its parent commit (i.e., our named commit)\njj log\n@  zsxsolsq sayls8@proton.me 2025-06-27 10:18:01 2c35d83f\n‚îÇ  (empty) (no description set)\n‚óã  lnmmxwko sayls8@proton.me 2025-06-27 10:18:01 git_head() 485eaee9\n‚îÇ  (empty) Switch from nixVim to NVF\n</code></pre>\n<p>This shows <code>jj squashes</code> effect, it merges the changes from the current (<code>@</code>)\ncommit into its parent. The (<code>@</code>) then moves to this modified parent, and a new\nempty commit is created on top, ready for the next set of changes.</p>\n<pre><code class=\"language-bash\">sudo nixos-rebuild switch --flake .\n</code></pre>\n<p>We‚Äôre still in the nameless commit and can either continue working or run\n<code>jj desc -m \"\"</code> again describing our new change, then <code>jj new</code> and <code>jj squash</code>\nit‚Äôs pretty simple. The nameless commit is used as an adhoc staging area.</p>\n<p>When you are ready to push, it‚Äôs important to know where your working copy\ncurrently is and if it‚Äôs attached to a bookmark. It‚Äôs common for <code>jj new</code> to\ndetach the head, all you have to do is tell JJ which branch to attach to, then\npush:</p>\n<pre><code class=\"language-bash\">jj st\nWorking copy changes:\nM hosts/magic/configuration.nix\nM hosts/magic/container.nix\nWorking copy  (@) : youptvvn 988e6fc9 (no description set)\nParent commit (@-): qlwqromx 4bb754fa mdbook container\n</code></pre>\n<p>The above output means that the working copy has modifications (<code>M</code>) in two\nfiles. And these changes are not yet committed.</p>\n<pre><code class=\"language-bash\">jj bookmark set main\njj git push\n</code></pre>\n<hr />\n<h3>The Edit Workflow</h3>\n<p>This workflow adds a few new commands <code>jj edit</code>, and <code>jj next</code>.</p>\n<p>Here‚Äôs the workflow:</p>\n<ol>\n<li>\n<p>Create a new change to work on the new feature with <code>jj new</code></p>\n</li>\n<li>\n<p>If everything works exactly as planned, we‚Äôre done.</p>\n</li>\n<li>\n<p>If we realize we want to break this big change up into multiple smaller ones,\nwe do it by making a new change before the current one, swapping to it, and\nmaking the necessary change.</p>\n</li>\n<li>\n<p>Lastly, we go back to the main change.</p>\n</li>\n</ol>\n<p>The squash workflow leaves <code>@</code> at an empty undescribed change, with this\nworkflow, <code>@</code> will often be on the existing change.</p>\n<p>If <code>@</code> wasn‚Äôt at an empty change, we would start this workflow with:</p>\n<pre><code class=\"language-bash\">jj new -m \"Switch from NVF to nixVim\"\n</code></pre>\n<p>since our <code>@</code> is already at an empty change, we‚Äôll just describe it and get\nstarted:</p>\n<p>For this example, lets say we want to revert back to nixVim:</p>\n<pre><code class=\"language-bash\">jj desc -m \"Switch from NVF to nixVim\"\njj log\n@  zsxsolsq sayls8@proton.me 2025-06-27 10:18:47 606abaa7\n‚îÇ  (empty) Switch from NVF to nixVim\n‚óã  lnmmxwko sayls8@proton.me 2025-06-27 10:18:01 git_head() 485eaee9\n‚îÇ  (empty) Switch from nixVim to NVF\n‚óã  qnknltto sayls8@proton.me 2025-06-27 09:04:08 5358483a\n‚îÇ  (empty) jj\n</code></pre>\n<p>Again, this shows <code>jj desc</code> renaming the current empty <code>@</code> commit.</p>\n<p>We make the changes, and it‚Äôs pretty straightforward so we‚Äôre done, every change\nis automatically staged so we can just run <code>sudo nixos-rebuild switch --flake .</code>\nnow to apply the changes.</p>\n<p>If we wanted to make more changes that aren‚Äôt described we can use <code>jj new -B</code>\nwhich is similar to <code>git add -a</code>.</p>\n<pre><code class=\"language-bash\">jj new -B @ -m \"Adding LSP to nixVim\"\nRebased 1 descendant commits\nWorking copy  (@) now at: lpnxxxpo bf929946 (empty) Adding LSP to nixVim\nParent commit (@-)      : lnmmxwko 485eaee9 (empty) Switch from nixVim to NVF\n</code></pre>\n<p>The <code>-B</code> tells jj to create the new change <em>before</em> the current one and it\ncreates a rebase. We created a change before the one we‚Äôre on, it automatically\nrebased our original change. This operation will <em>always</em> succeed with jj, we\nwill have our working copy at the commit we‚Äôve just inserted.</p>\n<p>You can see below that <code>@</code> moved down one commit:</p>\n<pre><code class=\"language-bash\">jj log\n‚óã  zsxsolsq sayls8@proton.me 2025-06-27 10:22:03 ad0713b6\n‚îÇ  (empty) Switch from NVF to nixVim\n@  lpnxxxpo sayls8@proton.me 2025-06-27 10:22:03 bf929946\n‚îÇ  (empty) Adding LSP to nixVim\n‚óã  lnmmxwko sayls8@proton.me 2025-06-27 10:18:01 git_head() 485eaee9\n‚îÇ  (empty) Switch from nixVim to NVF\n‚óã  qnknltto sayls8@proton.me 2025-06-27 09:04:08 5358483a\n‚îÇ  (empty) jj\n‚óã  qnknltto sayls8@proton.me 2025-06-27 09:04:08 git_head()\n</code></pre>\n<p>The ‚ÄúAdding LSP to nixVim‚Äù commit is directly above ‚ÄúSwitch from nixVim to NVF‚Äù\n(the old <code>git_head()</code>)</p>\n<p>The ‚ÄúSwitch from NVF to nixVim‚Äù commit (which was your <code>@</code> before <code>jj new -B</code>)\nis now above ‚ÄúAdding LSP to nixVim‚Äù in the log output, meaning ‚ÄúAdding LSP to\nnixVim‚Äù is its new parent.</p>\n<p><code>@</code> has moved to ‚ÄúAdding LSP to nixVim‚Äù</p>\n<p><code>jj log</code> example output</p>\n<hr />\n<h2>Operation Log and Undo</h2>\n<p>JJ records every operation (commits, merges, rebases, etc.) in an operation log.\nYou can view and undo previous operations, making it easy to recover from\nmistakes, a feature not present in Git‚Äôs core CLI</p>\n<pre><code class=\"language-bash\">jj op log\n@  fbf6e626df22 jr@magic 15 minutes ago, lasted 9 milliseconds\n‚îÇ  new empty commit\n‚îÇ  args: jj new -B @ -m 'Adding LSP to nixVim'\n‚óã  bde40b7c17cf jr@magic 19 minutes ago, lasted 8 milliseconds\n‚îÇ  describe commit 2c35d83f75031dc582bf28b64d4af1c218177f90\n‚îÇ  args: jj desc -m 'Switch from NVF to nixVim'\n‚óã  3a2bfe1c0b0a jr@magic 19 minutes ago, lasted 8 milliseconds\n‚îÇ  squash commits into 3e8f9f3a6a58fef86906e16e9b4375afb43e73e3\n‚îÇ  args: jj squash\n‚óã  80abcb58dcb6 jr@magic 21 minutes ago, lasted 8 milliseconds\n‚îÇ  new empty commit\n‚îÇ  args: jj new\n‚óã  8c80314cbcd7 jr@magic 21 minutes ago, lasted 8 milliseconds\n‚îÇ  describe commit 1eac6aa0b88ba014785ee9c1c2ad6e2abc6206e9\n‚îÇ  args: jj desc -m 'Switch from nixVim to NVF'\n‚óã  44b5789cb4d1 jr@magic 22 minutes ago, lasted 6 milliseconds\n‚îÇ  track remote bookmark main@origin\n‚îÇ  args: jj bookmark track main@origin\n‚óã  dbefee04aa85 jr@magic 23 minutes ago, lasted 4 milliseconds\n‚îÇ  import git head\n‚îÇ  args: jj git init --git-repo .\n</code></pre>\n<pre><code class=\"language-bash\">jj op undo &lt;operation-id&gt;\n# or\njj op restore &lt;operation-id&gt;\n</code></pre>\n<hr />\n<h2>Conflict Resolution</h2>\n<p>In JJ, conflicts live inside commits and can be resolved at any time, not just\nduring a merge. This makes rebasing and history editing safer and more flexible</p>\n<p>JJ treats conflicts as first-class citizens: conflicts can exist inside commits,\nnot just in the working directory. This means if a merge or rebase introduces a\nconflict, the conflicted state is saved in the commit itself, and you can\nresolve it at any time there‚Äôs no need to resolve conflicts immediately or use\n‚Äú<code>--continue</code>‚Äù commands as in Git</p>\n<p>Here‚Äôs how it works:</p>\n<p>When you check out or create a commit with conflicts, JJ materializes the\nconflicts as markers in your files (similar to Git‚Äôs conflict markers)</p>\n<p>You can resolve conflicts by editing the files to remove the markers, or by\nusing:</p>\n<pre><code class=\"language-bash\">jj resolve\n</code></pre>\n<hr />\n<h2>Revsets</h2>\n<p><a href=\"https://jj-vcs.github.io/jj/latest/revsets/\">Jujutsu Revsets</a></p>\n<p>JJ includes a powerful query language for selecting commits. For example:</p>\n<pre><code class=\"language-bash\">jj log -r \"author(alice) &amp; file(*.py)\"\n</code></pre>\n<p>This command lists all commits by Alice that touch Python files.</p>\n<h2>Filesets</h2>\n<p><a href=\"https://jj-vcs.github.io/jj/latest/filesets/\">Jujutsu Filesets</a></p>\n<p>Jujutsu supports a functional language for selecting a set of files. Expressions\nin this language are called ‚Äúfilesets‚Äù (the idea comes from Mercurial). The\nlanguage consists of file patterns, operators, and functions. ‚ÄìJJ Docs</p>\n<h2>Summary</h2>\n<p>Jujutsu (jj) offers a streamlined, branchless, and undo-friendly approach to\nversion control, fully compatible with Git but designed to be easier to use and\nreason about. Its workflows, operation log, and conflict handling provide a\nsafer and more flexible environment for managing code changes, making it a\ncompelling alternative for both new and experienced developers.</p>\n<hr />\n<h3>Resources</h3>\n<ul>\n<li>\n<p><a href=\"https://steveklabnik.github.io/jujutsu-tutorial/\">steves_jj_tutorial</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/jj-vcs/jj\">jj_github</a></p>\n</li>\n<li>\n<p><a href=\"https://jj-vcs.github.io/jj/latest/tutorial/\">official_tutorial</a></p>\n</li>\n<li>\n<p><a href=\"https://v5.chriskrycho.com/essays/jj-init/\">jj_init</a></p>\n</li>\n</ul>\n",
      "date_published": "2025-12-08T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/flakes/helix_flake.html",
      "url": "https://saylesss88.github.io/flakes/helix_flake.html",
      "title": "Understanding the Helix Flake",
      "content_html": "<h1>Chapter 4.4</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><img src=\"../images/helix.png\" alt=\"Helix Logo\" />‚Äì<a href=\"https://helix-editor.com/\">helix-editor.com</a></p>\n<h1>Understanding the Helix Flake and Modifying its Behavior</h1>\n<p>As we‚Äôve seen from previous examples, the helix editor repository includes a few\n<code>.nix</code> files including a <code>flake.nix</code>. Their flake uses a lot of idiomatic Nix\ncode and advanced features. First I will break down their <code>flake.nix</code> and\n<code>default.nix</code> to understand why they do certain things. And finally, we will\nchange the build to ‚Äúdebug‚Äù mode demonstrating how easily you can modify the\nbehavior of a package defined within a Nix flake without changing the original\nsource code or the upstream flake directly.</p>\n<ol>\n<li>Let‚Äôs clone the Helix repository:</li>\n</ol>\n<pre><code class=\"language-bash\">git clone https://github.com/helix-editor/helix.git\ncd helix\n</code></pre>\n<p>When you enter the <code>helix</code> directory, <code>direnv</code> is setup for you already. All you\nwould have to do is <code>direnv allow</code> and it will ask you a few questions then you\nare good to go. Looking at their <code>.envrc</code> it mentions ‚Äútry to use flakes, if it\nfails use normal nix (i.e., shell.nix)‚Äù. If it‚Äôs successful you‚Äôll see a long\nlist of environment variables displayed.</p>\n<ol start=\"2\">\n<li>Enter the Development Shell:</li>\n</ol>\n<p>The Helix project‚Äôs <code>flake.nix</code> includes a <code>devShells.default</code> output,\nspecifically designed for development.</p>\n<pre><code class=\"language-bash\">nix develop\n</code></pre>\n<ol start=\"3\">\n<li>You‚Äôre now in a fully configured development environment:</li>\n</ol>\n<ul>\n<li>When you run <code>nix develop</code>, Nix builds and drops you into a shell environment\nwith all the dependencies specified in <code>devShells.default</code>. This means you\ndon‚Äôt have to manually install or manage tools like Rust, Cargo, or Clang,\nit‚Äôs all handled declaratively through Nix.</li>\n</ul>\n<p>You can now build and run the project using its standard tooling:</p>\n<pre><code class=\"language-bash\">cargo check\ncargo build\ncargo run\n</code></pre>\n<ol start=\"4\">\n<li>Making Changes and Testing Them</li>\n</ol>\n<p>Since you‚Äôre in a reproducible environment, you can confidently hack on the\nproject without worrying about your system setup. Try modifying some code in\n<code>helix</code> and rebuilding with Cargo. The Nix shell ensures consistency for every\ncontributor or device you work on.</p>\n<ol start=\"5\">\n<li>Run Just the Binary</li>\n</ol>\n<p>If you only want to run the compiled program without entering the shell, use the\nnix run command:</p>\n<pre><code class=\"language-bash\">nix run\n</code></pre>\n<p>This builds and runs the default package defined by the flake. In the case of\nHelix, this launches the <code>hx</code> editor directly.</p>\n<ol start=\"6\">\n<li>Build Without Running</li>\n</ol>\n<p>To just build the project and get the path to the output binary:</p>\n<pre><code class=\"language-bash\">nix build\n</code></pre>\n<p>You‚Äôll find the compiled binary under <code>./result/bin</code>.</p>\n<ol start=\"7\">\n<li>Pinning and Reproducing</li>\n</ol>\n<p>Because the project uses a flake, you can ensure full reproducibility by pinning\nthe inputs. For example, you can clone with <code>--recurse-submodules</code> and copy the\n<code>flake.lock</code> to ensure you‚Äôre using the same dependency versions as upstream.\nThis is great for debugging or sharing exact builds.</p>\n<p>‚úÖ Recap:</p>\n<p>With flakes, projects like Helix provide everything you need for development and\nrunning in a single <code>flake.nix</code>. You can nix develop to get started hacking, nix\nrun to quickly try it out, and nix build to produce binaries all without\ninstalling or polluting your system.</p>\n<h2>Understanding the Helix flake.nix</h2>\n<p>The helix flake is full of idiomatic Nix code and displays some of the more\nadvanced things a flake can provide:</p>\n<pre><code class=\"language-nix\">{\n  description = \"A post-modern text editor.\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    rust-overlay = {\n      url = \"github:oxalica/rust-overlay\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n    rust-overlay,\n    ...\n  }: let\n    inherit (nixpkgs) lib;\n    systems = [\n      \"x86_64-linux\"\n      \"aarch64-linux\"\n      \"x86_64-darwin\"\n      \"aarch64-darwin\"\n    ];\n    eachSystem = lib.genAttrs systems;\n    pkgsFor = eachSystem (system:\n      import nixpkgs {\n        localSystem.system = system;\n        overlays = [(import rust-overlay) self.overlays.helix];\n      });\n    gitRev = self.rev or self.dirtyRev or null;\n  in {\n    packages = eachSystem (system: {\n      inherit (pkgsFor.${system}) helix;\n      /*\n      The default Helix build. Uses the latest stable Rust toolchain, and unstable\n      nixpkgs.\n\n      The build inputs can be overridden with the following:\n\n      packages.${system}.default.override { rustPlatform = newPlatform; };\n\n      Overriding a derivation attribute can be done as well:\n\n      packages.${system}.default.overrideAttrs { buildType = \"debug\"; };\n      */\n      default = self.packages.${system}.helix;\n    });\n    checks =\n      lib.mapAttrs (system: pkgs: let\n        # Get Helix's MSRV toolchain to build with by default.\n        msrvToolchain = pkgs.pkgsBuildHost.rust-bin.fromRustupToolchainFile ./rust-toolchain.toml;\n        msrvPlatform = pkgs.makeRustPlatform {\n          cargo = msrvToolchain;\n          rustc = msrvToolchain;\n        };\n      in {\n        helix = self.packages.${system}.helix.override {\n          rustPlatform = msrvPlatform;\n        };\n      })\n      pkgsFor;\n\n    # Devshell behavior is preserved.\n    devShells =\n      lib.mapAttrs (system: pkgs: {\n        default = let\n          commonRustFlagsEnv = \"-C link-arg=-fuse-ld=lld -C target-cpu=native --cfg tokio_unstable\";\n          platformRustFlagsEnv = lib.optionalString pkgs.stdenv.isLinux \"-Clink-arg=-Wl,--no-rosegment\";\n        in\n          pkgs.mkShell {\n            inputsFrom = [self.checks.${system}.helix];\n            nativeBuildInputs = with pkgs;\n              [\n                lld\n                cargo-flamegraph\n                rust-bin.nightly.latest.rust-analyzer\n              ]\n              ++ (lib.optional (stdenv.isx86_64 &amp;&amp; stdenv.isLinux) cargo-tarpaulin)\n              ++ (lib.optional stdenv.isLinux lldb)\n              ++ (lib.optional stdenv.isDarwin darwin.apple_sdk.frameworks.CoreFoundation);\n            shellHook = ''\n              export RUST_BACKTRACE=\"1\"\n              export RUSTFLAGS=\"''${RUSTFLAGS:-\"\"} ${commonRustFlagsEnv} ${platformRustFlagsEnv}\"\n            '';\n          };\n      })\n      pkgsFor;\n\n    overlays = {\n      helix = final: prev: {\n        helix = final.callPackage ./default.nix {inherit gitRev;};\n      };\n\n      default = self.overlays.helix;\n    };\n  };\n  nixConfig = {\n    extra-substituters = [\"https://helix.cachix.org\"];\n    extra-trusted-public-keys = [\"helix.cachix.org-1:ejp9KQpR1FBI2onstMQ34yogDm4OgU2ru6lIwPvuCVs=\"];\n  };\n}\n</code></pre>\n<p><strong>Top-Level Metadata</strong>:</p>\n<pre><code class=\"language-nix\">{\n  description = \"A post-modern text editor.\";\n}\n</code></pre>\n<ul>\n<li>This sets a human-readable description for the flake.</li>\n</ul>\n<h2>Inputs</h2>\n<pre><code class=\"language-nix\">inputs = {\n  nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n  rust-overlay = {\n    url = \"github:oxalica/rust-overlay\";\n    inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n};\n</code></pre>\n<ul>\n<li>\n<p><code>nixpkgs</code>: Uses the <code>nixos-unstable</code> branch of the Nixpkgs repository.</p>\n</li>\n<li>\n<p><code>rust-overlay</code>: follows the same <code>nixpkgs</code>, ensuring compatibility between\ninputs.</p>\n</li>\n</ul>\n<p><strong>Outputs Function</strong>:</p>\n<pre><code class=\"language-nix\">outputs = { self, nixpkgs, rust-overlay, ... }:\n</code></pre>\n<ul>\n<li>This defines what this flake exports, including <code>packages</code>, <code>devShells</code>, etc.</li>\n</ul>\n<p><strong>Common Setup</strong>:</p>\n<pre><code class=\"language-nix\">let\n  inherit (nixpkgs) lib;\n  systems = [ ... ];\n  eachSystem = lib.genAttrs systems;\n</code></pre>\n<ul>\n<li>\n<p><code>systems</code>: A list of the supported systems</p>\n</li>\n<li>\n<p><code>eachSystem</code>: A Helper to map over all platforms.</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">pkgsFor = eachSystem (system:\n  import nixpkgs {\n    localSystem.system = system;\n    overlays = [(import rust-overlay) self.overlays.helix];\n  });\n</code></pre>\n<ul>\n<li>This imports <code>nixpkgs</code> for each system and applies overlays</li>\n</ul>\n<p>üì¶ <code>packages</code></p>\n<pre><code class=\"language-nix\">packages = eachSystem (system: {\n  inherit (pkgsFor.${system}) helix;\n  default = self.packages.${system}.helix;\n});\n</code></pre>\n<ul>\n<li>For each platform:\n<ul>\n<li>\n<p>Includes a <code>helix</code> package (defined in <code>./default.nix</code>)</p>\n</li>\n<li>\n<p>Sets <code>default</code> to <code>helix</code> (used by <code>nix build</code>, <code>nix run</code>)</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>Let‚Äôs look at the helix <code>default.nix</code>:</p>\n<pre><code class=\"language-nix\">{\n  lib,\n  rustPlatform,\n  callPackage,\n  runCommand,\n  installShellFiles,\n  git,\n  gitRev ? null,\n  grammarOverlays ? [],\n  includeGrammarIf ? _: true,\n}: let\n  fs = lib.fileset;\n\n  src = fs.difference (fs.gitTracked ./.) (fs.unions [\n    ./.envrc\n    ./rustfmt.toml\n    ./screenshot.png\n    ./book\n    ./docs\n    ./runtime\n    ./flake.lock\n    (fs.fileFilter (file: lib.strings.hasInfix \".git\" file.name) ./.)\n    (fs.fileFilter (file: file.hasExt \"svg\") ./.)\n    (fs.fileFilter (file: file.hasExt \"md\") ./.)\n    (fs.fileFilter (file: file.hasExt \"nix\") ./.)\n  ]);\n\n  # Next we actually need to build the grammars and the runtime directory\n  # that they reside in. It is built by calling the derivation in the\n  # grammars.nix file, then taking the runtime directory in the git repo\n  # and hooking symlinks up to it.\n  grammars = callPackage ./grammars.nix {inherit grammarOverlays includeGrammarIf;};\n  runtimeDir = runCommand \"helix-runtime\" {} ''\n    mkdir -p $out\n    ln -s ${./runtime}/* $out\n    rm -r $out/grammars\n    ln -s ${grammars} $out/grammars\n  '';\nin\n  rustPlatform.buildRustPackage (self: {\n    cargoLock = {\n      lockFile = ./Cargo.lock;\n      # This is not allowed in nixpkgs but is very convenient here: it allows us to\n      # avoid specifying `outputHashes` here for any git dependencies we might take\n      # on temporarily.\n      allowBuiltinFetchGit = true;\n    };\n\n    nativeBuildInputs = [\n      installShellFiles\n      git\n    ];\n\n    buildType = \"release\";\n\n    name = with builtins; (fromTOML (readFile ./helix-term/Cargo.toml)).package.name;\n    src = fs.toSource {\n      root = ./.;\n      fileset = src;\n    };\n\n    # Helix attempts to reach out to the network and get the grammars. Nix doesn't allow this.\n    HELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\";\n\n    # So Helix knows what rev it is.\n    HELIX_NIX_BUILD_REV = gitRev;\n\n    doCheck = false;\n    strictDeps = true;\n\n    # Sets the Helix runtime dir to the grammars\n    env.HELIX_DEFAULT_RUNTIME = \"${runtimeDir}\";\n\n    # Get all the application stuff in the output directory.\n    postInstall = ''\n      mkdir -p $out/lib\n      installShellCompletion ${./contrib/completion}/hx.{bash,fish,zsh}\n      mkdir -p $out/share/{applications,icons/hicolor/{256x256,scalable}/apps}\n      cp ${./contrib/Helix.desktop} $out/share/applications/Helix.desktop\n      cp ${./logo.svg} $out/share/icons/hicolor/scalable/apps/helix.svg\n      cp ${./contrib/helix.png} $out/share/icons/hicolor/256x256/apps/helix.png\n    '';\n\n    meta.mainProgram = \"hx\";\n  })\n</code></pre>\n<h3>Breaking Down <code>helix/default.nix</code></h3>\n<details>\n<summary> ‚úîÔ∏è Click to Expand `helix/default.nix` breakdown </summary>\n<p>This <code>default.nix</code> file is a Nix derivation that defines how to build the Helix\neditor itself. It‚Äôs designed to be called by the main <code>flake.nix</code> as part of its\n<code>packages</code> output.</p>\n<p>Here‚Äôs a breakdown of its components:</p>\n<ol>\n<li><strong>Function Arguments</strong>:</li>\n</ol>\n<pre><code class=\"language-nix\">{\n  lib,\n  rustPlatform,\n  callPackage,\n  runCommand,\n  installShellFiles,\n  git,\n  gitRev ? null,\n  grammarOverlays ? [],\n  includeGrammarIf ? _: true,\n}:\n</code></pre>\n<p><code>lib</code>: The Nixpkgs <code>lib</code> (library) functions, essential for common operations\nlike <code>fileset</code> and <code>strings</code>.</p>\n<p><code>rustPlatform</code>: A helper function from Nixpkgs specifically for building Rust\nprojects. It provides a <code>buildRustPackage</code> function, which simplifies the\nprocess significantly.</p>\n<p><code>callPackage</code>: A Nixpkgs function used to instantiate a Nix expression (like\n<code>grammars.nix</code>) with its dependencies automatically supplied from the current\nNix environment.</p>\n<p><code>runCommand</code>: A Nixpkgs primitive that creates a derivation by running a shell\ncommand. It‚Äôs used here to construct the <code>runtimeDir</code>.</p>\n<p><code>installShellFiles</code>: A utility from Nixpkgs for installing shell completion\nfiles.</p>\n<p><code>git</code>: The Git package, needed for determining the <code>gitRev</code>.</p>\n<p><code>gitRev ? null</code>: The Git revision of the Helix repository. It‚Äôs an optional\nargument, defaulting to null. This is passed in from the main <code>flake.nix</code>.</p>\n<p><code>grammarOverlays ? []</code>: An optional list of overlays for grammars, allowing\ncustomization.</p>\n<p><code>includeGrammarIf ? _: true</code>: An optional function to control which grammars are\nincluded.</p>\n<ol start=\"2\">\n<li><strong>Local Variables</strong> (<code>let ... in</code>)</li>\n</ol>\n<pre><code class=\"language-nix\">let\n  fs = lib.fileset;\n\n  src = fs.difference (fs.gitTracked ./.) (fs.unions [\n    ./.envrc\n    ./rustfmt.toml\n    ./screenshot.png\n    ./book\n    ./docs\n    ./runtime\n    ./flake.lock\n    (fs.fileFilter (file: lib.strings.hasInfix \".git\" file.name) ./.)\n    (fs.fileFilter (file: file.hasExt \"svg\") ./.)\n    (fs.fileFilter (file: file.hasExt \"md\") ./.)\n    (fs.fileFilter (file: file.hasExt \"nix\") ./.)\n  ]);\n\n  grammars = callPackage ./grammars.nix { inherit grammarOverlays includeGrammarIf; };\n  runtimeDir = runCommand \"helix-runtime\" {} ''\n    mkdir -p $out\n    ln -s ${./runtime}/* $out\n    rm -r $out/grammars\n    ln -s ${grammars} $out/grammars\n  '';\nin\n</code></pre>\n<p><code>fs = lib.fileset;</code>: Aliases <code>lib.fileset</code> for convenient file set operations.</p>\n<p><code>src</code>: This is a crucial part. It defines the source files that will be used to\nbuild Helix by:</p>\n<ul>\n<li>\n<p>Taking all Git-tracked files in the current directory (<code>fs.gitTracked ./.</code>).</p>\n</li>\n<li>\n<p>Excluding configuration files (e.g., <code>.envrc</code>, <code>flake.lock</code>), documentation\n(<code>.md</code>), images (<code>.svg</code>), and Nix files (<code>.nix</code>) using <code>fs.difference</code> and\n<code>fs.unions</code>. This ensures a clean build input, reducing Nix store size and\navoiding unnecessary rebuilds.</p>\n</li>\n<li>\n<p><code>grammars</code>: Builds syntax grammars by calling <code>grammars.nix</code>, passing\n<code>grammarOverlays</code> (for customizing grammar builds) and <code>includeGrammarIf</code> (a\nfilter for selecting grammars).</p>\n</li>\n<li>\n<p><code>runtimeDir</code>: Creates a runtime directory for Helix by:</p>\n<ul>\n<li>\n<p>Symlinking the <code>runtime</code> directory from the source.</p>\n</li>\n<li>\n<p>Replacing the <code>grammars</code> subdirectory with a symlink to the <code>grammars</code>\nderivation, ensuring Helix uses Nix-managed grammars.</p>\n</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>The Build Derivation</strong> (<code>rustPlatform.buildRustPackage</code>)</li>\n</ol>\n<p>The core of this <code>default.nix</code> is the <code>rustPlatform.buildRustPackage</code> call,\nwhich is a specialized builder for Rust projects:</p>\n<pre><code class=\"language-nix\">in\n  rustPlatform.buildRustPackage (self: {\n    cargoLock = {\n      lockFile = ./Cargo.lock;\n      # ... comments ...\n      allowBuiltinFetchGit = true;\n    };\n</code></pre>\n<p><code>cargoLock</code>: Specifies how Cargo dependencies are handled.</p>\n<p><code>lockFile = ./Cargo.lock;</code> Points to the <code>Cargo.lock</code> file for reproducible\nbuilds.</p>\n<p><code>allowBuiltinFetchGit = true</code>: Allows Cargo to fetch Git dependencies directly\nfrom repositories specified in <code>Cargo.lock</code>. This is discouraged in Nixpkgs\nbecause it can break build reproducibility, but it‚Äôs used here for convenience\nduring development, eliminating the need to manually specify <code>outputHashes</code> for\nGit dependencies.</p>\n<pre><code class=\"language-nix\">nativeBuildInputs = [\n      installShellFiles\n      git\n    ];\n</code></pre>\n<p><code>nativeBuildInputs</code>: Are tools needed during the build process but not\nnecessarily at runtime.</p>\n<pre><code class=\"language-nix\">buildType = \"release\";\n</code></pre>\n<p><code>buildType</code>: Specifies that Helix should be built in ‚Äúrelease‚Äù mode (optimized).</p>\n<pre><code class=\"language-nix\">name = with builtins; (fromTOML (readFile ./helix-term/Cargo.toml)).package.name;\n    src = fs.toSource {\n      root = ./.;\n      fileset = src;\n    };\n</code></pre>\n<p><code>name</code>: Dynamically sets the package name by reading it from the <code>Cargo.toml</code>\nfile.</p>\n<p><code>src</code>: Uses the <code>src</code> file set defined earlier as the source for the build.</p>\n<pre><code class=\"language-nix\"># Helix attempts to reach out to the network and get the grammars. Nix doesn't allow this.\n    HELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\";\n\n    # So Helix knows what rev it is.\n    HELIX_NIX_BUILD_REV = gitRev;\n</code></pre>\n<p><strong>Environment Variables</strong>: Sets environment variables that Helix uses.</p>\n<p><code>HELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\"</code>: Prevents Helix from downloading\ngrammars during the build, as Nix‚Äôs sandboxed environment disallows network\naccess. Instead, grammars are provided via the <code>runtimeDir</code> derivation.</p>\n<p><code>HELIX_NIX_BUILD_REV = gitRev</code>: Embeds the specified Git revision (or <code>null</code> if\nunspecified) into the Helix binary, allowing Helix to display its version or\ncommit hash.</p>\n<pre><code class=\"language-nix\">doCheck = false;\n   strictDeps = true;\n</code></pre>\n<p><code>doCheck = false;</code>: Skips running tests during the build. This is common for\nfaster builds, especially in CI/CD, but tests are often run in a separate\n<code>checks</code> output (as seen in the <code>flake.nix</code>).</p>\n<p><code>strictDeps = true;</code>: Ensures that all dependencies are explicitly declared.</p>\n<pre><code class=\"language-nix\"># Sets the Helix runtime dir to the grammars\nenv.HELIX_DEFAULT_RUNTIME = \"${runtimeDir}\";\n</code></pre>\n<pre><code class=\"language-nix\"># Sets the Helix runtime dir to the grammars\nenv.HELIX_DEFAULT_RUNTIME = \"${runtimeDir}\";\n</code></pre>\n<p><code>env.HELIX_DEFAULT_RUNTIME</code>: Tells Helix where to find its runtime files\n(including the Nix-managed grammars).</p>\n<pre><code class=\"language-nix\"># Get all the application stuff in the output directory.\npostInstall = ''\n  mkdir -p $out/lib\n  installShellCompletion ${./contrib/completion}/hx.{bash,fish,zsh}\n  mkdir -p $out/share/{applications,icons/hicolor/{256x256,scalable}/apps}\n  cp ${./contrib/Helix.desktop} $out/share/applications/Helix.desktop\n  cp ${./logo.svg} $out/share/icons/hicolor/scalable/apps/helix.svg\n  cp ${./contrib/helix.png} $out/share/icons/hicolor/256x256/apps/helix.png\n'';\n</code></pre>\n<p><code>postInstall</code>: A shell script that runs after the main build is complete. This\nis used for installing additional files that are part of the Helix distribution\nbut not directly built by Cargo.</p>\n<p>Installs shell completion files (<code>hx.bash</code>, <code>hx.fish</code>, <code>hx.zsh</code>). This enables\ntab completion.</p>\n<p>Installs desktop entry files (<code>Helix.desktop</code>) and icons (<code>logo.svg</code>,\n<code>helix.png</code>) for desktop integration for GUI environments.</p>\n<pre><code class=\"language-nix\">    meta.mainProgram = \"hx\";\n\n})\n</code></pre>\n<p><code>meta.mainProgram</code>: Specifies the primary executable provided by this package,\nallowing <code>nix run</code> to automatically execute <code>hx</code>.</p>\n<p>A lot going on in this derivation!</p>\n</details>\n<h3>Making Actual Changes</h3>\n<ol>\n<li>Locate the <code>packages</code> output section. It looks like this:</li>\n</ol>\n<pre><code class=\"language-nix\">packages = eachSystem (system: {\n      inherit (pkgsFor.${system}) helix;\n      /*\n      The default Helix build. Uses the latest stable Rust toolchain, and unstable\n      nixpkgs.\n\n      The build inputs can be overridden with the following:\n\n      packages.${system}.default.override { rustPlatform = newPlatform; };\n\n      Overriding a derivation attribute can be done as well:\n\n      packages.${system}.default.overrideAttrs { buildType = \"debug\"; };\n      */\n      default = self.packages.${system}.helix;\n    });\n</code></pre>\n<ol start=\"2\">\n<li>Modify the <code>default</code> package. The comments actually tell us exactly how to do\nthis. We want to use <code>overrideAttrs</code> to change the <code>buildType</code></li>\n</ol>\n<p>Change this line:</p>\n<pre><code class=\"language-nix\">default = self.packages.${system}.helix;\n</code></pre>\n<p>To this:</p>\n<pre><code class=\"language-nix\">default = self.packages.${system}.helix.overrideAttrs { buildType = \"debug\"; };\n</code></pre>\n<ul>\n<li>This tells Nix to take the standard Helix package definition and override one\nof its internal attributes (<code>buildType</code>) to ‚Äúdebug‚Äù instead of ‚Äúrelease‚Äù.</li>\n</ul>\n<ol start=\"3\">\n<li>Build the ‚ÄúHacked‚Äù Helix:</li>\n</ol>\n<pre><code class=\"language-bash\">nix build\n</code></pre>\n<ul>\n<li>Nix will now rebuild Helix, but this time, it will compile it in debug mode.\nYou‚Äôll likely notice the build takes a bit longer, and the resulting binary\nwill be larger due to the included debugging symbols.</li>\n</ul>\n<ol start=\"4\">\n<li>Run the Debug Binary:</li>\n</ol>\n<pre><code class=\"language-bash\">./result/bin/hx\n</code></pre>\n<ul>\n<li>You‚Äôre now running your custom-built debug version of Helix! This is useful if\nyou were, for example, attatching a debugger.</li>\n</ul>\n<p>This is a simple yet powerful ‚Äúhack‚Äù that demonstrates how easily you can modify\nthe behavior of a package defined within a Nix flake without changing the\noriginal source code or the upstream flake directly. You‚Äôre simply telling Nix\nhow you‚Äôd like your version of the package to be built.</p>\n<h3>Another way to Modify Behavior</h3>\n<p>Since we are already familiar with the structure and behavior of Helix‚Äôs\n<code>flake.nix</code>, we can leverage that understanding to create our own Nix flake. By\nanalyzing how Helix organizes its <code>inputs</code>, <code>outputs</code>, and package definitions,\nwe gain the confidence to modify and extend a flake‚Äôs functionality to suit our\nspecific needs‚Äîwhether that‚Äôs customizing builds, adding overlays, or\nintegrating with home-manager.</p>\n<ol>\n<li>Create a <code>flake.nix</code> in your own directory (outside the helix repo):</li>\n</ol>\n<pre><code class=\"language-nix\">{\n  description = \"Customized Helix build with debug features\";\n\n  inputs = {\n    helix.url = \"github:helix-editor/helix\";\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    rust-overlay = {\n      url = \"github:oxalica/rust-overlay\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n  outputs = {\n    self,\n    helix,\n    nixpkgs,\n    rust-overlay,\n  }: let\n    system = \"x86_64-linux\";\n    pkgs = import nixpkgs {\n      system = system;\n      overlays = [rust-overlay.overlay.overlays.default];\n    };\n  in {\n    packages.${system}.default = helix.packages.${system}.helix.overrideAttrs (old: {\n      buildType = \"debug\";\n\n      # Add additional cargo features\n      cargoBuildFlags =\n        (old.cargoBuildFlags or [])\n        ++ [\n          \"--features\"\n          \"tokio-console\"\n        ];\n\n      # Inject custom RUSTFLAGS\n      RUSTFLAGS = (old.RUSTFLAGS or \"\") + \" -C debuginfo=2 -C opt-level=1\";\n    });\n  };\n}\n</code></pre>\n<p>Check it:</p>\n<pre><code class=\"language-bash\">nix flake check\nwarning: creating lock file '\"/home/jr/world/flake.lock\"':\n‚Ä¢ Added input 'helix':\n    'github:helix-editor/helix/8961ae1dc66633ea6c9f761896cb0d885ae078ed?narHash=sha256-f14perPUk%2BH15GyGRbg0Akqhn3rxFnc6Ez5onqpzu6A%3D' (2025-05-29)\n‚Ä¢ Added input 'helix/nixpkgs':\n    'github:nixos/nixpkgs/5135c59491985879812717f4c9fea69604e7f26f?narHash=sha256-Vr3Qi346M%2B8CjedtbyUevIGDZW8LcA1fTG0ugPY/Hic%3D' (2025-02-26)\n‚Ä¢ Added input 'helix/rust-overlay':\n    'github:oxalica/rust-overlay/d342e8b5fd88421ff982f383c853f0fc78a847ab?narHash=sha256-3SdPQrZoa4odlScFDUHd4CUPQ/R1gtH4Mq9u8CBiK8M%3D' (2025-02-27)\n‚Ä¢ Added input 'helix/rust-overlay/nixpkgs':\n    follows 'helix/nixpkgs'\n‚Ä¢ Added input 'nixpkgs':\n    'github:nixos/nixpkgs/96ec055edbe5ee227f28cdbc3f1ddf1df5965102?narHash=sha256-7doLyJBzCllvqX4gszYtmZUToxKvMUrg45EUWaUYmBg%3D' (2025-05-28)\n‚Ä¢ Added input 'rust-overlay':\n    'github:oxalica/rust-overlay/405ef13a5b80a0a4d4fc87c83554423d80e5f929?narHash=sha256-k0nhPtkVDQkVJckRw6fGIeeDBktJf1BH0i8T48o7zkk%3D' (2025-05-30)\n‚Ä¢ Added input 'rust-overlay/nixpkgs':\n    follows 'nixpkgs'\n</code></pre>\n<ul>\n<li>The <code>nix flake check</code> command will generate a <code>flake.lock</code> file if one doesn‚Äôt\nexist, and the warnings you see indicate that new inputs are being added and\nlocked to specific versions for reproducibility. This is expected behavior for\na new or modified flake.</li>\n</ul>\n<p>Inspect the outputs:</p>\n<pre><code class=\"language-bash\">nix flake show\npath:/home/jr/world?lastModified=1748612128&amp;narHash=sha256-WEYtptarRrrm0Jb/0PJ/b5VPqLkCk5iEenjbKYU4Xm8%3D\n‚îî‚îÄ‚îÄ‚îÄpackages\n    ‚îî‚îÄ‚îÄ‚îÄx86_64-linux\n        ‚îî‚îÄ‚îÄ‚îÄdefault: package 'helix-term'\n</code></pre>\n<ul>\n<li>\n<p>The <code>‚îî‚îÄ‚îÄ‚îÄpackages</code> line indicates that our flake exposes a top-level\n<code>packages</code> attribute.</p>\n</li>\n<li>\n<p><code>‚îî‚îÄ‚îÄ‚îÄx86_64-linux</code>: System architecture specificity</p>\n</li>\n<li>\n<p><code>‚îî‚îÄ‚îÄ‚îÄdefault: package 'helix-term'</code> Signifies that within the <code>x86_64-linux</code>\npackages, there‚Äôs a package named <code>default</code>. This is a special name that\nallows you to omit the package name when using commands like <code>nix build</code>.</p>\n</li>\n<li>\n<p><code>package 'helix-term'</code> This is the most direct confirmation of our ‚Äúhack‚Äù. It\ntells us that our <code>default</code> package is <code>helix-term</code>. This confirms that our\n<code>overrideAttrs</code> in the <code>packages.${system}.default</code> section successfully\ntargeted and modified the Helix editor package, which is internally named\n<code>helix-term</code> by the Helix flake.</p>\n</li>\n</ul>\n<p><strong>What This Does</strong>:</p>\n<ul>\n<li>\n<p><code>overrideAttrs</code> lets you change <em>only</em> parts of the derivation without\nrewriting everything.</p>\n</li>\n<li>\n<p><code>buildType = \"debug\"</code> enables debug builds.</p>\n</li>\n<li>\n<p><code>cargoBuildFlags</code> adds extra features passed to Cargo, e.g.,\n<code>--features tokio-console</code></p>\n</li>\n<li>\n<p><code>RUSTFLAGS</code> gives you even more control over compiler behavior, optimization\nlevels, etc.</p>\n</li>\n</ul>\n<p><strong>Run It</strong>:</p>\n<pre><code class=\"language-bash\">nix run\n</code></pre>\n<p>Or drop into the dev shell:</p>\n<pre><code class=\"language-bash\">nix develop\n</code></pre>\n<ul>\n<li>(assuming you also wire in a <code>devShells</code> output)</li>\n</ul>\n<p><strong>Adding the <code>devShells</code> output</strong>:</p>\n<p>Since we already have the helix flake as an input to our own <code>flake.nix</code> we can\nnow forward or extend Helix‚Äôs <code>devShells</code> like this:</p>\n<pre><code class=\"language-nix\">outputs = { self, nixpkgs, helix, rust-overlay, ... }: {\n  devShells = helix.devShells;\n};\n</code></pre>\n<p>Or if you want to pick a specific system:</p>\n<pre><code class=\"language-nix\">outputs = { self, nixpkgs, helix, rust-overlay ... }:\n  let\n    system = \"x86_64-linux\";\n  in {\n    devShells.${system} = helix.devShells.${system};\n  };\n</code></pre>\n<p><strong>Optional: Combine with your own</strong> <code>devShell</code></p>\n<p>You can also extend or merge it with your own shell like so:</p>\n<pre><code class=\"language-nix\">outputs = { self, nixpkgs, helix, rust-overlay, ... }:\n  let\n    system = \"x86_64-linux\";\n    pkgs = import nixpkgs { inherit system; };\n  in {\n    devShells.${system} = {\n      default = pkgs.mkShell {\n        name = \"my-shell\";\n        inputsFrom = [ helix.devShells.${system}.default ];\n        buildInputs = [ pkgs.git ];\n      };\n    };\n  };\n</code></pre>\n",
      "date_published": "2025-12-05T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/intro_to_nushell_on_NixOS.html",
      "url": "https://saylesss88.github.io/intro_to_nushell_on_NixOS.html",
      "title": "Intro to Nushell",
      "content_html": "<h1>Nushell on NixOS</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><img src=\"images/nu.png\" alt=\"Nu\" /></p>\n<h2>Intro</h2>\n<ul>\n<li>\n<p><strong>TL;DR</strong>:I recently switched default shells from zsh to nushell, this post is\nabout some of the challenges and advantages of using nushell with NixOS.</p>\n</li>\n<li>\n<p>While the average user might not immediately see significant advantages, those\nwho frequently work with structured data formats like JSON, YAML, and CSV ‚Äì\nsuch as developers interacting with APIs, system administrators managing\nconfigurations, and data professionals ‚Äì will likely find Nushell‚Äôs native\ndata handling and powerful pipeline capabilities a plus. Additionally, users\nwho value a more consistent and safer scripting experience might appreciate\nNushell‚Äôs language-first design and features like strong typing.</p>\n</li>\n<li>\n<p>I‚Äôll start with some of the unique build design choices and unique features\nthat I think make Nushell special, then show an example using Nushell to\nmanipulate JSON data. Finally, I will highlight some of the visually appealing\naspects of Nushell and lastly I share some resources for learning more.</p>\n</li>\n</ul>\n<h2>The Good</h2>\n<ul>\n<li>\n<p>Nushell borrows concepts from many shells and languages and is itself both a\nprogramming language and a shell. Because of this, it has its own way of\nworking with files, directories, websites, and more.</p>\n</li>\n<li>\n<p>Nushell is powerful and has many essential commands built directly into the\nshell (‚Äúinternal‚Äù commands) rather than a link to an executable. You can use\nthis set of commands across different operating systems, having this\nconsistency is helpful when creating cross-platform code.</p>\n</li>\n<li>\n<p>When internal Nushell commands (like <code>ls</code>, <code>open</code>, <code>where</code>, <code>get</code>, <code>sort-by</code>,\netc.) produce output, they generally do so in Nushell‚Äôs structured data format\n(tables or records). This is the shell‚Äôs native way of representing\ninformation.</p>\n</li>\n<li>\n<p>Beyond these foundational strengths, Nushell offers a range of unique features\nthat enhance its functionality and make it particularly well-suited for\ndata-heavy tasks. Here are some highlights that showcase its versatility.</p>\n</li>\n</ul>\n<p><strong>Some Unique Features</strong>:</p>\n<ul>\n<li>\n<p>Besides the built-in commands, Nushell has a\n<a href=\"https://www.nushell.sh/book/standard_library.html\">standard library</a> Nushell\noperates on <em>structured data</em>. You could call it a ‚Äúdata-first‚Äù shell and\nprogramming language.</p>\n</li>\n<li>\n<p>Also included, is a full-featured dataframe processing engine using\n<a href=\"https://github.com/pola-rs/polars\">Polars</a> if you want to process large data\nefficiently directly in your shell, check out the\n<a href=\"https://www.nushell.sh/book/dataframes.html\">Dataframes-Docs</a></p>\n</li>\n<li>\n<p><strong>Multi-Line Editing</strong>:</p>\n</li>\n<li>\n<p>When writing a long command you can press Enter to add a newline and move to\nthe next line. For example:</p>\n</li>\n</ul>\n<pre><code class=\"language-nu\">ls            |    # press enter\nwhere name =~ |    # press enter, comments after pipe ok\nget name      |    # press enter\nmv ...$in ./backups/\n</code></pre>\n<ul>\n<li>\n<p>This allows you to cycle through the entire multi-line command using the up\nand down arrow keys and then customize different lines or sections of the\ncommand.</p>\n</li>\n<li>\n<p>You can manually insert a newline using <code>Alt+Enter</code> or <code>Shift+Enter</code>.</p>\n</li>\n<li>\n<p>The <a href=\"https://www.nushell.sh/book/line_editor.html\">Reedline-Editor</a> is\npowerful and provides good <code>vi-mode</code> or <code>emacs</code> support built in.</p>\n</li>\n<li>\n<p>It‚Äôs default <code>Ctrl+r</code> history command is nice to work with out of the box.</p>\n</li>\n<li>\n<p>The <a href=\"https://www.nushell.sh/book/explore.html#parameters\">explore</a> command, is\nnu‚Äôs version of a table pager, just like <code>less</code> but for table structured data:</p>\n</li>\n</ul>\n<pre><code class=\"language-nu\">$nu | explore --peek\n</code></pre>\n<ul>\n<li>\n<p>With the above command you can navigate with vim keybinds or arrow keys.</p>\n</li>\n<li>\n<p>These features demonstrate Nushell‚Äôs user-friendly interface, but what truly\nsets it apart is its underlying design as a structured data scripting\nlanguage. This ‚Äúlanguage-first‚Äù approach powers many of its distinctive\ncapabilities.</p>\n</li>\n</ul>\n<p><img src=\"images/explore.png\" alt=\"explore\" /></p>\n<p><strong>Unique design</strong>:</p>\n<ul>\n<li>\n<p><strong>Fundamentally designed as a structured data scripting language</strong>: and then\nit acts as a shell on top of that foundation. This ‚Äúlanguage first‚Äù approach\nis what gives it many of its distinctive features and makes it a powerful\nscripting language. I reiterate this here because of the implications of this.\nA few of those features are:</p>\n<ul>\n<li>\n<p><strong>Pipelines of structured data</strong>: Unlike traditional shells that primarily\ndeal with plain text streams, Nushell pipelines operate on tables of\nstructured data. Each command can understand and manipulate this structured\ndata directly.</p>\n</li>\n<li>\n<p><strong>Consistent syntax</strong>: Its syntax is more consistent and predictable\ncompared to the often quirky syntax of Bash and Zsh, drawing inspiration\nfrom other programming languages.</p>\n</li>\n<li>\n<p><strong>Strong typing</strong> Nushell has a type system, which helps catch errors early\nand allows for more robust scripting.</p>\n</li>\n<li>\n<p><strong>First-class data types</strong>: It treats various data formats (like JSON, CSV,\nTOML) as native data types, making it easier to work with them. Because of\nthis, Nushell aims to replace the need for external tools like <code>jq</code>, <code>awk</code>,\n<code>sed</code>, <code>cut</code>, and even some uses of <code>grep</code> and <code>curl</code>.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Variables are Immutable by Default</strong>: Nushell‚Äôs commands are based on a\nfunctional-style of programming which requires immutability, sound familiar?</p>\n</li>\n<li>\n<p><strong>Nushell‚Äôs Environment is Scoped</strong>: Nushell takes many design cues from\ncompiled languages, one is that languages should avoid global mutable state.\nShells have commonly used global mutation to update the environment, Nushell\nattempts to steer clear of this increasing reproducability.</p>\n</li>\n<li>\n<p><strong>Single-use Environment Variables</strong>:</p>\n</li>\n</ul>\n<pre><code class=\"language-nu\">FOO=BAR $env.FOO\n# =&gt; BAR\n</code></pre>\n<ul>\n<li><strong>Permanent Environment Variables</strong>: In your <code>config.nu</code></li>\n</ul>\n<pre><code class=\"language-nu\"># config.nu\n$env.FOO = 'BAR'\n</code></pre>\n<ul>\n<li>\n<p><a href=\"https://www.nushell.sh/book/coming_from_bash.html\">Coming-From-Bash</a></p>\n</li>\n<li>\n<p>These design principles make Nushell a powerful tool for scripting, but\nthey‚Äôre best understood through a hands-on example. Let‚Äôs see how Nushell‚Äôs\nstructured data capabilities shine in a common task: processing a JSON file.</p>\n</li>\n</ul>\n<p><strong>Example</strong>: I wanted to provide a practical example to illustrate some of these\n‚ÄúGood‚Äù features in action. And break it down for better understanding.</p>\n<ul>\n<li>\n<p>Let‚Äôs consider a common task: processing data from a JSON file. Imagine you\nhave a file containing a list of users with their names and ages. With\ntraditional shells, you‚Äôd likely need to rely on external tools like <code>jq</code> to\nparse and filter this data. However, Nushell can handle this directly within\nits own commands.</p>\n</li>\n<li>\n<p>For this example you could create a <code>test</code> directory and move to it:</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">mkdir test ; cd test\n</code></pre>\n<ul>\n<li>Create a <code>users.json</code> with the following contents:</li>\n</ul>\n<p>üëá users.json</p>\n<pre><code class=\"language-json\">[\n  { \"name\": \"Alice\", \"age\": 25 },\n  { \"name\": \"Bob\", \"age\": 30 },\n  { \"name\": \"Charlie\", \"age\": 20 }\n]\n</code></pre>\n<ul>\n<li>And create the following <code>filter.nu</code> that first converts <code>users.json</code> into its\nown internal structured data format with the <code>open</code> command, then to filters\nout people under <code>21</code> with the <code>where</code> control flow construct, then selects\nthe <code>name</code> and <code>age</code> columns, sorts them by age, and finally converts them\nback to <code>json</code> and saves them to a file called <code>filtered_users.json</code>. A lot\nhappening in a 6 line script.</li>\n</ul>\n<pre><code class=\"language-nu\"># filter.nu\nopen users.json           # Read JSON file into structured data\n| where age &gt; 21         # Filter users older than 21\n| select name age        # Select only name and age columns\n| sort-by age            # Sort by age\n| to json                # Convert back to JSON\n| save filtered_users.json # Save result to a new file\n</code></pre>\n<ul>\n<li>The <code>open</code> command takes data from a file (or even a URL in some cases) and\nparses it and converts it into Nushells own internal structured data format.\nSo this command isn‚Äôt just showing you the contents of <code>users.json</code> but doing\na conversion to Nu‚Äôs special structured format.</li>\n</ul>\n<pre><code class=\"language-nu\">open users.json\n‚ï≠‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ # ‚îÇ  name   ‚îÇ age ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ 0 ‚îÇ Alice   ‚îÇ  25 ‚îÇ\n‚îÇ 1 ‚îÇ Bob     ‚îÇ  30 ‚îÇ\n‚îÇ 2 ‚îÇ Charlie ‚îÇ  20 ‚îÇ\n‚ï∞‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n</code></pre>\n<ul>\n<li>The <code>source</code> command in Nushell is used to execute the commands within a\nscript file (like <code>filter.nu</code>) in the current Nushell environment. It‚Äôs\nsimilar to running the script directly in the shell, but keeps the shell open\nfor further use. In this example, <code>source filter.nu</code> runs the commands inside\n<code>filter.nu</code>, processing the <code>users.json</code> file and creating the\n<code>filtered_users.json</code> file:</li>\n</ul>\n<pre><code class=\"language-nu\">source filter.nu\n# View the contents with bat\nbat filtered_users.json\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n       ‚îÇ File: filtered_users.json\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n   1   ‚îÇ [\n   2   ‚îÇ   {\n   3   ‚îÇ     \"name\": \"Alice\",\n   4   ‚îÇ     \"age\": 25\n   5   ‚îÇ   },\n   6   ‚îÇ   {\n   7   ‚îÇ     \"name\": \"Bob\",\n   8   ‚îÇ     \"age\": 30\n   9   ‚îÇ   }\n  10   ‚îÇ ]\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n</code></pre>\n<ul>\n<li>As you can see, without needing any external tools, Nushell was able to read,\nfilter, select, sort, and then re-serialize JSON data using a clear and\nconcise pipeline. This demonstrates its power in handling structured data\nnatively, making common data manipulation tasks within the shell significantly\nmore streamlined and readable compared to traditional approaches.</li>\n</ul>\n<p><strong>In the filter.nu example:</strong></p>\n<pre><code class=\"language-nu\"># filter.nu\nopen users.json           # Read JSON file into structured data\n| where age &gt; 21         # Filter users older than 21\n| select name age        # Select only name and age columns\n| sort-by age            # Sort by age\n| to json                # Convert back to JSON\n| save filtered_users.json # Save result to a new file\n</code></pre>\n<details>\n<summary> ‚úîÔ∏è Summary of above Command (Click to Expand)</summary>\n<ol>\n<li>\n<p><code>open users.json</code>: Produces a <strong>Nushell table</strong> representing the data.</p>\n</li>\n<li>\n<p><code>| where age &gt; 21</code>: Receives the table, filters rows based on the <code>age</code>\ncolumn, and outputs a new, filtered table.</p>\n</li>\n<li>\n<p><code>| select name age</code>: Receives the filtered table, selects only the <code>name</code> and\n<code>age</code> columns, and outputs a table with fewer columns.</p>\n</li>\n<li>\n<p><code>| sort-by age</code>: Receives the table, sorts the rows based on the <code>age</code>\ncolumn, and outputs a sorted table.</p>\n</li>\n<li>\n<p><code>| to json</code>: Receives the sorted table and converts it back into JSON text.</p>\n</li>\n<li>\n<p><code>| save filtered_users.json</code>: Receives the JSON text and saves it to a file.</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>So, while the concept of piping is the same, the nature of the data flowing\nthrough the Nushell pipeline is richer and more structured, enabling more\npowerful and direct data manipulation.</p>\n</li>\n<li>\n<p>While Nushell‚Äôs strengths, like its structured data pipelines, make it a\ngame-changer for many tasks, it‚Äôs not without its challenges, especially when\nintegrated with NixOS‚Äôs Bash-centric ecosystem. Let‚Äôs explore some of the\nlimitations you might encounter when adopting Nushell as your default shell.</p>\n</li>\n</ul>\n</details>\n<h3>The Bad</h3>\n<ul>\n<li>\n<p>While the project is still maturing, the active community and ongoing\nimprovements are promising. Don‚Äôt get too discouraged by the following, there\nwould be a bad section for any shell imo.</p>\n</li>\n<li>\n<p>There are many similarities so it can be easy to forget that some Bash (and\nPOSIX in general) style constructs just won‚Äôt work in Nushell. Considering\nthat NixOS seems to have been designed for bash, even Zsh isn‚Äôt fully\ncompatable you may want to think twice before you choose Nushell as your\ndefault.</p>\n</li>\n<li>\n<p>The documentation is incomplete and written by devs for devs imo, it is quite\na bit different from anything else I‚Äôve seen so there is a bit of a learning\ncurve. Nushell is generally still considered to be in a stage where it might\nnot be the most seamless or trouble-free experience as a daily driver default\nshell for most users, especially on a system like NixOS known for its unique\napproach.</p>\n</li>\n<li>\n<p>The <a href=\"https://github.com/haslersn/any-nix-shell\">any-nix-shell</a> project doesn‚Äôt\ninclude Nushell as with many others because of it‚Äôs lack of maturity.</p>\n</li>\n<li>\n<p>The following addition comes from Joey_McKur‚Äôs sugggestion, on mentioning the\n<code>job</code> command as one of the biggest criticisms against Nu because it doesn‚Äôt\nsupport background tasks. I should also note that Nushell‚Äôs team is aware of\nthese criticisms and actively working on improving job control.</p>\n</li>\n</ul>\n<p><strong>Limited Feature Set Compared to Traditional Job Control:</strong></p>\n<ul>\n<li>\n<p><strong>Lack of Full POSIX Job Control</strong>: Nushell‚Äôs job control doesn‚Äôt yet fully\nimplement all the features and signals defined by POSIX job control (e.g.,\nmore nuanced signal handling, stopped jobs). While it covers the basics, users\naccustomed to advanced Bash job control might find it lacking.</p>\n</li>\n<li>\n<p><strong>Foregrounding Behavior</strong>: There have been criticisms about how foregrounding\njobs interacts with the terminal and potential issues with signal propagation.</p>\n</li>\n</ul>\n<p><strong>Output Handling Challenges</strong>:</p>\n<ul>\n<li>\n<p><strong>Interleaved Output</strong>: Managing the output of multiple backgrounded jobs can\nsometimes be messy, with output from different jobs potentially interleaving\nin the terminal. While Nushell tries to handle this, it‚Äôs not always as clean\nas desired.</p>\n</li>\n<li>\n<p><strong>Redirection Complexity</strong>: Redirecting the input and output of backgrounded\njobs can be less straightforward than in Bash, sometimes requiring more\nexplicit handling.</p>\n</li>\n</ul>\n<p><strong>Integration with Pipelines:</strong></p>\n<ul>\n<li><strong>Backgrounding Pipelines</strong>: Backgrounding complex pipelines with multiple\nstages can sometimes lead to unexpected behavior or difficulties in managing\nthe entire pipeline as a single job.</li>\n</ul>\n<p><strong>Error Reporting:</strong></p>\n<ul>\n<li>\n<p><strong>Difficult to Track Errors in Background Jobs</strong>: Identifying and debugging\nerrors in backgrounded jobs can be less direct than with foreground processes,\nand the job command‚Äôs output might not always provide sufficient information\nfor troubleshooting.</p>\n</li>\n<li>\n<p>Many of Nushell‚Äôs challenges stem from its departure from traditional shell\nconventions, particularly those of Bash, which NixOS heavily relies on. To\nbetter understand these differences and how they impact your workflow, let‚Äôs\ncompare Nushell‚Äôs static, structured approach to Bash‚Äôs dynamic, text-based\nmodel.</p>\n</li>\n</ul>\n<h3>Key Differences Between Nushell &amp; Bash</h3>\n<table><thead><tr><th><strong>Feature</strong></th><th><strong>Bash (Dynamic)</strong></th><th><strong>Nushell (Static)</strong></th></tr></thead><tbody>\n<tr><td>Code Execution</td><td>Line-by-line</td><td>Whole script parsed first</td></tr>\n<tr><td>Error Detection</td><td>Runtime errors only</td><td>Catches errors before running</td></tr>\n<tr><td>Support for <code>eval</code></td><td>‚úÖ Allowed</td><td>‚ùå Not supported</td></tr>\n<tr><td>Custom Parsing</td><td>Limited</td><td>Built-in semantic analysis</td></tr>\n<tr><td>IDE Features</td><td>Basic syntax highlighting</td><td>Advanced integration, linting, and formatting</td></tr>\n</tbody></table>\n<ul>\n<li>\n<p><code>&amp;&amp;</code> doesn‚Äôt work use <code>;</code> instead.</p>\n</li>\n<li>\n<p><code>&gt;</code> is used as the greater-than operator for comparisons:</p>\n</li>\n</ul>\n<pre><code class=\"language-nu\">\"hello\" | save output.txt\n</code></pre>\n<p>is equivalent to the following in bash:</p>\n<pre><code class=\"language-bash\">echo \"hello\" &gt; output.txt\n</code></pre>\n<ul>\n<li>If you notice above the nushell command doesn‚Äôt require an <code>echo</code> prefix, this\nis because Nushell has <strong>Implicit Return</strong>:</li>\n</ul>\n<pre><code class=\"language-nu\">\"Hello, World\" == (echo \"Hello, World\")\n# =&gt; true\n</code></pre>\n<ul>\n<li>\n<p>The above example shows that the string, <code>\"Hello, World\"</code> is equivalent to the\noutput value from <code>echo \"Hello, World\"</code></p>\n</li>\n<li>\n<p><strong>Every Command Returns a Value</strong>:</p>\n</li>\n</ul>\n<pre><code class=\"language-nu\">let p = 7\nprint $p  # 7\n$p * 6    # 42\n</code></pre>\n<ul>\n<li>Understanding these differences highlights why Nushell feels so distinct from\nBash, but it‚Äôs the shell‚Äôs advanced features and integrations that truly make\nit shine. Let‚Äôs dive into some of the beautiful and powerful tools and custom\ncommands that elevate Nushell for NixOS users.</li>\n</ul>\n<h3>The Beautiful and Powerful</h3>\n<ul>\n<li>\n<p><code>Ctrl+t</code> List Commands with carapace and fzf:</p>\n<p><img src=\"images/nu4.png\" alt=\"nu4\" /></p>\n</li>\n<li>\n<p><code>Carapace</code>\n<a href=\"https://carapace-sh.github.io/carapace-bin/install.html\">Carapace-Bin Install</a>:</p>\n</li>\n</ul>\n<p>The folling is showing tab completion, I typed <code>hx fl&lt;TAB&gt;</code>:</p>\n<p><img src=\"images/nu9.png\" alt=\"nu9\" /></p>\n<ul>\n<li>\n<p><code>Carapace</code> man example:</p>\n<p><img src=\"images/nu7.png\" alt=\"nu7\" /></p>\n</li>\n</ul>\n<p><strong>Custom Nushell Commands</strong></p>\n<p>Most of the following scripts come from the\n<a href=\"https://github.com/nushell/nu_scripts#\">nu_scripts repo</a></p>\n<ul>\n<li>The following command allows you to choose which input to update interactively\nwith fzf.</li>\n</ul>\n<details>\n<summary> ‚úîÔ∏è Click to See Command</summary>\n<pre><code class=\"language-nu\"># nix.nu\n# upgrade system packages\n# `nix-upgrade` or `nix-upgrade -i`\ndef nix-upgrade [\n  flake_path: string = \"/home/jr/flake\", # path that contains a flake.nix\n  --interactive (-i) # select packages to upgrade interactively\n]: nothing -&gt; nothing {\n  let working_path = $flake_path | path expand\n  if not ($working_path | path exists) {\n    echo \"path does not exist: $working_path\"\n    exit 1\n  }\n  let pwd = $env.PWD\n  cd $working_path\n  if $interactive {\n    let selections = nix flake metadata . --json\n    | from json\n    | get locks.nodes\n    | columns\n    | str join \"\\n\"\n    | fzf --multi --tmux center,20%\n    | lines\n    # Debug: Print selections to verify\n    print $\"Selections: ($selections)\"\n    # Check if selections is empty\n    if ($selections | is-empty) {\n      print \"No selections made.\"\n      cd $pwd\n      return\n    }\n    # Use spread operator to pass list items as separate arguments\n    nix flake update ...$selections\n  } else {\n    nix flake update\n  }\n  cd $pwd\n  nh os switch $working_path\n}\n</code></pre>\n</details>\n<p><strong>Usage</strong>:</p>\n<pre><code class=\"language-nu\">nix-upgrade\n# or for individual packages\nnix-upgrade -i\n</code></pre>\n<p><img src=\"images/nu5.png\" alt=\"nu5\" /></p>\n<ul>\n<li>The <code>ns</code> command is designed to search for Nix packages using <code>nix search</code> and\npresent the results in a cleaner format, specifically removing the\narchitecture and operating system prefix that nix search often includes.</li>\n</ul>\n<details>\n<summary> ‚úîÔ∏è Click To Expand</summary>\n<pre><code class=\"language-nu\">def ns [\n    term: string # Search target.\n] {\n\n    let info = (\n        sysctl -n kernel.arch kernel.ostype\n        | lines\n        | {arch: ($in.0|str downcase), ostype: ($in.1|str downcase)}\n    )\n\n    nix search --json nixpkgs $term\n        | from json\n        | transpose package description\n        | flatten\n        | select package description version\n        | update package {|row| $row.package | str replace $\"legacyPackages.($info.arch)-($info.ostype).\" \"\"}\n}\n</code></pre>\n</details>\n<p><strong>Usage</strong>:</p>\n<pre><code class=\"language-nu\">ns fzf&lt;ENTER&gt;\n</code></pre>\n<p><img src=\"images/nu10.png\" alt=\"nu10\" /></p>\n<ul>\n<li><code>nufetch</code> command:</li>\n</ul>\n<details>\n<summary> ‚úîÔ∏è Click To Expand</summary>\n<pre><code class=\"language-nu\"># `nufetch` `(nufetch).packages`\ndef nufetch [] {\n{\n\"kernel\": $nu.os-info.kernel_version,\n\"nu\": $env.NU_VERSION,\n\"packages\": (ls /etc/profiles/per-user | select name | prepend [[name];\n[\"/run/current-system/sw\"]] | each { insert \"number\" (nix path-info --recursive\n ($in | get name) | lines | length) | insert \"size\" ( nix path-info -S\n ($in | get name) | parse -r '\\s(.*)' | get capture0.0 | into filesize) | update\n \"name\" ($in | get name | parse -r '.*/(.*)' | get capture0.0 | if $in == \"sw\"\n {\"system\"} else {$in}) | rename \"environment\"}),\n\"uptime\": (sys host).uptime\n}\n}\n</code></pre>\n</details>\n<p><img src=\"images/nu1.png\" alt=\"nu1\" /></p>\n<ul>\n<li><code>duf</code> command, I have mine aliased to <code>df</code>:</li>\n</ul>\n<p><img src=\"images/nu8.png\" alt=\"nu8\" /></p>\n<ul>\n<li><code>ps</code> command:</li>\n</ul>\n<p><img src=\"images/ps.png\" alt=\"ps\" /></p>\n<ul>\n<li><code>nix-list-system</code> command lists all installed packages:</li>\n</ul>\n<pre><code class=\"language-nu\"># list all installed packages\ndef nix-list-system []: nothing -&gt; list&lt;string&gt; {\n  ^nix-store -q --references /run/current-system/sw\n  | lines\n  | filter { not ($in | str ends-with 'man') }\n  | each { $in | str replace -r '^[^-]*-' '' }\n  | sort\n}\n</code></pre>\n<p><strong>Usage</strong>:</p>\n<pre><code class=\"language-bash\">nix-list-system\n</code></pre>\n<p><img src=\"images/nu6.png\" alt=\"nu6\" /></p>\n<ul>\n<li>These custom Nushell commands showcase its flexibility, but sometimes you need\nto work around Nushell‚Äôs limitations, like compatability with certain NixOS\ntools. This is where <code>just</code> and <code>justfiles</code> come in, simplifying complex\nworkflows and bridging gaps in Nushell‚Äôs functionality.</li>\n</ul>\n<h2>Using Just and Justfiles</h2>\n<ul>\n<li>\n<p>The following is my <code>justfile</code> that I keep right next to my <code>flake.nix</code> it\nsimplifies some commands and makes things work that weren‚Äôt working with\nnushell for my case, you‚Äôll have to change it to match your configuration.\nIt‚Äôs not perfect but works for my use case, take whats useful and leave the\nrest.</p>\n</li>\n<li>\n<p>You‚Äôll first need to install <a href=\"https://github.com/casey/just\">just</a> to make use\nof <code>justfiles</code>.</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\"># nix shell nixpkgs#just nixpkgs#nushell\nset shell := [\"nu\", \"-c\"]\nflake_path := \"/home/jr/flake\"\nhostname := \"magic\"\nhome_manager_output := \"jr@magic\"\n\nutils_nu := absolute_path(\"utils.nu\")\n\ndefault:\n    @just --list\n# Rebuild\n[group('nix')]\nfr:\n    nh os switch --hostname {{hostname}} {{flake_path}}\n\n# Flake Update\n[group('nix')]\nfu:\n    nh os switch  --hostname {{hostname}} --update {{flake_path}}\n\n# Update specific input\n# Usage: just upp nixpkgs\n[group('nix')]\nupp input:\n    nix flake update {{input}}\n# Test\n[group('nix')]\nft:\n    nh os test --hostname {{hostname}} {{flake_path}}\n# Collect Garbage\n[group('nix')]\nncg:\n    nix-collect-garbage --delete-old ; sudo nix-collect-garbage -d ; sudo /run/current-system/bin/switch-to-configuration boot\n\n[group('nix')]\ncleanup:\n    nh clean all\n\n</code></pre>\n<ul>\n<li>To list available commands type, (you must be in the same directory as the\njustfile): <code>just</code></li>\n</ul>\n<p><img src=\"images/just2.png\" alt=\"just\" /></p>\n<ul>\n<li>\n<p>So <code>just fmt</code> will run <code>nix fmt</code>.</p>\n</li>\n<li>\n<p>A lot of the <code>.nu</code> files came from this repo by BlindFS:</p>\n<ul>\n<li>\n<p><a href=\"https://github.com/blindFS/modern-dot-files/tree/main\">modern-dot-files</a> he\nuses Nix Darwin so there are a few changes for NixOS. I found this through\n<a href=\"https://github.com/nushell/this_week_in_nu\">this_week_in_nu</a>.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/TSawyer87/flakes/tree/main/homeManagerModules/shells/nushell\">my-nu-config</a>\nIf you use this, you‚Äôll need to change the first line of <code>fzf.nu</code> to the\nlocation of your config. You‚Äôll also need to change the constants at the top\nof <code>config.nu</code>. These are my old dotfiles, I have recently updated and made\nsure this config is up to date with recent nushell changes. Also, change the\n<code>let flake_path = ($env.HOME | path join \"flake\")</code> to your flake path.</p>\n</li>\n<li>\n<p>The examples use this starship\nconfig<a href=\"https://github.com/Aylur/dotfiles/blob/main/home/starship.nix\">Aylur-dotfiles</a>\nThe logic on the bottom enables starship for Nushell, Zsh, and Bash!</p>\n</li>\n<li>\n<p>If you wan‚Äôt to use my config you‚Äôll have to enable the experimental-feature\n<code>pipe-operators</code> in the same place you enable flakes and nix-command.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>There are still situations where I need to switch to zsh or bash to get\nsomething to work i.e. <code>nix-shell</code> and a few others.</p>\n</li>\n<li>\n<p>From custom commands to <code>justfile</code> integrations, Nushell offers a wealth of\ntools to enhance your NixOS experience, even if occasional workarounds are\nneeded. To dive deeper into Nushell and tailor it to your needs, here are some\nvaluable resources to explore, from official documentation to community-driven\nconfigurations.</p>\n</li>\n</ul>\n<h4>Resources</h4>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Resources </summary>\n<ul>\n<li>\n<p><a href=\"https://www.nushell.sh/book/\">Nushell-Book</a></p>\n</li>\n<li>\n<p><a href=\"https://www.nushell.sh/cookbook/\">Nushell-Cookbook</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/nushell/nu_scripts\">nu_scripts</a> some of the custom\ncommands came from here.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/nushell/nushell/tree/main/crates/nu-utils/src/default_files\">nushell sample-config</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/nushell/awesome-nu#plugins\">awesome-nu repo</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/nushell/showcase\">nu showcase-repo</a></p>\n</li>\n<li>\n<p><a href=\"https://discord.com/invite/NtAbbGn\">discord</a> You can find custom commands,\nconfigurations, etc here.</p>\n</li>\n</ul>\n</details>\n",
      "date_published": "2025-11-30T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/functions/functions_and_modules.html",
      "url": "https://saylesss88.github.io/functions/functions_and_modules.html",
      "title": "Functions and NixOS Modules",
      "content_html": "<h1>Functions and NixOS Modules</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p>When you start exploring NixOS configurations or tools like Home Manager, you‚Äôll\nencounter a concept called Nix Modules. Modules are also functions, but they\nbehave differently regarding their arguments, which can be a source of\nconfusion.</p>\n<p><strong>What are NixOS Modules</strong>?</p>\n<p>Nix Modules are a powerful system built on top of basic Nix functions, primarily\nused for declarative system configurations (like NixOS, Home Manager, NixOps,\netc.). They allow you to define parts of your system configuration in separate\nfiles that are then composed together.</p>\n<p>Each module is typically a Nix function that returns an attribute set with\nspecific keys like <code>options</code>, <code>config</code>, and <code>imports</code>.</p>\n<p><strong>Automatic Arguments in Modules</strong></p>\n<p>Unlike the functions we‚Äôve been writing, Nix‚Äôs module system automatically\npasses a standard set of arguments to every module function it evaluates. You\ndon‚Äôt explicitly pass these arguments when you <code>import</code> a module file; the\nmodule system handles it for you.</p>\n<p>The most common automatic arguments you‚Äôll see are:</p>\n<ul>\n<li>\n<p><code>config</code>: The aggregated configuration options of all modules combined. This\nis what you use to read other configuration values.</p>\n</li>\n<li>\n<p><code>options</code>: The definitions of all available configuration options across all\nmodules.</p>\n</li>\n<li>\n<p><code>pkgs</code>: The standard Nixpkgs set, equivalent to <code>import &lt;nixpkgs&gt; {}</code>. This is\nincredibly convenient as you don‚Äôt need to import it in every module.</p>\n</li>\n<li>\n<p><code>lib</code>: The Nixpkgs utility library (<code>pkgs.lib</code>), providing helper functions\nfor common tasks.</p>\n</li>\n<li>\n<p><code>specialArgs</code>: An attribute set of extra arguments to be passed to the module\nfunctions.</p>\n</li>\n</ul>\n<p>A typical module might start like this:</p>\n<pre><code class=\"language-nix\"># Example NixOS module\n{ config, pkgs, lib, ... }: # These arguments are passed automatically by the module system\n{\n  # ... module options and configuration\n  environment.systemPackages = [ pkgs.firefox pkgs.git ];\n  services.nginx.enable = true;\n  # ...\n}\n</code></pre>\n<p>In the above module, the only required argument is <code>pkgs</code> because we explicitly\nuse it in the module (i.e. <code>pkgs.firefox</code>). Editors have pretty good support for\nletting you know if you‚Äôre missing arguments or have unnecessary ones. <code>config</code>,\nand <code>lib</code> and would be required if we were setting any options in this module.</p>\n<p>This automatic passing of arguments is a core feature of the module system that\nsimplifies writing configurations, as you always have access to <code>pkgs</code>, <code>lib</code>,\nand the evolving <code>config</code> and <code>options</code> without boilerplate.</p>\n<h4><code>specialArgs</code>: Passing Custom Arguments to Modules</h4>\n<p>While the module system passes a standard set of arguments automatically, what\nif you need to pass additional, custom data to your modules that isn‚Äôt part of\nthe standard <code>config</code>, <code>pkgs</code>, <code>lib</code>, or <code>options</code>? This is where <code>specialArgs</code>\ncomes in.</p>\n<p><code>specialArgs</code> is an attribute you can pass to the <code>import</code> function when you\nload a module (or a set of modules). It‚Äôs typically used to provide data that\nyour modules need but isn‚Äôt something Nixpkgs would normally manage.</p>\n<p>For example, in a <code>configuration.nix</code>:</p>\n<pre><code class=\"language-nix\"># From your configuration.nix\n{ config, pkgs, lib, ... }: # Standard module arguments\n\nlet\n  myCustomValue = \"helloWorld\";\nin\n{\n  # ... imports all modules, including your custom ones\n  imports = [\n    ./hardware-configuration.nix\n    ./my-webserver-module.nix\n  ];\n\n  # This is where specialArgs would be used (often in import statements)\n  # Example: passing a custom value to ALL modules:\n  # (in module context, this is more complex, but conceptually)\n  # let\n  #   allModules = [ ./my-module.nix ];\n  # in\n  # lib.nixosSystem {\n  #   modules = allModules;\n  #   specialArgs = {\n  #     username = \"johndoe\";\n  #     mySecretKey = \"/run/keys/ssh_key\";\n  #   };\n  #   # ...\n  # };\n}\n</code></pre>\n<p>And then, inside <code>my-webserver-module.nix</code>:</p>\n<pre><code class=\"language-nix\"># my-webserver-module.nix\n{ config, pkgs, lib, username, mySecretKey, ... }: # username and mySecretKey come from specialArgs\n{\n  # ... use username and mySecretKey in your module\n  users.users.${username} = {\n    isNormalUser = true;\n    extraGroups = [ \"wheel\" \"networkmanager\" ];\n    # ...\n  };\n  # ...\n}\n</code></pre>\n<p>Any argument listed in a module‚Äôs function signature that is not one of the\nstandard <code>config</code>, <code>pkgs</code>, <code>lib</code>, <code>options</code> (or <code>pkgs.callPackage</code>, etc., which\nare often implicit through <code>pkgs</code>) must be provided via <code>specialArgs</code> at the\npoint where the modules are composed.</p>\n<p>Any values listed in a module that aren‚Äôt automatically passed via Nixpkgs must\nbe explicitly provided through <code>specialArgs</code>.</p>\n<h3><code>specialArgs</code> and <code>extraSpecialArgs</code> with Flakes</h3>\n<p>NixOS modules use <code>specialArgs</code> and Home-Manager uses <code>extraSpecialArgs</code> to\nallow you to pass extra arguments.</p>\n<p>Or with Flakes it would look like this:</p>\n<pre><code class=\"language-nix\">{\n  description = \"My Flake\";\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n   };\n\n  outputs = { self, nixpkgs, home-manager, ... }:\n    let\n      lib = nixpkgs.lib;\n      pkgs = nixpkgs.legacyPackages.${\"x86_64-linux\"};\n      system = \"x86_64-linux\";\n  host = \"magic\";\n  username = \"jr\";\n  userVars = {\n    timezone = \"America/New_York\";\n    locale = \"en_US.UTF-8\";\n    gitUsername = \"TSawyer87\";\n    dotfilesDir = \"~/.dotfiles\";\n    wm = \"hyprland\";\n    browser = \"firefox\";\n    term = \"ghostty\";\n    editor = \"hx\";\n    keyboardLayout = \"us\";\n  };\n    in {\n      nixosConfigurations = {\n        YOURHOSTNAME = lib.nixosSystem {\n          system = \"x86_64-linux\";\n          modules = [ ./configuration.nix ];\n          specialArgs = {\n            inherit userVars; # == userVars = userVars;\n            inherit host;\n            inherit username;\n          };\n        };\n      };\n      homeConfigurations = {\n        USERNAME = home-manager.lib.homeManagerConfiguration {\n          inherit pkgs;\n          modules = [ ./home.nix ];\n          extraSpecialArgs = {\n            inherit userVars;\n            inherit host;\n            inherit username;\n            # or it can be written like this:\n            # inherit userVars host username;\n          };\n        };\n      };\n    };\n}\n</code></pre>\n<p>Now if I want to use any of these arguments in modules I can by any module file\nreferenced by my configuration.</p>\n<p>For example, the following is a <code>git.nix</code> module that uses the variables from\nthe flake passed from <code>extraSpecialArgs</code> in this case because it‚Äôs a\nhome-manager module:</p>\n<pre><code class=\"language-nix\"># git.nix\n{ userVars, ... }: {\n  programs = {\n    git = {\n      enable = true;\n      userName = userVars.gitUsername;\n    };\n  };\n}\n</code></pre>\n<table><thead><tr><th style=\"text-align: left\">Feature</th><th style=\"text-align: left\">Regular Nix Function (e.g., <code>hello.nix</code>)</th><th style=\"text-align: left\">Nix Module (e.g., <code>my-config-module.nix</code>)</th></tr></thead><tbody>\n<tr><td style=\"text-align: left\"><strong>Arguments</strong></td><td style=\"text-align: left\"><strong>You must explicitly pass every single argument.</strong></td><td style=\"text-align: left\"><strong>Automatically receives <code>config</code>, <code>pkgs</code>, <code>lib</code>, <code>options</code>, etc.</strong></td></tr>\n<tr><td style=\"text-align: left\"><strong>Custom Args</strong></td><td style=\"text-align: left\">Passed directly in the function call.</td><td style=\"text-align: left\">Passed via <code>specialArgs</code> when the modules are composed.</td></tr>\n<tr><td style=\"text-align: left\"><strong>Boilerplate</strong></td><td style=\"text-align: left\">Often needs <code>pkgs = import &lt;nixpkgs&gt; {};</code> if not explicitly passed.</td><td style=\"text-align: left\"><code>pkgs</code> and <code>lib</code> are always available automatically.</td></tr>\n<tr><td style=\"text-align: left\"><strong>Purpose</strong></td><td style=\"text-align: left\">Defines a package, a utility, or a single value.</td><td style=\"text-align: left\">Defines a reusable part of a declarative system configuration.</td></tr>\n</tbody></table>\n",
      "date_published": "2025-11-30T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/vcs/git.html",
      "url": "https://saylesss88.github.io/vcs/git.html",
      "title": "Git",
      "content_html": "<h1>Version Control with Git</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<!-- ![Git Logo](../images/git1.png) -->\n<p>‚ö†Ô∏è <strong>Important</strong>: Never commit secrets (passwords, API keys, tokens, etc.) in\nplain text to your Git repository. If you plan to publish your NixOS\nconfiguration, always use a secrets management tool like sops-nix or agenix to\nkeep sensitive data safe. See the\n<a href=\"https://saylesss88.github.io/installation/enc/sops-nix.html\">Sops-Nix Guide</a>\nfor details.</p>\n<p>It‚Äôs also important to understand that <strong>all files in the <code>/nix/store</code> are\nworld-readable by default</strong> This has important security implications for anyone\nmanaging sensitive data on a NixOS system.</p>\n<p>What Does ‚ÄúWorld-Readable‚Äù Mean?</p>\n<ul>\n<li>\n<p>All files in /nix/store are readable by any user on the system.</p>\n</li>\n<li>\n<p>This is by design, the nix store is intended to be shared, immutable store of\nall packages and configuration files.</p>\n</li>\n<li>\n<p>Permissions are typically set to <code>r-xr-xr-x</code>(read and execute for everyone)</p>\n</li>\n</ul>\n<p><strong>Security Implications</strong></p>\n<ul>\n<li>\n<p>Never store secrets or sensitive data in plane text in the Nix store.</p>\n</li>\n<li>\n<p>If you include secrets directly in your configuration, they will end up in the\n<code>/nix/store</code> and be accessible to any user or process on the system.</p>\n</li>\n<li>\n<p>This applies to files, environment variables, and any data embedded in\nderivations.</p>\n</li>\n</ul>\n<p><strong>Best Practices</strong></p>\n<ul>\n<li>\n<p>Always use a secrets management tool (like <code>sops-nix</code> or <code>agenix</code>) that\ndecrypts secrets at activation time and stores them outside the Nix store,\nwith restricted permissions.</p>\n</li>\n<li>\n<p>Do not embed secrets directly in Nix expressions or configuration files that\nwill be build into the store.</p>\n</li>\n<li>\n<p>Even hashed passwords can be vulnerable when stored in a public repository, be\nconscious of what you store where.</p>\n</li>\n<li>\n<p>If you‚Äôre unsure about what‚Äôs safe to share, start with a private repository.\nThis gives you time to learn about secrets management and review your\nconfiguration before making anything public.</p>\n</li>\n</ul>\n<p>First, I‚Äôll briefly explain some of the limitations of NixOS Rollbacks and then\nI‚Äôll go into how Git compliments them.</p>\n<h2>Limitations of NixOS Rollbacks</h2>\n<p>NixOS is famous for its ability to roll back to previous system generations,\neither from the boot menu or with commands like <code>nixos-rebuild --rollback</code>.</p>\n<p>When you perform rollbacks in NixOS, whether from the boot menu or using\ncommands like <code>nixos-rebuild --rollback</code> only the contents and symlinks managed\nby the Nix store are affected. The rollback works by switching which system\ngeneration is active, atomically updating symlinks to point to the previous\nversion of all packages, <code>systemd</code> units and services stored in <code>/nix/store</code>.</p>\n<p>However, it‚Äôs important to understand what these rollbacks actually do and what\nthey don‚Äôt do. What NixOS Rollbacks Cover</p>\n<ul>\n<li>\n<p>System generations: When you rebuild your system, NixOS creates a new\n‚Äúgeneration‚Äù that you can boot into or roll back to. This includes all\npackages, services, and system configuration managed by Nix.</p>\n</li>\n<li>\n<p>Quick recovery: If an upgrade breaks your system, you can easily select an\nolder generation at boot and get back to a working state</p>\n</li>\n</ul>\n<p><strong>Key Limitations</strong>:</p>\n<ul>\n<li>\n<p><strong>Configuration files are not reverted</strong>: Rolling back only changes which\nsystem generation is active, it does not revert your actual configuration\nfiles (like <code>configuration.nix</code> or your flake files)</p>\n</li>\n<li>\n<p><strong>User data and service data are not rolled back</strong>: Only files managed by Nix\nare affected. Databases, user files, and other persistent data remain\nunchanged, which can cause problems if, for example, a service migrates its\ndatabase schema during an upgrade</p>\n</li>\n<li>\n<p><strong>Manual changes persist</strong>: Any manual edits to configuration files or system\nstate outside of Nix are not reverted by a rollback</p>\n</li>\n</ul>\n<h2>How Git Helps</h2>\n<!-- ![Git Logo 2](../images/git3.png) -->\n<ul>\n<li>\n<p>The <a href=\"https://docs.github.com/en/github-cli/github-cli/quickstart\">gh-cli</a>,\nsimplifies quite a few things for working with GitHub from the command line.</p>\n</li>\n<li>\n<p><strong>Tracks every configuration change</strong>: By version-controlling your NixOS\nconfigs with Git, you can easily see what changed, when, and why.</p>\n</li>\n<li>\n<p><strong>True config rollback</strong>: If a configuration change causes issues, you can use\n<code>git checkout</code> or <code>git revert</code> to restore your config files to a previous good\nstate, then rebuild your system</p>\n</li>\n<li>\n<p><strong>Safer experimentation</strong>: You can confidently try new settings or upgrades,\nknowing you can roll back both your system state (with NixOS generations) and\nyour config files (with Git).</p>\n</li>\n<li>\n<p><strong>Collaboration and backup</strong>: Git lets you share your setup, collaborate with\nothers, and restore your configuration if your machine is lost or damaged.</p>\n</li>\n</ul>\n<p>In summary: NixOS rollbacks are powerful for system state, but they don‚Äôt manage\nyour configuration file history. Git fills this gap, giving you full control and\ntraceability over your NixOS configs making your system both robust and truly\nreproducible. Version control is a fundamental tool for anyone working with\nNixOS, whether you‚Äôre customizing your desktop, managing servers, or sharing\nyour configuration with others. Git is the most popular version control system\nand is used by the NixOS community to track, share, and back up system\nconfigurations.</p>\n<p><strong>Why use Git with NixOS?</strong></p>\n<ul>\n<li>\n<p><strong>Track every change</strong>: Git lets you record every modification to your\nconfiguration files, so you can always see what changed, when, and why.</p>\n</li>\n<li>\n<p><strong>Experiment safely</strong>: Try new settings or packages without fear‚Äîif something\nbreaks, you can easily roll back to a previous working state.</p>\n</li>\n<li>\n<p><strong>Sync across machines</strong>: With Git, you can keep your NixOS setups in sync\nbetween your laptop, desktop, or servers, and collaborate with others.</p>\n</li>\n<li>\n<p><strong>Disaster recovery</strong>: Accidentally delete your config? With Git, you can\nrestore it from your repository in minutes.</p>\n</li>\n</ul>\n<p>Installing Git on NixOS</p>\n<p>You can install Git by adding it to your system packages in your\nconfiguration.nix or via Home Manager:</p>\n<h2>Git Tips</h2>\n<!-- ![Octocat](../images/octocat.png) -->\n<p>If you develop good git practices on your own repositories it will make it\neasier to contribute with others as well as get help from others.</p>\n<h2>Atomic Commits</h2>\n<p><strong>Atomic commits</strong> are a best practice in Git where each commit represents a\nsingle, focused, and complete change to the codebase. The main characteristics\nof atomic commits are:</p>\n<ul>\n<li>\n<p><strong>One purpose</strong>: Each commit should address only one logical change or task.</p>\n</li>\n<li>\n<p><strong>Complete</strong>: The commit should leave the codebase in a working state.</p>\n</li>\n<li>\n<p><strong>Descriptive</strong>: The commit message should be able to clearly summarize the\nchange in a single sentence.</p>\n</li>\n</ul>\n<p><strong>Why Atomic Commits Matter</strong></p>\n<ul>\n<li>\n<p><strong>Easier debugging</strong>: You can use tools like <code>git bisect</code> to quickly find\nwhich commit introduced a bug, since each commit is isolated.</p>\n</li>\n<li>\n<p><strong>Simpler reverts</strong>: You can revert without affecting unrelated changes.</p>\n</li>\n<li>\n<p><strong>Better collaboration</strong>: Code reviews and merges are more manageable when\nchanges are small and focused.</p>\n</li>\n</ul>\n<p>When you lump together a bunch of changes into a single commit it can lead to\nquite a few undesirable consequences. They make it harder to track down bugs,\nit‚Äôs more difficult to revert undesired changes without reverting desired ones,\nmake larger tickets harder to manage.</p>\n<p><strong>Every time a logical component is completed, commit it</strong>. Smaller commits make\nit easier for other devs and yourself to understand the changes and roll them\nback if necessary. This also makes it easier to share your code with others to\nget help when needed and makes merge conflicts less frequent and complex.</p>\n<p><strong>Finish the component, then commit it</strong>: There‚Äôs really no reason to commit\nunfinished work, use <code>git stash</code> for unfinished work and <code>git commit</code> for when\nthe logical component is complete. Use common sense and break complex components\ninto logical chunks that can be finished quickly to allow yourself to commit\nmore often.</p>\n<p><strong>Write Good Commit Messages</strong>: Begin with a summary of your changes, add a line\nof whitespace between the summary and the body of your message. Make it clear\nwhy this change was necessary. Use consistent language with generated messages\nfrom commands like <code>git merge</code> which is imperative and present tense\n(<code>&lt;&lt;change&gt;&gt;</code>, not <code>&lt;&lt;changed&gt;&gt;</code> or <code>&lt;&lt;changes&gt;&gt;</code>).</p>\n<h3>Tips for Keeping Commits Atomic with a Linear History</h3>\n<p>Squashing limits the benefits of atomic commits as it combines them all into a\nsingle commit as if you didn‚Äôt take the time to write them all out atomically.</p>\n<p>üß† Why Rebasing Wins for Linear History</p>\n<ul>\n<li>\n<p>No Merge Bubbles: Rebasing avoids those extra merge commits that clutter\n<code>git log --graph</code>. You get a clean, readable timeline.</p>\n</li>\n<li>\n<p>Atomic Commit Integrity: Each commit stands alone and tells a story. Rebasing\npreserves that narrative without diluting it with merge noise.</p>\n</li>\n<li>\n<p>Better Blame &amp; Bisect: Tools like git blame and git bisect work best when\nhistory is linear and logical.</p>\n</li>\n<li>\n<p>Time-Travel Simplicity: Cherry-picking or reverting is easier when commits\naren‚Äôt tangled in merge commits.</p>\n</li>\n</ul>\n<p>By default, when you run <code>git pull</code> git merges the commits into your local repo.\nTo change this to a rebase you can set the following:</p>\n<pre><code class=\"language-bash\">git config --global pull.rebase true\ngit config --global rebase.autoStash true\ngit config --global fetch.prune true  # auto delets remote-tracking branches that no longer exist\ngit config --global pull.ff only          # blocks merge pulls\n</code></pre>\n<p>Note: With pull.ff only pulls will fail if they would have had to merge. This\ncould happen if your local branch has diverged from the remote (e.g., someone\npushed new commits and you also committed locally) <code>git pull</code> will throw an\nerror like:</p>\n<pre><code class=\"language-bash\">fatal: Not possible to fast-forward, aborting.\n</code></pre>\n<p><strong>How to fix it</strong></p>\n<p>You basically do what Git won‚Äôt auto-do:</p>\n<pre><code class=\"language-bash\">git fetch origin\ngit rebase origin/main\n</code></pre>\n<p>This rewinds your local commits, applies remote commits, and replays yours on\ntop, keeping the history linear.</p>\n<p>If you don‚Äôt care about your local changes and want to discard them you can use\nthe following command:</p>\n<pre><code class=\"language-bash\">git reset --hard origin/main\n</code></pre>\n<p>This just makes your branch identical to the remote, no rebase required. This\nprevents rogue merge commits, preserving atomic commits and linear logs.</p>\n<p>You could set an alias for this with:</p>\n<pre><code class=\"language-bash\">git config --global alias.grs '!git fetch origin &amp;&amp; git rebase origin/main'\n</code></pre>\n<p>To check whether a setting is active or now you can use:</p>\n<pre><code class=\"language-bash\">git config --get rebase.autoStash\ntrue\n</code></pre>\n<p>To set these options with home-manager:</p>\n<pre><code class=\"language-nix\"># ... snip ...\n    extraConfig = lib.mkOption {\n      type = lib.types.attrs;\n      default = {\n        commit.gpgsign = true;\n        gpg.format = \"ssh\";\n        user.signingkey = \"/etc/ssh/ssh_host_ed25519_key.pub\";\n        extraConfig = {\n          pull = {\n            rebase = true;\n            ff = \"only\";\n        };\n        };\n        rebase = {\n          autoStash = true; # Auto stashes and unstashes local changes during rebase\n        };\n        fetch = {\n          prune = true; # Automatically deletes remote-tracking branches that no longer exist\n        };\n# ... snip ...\n</code></pre>\n<h2>Time Travel in Git</h2>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Time Travel Section </summary>\n<p><strong>View an old commit</strong>:</p>\n<pre><code class=\"language-bash\">git checkout &lt;commit_hash&gt;\n</code></pre>\n<p>This puts you in a ‚Äúdetached HEAD‚Äù state, letting you explore code as it was at\nthat commit. To return, checkout your branch again.</p>\n<p><strong>Go back and keep history (revert)</strong>:</p>\n<pre><code class=\"language-bash\">git revert &lt;commit_hash&gt;\n</code></pre>\n<p><strong>Go back and rewrite history (reset)</strong>:</p>\n<ul>\n<li>Soft reset (keep changes staged):</li>\n</ul>\n<pre><code class=\"language-bash\">git reset --soft &lt;commit_hash&gt;\n</code></pre>\n<ul>\n<li>Mixed reset (keep changes in working directory):</li>\n</ul>\n<pre><code class=\"language-bash\">git reset &lt;commit_hash&gt;\n</code></pre>\n<ul>\n<li>Hard reset (discard all changes after the commit):</li>\n</ul>\n<pre><code class=\"language-bash\">git reset --hard &lt;commit_hash&gt;\n</code></pre>\n<p>Use the above command with caution, it can delete commits from history.</p>\n<ul>\n<li>Relative time travel:</li>\n</ul>\n<pre><code class=\"language-bash\">git reset --hard HEAD@{5.minutes.ago}\n</code></pre>\n<p>or</p>\n<pre><code class=\"language-bash\">git reset --hard HEAD@{yesterday}\n</code></pre>\n<p><strong>Create a branch from the past</strong>:</p>\n<pre><code class=\"language-bash\">git checkout -b &lt;new-brach&gt; &lt;commit_hash&gt;\n</code></pre>\n<p>This starts a new branch from any previous commit, preserving current changes.</p>\n</details>\n<p>Some repositories have guidelines, such as Nixpkgs:</p>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Nixpkgs Commit Conventions </summary>\n<p><strong>Commit conventions</strong></p>\n<ul>\n<li>\n<p>Create a commit for each logical unit.</p>\n</li>\n<li>\n<p>Check for unnecessary whitespace with <code>git diff --check</code> before committing.</p>\n</li>\n<li>\n<p>If you have commits pkg-name: oh, forgot to insert whitespace: squash commits\nin this case. Use <code>git rebase -i</code>. See Squashing Commits for additional\ninformation.</p>\n</li>\n<li>\n<p>For consistency, there should not be a period at the end of the commit\nmessage‚Äôs summary line (the first line of the commit message).</p>\n</li>\n<li>\n<p>When adding yourself as maintainer in the same pull request, make a separate\ncommit with the message maintainers: <code>add &lt;handle&gt;</code>. Add the commit before\nthose making changes to the package or module. See Nixpkgs Maintainers for\ndetails.</p>\n<p>Make sure you read about any commit conventions specific to the area you‚Äôre\ntouching. See: Commit conventions for changes to <code>pkgs</code>. Commit conventions\nfor changes to <code>lib</code>. Commit conventions for changes to <code>nixos</code>. Commit\nconventions for changes to <code>doc</code>, the Nixpkgs manual.</p>\n</li>\n</ul>\n<p><strong>Writing good commit messages</strong></p>\n<p>In addition to writing properly formatted commit messages, it‚Äôs important to\ninclude relevant information so other developers can later understand why a\nchange was made. While this information usually can be found by digging code,\nmailing list/Discourse archives, pull request discussions or upstream changes,\nit may require a lot of work.</p>\n<p>Package version upgrades usually allow for simpler commit messages, including\nattribute name, old and new version, as well as a reference to the relevant\nrelease notes/changelog. Every once in a while a package upgrade requires more\nextensive changes, and that subsequently warrants a more verbose message.</p>\n<p>Pull requests should not be squash merged in order to keep complete commit\nmessages and GPG signatures intact and must not be when the change doesn‚Äôt make\nsense as a single commit.</p>\n</details>\n<p>A <strong>Git workflow</strong> is a recipe or recommendation for how to use Git to\naccomplish work in a consistent and productive manner. Having a defined workflow\nlets you leverage Git effectively and consistently. This is especially important\nwhen working on a team.</p>\n<p><strong>Origin</strong> is the <em>default name</em> (alias) for the <strong>remote repository</strong> that your\n<strong>local repository</strong> is connected to, usually the one you cloned from.</p>\n<p><strong>Remote Repositories</strong> are versions of your project that are hosted on the\ninternet or network somewhere.</p>\n<ul>\n<li>\n<p>When you run <code>git push origin main</code>, you‚Äôre telling Git to push your changes\nto the remote repo called <code>origin</code>.</p>\n</li>\n<li>\n<p>You can see which URL <code>origin</code> points to with <code>git remote -v</code>.</p>\n</li>\n<li>\n<p>You can have multiple remotes (like <code>origin</code>, <code>upstream</code>, etc.) each pointing\nto a different remote repo. Each of which is generally either read-only or\nread/write for you. Collaborating involves managing these remotes and pushing\nand pulling data to and from them when you need to share work.</p>\n</li>\n</ul>\n<blockquote>\n<p>‚ùó You can have a remote repo on your local machine. The word ‚Äúremote‚Äù doesn‚Äôt\nimply that the repository is somewhere else, only that it‚Äôs elsewhere.</p>\n</blockquote>\n<ul>\n<li>The name <code>origin</code> is just a convention, it‚Äôs not special. It is automatically\nset when you clone a repo.</li>\n</ul>\n<!-- ![git local remote](../images/git_local-remote.png) -->\n<p><strong>Local</strong> is your local copy of the repository, git tracks the differences\nbetween <strong>local</strong> and <strong>remote</strong> which is a repo hosted elsewhere (e.g., GitHub\nGitLab etc.)</p>\n<p>The <strong>Upstream</strong> in Git typically refers to the original repository from which\nyour local repository or fork was derived. The <strong>Upstream</strong> is the remote repo\nthat serves as the main source of truth, often the original project you forked\nfrom. You typically fetch changes from upstream to update your local repo with\nthe latest updates from the original project, but you don‚Äôt push to upstream\nunless you have write access.</p>\n<h3>A Basic Git Workflow</h3>\n<!-- ![Git logo 3](../images/git2.png) -->\n<ol>\n<li>Initialize your Repository:</li>\n</ol>\n<p>If you haven‚Äôt already created a Git repo in your NixOS config directory (for\nexample, in your flake or <code>/etc/nixos</code>):</p>\n<pre><code class=\"language-bash\">cd ~/flake\ngit init\ngit add .\ngit commit -m \"Initial commit: NixOS Configuration\"\n</code></pre>\n<p>Taking this initial snapshot with Git is a best practice‚Äîit captures the exact\nstate of your working configuration before you make any changes.</p>\n<ul>\n<li>\n<p>The command <code>git add .</code> stages all files in the directory (and its\nsubdirectories) for commit, meaning Git will keep track of them in your\nproject history.</p>\n</li>\n<li>\n<p>The command <code>git commit -m \"message\"</code> then saves a snapshot of these staged\nfiles, along with your descriptive message, into the repository.</p>\n<ul>\n<li>Think of a commit as a ‚Äúsave point‚Äù in your project. You can always go back\nto this point if you need to, making it easy to experiment or recover from\nmistakes. This two-step process, staging with <code>git add</code> and saving with\n<code>git commit</code> is at the heart of how Git tracks and manages changes over\ntime.</li>\n</ul>\n</li>\n</ul>\n<!-- ![git commit add](../images/git-add-commit.png) -->\n<ol start=\"2\">\n<li>Make and Track Changes:</li>\n</ol>\n<p>Now that you‚Äôve saved a snapshot of your working configuration, you‚Äôre free to\nexperiment and try new things, even if they might break your setup.</p>\n<p>Suppose you want to try a new desktop environment, like Xfce. You edit your\n<code>configuration.nix</code> to add:</p>\n<pre><code class=\"language-nix\">services.xserver.desktopManager.xfce.enable = true;\n</code></pre>\n<p>You run:</p>\n<pre><code class=\"language-bash\">sudo nixos-rebuild switch # if configuration.nix is in /etc/nixos/\n</code></pre>\n<p>But something goes wrong: the system boots, but your desktop is broken or won‚Äôt\nstart. You decide to roll back using the boot menu or:</p>\n<pre><code class=\"language-bash\">sudo nixos-rebuild switch --rollback\n</code></pre>\n<p><strong>What happens?</strong></p>\n<ul>\n<li>\n<p>Your system reverts to the previous working generation in <code>/nix/store</code></p>\n</li>\n<li>\n<p>But: Your <code>configuration.nix</code> file is still changed, it still has the line\nenabling Xfce. If you rebuild again, you‚Äôll get the same broken system,\nbecause your config itself wasn‚Äôt rolled back.</p>\n</li>\n</ul>\n<p><strong>How does Git Help on Failure?</strong></p>\n<p>Git gives you quite a few options and ways to inspect what has been done.</p>\n<ul>\n<li>\n<p>Use <code>git status</code> to see what‚Äôs changed, and <code>git checkout -- &lt;file&gt;</code> to\nrestore any file to its last committed state.</p>\n</li>\n<li>\n<p>Review your changes with <code>git diff</code> to see exactly what you modified before\ndeciding whether to keep or revert those changes.</p>\n</li>\n<li>\n<p>Reset everything with <code>git reset --hard HEAD</code>, this will discard all local\nchanges and return to your last commit.</p>\n</li>\n</ul>\n<p>With Git you can simply run:</p>\n<pre><code class=\"language-bash\">git checkout HEAD~1 configuration.nix\n# or, if you committed before the change:\ngit revert &lt;commit-hash&gt;\n</code></pre>\n<p>Show the full hash of the latest commit:</p>\n<pre><code class=\"language-bash\">git rev-parse HEAD\nf53fef375d89496c0174e70ce94993d43335098e\n</code></pre>\n<p>Short hash:</p>\n<pre><code class=\"language-bash\">git log --pretty=format:'%h' -n 1\nf53fef3\ngit revert f53fef3\n</code></pre>\n<p>Show a list of Recent commits:</p>\n<pre><code class=\"language-bash\">git log\n# a list of all commits, with hashes, author, date, and message\ngit log --oneline\ngit log --oneline\nf53fef3 (HEAD -&gt; main) thunar\nb34ea22 thunar\n801cbcf thunar\n5e72ba5 sops\n8b67c59 sops\n1a353cb sops\n</code></pre>\n<p>You can copy the commit hash from any of these and use it in commands like\n<code>git checkout &lt;hash&gt;</code> or <code>git revert &lt;hash&gt;</code>.</p>\n<p><strong>Commit successful experiments</strong></p>\n<ul>\n<li>If your changes work, stage, and commit them:</li>\n</ul>\n<pre><code class=\"language-bash\">git add .\n# or more specifically the file you changed or created\ngit add configuration.nix\ngit commit -m \"Describe the new feature or fix\"\n</code></pre>\n<h3>Basic Branching</h3>\n<p>With Git you‚Äôre always on a branch and the default branch is <code>master</code>. Many\nchange it to <code>main</code> because of the suggestion Git gives you. I think people are\ntoo easily offended these days, just keep this in mind that <code>main</code> and <code>master</code>\nrefer to the main development branch.</p>\n<p>You can get a listing of your current branches with:</p>\n<pre><code class=\"language-bash\">git branch\n* (no branch)\n  main\n</code></pre>\n<p>The <code>*</code> is next to the current branch and is where the <code>HEAD</code> is currently\npointing. It says <code>(no branch)</code> because I‚Äôm currently in detached <code>HEAD</code> where\n<code>HEAD</code> points to no branch. The reason for this is because I‚Äôve been trying out\nJujutsu VCS and that‚Äôs JJ‚Äôs default setting, a detached <code>HEAD</code>.</p>\n<p>Git actually gives you a warning about working in a detached <code>HEAD</code>:</p>\n<pre><code class=\"language-bash\">You are in 'detached HEAD' state. You can make experimental\nchanges and commit them, and you can discard any commits you make\nin this state without impacting any branch by switching back.\n\nIf you want to create a new branch to retain commits you create,\nyou can do so now (using 'git switch -c &lt;new-branch-name&gt;') or\nlater (using 'git branch &lt;new-branch-name&gt; &lt;commit-id&gt;').\n\nSee 'git help switch' for details.\n</code></pre>\n<p>To attach the <code>HEAD</code> (i.e., have the pointer pointing to a branch), use the\n<code>git checkout</code> command</p>\n<pre><code class=\"language-bash\">git checkout main\nSwitched to branch 'main'\n</code></pre>\n<pre><code class=\"language-bash\">git branch\n* main\n# Ensure that you have the latest \"tip\" from the remote repository `origin`\ngit fetch origin main\nFrom github.com:sayls8/flake\n * branch            main       -&gt; FETCH_HEAD\n</code></pre>\n<p>Although we‚Äôre working on our own repo and there is basically no chance of our\nlocal branch diverging from our remote, it‚Äôs still good to get in the practice\nof getting everything in sync before merging or rebasing etc.</p>\n<p><code>git fetch</code> doesn‚Äôt update <code>main</code>, it just updates your references. To update\n<code>main</code> you would use <code>git pull origin/main</code> or <code>git rebase origin/main</code></p>\n<p>You can inspect your upstream branches with the following command:</p>\n<pre><code class=\"language-bash\">git remote show origin\n* remote origin\n  Fetch URL: git@github.com:saylesss88/flake.git\n  Push  URL: git@github.com:saylesss88/flake.git\n  HEAD branch: main\n  Remote branch:\n    main tracked\n  Local ref configured for 'git push':\n    main pushes to main (fast-forwardable)\n</code></pre>\n<p><code>* branch     main      -&gt; FETCH_HEAD</code>: This line signifies that the <code>main</code>\nbranch from the remote repository (likely <code>origin</code>) was successfully fetched,\nand the commit ID of its current tip (its latest commit) is now stored in your\nlocal <code>FETCH_HEAD</code> reference.</p>\n<p>Now that we know our local <code>main</code> is up to date with our remote <code>origin/main</code> we\ncan safely create a new feature branch:</p>\n<pre><code class=\"language-bash\">git checkout -b feature/prose_wrap\nSwitched to a new branch 'feature/prose_wrap'\n</code></pre>\n<p>Right now the branch <code>feature/prose_wrap</code> is exactly the same as <code>main</code> and we\ncan safely make changes without affecting <code>main</code>. We can try crazy or even\n‚Äúdangerous‚Äù things and always be able to revert to a working state with\n<code>git checkout main</code>.</p>\n<p>If our crazy idea works out, we can then merge our feature branch into <code>main</code>.</p>\n<p>Ok the feature works, I‚Äôve added and committed the change. Now it‚Äôs time to\npoint the <code>HEAD</code> to <code>main</code> and then either merge or rebase the feature branch\ninto <code>main</code>:</p>\n<pre><code class=\"language-bash\">git checkout main\ngit fetch origin main\ngit merge feature/prose_wrap\nUpdating c8bd54c..b281f79\nFast-forward\n home/editors/helix/default.nix | 69 +++++++++++++++++++++++++++++++--------------------------------------\n 1 file changed, 31 insertions(+), 38 deletions(-)\n</code></pre>\n<ul>\n<li>‚Äúfast-forward‚Äù means that our <code>feature/prose_wrap</code> branch was directly ahead\nof the last commit on <code>main</code>. When you merge one commit with another commit\nthat can be reached by following the first commits history, remember the\nfeature branch is exactly the same as <code>main</code> until I made another commit. If\nthe branches diverged more and the history can‚Äôt be followed, Git will perform\na 3-way merge where it creates a new ‚Äúmerge commit‚Äù that combines the 2\nchanges.</li>\n</ul>\n<p>If you have a bunch of branches and forget which have been merged yet use:</p>\n<pre><code class=\"language-bash\">git branch --merged\nfeature/prose_wrap\n* main\n# OR to see branches that haven't been merged use:\ngit branch --no-merged\n</code></pre>\n<p>It‚Äôs now safe to delete the feature branch:</p>\n<pre><code class=\"language-bash\">git branch -d feature/prose_wrap\nDeleted branch feature/prose_wrap (was b281f79)\n</code></pre>\n<blockquote>\n<p>‚ùó TIP: If your feature branch has a lot of sloppy commits that won‚Äôt be of\nmuch benefit to anyone, squash them first then merge. The workflow would look\nsomething like this:</p>\n<pre><code class=\"language-bash\"> # Make sure you're on the main branch\n git checkout main\n\n # Merge the feature branch with squash\n git merge --squash feature/prose_wrap\n</code></pre>\n<ul>\n<li>This combines all the commits in your branch and adds them to your <code>main</code>\nstaging area, it doesn‚Äôt move HEAD or create a merge commit for you. To\napply the changes into one big commit, finalize it with:</li>\n</ul>\n<pre><code class=\"language-bash\"> git commit -m \"Add prose wrapping feature\"\n</code></pre>\n<p>This is often referred to as the ‚Äúsquash commit‚Äù.</p>\n</blockquote>\n<p>Branching means to diverge from the main line of development and continue to do\nwork without risking messing up your main branch. There are a few commits on\nyour main branch so to visualize this it would look something like this, image\nis from <a href=\"https://git-scm.com/book/en/v2\">Pro Git</a>:</p>\n<!-- ![Git Branch 1](../images/git-branch3.png) -->\n<h2>Nix flake update example with branches</h2>\n<p>Let‚Äôs say you haven‚Äôt ran <code>nix flake update</code> in a while and you don‚Äôt want to\nintroduce errors to your working configuration. To do so we can first, make sure\nwe don‚Äôt lose any changes on our main branch:</p>\n<pre><code class=\"language-bash\">git add .\ngit commit -m \"Staging changes before switching branches\"\n# I always like to make sure the configuration will build before pushing to git\nsudo nixos-rebuild switch --flake .\n# If everything builds and looks correct\ngit push origin main\n</code></pre>\n<p>OR, if you have incomplete changes that you don‚Äôt want to commit yet you can\nstash them with <code>git stash</code>:</p>\n<pre><code class=\"language-bash\">git status\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   home/git.nix\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n</code></pre>\n<p>Now we want to switch branches, without committing the incomplete changes to\n<code>git.nix</code>:</p>\n<pre><code class=\"language-bash\">git stash\nSaved working directory and index state WIP on main: 0e46d6b git: lol alias\n\ngit status\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\n</code></pre>\n<blockquote>\n<p>‚ùó <code>git stash</code> is equivalent to <code>git stash push</code></p>\n</blockquote>\n<p>To see which stashes you have stored, use <code>git sash list</code>:</p>\n<pre><code class=\"language-bash\">git stash list\nstash@{0}: WIP on main: 0e46d6b git: lol alias\n</code></pre>\n<p>To apply the most recent stash:</p>\n<pre><code class=\"language-bash\">git stash apply\ngit add home/git.nix\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   home/git.nix\n\n# or for multiple stashes\ngit stash apply stash@{2}\n</code></pre>\n<p>Running <code>git stash apply</code> applies the changes that were in your stash but\ndoesn‚Äôt automatically restage them, to apply the changes and stage them in one\ncommand:</p>\n<pre><code class=\"language-bash\">git stash apply --index\n</code></pre>\n<p>Now let‚Äôs create our branch so we can safely update:</p>\n<pre><code class=\"language-bash\">git checkout -b update-test\nSwitched to a new branch 'update-test'\n</code></pre>\n<p><code>-b</code> is to switch to the branch that was just created</p>\n<p>Some may prefer a more descriptive branch name such as: <code>update/flake-inputs</code>, I\nkept it short for the example. Or if your company uses an issue tracker,\nincluding the ticket number in the branch name can be helpful:\n<code>update/123-flake-inputs</code></p>\n<p>The above command is equivalent to:</p>\n<pre><code class=\"language-bash\">git branch update-test\ngit checkout update-test\n</code></pre>\n<p><del>Now our branches would look something like this, note how both branches\ncurrently point to the same commit:</del> I discovered that Git Book has pretty\nrestrictive licensing and will eventually find a replacement.</p>\n<!-- ![Git Branch 2](../images/git-branch2.png) -->\n<p>Now, lets run our update:</p>\n<pre><code class=\"language-bash\">nix flake update\nsudo nixos-rebuild test --flake .\n# If everything looks ok let's try applying the changes\nsudo nixos-rebuild switch --flake .\n# And if everything looks ok:\ngit add .\ngit commit -m \"feat: Updated all flake inputs\"\ngit push origin update-test\n</code></pre>\n<blockquote>\n<p>‚ùó This is the same workflow for commiting a PR. After you first fork and\nclone the repo you want to work on, you then create a new feature branch and\npush to that branch on your fork. This allows you to create a PR comparing\nyour changes to their existing configuration.</p>\n</blockquote>\n<p><del>At this point our graph would look similar to the following</del>:</p>\n<!-- ![Git Branch 3](../images/git-branch1.png) -->\n<p>If we are satisfied, we can switch back to our <code>main</code> branch and merge\n<code>update-test</code> into it:</p>\n<pre><code class=\"language-bash\">git checkout main\ngit merge origin/update-test\ngit branch -D update-test\nsudo nixos-rebuild test --flake .\nsudo nixos-rebuild switch --flake .\n</code></pre>\n<p>It‚Äôs good practice to delete a branch after you‚Äôve merged and are done with it.</p>\n<h2>Rebasing Branches</h2>\n<p>To combine two seperate branches into one unified history you typically use\n<code>git merge</code> or <code>git rebase</code>.</p>\n<p><code>git merge</code> takes two commit pointers and finds a common base commit between\nthem, it then creates a ‚Äúmerge commit‚Äù that combines the changes.</p>\n<p><code>git rebase</code> is used to move a sequence of commits to a new base commit.</p>\n<!-- ![Git rebase](../images/rebase.png) -->\n<h2>Configure Git Declaratively</h2>\n<p>The following example is the <code>git.nix</code> from the hydenix project it shows some\ncustom options and a way to manage everything from a single location:</p>\n<pre><code class=\"language-nix\"># git.nix from hydenix: declarative Git configuration for Home Manager\n{ lib, config, ... }:\n\nlet\n  cfg = config.hydenix.hm.git;\nin\n{\n\n  options.hydenix.hm.git = {\n    enable = lib.mkOption {\n      type = lib.types.bool;\n      default = config.hydenix.hm.enable;\n      description = \"Enable git module\";\n    };\n\n    name = lib.mkOption {\n      type = lib.types.nullOr lib.types.str;\n      default = null;\n      description = \"Git user name\";\n    };\n\n    email = lib.mkOption {\n      type = lib.types.nullOr lib.types.str;\n      default = null;\n      description = \"Git user email\";\n    };\n  };\n\n  config = lib.mkIf cfg.enable {\n\n    programs.git = {\n      enable = true;\n      userName = cfg.name;\n      userEmail = cfg.email;\n      extraConfig = {\n        init.defaultBranch = \"main\";\n        pull.rebase = false;\n      };\n    };\n  };\n}\n</code></pre>\n<blockquote>\n<p>‚ùó You can easily change the name of the option, everything after <code>config.</code> is\ncustom. So you could change it to for example, <code>config.custom.git</code> and you\nwould enable it with <code>custom.git.enable = true;</code> in your <code>home.nix</code> or\nequivalent.</p>\n</blockquote>\n<p>Then he has a <code>hm/default.nix</code> with the following to enable it.</p>\n<pre><code class=\"language-nix\">#...snip...\n\n # hydenix home-manager options go here\n  hydenix.hm = {\n    #! Important options\n    enable = true;\n      git = {\n        enable = true; # enable git module\n        name = null; # git user name eg \"John Doe\"\n        email = null; # git user email eg \"john.doe@example.com\"\n      };\n    }\n\n    # ... snip ...\n</code></pre>\n<p>You can enable git, and set your git username as well as git email right here.</p>\n<h3>Resources</h3>\n<ul>\n<li>\n<p><a href=\"https://gist.github.com/luismts/495d982e8c5b1a0ced4a57cf3d93cf60\">GitCommitBestPractices</a></p>\n</li>\n<li>\n<p><a href=\"https://git-scm.com/book/en/v2\">ProGit</a></p>\n</li>\n<li>\n<p><a href=\"https://ohshitgit.com/\">Oh shit Git</a></p>\n</li>\n</ul>\n",
      "date_published": "2025-11-30T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/Intro_to_Nix_Derivations.html",
      "url": "https://saylesss88.github.io/Intro_to_Nix_Derivations.html",
      "title": "Intro to Derivations",
      "content_html": "<h1>Derivations</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<h2>Introduction to Nix Derivations</h2>\n<p><img src=\"images/gruv10.png\" alt=\"gruv10\" /></p>\n<p>Nix‚Äôs build instructions, known as <strong>derivations</strong>, are defined using the Nix\nLanguage. These derivations can describe anything from individual software\npackages to complete system configurations. The Nix package manager then\ndeterministically ‚Äúrealizes‚Äù (builds) these derivations, ensuring consistency\nbecause they rely solely on a predefined set of inputs.</p>\n<p>Most things in NixOS are built around derivations. Your NixOS system is\ndescribed by such a single system derivation. When you want to apply a new\nconfiguration, <code>nixos-rebuild</code> handles the process:</p>\n<p>It first builds this derivation:</p>\n<pre><code class=\"language-bash\">nix-build '&lt;nixpkgs/nixos&gt;' -A system\n</code></pre>\n<p>Then, once the build is complete, it switches to that new system:</p>\n<pre><code class=\"language-bash\">result/bin/switch-to-configuration\n</code></pre>\n<p>After the build, <code>nixos-rebuild</code> updates a crucial symbolic link:\n<code>/run/current-system</code> This symlink always points to the active, running version\nof your system in the Nix store. In essence, the <code>/run/current-system</code> path is\nthe currently active system derivation. This design choice gives NixOS its\npowerful atomic upgrade and rollback capabilities: changing your system involves\nbuilding a new system derivation and updating this symlink to point to the\nlatest version.</p>\n<blockquote>\n<pre><code class=\"language-nix\"> ls -lsah /run/current-system\n 0 lrwxrwxrwx 1 root root 85 May 23 12:11 /run/current-system -&gt; /nix/store/\n cy2c0kxpjrl7ajlg9v3zh898mhj4dyjv-nixos-system-magic-25.11.20250520.2795c50\n</code></pre>\n</blockquote>\n<ul>\n<li>\n<p>The <code>-&gt;</code> indicates a symlink and it‚Äôs pointing to a <strong>store path</strong> which is\nthe result of a derivation being built (the system closure)</p>\n</li>\n<li>\n<p>For beginners, the analogy of a cooking recipe is helpful:</p>\n<ul>\n<li>\n<p><strong>Ingredients (Dependencies):</strong> What other software or libraries are needed.</p>\n</li>\n<li>\n<p><strong>Steps (Build Instructions):</strong> The commands to compile, configure, and\ninstall.</p>\n</li>\n<li>\n<p><strong>Final Dish (Output):</strong> The resulting package or resource.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>A Nix derivation encapsulates all this information, telling Nix what inputs to\nuse, how to build it, and what the final output should be.</p>\n<p>Nix derivations run in <strong>pure</strong>, <strong>isolated environments</strong>, meaning they\n<strong>cannot</strong> access the internet during the build phase. This ensures that builds\nare reproducible ‚Äì they don‚Äôt depend on external sources that might change over\ntime.</p>\n<p>There are <code>Fixed-output-derivations</code> that allow fetching resources during the\nbuild process by explicitly specifying the expected hash upfront. Just keep this\nin mind that normal derivations don‚Äôt have network access.</p>\n<h2>Creating Derivations in Nix</h2>\n<p>The primary way to define packages in Nix is through the <code>mkDerivation</code>\nfunction, which is part of the standard environment (<code>stdenv</code>). While a\nlower-level <code>derivation</code> function exists for advanced use cases, <code>mkDerivation</code>\nsimplifies the process by automatically managing dependencies and the build\nenvironment.</p>\n<p><code>mkDerivation</code> (and <code>derivation</code>) takes a set of attributes as its argument. At\na minimum, you‚Äôll often encounter these essential attributes:</p>\n<ol>\n<li>\n<p><strong>name:</strong> A human-readable identifier for the derivation (e.g., ‚Äúfoo‚Äù,\n‚Äúhello.txt‚Äù). This helps you and Nix refer to the package.</p>\n</li>\n<li>\n<p><strong>system:</strong> Specifies the target architecture for the build (e.g.,\n<code>builtins.currentSystem</code> for your current machine).</p>\n</li>\n<li>\n<p><strong>builder:</strong> Defines the program that will execute the build instructions\n(e.g., <code>bash</code>).</p>\n</li>\n</ol>\n<p><strong>How do we pass these required attributes to the <code>derivation</code> function?</strong></p>\n<p>Functions in Nix often take a single argument which is an attribute set. For\n<code>derivation</code> and <code>mkDerivation</code>, this takes the form\n<code>functionName { attribute1 = value1; attribute2 = value2; ... }</code>, where the <code>{}</code>\nencloses the set of attributes being passed as the function‚Äôs argument.</p>\n<p>Remember that <code>derivation</code> and <code>mkDerivation</code> take a set (i.e. <code>{}</code>) of\nattributes as its first argument. So, in order to pass the required attributes\nyou would do something like this:</p>\n<pre><code class=\"language-nix\">nix-repl&gt; pkgs = import &lt;nixpkgs&gt; {}\n\nnix-repl&gt; d = derivation {\n            name = \"mydrv\";\n            builder = \"${pkgs.bash}/bin/bash\";\n            args = [\n              \"-c\" # Tells bash to execute the following string as a command\n              ''\n                # Explicitly set PATH to include coreutils bin directory\n                export PATH=\"${pkgs.coreutils}/bin:$PATH\"\n                mkdir $out\n              ''\n            ];\n            system = builtins.currentSystem;\n          }\n\nnix-repl&gt; :b d\n</code></pre>\n<ul>\n<li>When I was starting out, seeing the above written in the following format made\nit clearer in my mental map that we were passing these attributes as arguments\nbut both accomplish the same thing.</li>\n</ul>\n<pre><code class=\"language-nix\">d = derivation { name = \"myname\"; builder = \"${coreutils}/bin/true\"; system = builtins.currentSystem; }\n</code></pre>\n<ul>\n<li>When you write <code>pkgs = import &lt;nixpkgs&gt; {};</code>, you are importing the Nixpkgs\n<code>default.nix</code> file, which resolves to a function. Calling that function by\npassing it an empty attribute set <code>{}</code> as its argument. The function then\nevaluates and returns the entire <code>pkgs</code> attribute set. To specify a different\nsystem for example, you could do something like:</li>\n</ul>\n<pre><code class=\"language-nix\">pkgsForAarch64 = import &lt;nixpkgs&gt; { system = \"aarch64-linux\"; };\n</code></pre>\n<p>So when you see:</p>\n<pre><code class=\"language-nix\">import &lt;nixpkgs&gt; { overlays = []; config = {}; }\n</code></pre>\n<ul>\n<li>\n<p>Instead, these empty sets explicitly override any global or implicit\noverlays/configurations that Nix might otherwise pick up from environment\nvariables (like <code>NIXPKGS_CONFIG</code>), default locations (like\n<code>~/.config/nixpkgs/config.nix</code> or <code>~/.config/nixpkgs/overlays</code>), or other\nmechanisms.</p>\n</li>\n<li>\n<p>This is to prevent accidental partial application from other parts of your\nconfiguration and is saying ‚ÄúDo not pass any custom configuration options for\nthis particular import‚Äù</p>\n</li>\n<li>\n<p><code>derivation</code> is a pre-made, built-in function in the Nix language. Here, we\nare passing it an attribute set as argument with the three required\nattributes. (<code>name</code>, <code>builder</code>, <code>system</code>, and we added an extra argument\n<code>args</code>.)</p>\n</li>\n</ul>\n<h2>The Hello World Derivation</h2>\n<p>For this example, first create a <code>hello</code> directory and add the\n<a href=\"https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz\">Hello tarball</a> to said\ndirectory.</p>\n<p>Now lets create the classic Hello derivation:</p>\n<pre><code class=\"language-nix\"># hello.nix\nlet\n  pkgs = import &lt;nixpkgs&gt; { };\nin\nderivation {\n  name = \"hello\";\n  builder = \"${pkgs.bash}/bin/bash\";\n  args = [ ./hello_builder.sh ];\n  inherit (pkgs)\n    gnutar\n    gzip\n    gnumake\n    gcc\n    coreutils\n    gawk\n    gnused\n    gnugrep\n    ;\n  bintools = pkgs.binutils.bintools;\n  src = ./hello-2.12.1.tar.gz;\n  system = builtins.currentSystem;\n}\n</code></pre>\n<ul>\n<li>As you can see, this isn‚Äôt the only required file but is a recipe outlining\nhow to build the <code>hello</code> package. The <code>tar.gz</code> package can be found\n<a href=\"https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz\">here</a> You would just place\nthe tarball in the same directory as the derivation along with the following\n<code>hello_builder.sh</code>:</li>\n</ul>\n<pre><code class=\"language-bash\"># hello_builder.sh\nexport PATH=\"$gnutar/bin:$gcc/bin:$gnumake/bin:$coreutils/bin:$gawk/bin:$gzip/bin:$gnugrep/bin:$gnused/bin:$bintools/bin\"\ntar -xzf $src\ncd hello-2.12.1\n./configure --prefix=$out\nmake\nmake install\n</code></pre>\n<p>And build it with:</p>\n<pre><code class=\"language-bash\">nix-build hello.nix\n</code></pre>\n<p>Finally execute it with:</p>\n<pre><code class=\"language-bash\">./result/bin/hello\nHello, world!\n</code></pre>\n<h2>Simple Rust Derivation</h2>\n<p>Create a <code>simple.rs</code> with the following contents:</p>\n<pre><code class=\"language-rust\">fn main() {\n  println!(\"Simple Rust!\")\n}\n</code></pre>\n<p>And a <code>rust_builder.sh</code> like this (this is our builder script):</p>\n<pre><code class=\"language-bash\"># rust_builder.sh\n# Set up the PATH to include rustc coreutils and gcc\nexport PATH=\"$rustc/bin:$coreutils/bin:$gcc/bin\"\n\n# IMPORTANT: Create the $out directory BEFORE rustc tries to write to it\nmkdir -p \"$out\"\n\n# Compile the Rust source code and place the executable inside $out\nrustc -o \"$out/simple_rust\" \"$src\"\n</code></pre>\n<p>Now we‚Äôll enter the <code>nix repl</code> and build it:</p>\n<pre><code class=\"language-bash\">‚ùØ nix repl\nNix 2.28.3\nType :? for help.\n\nnix-repl&gt; :l &lt;nixpkgs&gt;\nadded 3950 variables.\n\n# Define the variables for rustc, coreutils, bash, AND gcc from the loaded nixpkgs\nnix-repl&gt; rustc = pkgs.rustc\n\nnix-repl&gt; coreutils = pkgs.coreutils\n\nnix-repl&gt; bash = pkgs.bash\n\nnix-repl&gt; gcc = pkgs.gcc\n\n# Now define the derivation\nnix-repl&gt; simple_rust_program = derivation {\n            name = \"simple-rust-program\";\n            builder = \"${bash}/bin/bash\";\n            args = [ ./rust_builder.sh ];\n            rustc = rustc;\n            coreutils = coreutils;\n            gcc = gcc;\n            src = ./simple.rs;\n            system = builtins.currentSystem;\n          }\n\nnix-repl&gt; :b simple_rust_program\nThis derivation produced the following outputs:\nout -&gt; /nix/store/fmyqr2d3ph0lpnxd0xppwvwyhv3iyb7y-simple-rust-program\n</code></pre>\n<pre><code class=\"language-bash\">nix-store -r /nix/store/fmyqr2d3ph0lpnxd0xppwvwyhv3iyb7y-simple-rust-program\n\nwarning: you did not specify '--add-root'; the result might be removed by the garbage collector\n/nix/store/fmyqr2d3ph0lpnxd0xppwvwyhv3iyb7y-simple-rust-program\n</code></pre>\n<p>This simple Rust example, built with a direct derivation call, illustrates:</p>\n<ul>\n<li>\n<p>How Nix explicitly manages every single tool in your build environment\n(<code>bash</code>, <code>rustc</code>, <code>gcc</code>, <code>coreutils</code>).</p>\n</li>\n<li>\n<p>The strict isolation of Nix builds, where nothing is implicitly available.</p>\n</li>\n<li>\n<p>The deterministic mapping of inputs to unique output paths in the Nix store.</p>\n</li>\n<li>\n<p>The above example shows the fundamental structure of a Nix derivation, how\nit‚Äôs defined within the <code>nix-repl</code>.</p>\n</li>\n<li>\n<p><code>.drv</code> files are intermediate files that describe how to build a derivation;\nit‚Äôs the bare minimum information.</p>\n</li>\n</ul>\n<h2>When Derivations are Built</h2>\n<p>Nix doesn‚Äôt build derivations during the evaluation of your Nix expressions.\nInstead, it processes your code in two main phases (and why you need to use\n<code>:b simple_rust_program</code> or <code>nix-store -r</code> to actually build or realize it):</p>\n<ol>\n<li>\n<p>Evaluation/Instantiate Phase: This is when Nix parses and interprets your\n.nix expression. The result is a precise derivation description (often\nrepresented as a .drv file on disk), and the unique ‚Äúout paths‚Äù where the\nfinal built products will go are calculated. No actual code is compiled or\nexecuted yet. Achieved with <code>nix-instantiate</code></p>\n</li>\n<li>\n<p>Realize/Build Phase: Only after a derivation has been fully described does\nNix actually execute its build instructions. It first ensures all the\nderivation‚Äôs inputs (dependencies) are built, then runs the builder script\nin an isolated environment, and places the resulting products into their\ndesignated ‚Äúout paths‚Äù in the Nix store. Achieved with <code>nix-store -r</code></p>\n</li>\n</ol>\n<h2>Referring to other derivations</h2>\n<p>The way that we can refer to other packages/derivations is to use the <code>outPath</code>.</p>\n<p>The <code>outPath</code> describes the location of the files of that derivation. Nix can\nthen convert the derivation set into a string:</p>\n<pre><code class=\"language-bash\">nix repl\nnix-repl&gt; :l &lt;nixpkgs&gt;\nnix-repl&gt; fzf\n¬´derivation /nix/store/vw1zag9q4xvf10z24j1qybji7wfsz78v-fzf-0.62.0.drv¬ª\nnix-repl&gt; fzf.outPath\n\"/nix/store/z3ayhjslz72ldiwrv3mn5n7rs96p2g8a-fzf-0.62.0\"\nnix-repl&gt; builtins.toString fzf\n\"/nix/store/z3ayhjslz72ldiwrv3mn5n7rs96p2g8a-fzf-0.62.0\"\n</code></pre>\n<ul>\n<li>As long as there is an <code>outPath</code> attribute, Nix will do the ‚Äúset to string\nconversion‚Äù.</li>\n</ul>\n<h2>Produce a development shell from a derivation</h2>\n<p>Building on the concept of a derivation as a recipe, let‚Äôs create our first\npractical derivation. This example shows how to define a temporary development\nenvironment (a shell) using stdenv.mkDerivation, which is the primary function\nfor defining packages in Nix.</p>\n<pre><code class=\"language-nix\"># my-shell.nix\n# We use a `let` expression to bring `pkgs` and `stdenv` into scope.\n# This is a recommended practice over `with import &lt;nixpkgs&gt; {}`\n# for clarity and to avoid potential name collisions.\nlet\n  pkgs = import &lt;nixpkgs&gt; {};\n  stdenv = pkgs.stdenv; # Access stdenv from the imported nixpkgs\nin\n\n# Make a new \"derivation\" that represents our shell\nstdenv.mkDerivation {\n  name = \"my-environment\";\n\n  # The packages in the `buildInputs` list will be added to the PATH in our shell\n  buildInputs = [\n    # cowsay is an arbitrary package\n    # see https://nixos.org/nixos/packages.html to search for more\n    pkgs.cowsay\n    pkgs.fortune\n  ];\n}\n</code></pre>\n<p><strong>Usage</strong></p>\n<pre><code class=\"language-bash\">nix-shell my-shell.nix\nfortune | cowsay\n _________________________________________\n/ \"Lines that are parallel meet at        \\\n| Infinity!\" Euclid repeatedly, heatedly, |\n| urged.                                  |\n|                                         |\n| Until he died, and so reached that      |\n| vicinity: in it he found that the       |\n| damned things diverged.                 |\n|                                         |\n\\ -- Piet Hein                            /\n -----------------------------------------\n        \\   ^__^\n         \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n</code></pre>\n<ul>\n<li>To exit type: <code>exit</code></li>\n</ul>\n<p>This Nix expression defines a temporary development shell. Let‚Äôs break it down:</p>\n<ul>\n<li>\n<p><code>pkgs = import &lt;nixpkgs&gt; {};</code>: Standard way to get access to all the packages\nand helper functions (i.e. <code>nixpkgs.lib</code>)</p>\n</li>\n<li>\n<p><code>stdenv = pkgs.stdenv;</code>: <code>stdenv</code> provides us <code>mkDerivation</code> and is from the\n<code>nixpkgs</code> collection.</p>\n</li>\n<li>\n<p><code>stdenv.mkDerivation { ... };</code>: This is the core function for creating\npackages.</p>\n<ul>\n<li><code>stdenv</code> provides a set of common build tools and conventions.</li>\n</ul>\n</li>\n<li>\n<p><code>mkDerivation</code> takes an attribute set (a collection of key-value pairs) as its\nargument.</p>\n</li>\n<li>\n<p><code>name = \"my-environment\";</code>: This gives your derivation a human-readable name.</p>\n</li>\n<li>\n<p><code>buildInputs = [ pkgs.cowsay ];</code>: This is a list of dependencies that will be\navailable in the build environment of this derivation (or in the <code>PATH</code> if you\nenter the shell created by this derivation). <code>pkgs.cowsay</code> refers to the\n<code>cowsay</code> package from the imported <code>pkgs</code> collection.</p>\n</li>\n</ul>\n<p>The command <code>nix-instantiate --eval my-shell.nix</code> evaluates the Nix expression\nin the file. It does not build the derivation. Instead, it returns the Nix value\nthat the expression evaluates to.</p>\n<pre><code class=\"language-bash\">nix-instantiate --eval my-shell.nix\n</code></pre>\n<p>This value is a structured data type that encapsulates all the attributes (like\n<code>name</code>, <code>system</code>, <code>buildInputs</code>, etc.) required to build the derivation. Your\noutput shows this detailed internal representation of the derivation‚Äôs ‚Äúrecipe‚Äù\nas understood by Nix. This is useful for debugging and inspecting the\nderivation‚Äôs definition.</p>\n<h2>Our Second Derivation: Understanding the Builder</h2>\n<details>\n<summary> Understanding the Builder (Click to Expand) </summary>\n<ul>\n<li>To understand how derivations work, let‚Äôs create a very basic example using a\nbash script as our <code>builder</code>.</li>\n</ul>\n<h3>Why a Builder Script?</h3>\n<ul>\n<li>The <code>builder</code> attribute in a derivation tells Nix <em>how</em> to perform the build\nsteps. A simple and common way to define these steps is with a bash script.</li>\n</ul>\n<h3>The Challenge with Shebangs in Nix</h3>\n<ul>\n<li>\n<p>In typical Unix-like systems, you might start a bash script with a shebang\n(<code>#!/bin/bash</code> or <code>#!/usr/bin/env bash</code>) to tell the system how to execute it.\nHowever, in Nix derivations, we generally avoid this.</p>\n</li>\n<li>\n<p><strong>Reason:</strong> Nix builds happen in an isolated environment where the exact path\nto common tools like <code>bash</code> isn‚Äôt known beforehand (it resides within the Nix\nstore). Hardcoding a path or relying on the system‚Äôs <code>PATH</code> would break Nix‚Äôs\nstateless property.</p>\n</li>\n</ul>\n<h3>The Importance of Statelessness in Nix</h3>\n<ul>\n<li>\n<p><strong>Stateful Systems (Traditional):</strong> When you install software traditionally,\nit often modifies the core system environment directly. This can lead to\ndependency conflicts and makes rollbacks difficult.</p>\n</li>\n<li>\n<p><strong>Stateless Systems (Nix):</strong> Nix takes a different approach. When installing a\npackage, it creates a unique, immutable directory in the Nix store. This\nmeans:</p>\n<ul>\n<li>\n<p><strong>No Conflicts:</strong> Different versions of the same package can coexist without\ninterfering with each other.</p>\n</li>\n<li>\n<p><strong>Reliable Rollback:</strong> You can easily switch back to previous versions\nwithout affecting system-wide files.</p>\n</li>\n<li>\n<p><strong>Reproducibility:</strong> Builds are more likely to produce the same result\nacross different machines if they are ‚Äúpure‚Äù (don‚Äôt rely on external system\nstate).</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3>The Isolated Nix Build Environment: A Quick Overview</h3>\n<p>When Nix executes a builder script, it sets up a highly controlled and pristine\nenvironment to ensure <strong>reproducibility</strong> and <strong>isolation</strong>. Here‚Äôs what\nhappens:</p>\n<ol>\n<li>\n<p><strong>Fresh Start:</strong> Nix creates a temporary, empty directory for the build and\nmakes it the current working directory.</p>\n</li>\n<li>\n<p><strong>Clean Environment:</strong> It completely clears the environment variables from\nyour shell.</p>\n</li>\n<li>\n<p><strong>Controlled Inputs:</strong> Nix then populates the environment with <em>only</em> the\nvariables essential for the build, such as:</p>\n<ul>\n<li>\n<p><code>$NIX_BUILD_TOP</code>: The path to the temporary build directory.</p>\n</li>\n<li>\n<p><code>$PATH</code>: Carefully set to include only the explicit <code>buildInputs</code> you‚Äôve\nspecified, preventing reliance on arbitrary system tools.</p>\n</li>\n<li>\n<p><code>$HOME</code>: Set to <code>/homeless-shelter</code> to prevent programs from reading\nuser-specific configuration files.</p>\n</li>\n<li>\n<p>Variables for each declared output (<code>$out</code>, etc.), indicating where the\nfinal results should be placed in the Nix store.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Execution &amp; Logging:</strong> The builder script is run with its specified\narguments. All its output (stdout/stderr) is captured in a log.</p>\n</li>\n<li>\n<p><strong>Clean Up &amp; Registration:</strong> If successful, the temporary directory is\nremoved. Nix then scans the build outputs for references to other store\npaths, ensuring all dependencies are correctly tracked for future use and\ngarbage collection. Finally, it normalizes file permissions and timestamps\nin the output for consistent hashing.</p>\n</li>\n</ol>\n<p>This meticulous setup ensures that your builds are independent of the machine\nthey run on and always produce the same result, given the same inputs.</p>\n<h2>Our builder Script</h2>\n<ul>\n<li>For our first derivation, we‚Äôll create a simple <code>builder.sh</code> file in the\ncurrent directory:</li>\n</ul>\n<pre><code class=\"language-bash\"># builder.sh\ndeclare -xp\necho foo &gt; $out\n</code></pre>\n<ul>\n<li>\n<p>The command <code>declare -xp</code> lists exported variables (it‚Äôs a bash builtin\nfunction).</p>\n</li>\n<li>\n<p>Nix needs to know where the final built product (the ‚Äúcake‚Äù in our earlier\nanalogy) should be placed. So, during the derivation process, Nix calculates a\nunique output path within the Nix store. This path is then made available to\nour builder script as an environment variable named <code>$out</code>. The <code>.drv</code> file,\nwhich is the recipe, contains instructions for the builder, including setting\nup this <code>$out</code> variable. Our builder script will then put the result of its\nwork (in this case, the ‚Äúfoo‚Äù file) into this specific <code>$out</code> directory.</p>\n</li>\n<li>\n<p>As mentioned earlier we need to find the nix store path to the bash\nexecutable, common way to do this is to load Nixpkgs into the repl and check:</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">nix-repl&gt; :l &lt;nixpkgs&gt;\nAdded 3950 variables.\nnix-repl&gt; \"${bash}\"\n\"/nix/store/ihmkc7z2wqk3bbipfnlh0yjrlfkkgnv6-bash-4.2-p45\"\n</code></pre>\n<p>So, with this little trick we are able to refer to <code>bin/bash</code> and create our\nderivation:</p>\n<pre><code class=\"language-bash\">nix-repl&gt; d = derivation { name = \"foo\"; builder = \"${bash}/bin/bash\";\n args = [ ./builder.sh ]; system = builtins.currentSystem; }\nnix-repl&gt; :b d\n[1 built, 0.0 MiB DL]\n\nthis derivation produced the following outputs:\n  out -&gt; /nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo\n</code></pre>\n<ul>\n<li>\n<p>The contents of the resulting store path (<code>/nix/store/...-foo</code>) now contain\nthe file <code>foo</code>, as intended. We have successfully built a derivation!</p>\n</li>\n<li>\n<p>Derivations are the primitive that Nix uses to define packages. ‚ÄúPackage‚Äù is a\nloosely defined term, but a derivation is simply the result of calling\n<code>builtins.derivation</code>.</p>\n</li>\n</ul>\n</details>\n<h2>Our Last Derivation</h2>\n<p>Create a new directory and a <code>hello.nix</code> with the following contents:</p>\n<pre><code class=\"language-nix\"># hello.nix\n{\n  stdenv,\n  fetchzip,\n}:\n\nstdenv.mkDerivation {\n  pname = \"hello\";\n  version = \"2.12.1\";\n\n  src = fetchzip {\n    url = \"https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz\";\n    sha256 = \"\";\n  };\n}\n</code></pre>\n<p>Save this file to <code>hello.nix</code> and run <code>nix-build</code> to observe the build failure:</p>\n<ul>\n<li>Click to expand output:</li>\n</ul>\n<pre><code class=\"language-nix\">$ nix-build hello.nix\n~error: cannot evaluate a function that has an argument without a value ('stdenv')\n~       Nix attempted to evaluate a function as a top level expression; in\n~       this case it must have its arguments supplied either by default\n~       values, or passed explicitly with '--arg' or '--argstr'. See\n~       https://nix.dev/manual/nix/stable/language/constructs.html#functions.\n~\n~       at /home/nix-user/hello.nix:3:3:\n~\n~            2| {\n~            3|   stdenv,\n~             |   ^\n~            4|   fetchzip,\n</code></pre>\n<p><strong>Problem</strong>: The expression in <code>hello.nix</code> is a <em>function</em>, which only produces\nit‚Äôs intended output if it is passed the correct <em>arguments</em>.(i.e. <code>stdenv</code> is\navailable from <code>nixpkgs</code> so we need to import <code>nixpkgs</code> before we can use\n<code>stdenv</code>):</p>\n<p>The recommended way to do this is to create a <code>default.nix</code> file in the same\ndirectory as the <code>hello.nix</code> with the following contents:</p>\n<pre><code class=\"language-nix\"># default.nix\nlet\n  nixpkgs = fetchTarball \"https://github.com/NixOS/nixpkgs/tarball/nixos-24.05\";\n  pkgs = import nixpkgs { config = {}; overlays = []; };\nin\n{\n  hello = pkgs.callPackage ./hello.nix { };\n}\n</code></pre>\n<p>This allows you to run <code>nix-build -A hello</code> to realize the derivation in\n<code>hello.nix</code>, similar to the current convention used in Nixpkgs:</p>\n<ul>\n<li>Click to expand Output:</li>\n</ul>\n<pre><code class=\"language-nix\">nix-build -A hello\n~error: hash mismatch in fixed-output derivation '/nix/store/pd2kiyfa0c06giparlhd1k31bvllypbb-source.drv':\n~         specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\n~            got:    sha256-1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=\n~error: 1 dependencies of derivation '/nix/store/b4mjwlv73nmiqgkdabsdjc4zq9gnma1l-hello-2.12.1.drv' failed to build\n</code></pre>\n<ul>\n<li>Another way to do this is with\n<a href=\"https://nix.dev/manual/nix/2.24/command-ref/nix-prefetch-url\">nix-prefetch-url</a>\nIt is a utility to calculate the sha beforehand.</li>\n</ul>\n<pre><code class=\"language-bash\">nix-prefetch-url https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz\npath is '/nix/store/pa10z4ngm0g83kx9mssrqzz30s84vq7k-hello-2.12.1.tar.gz'\n086vqwk2wl8zfs47sq2xpjc9k066ilmb8z6dn0q6ymwjzlm196cd\n</code></pre>\n<ul>\n<li>When you use <code>nix-prefetch-url</code>, you get a Base32 hash when nix needs SRI\nformat.</li>\n</ul>\n<p>Run the following command to convert from Base32 to SRI:</p>\n<pre><code class=\"language-bash\">nix hash to-sri --type sha256 086vqwk2wl8zfs47sq2xpjc9k066ilmb8z6dn0q6ymwjzlm196cd\nsha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=\n</code></pre>\n<ul>\n<li>This actually fetched a different sha than the Nix compiler returned in the\nexample where we replace the empty sha with the one Nix gives us. The\ndifference was that <code>fetchzip</code> automatically extracts archives before\ncomputing the hash and slight differences in the metadata cause different\nresults. I had to switch from <code>fetchzip</code> to <code>fetchurl</code> to get the correct\nresults.\n<ul>\n<li>\n<p>Extracted archives can differ in timestamps, permissions, or compression\ndetails, causing different hash values.</p>\n</li>\n<li>\n<p>A simple takeaway is to use <code>fetchurl</code> when you need an exact match, and\n<code>fetchzip</code> when working with extracted contents.</p>\n</li>\n<li>\n<p><a href=\"https://nixos.org/manual/nixpkgs/stable/#fetchurl\">fetchurl</a></p>\n</li>\n<li>\n<p><code>fetchurl</code> returns a <code>fixed-output derivation</code>(FOD): A derivation where a\ncryptographic hash of the output is determined in advance using the\noutputHash attribute, and where the builder executable has access to the\nnetwork.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>Lastly replace the empty sha256 placeholder with the returned value from the\nlast command:</p>\n<pre><code class=\"language-nix\"># hello.nix\n{\n  stdenv,\n  fetchzip,\n}:\n\nstdenv.mkDerivation {\n  pname = \"hello\";\n  version = \"2.12.1\";\n\n  src = fetchzip {\n    url = \"https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz\";\n    sha256 = \"sha256-1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=\";\n  };\n}\n</code></pre>\n<p>Run <code>nix-build -A hello</code> again and you‚Äôll see the derivation successfully\nbuilds.</p>\n<h2>Best Practices</h2>\n<p><strong>Reproducible source paths</strong>: If we built the following derivation in\n<code>/home/myuser/myproject</code> then the store path of <code>src</code> will be\n<code>/nix/store/&lt;hash&gt;-myproject</code> causing the build to no longer be reproducible:</p>\n<pre><code class=\"language-nix\">let pkgs = import &lt;nixpkgs&gt; {}; in\n\npkgs.stdenv.mkDerivation {\n  name = \"foo\";\n  src = ./.;\n}\n</code></pre>\n<blockquote>\n<p>‚ùó TIP: Use <code>builtins.path</code> with the <code>name</code> attribute set to something fixed.\nThis will derive the symbolic name of the store path from the <code>name</code> instead\nof the working directory:</p>\n<pre><code class=\"language-nix\">let pkgs = import &lt;nixpkgs&gt; {}; in\n\npkgs.stdenv.mkDerivation {\n  name = \"foo\";\n  src = builtins.path { path = ./.; name = \"myproject\"; };\n}\n</code></pre>\n</blockquote>\n<h3>Conclusion</h3>\n<p>In this chapter, we‚Äôve laid the groundwork for understanding Nix derivations,\nthe fundamental recipes that define how software and other artifacts are built\nwithin the Nix ecosystem. We‚Äôve explored their key components ‚Äì inputs, builder,\nbuild phases, and outputs ‚Äì and how they contribute to Nix‚Äôs core principles of\nreproducibility and isolated environments. Derivations are the workhorses behind\nthe packages and tools we use daily in Nix.</p>\n<p>As you‚Äôve learned, derivations offer a powerful and principled approach to\nsoftware management. However, the way we organize and manage these derivations,\nalong with other Nix expressions and dependencies, has evolved over time.\nTraditionally, Nix projects often relied on patterns involving <code>default.nix</code>\nfiles, channel subscriptions, and manual dependency management.</p>\n<p>A more recent and increasingly popular approach to structuring Nix projects and\nmanaging dependencies is through Nix Flakes. Flakes introduce a standardized\nproject structure, explicit input tracking, and a more robust way to ensure\nreproducible builds across different environments.</p>\n<p>In our next chapter,\n<a href=\"https://saylesss88.github.io/Comparing_Flakes_and_Traditional_Nix_8.html\">Comparing Flakes and Traditional Nix</a>,\nwe will directly compare and contrast these two approaches. We‚Äôll examine the\nstrengths and weaknesses of traditional Nix practices in contrast to the\nbenefits and features offered by Nix Flakes. This comparison will help you\nunderstand the motivations behind Flakes and when you might choose one approach\nover the other for your Nix projects.</p>\n<p>As you can see below, there is a ton of information on derivations freely\navailable.</p>\n<h4>Links To Articles about Derivations</h4>\n<details>\n<summary> Click To Expand Resources </summary>\n<ul>\n<li>\n<p><a href=\"https://nixos.org/guides/nix-pills/06-our-first-derivation\">NixPillsOurFirstDerivation</a></p>\n</li>\n<li>\n<p><a href=\"https://nixos.org/guides/nix-pills/07-working-derivation\">NixPills-WorkingDerivation</a></p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/manual/nix/2.24/language/derivations\">nix.dev-Derivations</a></p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/tutorials/packaging-existing-software\">nix.dev-packagingExistingSoftware</a></p>\n</li>\n<li>\n<p><a href=\"https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/\">howToLearnNix-MyFirstDerivation</a></p>\n</li>\n<li>\n<p><a href=\"https://ianthehenry.com/posts/how-to-learn-nix/derivations-in-detail/\">howToLearnNix-DerivationsInDetail</a></p>\n</li>\n<li>\n<p><a href=\"https://www.sam.today/blog/creating-a-super-simple-derivation-learning-nix-pt-3\">Sparky/blog-creatingASuperSimpleDerivation</a> #\nHow to learn Nix</p>\n</li>\n<li>\n<p><a href=\"https://www.sam.today/blog/derivations-102-learning-nix-pt-4\">Sparky/blog-Derivations102</a></p>\n</li>\n<li>\n<p><a href=\"https://scrive.github.io/nix-workshop/04-derivations/01-derivation-basics.html\">ScriveNixWorkshop-nixDerivationBasics</a></p>\n</li>\n<li>\n<p><a href=\"https://zero-to-nix.com/concepts/derivations/\">zeroToNix-Derivations</a></p>\n</li>\n<li>\n<p><a href=\"https://www.tweag.io/blog/2021-02-17-derivation-outputs-and-output-paths/\">Tweag-derivationOutputs</a></p>\n</li>\n<li>\n<p><a href=\"https://ayats.org/blog/nix-tuto-2\">theNixLectures-Derivations</a></p>\n</li>\n<li>\n<p><a href=\"https://bmcgee.ie/posts/2023/02/nix-what-are-fixed-output-derivations-and-why-use-them/\">bmcgee-whatAreFixed-OutputDerivations</a></p>\n</li>\n</ul>\n</details>\n",
      "date_published": "2025-11-29T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/flakes/flake_outputs.html",
      "url": "https://saylesss88.github.io/flakes/flake_outputs.html",
      "title": "Flake outputs",
      "content_html": "<h1>Nix Flake Outputs</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p>Flake outputs are what the flake produces when built. Flakes can have multiple\noutputs simultaneously such as:</p>\n<ul>\n<li>\n<p><strong>Packages</strong>: Self-contained bundles that are built using derivations and\nprovide either some kind of software or dependencies of software.</p>\n</li>\n<li>\n<p><a href=\"https://saylesss88.github.io/NixOS_Modules_Explained_3.html\">NixOS modules</a></p>\n</li>\n<li>\n<p>Nix development environments</p>\n</li>\n<li>\n<p><a href=\"https://github.com/NixOS/templates\">Nix templates</a></p>\n</li>\n<li>\n<p>The <code>outputs</code> top-level attribute is actually a function that takes an\nattribute set of inputs and returns an attribute set that is essentially a\nrecipe for building the flake.</p>\n</li>\n</ul>\n<h2>Output Schema</h2>\n<p>Once the inputs are resolved, they‚Äôre passed to the <code>outputs</code> attribute. This\n<code>outputs</code> attribute is, in fact, a function, as indicated by the <code>:</code> colon (or\nthe <code>lambda</code> syntax) that follows its definition. This function takes the\nresolved inputs (and <code>self</code>, the flake‚Äôs directory in the store) as arguments,\nand its return value dictates the outputs of the flake, following this schema:</p>\n<pre><code class=\"language-nix\">{ self, nixpkgs, ... }@inputs:\n{\n  # Executed by `nix flake check`\n  checks.\"&lt;system&gt;\".\"&lt;name&gt;\" = derivation;\n  # Executed by `nix build .#&lt;name&gt;`\n  packages.\"&lt;system&gt;\".\"&lt;name&gt;\" = derivation;\n  # Executed by `nix build .`\n  packages.\"&lt;system&gt;\".default = derivation;\n  # Executed by `nix run .#&lt;name&gt;`\n  apps.\"&lt;system&gt;\".\"&lt;name&gt;\" = {\n    type = \"app\";\n    program = \"&lt;store-path&gt;\";\n  };\n  # Executed by `nix run . -- &lt;args?&gt;`\n  apps.\"&lt;system&gt;\".default = { type = \"app\"; program = \"...\"; };\n\n  # Formatter (alejandra, nixfmt or nixpkgs-fmt)\n  formatter.\"&lt;system&gt;\" = derivation;\n  # Used for nixpkgs packages, also accessible via `nix build .#&lt;name&gt;`\n  legacyPackages.\"&lt;system&gt;\".\"&lt;name&gt;\" = derivation;\n  # Overlay, consumed by other flakes\n  overlays.\"&lt;name&gt;\" = final: prev: { };\n  # Default overlay\n  overlays.default = final: prev: { };\n  # Nixos module, consumed by other flakes\n  nixosModules.\"&lt;name&gt;\" = { config, ... }: { options = {}; config = {}; };\n  # Default module\n  nixosModules.default = { config, ... }: { options = {}; config = {}; };\n  # Used with `nixos-rebuild switch --flake .#&lt;hostname&gt;`\n  # nixosConfigurations.\"&lt;hostname&gt;\".config.system.build.toplevel must be a derivation\n  nixosConfigurations.\"&lt;hostname&gt;\" = {};\n  # Used by `nix develop .#&lt;name&gt;`\n  devShells.\"&lt;system&gt;\".\"&lt;name&gt;\" = derivation;\n  # Used by `nix develop`\n  devShells.\"&lt;system&gt;\".default = derivation;\n  # Hydra build jobs\n  hydraJobs.\"&lt;attr&gt;\".\"&lt;system&gt;\" = derivation;\n  # Used by `nix flake init -t &lt;flake&gt;#&lt;name&gt;`\n  templates.\"&lt;name&gt;\" = {\n    path = \"&lt;store-path&gt;\";\n    description = \"template description goes here?\";\n  };\n  # Used by `nix flake init -t &lt;flake&gt;`\n  templates.default = { path = \"&lt;store-path&gt;\"; description = \"\"; };\n}\n</code></pre>\n<p>The first line <code>{ self, nixpkgs, ... }@ inputs:</code> defines the functions\nparameters: It‚Äôs important to understand that within the scope of the <code>outputs</code>\nfunction <code>nixpkgs</code> is available at the top-level because we explicitly passed it\nas an argument but for individual modules outside this flake the scope is lost,\nand you need to use <code>inputs.nixpkgs</code> (or equivalent)</p>\n<ol>\n<li>\n<p>It explicitly names the <code>self</code> attribute, making it directly accessible. The\nvariadic <code>...</code> ellipses part of the function signature is what allows all\nyour flake inputs to be brought into the function‚Äôs scope without having to\nlist each one explicitly.</p>\n</li>\n<li>\n<p>It destructures all other attributes (your defined <code>inputs</code>) into the\nfunctions scope.</p>\n</li>\n<li>\n<p>It gives you a convenient single variable, <code>inputs</code>, that refers to the\nentire attribute set passed to the <code>outputs</code> function. This allows you to\naccess inputs either individually (e.g. <code>nixpkgs</code>) or through the <code>inputs</code>\nvariable (e.g. <code>inputs.nixpkgs</code>).</p>\n</li>\n</ol>\n<p>You can also define additional arbitrary attributes, but these are the outputs\nthat Nix knows about.</p>\n<p>As you can see, the majority of the outputs within the outputs schema expect a\nderivation. This means that for packages, applications, formatters, checks, and\ndevelopment shells, you‚Äôll be defining a Nix derivation‚Äîa set of instructions\nthat tells Nix how to build a particular software component. This is central to\nNix‚Äôs declarative nature.</p>\n<ul>\n<li>The command <code>nix flake show</code>, takes a flake URI and prints all the outputs of\nthe flake as a nice tree structure, mapping attribute paths to the types of\nvalues.</li>\n</ul>\n<pre><code class=\"language-bash\">Ôåì  ~/players/third  3s\n‚ùØ nix flake show\npath:/home/jr/players/third?lastModified=1748272555&amp;narHash=sha256-oNzkC6X9hA0MpOBmJSZ89w4znXxv4Q5EkFhp0ewehY0%3D\n‚îú‚îÄ‚îÄ‚îÄnixosConfigurations\n‚îÇ   ‚îî‚îÄ‚îÄ‚îÄtesting: NixOS configuration\n‚îî‚îÄ‚îÄ‚îÄnixosModules\n    ‚îî‚îÄ‚îÄ‚îÄdefault: NixOS module\n</code></pre>\n<p>To show you the structure of this little flake project:</p>\n<pre><code class=\"language-bash\">Ôåì  ~/players\n‚ùØ tree\nÓóø .\n‚îú‚îÄ‚îÄ Óóø first\n‚îÇ   ‚îú‚îÄ‚îÄ Ôåì flake.lock\n‚îÇ   ‚îú‚îÄ‚îÄ Ôåì flake.nix\n‚îÇ   ‚îî‚îÄ‚îÄ Óóø result -&gt; /nix/store/701vyaanmqchd2nnaq71y65v8ws11zx0-nixos-system-nixos-24.11.20250523.f09dede\n‚îú‚îÄ‚îÄ Óóø second\n‚îÇ   ‚îú‚îÄ‚îÄ Ôåì flake.lock\n‚îÇ   ‚îî‚îÄ‚îÄ Ôåì flake.nix\n‚îî‚îÄ‚îÄ Óóø third\n    ‚îú‚îÄ‚îÄ Ôåì flake.lock\n    ‚îú‚îÄ‚îÄ Ôåì flake.nix\n    ‚îî‚îÄ‚îÄ Óóø result -&gt; /nix/store/mlszr5ws3xaly8m4q9jslgs31w6w76y2-nixos-system-nixos-24.11.20250523.f09dede\n</code></pre>\n<h2>Simple Example providing an output</h2>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  outputs = { self }: {\n    bada = \"bing\";\n  };\n}\n</code></pre>\n<p>You can then evaluate this specific output using <code>nix eval</code>:</p>\n<pre><code class=\"language-bash\">nix eval .#bada\n\"bing\"\n</code></pre>\n<h2>Outputs understood by Nix</h2>\n<p>While the attribute set that <code>outputs</code> returns may contain arbitrary attributes,\nmeaning any valid Nix value. Some of the standard outputs are understood by\nvarious <code>nix</code> utilities. <code>packages</code> is one of these:</p>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs\";\n  };\n\n  outputs = { self, nixpkgs }: {\n    # this is the re-exporting part!\n    packages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello;\n  };\n}\n</code></pre>\n<ul>\n<li>Re-exporting happens when you take the value of <code>hello</code> in its standard\nderivation format, exactly as <code>nixpkgs</code> produces it and assign it to an\nattribute in your own flake‚Äôs outputs.\n<ul>\n<li>\n<p><code>packages.x86_64-linux.hello</code>(your flake‚Äôs output path) <code>=</code>\n<code> nixpkgs.legacyPackages.x86_64-linux.hello</code>(the source from the <code>nixpkgs</code>\nflake‚Äôs output)</p>\n</li>\n<li>\n<p>We‚Äôre saying, My flakes <code>hello</code> package is exactly the same as the <code>hello</code>\npackage found inside the <code>nixpkgs</code> input flake.</p>\n</li>\n<li>\n<p>It‚Äôs important to understand that within the scope of the <code>outputs</code> function\n(i.e. within your flake), <code>nixpkgs</code> is available at the top-level (i.e. the\n<code>= nixpkgs</code> part) because we explicitly passed it as an argument but for\nindividual modules outside of this flake the scope is lost, and\n<code>inputs.nixpkgs</code> is needed.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>The following command builds the reexported package:</p>\n<pre><code class=\"language-bash\">nix build .#hello\n</code></pre>\n<p>or run it with:</p>\n<pre><code class=\"language-bash\">nix run .#hello\n</code></pre>\n<p>You might notice <code>x86_64-linux</code> appearing in the package path, and there‚Äôs a\ngood reason for it. Flakes are designed to provide <em>hermetic evaluation</em>,\nmeaning their outputs should be identical regardless of the environment where\nthey‚Äôre built. A key factor in any build system is the platform (which combines\nthe architecture and operating system, like <code>x86_64-linux</code> or <code>aarch64-darwin</code>).</p>\n<p>Because of Nix‚Äôs commitment to reproducibility across different systems, any\nflake output that involves building software packages must explicitly specify\nthe platform. The standard approach is to structure these outputs as an\nattribute set where the names are platforms, and the values are the outputs\nspecific to that platform. For the packages output, each platform-specific value\nis itself an attribute set containing the various packages built for that\nparticular system.</p>\n<h2>Exporting Functions</h2>\n<p>This example outputs a <code>sayGoodbye</code> function, via the <code>lib</code> attribute, that\ntakes a name for its input and outputs a string saying Goodbye very nicely to\nthe person with that name:</p>\n<pre><code class=\"language-nix\">{\n  outputs = { self }: {\n    lib = {\n      sayGoodbye = name: \"Goodbye F*** Off, ${name}!\";\n    };\n  };\n}\n</code></pre>\n<p>You could then specify this flake as an input to another flake and use\n<code>sayGoodbye</code> however you‚Äôd like.</p>\n<p>Or load it into the <code>nix repl</code> like so:</p>\n<pre><code class=\"language-bash\">nix repl\nnix-repl&gt; :lf .\nnix-repl&gt; lib.sayGoodbye\n¬´lambda sayGoodbye @ /nix/store/665rwfvkwdx6kwvk9ldijp2a6jvcgv1n-source/flake.nix:4:20¬ª\nnix-repl&gt; lib.sayGoodbye \"Jr\"\n\"Goodbye F*** Off, Jr!\"\n</code></pre>\n<ul>\n<li>As you can see, specifying <code>lib.sayGoodbye</code> without any arguments returns a\nfunction. (a lambda function)</li>\n</ul>\n<h2>Simplifying Multi-Platform Outputs with flake-utils</h2>\n<p>Manually repeating these platform definitions for every output (<code>packages</code>,\n<code>devShells</code>, <code>checks</code>, etc.) can quickly become verbose. This is where the\nflake-utils helper flake comes in handy. It provides utilities to reduce\nboilerplate when defining outputs for multiple systems.</p>\n<p>A commonly used function is <code>flake-utils.lib.eachDefaultSystem</code>, which\nautomatically generates outputs for common platforms (like <code>x86_64-linux</code>,\n<code>aarch64-linux</code>, <code>x86_64-darwin</code>, <code>aarch64-darwin</code>). This transforms your\noutputs definition from manually listing each system to a more concise\nstructure:</p>\n<h1>Example using flake-utils</h1>\n<pre><code class=\"language-nix\">{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    flake-utils.url = \"github:numtide/flake-utils\"; # Don't forget to add flake-utils to inputs!\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n    flake-utils,\n    ...\n  }:\n    flake-utils.lib.eachDefaultSystem (\n      system: let\n        pkgs = import nixpkgs {inherit system;};\n      in {\n        packages.hello = pkgs.hello; # Now directly defines 'hello' for the current 'system' # packages.default = self.packages.${system}.hello; # Optional default alias\n        devShells.default = pkgs.mkShell {\n          packages = [pkgs.hello];\n        };\n      }\n    );\n}\n</code></pre>\n<ul>\n<li>This flake-utils pattern is particularly useful for defining consistent\ndevelopment environments across platforms, which can then be activated simply\nby running <code>nix develop</code> in the flake‚Äôs directory.</li>\n</ul>\n<h3>Adding Formatter, Checks, and Devshell Outputs</h3>\n<p>This is a minimal flake for demonstration with a hardcoded <code>system</code>, for more\nportability:</p>\n<pre><code class=\"language-nix\">{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n    treefmt-nix.url = \"github:numtide/treefmt-nix\";\n   };\n\n  outputs = inputs@{ nixpkgs, home-manager, treefmt-nix, ... }: let\n\n    system = \"x86_64-linux\";\n    host = \"your-hostname-goes-here\";\n      # Define pkgs with allowUnfree\n    pkgs = import inputs.nixpkgs {\n      inherit system;\n      config.allowUnfree = true;\n    };\n\n        # Formatter configuration\n    treefmtEval = treefmt-nix.lib.evalModule pkgs ./lib/treefmt.nix;\n\nin {\n\n    formatter.${system} = treefmtEval.config.build.wrapper;\n\n    # Style check for CI\n    checks.${system}.style = treefmtEval.config.build.check self;\n\n    # Development shell\n    devShells.${system}.default = import ./lib/dev-shell.nix {\n      inherit inputs;\n    };\n\n\n    nixosConfigurations = {\n      hostname = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n          home-manager.nixosModules.home-manager\n          {\n            home-manager.useGlobalPkgs = true;\n            home-manager.useUserPackages = true;\n            home-manager.users.jdoe = ./home.nix;\n\n            # Optionally, use home-manager.extraSpecialArgs to pass\n            # arguments to home.nix\n          }\n        ];\n      };\n    };\n  };\n}\n</code></pre>\n<p>And in <code>lib/treefmt.nix</code>:</p>\n<pre><code class=\"language-nix\"># treefmt.nix\n{\n  projectRootFile = \"flake.nix\";\n  programs = {\n    alejandra.enable = true;\n    deadnix.enable = true;\n    # rustfmt.enable = true;\n    # shellcheck.enable = true;\n    # prettier.enable = true;\n    statix.enable = true;\n    keep-sorted.enable = true;\n    # nixfmt = {\n    #   enable = true;\n    #   # strict = true;\n    # };\n  };\n  settings = {\n    global.excludes = [\n      \"LICENSE\"\n      \"README.md\"\n      \".adr-dir\"\n      \"nu_scripts\"\n      # unsupported extensions\n      \"*.{gif,png,svg,tape,mts,lock,mod,sum,toml,env,envrc,gitignore,sql,conf,pem,*.so.2,key,pub,py,narHash}\"\n      \"data-mesher/test/networks/*\"\n      \"nss-datamesher/test/dns.json\"\n      \"*.age\"\n      \"*.jpg\"\n      \"*.nu\"\n      \"*.png\"\n      \".jj/*\"\n      \"Cargo.lock\"\n      \"flake.lock\"\n      \"hive/moonrise/borg-key-backup\"\n      \"justfile\"\n    ];\n    formatter = {\n      deadnix = {\n        priority = 1;\n      };\n      statix = {\n        priority = 2;\n      };\n      alejandra = {\n        priority = 3;\n      };\n    };\n  };\n}\n</code></pre>\n<p>Now we have a few commands available to us in our flake directory:</p>\n<ul>\n<li>\n<p><code>nix fmt</code>: Will format your whole configuration consistently</p>\n</li>\n<li>\n<p><code>nix flake check</code>: While this command was already available, it is now tied to\ntreefmt‚Äôs check which will check the style of your syntax and provide\nsuggestions.</p>\n</li>\n</ul>\n<p>And this is <code>lib/dev-shell.nix</code>:</p>\n<pre><code class=\"language-nix\">{\n  inputs,\n  system ? \"x86_64-linux\",\n}: let\n  # Instantiate nixpkgs with the given system and allow unfree packages\n  pkgs = import inputs.nixpkgs {\n    inherit system;\n    config.allowUnfree = true;\n    overlays = [\n      # Add overlays if needed, e.g., inputs.neovim-nightly-overlay.overlays.default\n    ];\n  };\nin\n  pkgs.mkShell {\n    name = \"nixos-dev\";\n    packages = with pkgs; [\n      # Nix tools\n      nixfmt-rfc-style # Formatter\n      deadnix # Dead code detection\n      nixd # Nix language server\n      nil # Alternative Nix language server\n      nh # Nix helper\n      nix-diff # Compare Nix derivations\n      nix-tree # Visualize Nix dependencies\n\n      # Code editing\n      helix # Your editor\n\n      # General utilities\n      git\n      ripgrep\n      jq\n      tree\n    ];\n\n    shellHook = ''\n      echo \"Welcome to the NixOS development shell!\"\n      echo \"System: ${system}\"\n      echo \"Tools available: nixfmt, deadnix, nixd, nil, nh, nix-diff, nix-tree, helix, git, ripgrep, jq, tree\"\n    '';\n  }\n</code></pre>\n<p>Now you can run <code>nix develop</code> in the flake directory and if successfull, you‚Äôll\nsee the <code>echo</code> commands above and you will have all the tools available in your\nenvironment without having to explicitly install them.</p>\n",
      "date_published": "2025-11-28T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/flakes/flake_inputs.html",
      "url": "https://saylesss88.github.io/flakes/flake_inputs.html",
      "title": "Flake Inputs",
      "content_html": "<h1>Nix Flake Inputs</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p>The attribute <code>inputs</code> specifies the dependencies of a flake, as an attrset\nmapping input names to flake references.</p>\n<p>If a repository provides a <code>flake.nix</code> you can include it as an input in your\n<code>flake.nix</code>.</p>\n<p>For example, I like yazi as my file explorer and have been using helix as my\neditor. To be able to get yazi to work with helix I needed the latest versions\nof both yazi and helix. One way to get the latest versions was to add their\nflakes as inputs to my flake:</p>\n<pre><code class=\"language-nix\">{\n\tinputs = {\n\t\tnixpkgs.url = \"github:NixOS/nixpkgs/nixos-24.11\";\n\t\thome-manager = {\n\t\t\turl = \"github:nix-community/home-manager/release-24.11\";\n\t\t\tinputs.nixpkgs.follows = \"nixpkgs\";\n\t\t};\n    helix = {\n      url = \"github:helix-editor/helix\";\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n\t\tyazi.url = \"github:sxyazi/yazi\";\n\t};\n\toutputs = { nixpkgs, home-manager, ... } @ inputs: {\n\t# ... snip ... #\n</code></pre>\n<ul>\n<li>Now to use this input, I would reference these inputs in both my yazi and\nhelix modules:</li>\n</ul>\n<pre><code class=\"language-nix\"># yazi.nix\n{ pkgs, config, inputs, ... }: {\n\tprograms.yazi = {\n\t\tenable = true;\n\t\tpackage = inputs.yazi.packages.${pkgs.system}.default;\n\t};\n}\n</code></pre>\n<pre><code class=\"language-nix\"># helix.nix\n{ pkgs, config, inputs, ... }: {\n\tprograms.helix = {\n\t\tenable = true;\n\t\tpackage = inputs.helix.packages.${pkgs.system}.helix;\n\t};\n}\n</code></pre>\n<p>Understanding <code>.default</code> vs. Named Outputs (e.g., <code>.helix</code>) from the Source</p>\n<p>The difference between <code>inputs.yazi.packages.${pkgs.system}.default</code> and\n<code>inputs.helix.packages.${pkgs.system}.helix</code> comes down to how the respective\nupstream flakes define their outputs. You can always inspect a flake‚Äôs\n<code>flake.nix</code> or use <code>nix flake show &lt;flake-reference&gt;</code> to understand its\nstructure.</p>\n<h2>Helix <code>flake.nix</code></h2>\n<p>Let‚Äôs look at the relevant section of Helix‚Äôs <code>flake.nix</code> click the eye to see\nthe full flake:</p>\n<pre><code class=\"language-nix\">~ {\n~   description = \"A post-modern text editor.\";\n~\n~   inputs = {\n~     nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n~     rust-overlay = {\n~       url = \"github:oxalica/rust-overlay\";\n~       inputs.nixpkgs.follows = \"nixpkgs\";\n~     };\n~   };\n~\n~   outputs = {\n~     self,\n~     nixpkgs,\n~     rust-overlay,\n~     ...\n~   }: let\n~     inherit (nixpkgs) lib;\n~     systems = [\n~       \"x86_64-linux\"\n~       \"aarch64-linux\"\n~       \"x86_64-darwin\"\n~       \"aarch64-darwin\"\n~     ];\n~     eachSystem = lib.genAttrs systems;\n~     pkgsFor = eachSystem (system:\n~       import nixpkgs {\n~         localSystem.system = system;\n~         overlays = [(import rust-overlay) self.overlays.helix];\n~       });\n~     gitRev = self.rev or self.dirtyRev or null;\n   in {\n     packages = eachSystem (system: {\n       inherit (pkgsFor.${system}) helix;\n       /*\n       The default Helix build. Uses the latest stable Rust toolchain, and unstable\n       nixpkgs.\n\n       The build inputs can be overridden with the following:\n\n       packages.${system}.default.override { rustPlatform = newPlatform; };\n\n       Overriding a derivation attribute can be done as well:\n\n       packages.${system}.default.overrideAttrs { buildType = \"debug\"; };\n       */\n      default = self.packages.${system}.helix;\n    });\n~    checks =\n~      lib.mapAttrs (system: pkgs: let\n~        # Get Helix's MSRV toolchain to build with by default.\n~        msrvToolchain = pkgs.pkgsBuildHost.rust-bin.fromRustupToolchainFile ./rust-toolchain.toml;\n~        msrvPlatform = pkgs.makeRustPlatform {\n~          cargo = msrvToolchain;\n~          rustc = msrvToolchain;\n~        };\n~      in {\n~        helix = self.packages.${system}.helix.override {\n~          rustPlatform = msrvPlatform;\n~        };\n~      })\n~      pkgsFor;\n~\n~    # Devshell behavior is preserved.\n~    devShells =\n~      lib.mapAttrs (system: pkgs: {\n~        default = let\n~          commonRustFlagsEnv = \"-C link-arg=-fuse-ld=lld -C target-cpu=native --cfg tokio_unstable\";\n~          platformRustFlagsEnv = lib.optionalString pkgs.stdenv.isLinux \"-Clink-arg=-Wl,--no-rosegment\";\n~        in\n~          pkgs.mkShell {\n~            inputsFrom = [self.checks.${system}.helix];\n~            nativeBuildInputs = with pkgs;\n~              [\n~                lld\n~                cargo-flamegraph\n~                rust-bin.nightly.latest.rust-analyzer\n~              ]\n~              ++ (lib.optional (stdenv.isx86_64 &amp;&amp; stdenv.isLinux) cargo-tarpaulin)\n~              ++ (lib.optional stdenv.isLinux lldb)\n~              ++ (lib.optional stdenv.isDarwin darwin.apple_sdk.frameworks.CoreFoundation);\n~            shellHook = ''\n~              export RUST_BACKTRACE=\"1\"\n~              export RUSTFLAGS=\"''${RUSTFLAGS:-\"\"} ${commonRustFlagsEnv} ${platformRustFlagsEnv}\"\n~            '';\n~          };\n~      })\n~      pkgsFor;\n~\n~    overlays = {\n~      helix = final: prev: {\n~        helix = final.callPackage ./default.nix {inherit gitRev;};\n~      };\n~\n~      default = self.overlays.helix;\n~    };\n~  };\n~  nixConfig = {\n~    extra-substituters = [\"https://helix.cachix.org\"];\n~    extra-trusted-public-keys = [\"helix.cachix.org-1:ejp9KQpR1FBI2onstMQ34yogDm4OgU2ru6lIwPvuCVs=\"];\n~  };\n~}\n</code></pre>\n<p>Dissecting <code>inherit (pkgsFor.${system}) helix;</code></p>\n<p>Imagine the Nix evaluation process for Helix <code>flake.nix</code> in the <code>outputs</code>\nsection:</p>\n<ol>\n<li>\n<p><code>packages = eachSystem (system: { ... });</code> Part iterates through each\n<code>system</code> (like <code>x86_64-linux</code>). For each <code>system</code>, it‚Äôs creating an attribute\nset that will become <code>self.packages.${system}</code>.</p>\n</li>\n<li>\n<p>Inside the <code>eachSystem</code> function, for a specific system (e.g.\n<code>x86_64-linux</code>): The code is building an attribute set that will ultimately\nbe assigned to <code>self.packages.x86_64-linux</code>.</p>\n</li>\n<li>\n<p>When you write <code>inherit (sourceAttrset) attributeName;</code>, it‚Äôs equivalent to\nwriting <code>attributeName = sourceAttrset.attributeName;</code>.</p>\n</li>\n</ol>\n<p>So, <code>inherit (pkgsFor.${system}) helix;</code> is equivalent to:</p>\n<pre><code class=\"language-nix\">helix = pkgsFor.${system}.helix;\n</code></pre>\n<p>Therefore, because of <code>inherit (pkgsFor.${system}) helix;</code>, the helix attribute\nis explicitly defined under\n<code>packages.${system}``. This is why you access it as </code>inputs.helix.packages.${pkgs.system}.helix;`.</p>\n<h2>Yazi <code>flake.nix</code></h2>\n<p>Now this is yazi‚Äôs <code>flake.nix</code>, yazi‚Äôs documentation tells you to use <code>.default</code>\nbut lets examine the flake and see why:</p>\n<pre><code class=\"language-nix\">~{\n~  inputs = {\n~    nixpkgs.url = \"github:NixOS/nixpkgs/nixpkgs-unstable\";\n~    flake-utils.url = \"github:numtide/flake-utils\";\n~    rust-overlay = {\n~      url = \"github:oxalica/rust-overlay\";\n~      inputs.nixpkgs.follows = \"nixpkgs\";\n~    };\n~  };\n~\n~  outputs =\n~    {\n~      self,\n~      nixpkgs,\n~      rust-overlay,\n~      flake-utils,\n~      ...\n~    }:\n~    flake-utils.lib.eachDefaultSystem (\n~      system:\n~      let\n~        pkgs = import nixpkgs {\n~          inherit system;\n~          overlays = [ rust-overlay.overlays.default ];\n~        };\n~        toolchain = pkgs.rust-bin.stable.latest.default;\n~        rustPlatform = pkgs.makeRustPlatform {\n~          cargo = toolchain;\n~          rustc = toolchain;\n~        };\n~\n~        rev = self.shortRev or self.dirtyShortRev or \"dirty\";\n~        date = self.lastModifiedDate or self.lastModified or \"19700101\";\n~        version =\n~          (builtins.fromTOML (builtins.readFile ./yazi-fm/Cargo.toml)).package.version\n~          + \"pre${builtins.substring 0 8 date}_${rev}\";\n~      in\n      {\n        packages = {\n          yazi-unwrapped = pkgs.callPackage ./nix/yazi-unwrapped.nix {\n            inherit\n              version\n              rev\n              date\n              rustPlatform\n              ;\n          };\n          yazi = pkgs.callPackage ./nix/yazi.nix { inherit (self.packages.${system}) yazi-unwrapped; };\n          default = self.packages.${system}.yazi;\n        };\n\n~        devShells = {\n~          default = pkgs.callPackage ./nix/shell.nix { };\n~        };\n~\n~        formatter = pkgs.nixfmt-rfc-style;\n~      }\n~    )\n~    // {\n~      overlays = {\n~        default = self.overlays.yazi;\n~        yazi = _: prev: { inherit (self.packages.${prev.stdenv.system}) yazi yazi-unwrapped; };\n~      };\n~    };\n~}\n</code></pre>\n<p>In this case using <code>inputs.yazi.packages.${pkgs.system}.yazi</code> would also work</p>\n<ul>\n<li>\n<p><code>yazi = pkgs.callPackage ./nix/yazi.nix { inherit (self.packages.${system}) yazi-unwrapped; };</code>\nThis line defines the yazi variable (or, more precisely, creates an attribute\nnamed yazi within the <code>packages.${system}</code> set). It assigns to this yazi\nattribute the result of calling the Nix expression in <code>./nix/yazi.nix</code> with\nyazi-unwrapped as an argument. This yazi attribute represents the actual,\nrunnable Yazi package.</p>\n</li>\n<li>\n<p><code>default = self.packages.${system}.yazi;</code> This line then aliases the yazi\npackage. It creates another attribute named <code>default</code> within the same\n<code>packages.${system}</code> set and points it directly to the yazi attribute that was\njust defined.</p>\n</li>\n<li>\n<p>So, when you access <code>inputs.yazi.packages.${pkgs.system}.default</code>, you‚Äôre\neffectively following the alias to the yazi package.</p>\n</li>\n<li>\n<p>The choice to use <code>.default</code> is primarily for convenience and adherence to a\ncommon flake convention, making the flake easier for users to consume without\nneeding to dive into its internal structure.</p>\n</li>\n</ul>\n",
      "date_published": "2025-11-28T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/flakes/flake_examples.html",
      "url": "https://saylesss88.github.io/flakes/flake_examples.html",
      "title": "Flake outputs",
      "content_html": "<h1>Nix Flake Examples</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p>This chapter provides practical examples to illustrate the concepts discussed in\n‚ÄúNix Flakes Explained.‚Äù</p>\n<h2>Example showing the extensibility of Flakes</h2>\n<p>NixOS modules and configurations offer us a powerful and composable way to\ndefine and share system configurations. Imagine we have several independent\n‚Äúplayers,‚Äù each with their own unique set of configurations or modules. How do\nwe combine these individual contributions into a single, cohesive system without\ndirectly altering each player‚Äôs original flake?</p>\n<p>This example demonstrates how flakes can extend and compose each other, allowing\nyou to layer configurations on top of existing ones. This is particularly useful\nwhen you want to:</p>\n<ul>\n<li>\n<p>Build upon a base configuration without modifying its source.</p>\n</li>\n<li>\n<p>Combine features from multiple independent flakes into a single system.</p>\n</li>\n<li>\n<p>Create specialized versions of an existing configuration.</p>\n</li>\n</ul>\n<p>Let‚Äôs simulate this by creating a players directory with three sub-directories:\n<code>first</code>, <code>second</code>, and <code>third</code>. Each of these will contain its own <code>flake.nix</code>.</p>\n<pre><code class=\"language-bash\">mkdir players\ncd players\nmkdir first\nmkdir second\nmkdir third\ncd first\n</code></pre>\n<p>Now create a <code>flake.nix</code> with the following contents:</p>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-24.11\";\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n  }: {\n    nixosModules.default = {\n      config,\n      pkgs,\n      lib,\n      ...\n    }: {\n      # Create a file `/etc/first-file`\n      environment.etc.first-file.text = \"Hello player # 1!\";\n      boot.initrd.includeDefaultModules = false;\n      documentation.man.enable = false;\n      boot.loader.grub.enable = false;\n      fileSystems.\"/\".device = \"/dev/null\";\n      system.stateVersion = \"24.11\";\n    };\n    nixosConfigurations.testing = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      modules = [\n        self.nixosModules.default\n      ];\n    };\n  };\n}\n</code></pre>\n<ul>\n<li>This demonstrates using <code>self</code> to reference this flake from within its own\noutputs. This is the main use for <code>self</code> with flakes. Without <code>self</code>, I\nwouldn‚Äôt have a direct way to refer to the <code>nixosModules.default</code> that‚Äôs\ndefined within the same flake.</li>\n</ul>\n<p>Now in the <code>players/second</code> directory create this <code>flake.nix</code>:</p>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-24.11\";\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n  }: {\n    nixosModules.default = {\n      config,\n      pkgs,\n      lib,\n      ...\n    }: {\n      # Create a file `/etc/second-file`\n      environment.etc.second-file.text = \"Hello player # 2!\";\n    };\n  };\n}\n</code></pre>\n<ul>\n<li><code>nixosModules.default</code> is a module which is a function that, when called by\nthe NixOS module system, returns an attribute set representing a piece of\nsystem configuration.\n<ul>\n<li>Within that attribute set, it specifies that the file <code>/etc/second-file</code>\nshould exist with ‚ÄúHello player # 2!‚Äù as its content.</li>\n</ul>\n</li>\n</ul>\n<p>And finally in <code>players/third</code> create another <code>flake.nix</code>:</p>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  inputs = {\n    first.url = \"/home/jr/players/first\";\n    nixpkgs.follows = \"first/nixpkgs\";\n    second = {\n      url = \"/home/jr/players/second\";\n      inputs.nixpkgs.follows = \"first/nixpkgs\";\n    };\n  };\n\n  outputs = {\n    self,\n    nixpkgs,\n    first,\n    second,\n  }:\n    first.outputs\n    // {\n      nixosConfigurations.testing = first.nixosConfigurations.testing.extendModules {\n        modules = [\n          second.nixosModules.default\n        ];\n      };\n    };\n}\n</code></pre>\n<ul>\n<li>You‚Äôll have to change the locations to where you placed your <code>players</code>\ndirectory in the <code>inputs</code> above.</li>\n</ul>\n<p>In your <code>third</code> directory inspect it with:</p>\n<pre><code class=\"language-bash\">Ôåì  ~/players/third\n‚ùØ nix flake show\npath:/home/jr/players/third?lastModified=1748271697&amp;narHash=sha256-oNzkC6X9hA0MpOBmJSZ89w4znXxv4Q5EkFhp0ewehY0%3D\n‚îú‚îÄ‚îÄ‚îÄnixosConfigurations\n‚îÇ   ‚îî‚îÄ‚îÄ‚îÄtesting: NixOS configuration\n‚îî‚îÄ‚îÄ‚îÄnixosModules\n    ‚îî‚îÄ‚îÄ‚îÄdefault: NixOS module\n</code></pre>\n<p>and build it with:</p>\n<pre><code class=\"language-bash\">nix build .#nixosConfigurations.testing.config.system.build.toplevel\n</code></pre>\n<pre><code class=\"language-bash\">cat result/etc/first-file\nHello player # 1!\ncat result/etc/second-file\nHello player # 2!\n</code></pre>\n<p><strong>Understanding the Extension</strong></p>\n<p>As you saw in the <code>flake.nix</code> for the third player, we leveraged two key flake\nfeatures to combine and extend the previous configurations:</p>\n<ol>\n<li><strong>Attribute Set Union</strong> (<code>//</code> operator):</li>\n</ol>\n<pre><code class=\"language-nix\">outputs = { ..., first, second, ... }:\nfirst.outputs // { # ... your extensions here ...\n};\n</code></pre>\n<p>The <code>//</code> (attribute set union) operator allows us to take all the outputs from\n<code>first.outputs</code> (which includes its <code>nixosConfigurations</code> and <code>nixosModules</code>)\nand then overlay or add to them on the right-hand side. This means our third\nflake will inherit all the outputs from first, but we can then modify or add new\nones without changing the first flake itself.</p>\n<ol start=\"2\">\n<li><code>config.extendModules</code>:</li>\n</ol>\n<pre><code class=\"language-nix\">    nixosConfigurations.testing = first.nixosConfigurations.testing.extendModules {\n      modules = [\n        second.nixosModules.default\n      ];\n    };\n</code></pre>\n<p>This is the core of the extension. We‚Äôre taking the testing NixOS configuration\ndefined in the first flake (<code>first.nixosConfigurations.testing</code>) and then\ncalling its <code>extendModules</code> function. This function allows us to inject\nadditional NixOS modules into an already defined system configuration. In this\ncase, we‚Äôre adding the default module from the second flake\n(<code>second.nixosModules.default</code>).</p>\n<p>By combining these techniques, the third flake successfully creates a NixOS\nconfiguration that includes both the settings from first (like <code>/etc/first-file</code>\nand the base system options) and the settings from second (like\n<code>/etc/second-file</code>), all without directly altering the first or second flakes.\nThis demonstrates the incredible power of flake extensibility for building\ncomplex, modular, and composable systems.</p>\n",
      "date_published": "2025-11-28T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/Nix_Pull_Requests.html",
      "url": "https://saylesss88.github.io/Nix_Pull_Requests.html",
      "title": "Nix Pull Requests",
      "content_html": "<h1>Pull Requests</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><img src=\"images/gruv16.png\" alt=\"gruv16\" /></p>\n<h2>Nix Pull Requests</h2>\n<p><strong>Pull requests</strong> communicate changes to a branch in a repository. Once a pull\nrequest is opened, you can review changes with collaborators and add follow-up\ncommits.</p>\n<ul>\n<li>\n<p>A <strong>pull request</strong> is a proposal to merge a set of changes from one branch\ninto another. In a pull request, collaborators can review and discuss the\nproposed set of changes before they integrate the changes into the main\ncodebase.</p>\n</li>\n<li>\n<p>Pull requests display the differences, or diffs, between the content in the\nsource branch and the content in the target branch.</p>\n</li>\n</ul>\n<pre><code class=\"language-mermaid\">graph LR\n    A[Your Local Repository] --&gt; B(Feature Branch);\n    B --&gt; C{GitHub Repository};\n    C -- \"Open Pull Request\" --&gt; D[Pull Request on GitHub];\n    D -- \"Review &amp; Discussion\" --&gt; D;\n    D -- \"Merge\" --&gt; E(Main Branch on GitHub);\n    E --&gt; F[Nixpkgs Users];\n</code></pre>\n<p><strong>Explanation of the Diagram</strong>:</p>\n<details>\n<summary> ‚úîÔ∏è Click to see Explanation </summary>\n<ul>\n<li>\n<p><strong>A[Your Local Repository]</strong>: This represents the copy of the Nixpkgs repo on\nyour computer where you make changes.</p>\n</li>\n<li>\n<p><strong>B (Feature Branch)</strong>: You create a dedicated branch (e.g.<code>my-pack-update</code>)\nto isolate your changes.</p>\n</li>\n<li>\n<p><strong>C {GitHub Repository}</strong>: This is the central online repo for Nixpkgs on\nGithub. You push your feature branch to this repo.</p>\n</li>\n<li>\n<p><strong>C ‚Äì ‚ÄúOpen Pull Request‚Äù ‚Äì D [Pull Request on Github]</strong>: You initiate a\npull request from your feature branch to the main branch (usually <code>master</code> or\n<code>main</code>) through the GitHub interface.</p>\n</li>\n<li>\n<p><strong>D [Pull Request on GitHub]</strong>: This is where collaborators can see your\nproposed changes, discuss them, and provide feedback.</p>\n</li>\n<li>\n<p><strong>D ‚Äì ‚ÄúReview &amp; Discussion‚Äù ‚Äì&gt; D</strong>: The pull request facilitates\ncommunication and potential revisions based on the review.</p>\n</li>\n<li>\n<p><strong>D ‚Äì ‚ÄúMerge‚Äù ‚Äì&gt; E (Main Branch on GitHub)</strong>: Once the changes are approved,\nthey are merged into the main branch of the Nixpkgs repository.</p>\n</li>\n<li>\n<p><strong>E (Main Branch on GitHub)</strong>: The main branch now contains the integrated\nchanges.</p>\n</li>\n<li>\n<p><strong>E ‚Äì&gt; F [Nixpkgs Users]</strong>): Eventually, these changes become available to\nall Nixpkgs users through updates to their Nix installations.</p>\n</li>\n</ul>\n</details>\n<p>Flakes often rely on having access to the full history of the Git repository to\ncorrectly determine dependencies, identify specific revisions of inputs, and\nevaluate the flake. Not in all situations will a shallow clone work and this is\none of them.</p>\n<p>If you have any changes to your local copy of Nixpkgs make sure to stash them\nbefore the following:</p>\n<pre><code class=\"language-bash\">git stash -u\n</code></pre>\n<ul>\n<li>This command saves your uncommited changes (including staged files)\ntemporarily. You can restore them later with <code>git stash pop</code></li>\n</ul>\n<p><strong>Step 1 Clone Nixpkgs Locally</strong></p>\n<p>If you don‚Äôt have Nixpkgs locally, you‚Äôll need to clone it:</p>\n<pre><code class=\"language-bash\">git clone https://github.com/NixOS/nixpkgs.git\n</code></pre>\n<p><strong>Step 2 Find a Relevant Pull Request</strong></p>\n<p>To find specifig commits and releases:</p>\n<p><a href=\"https://status.nixos.org/\">status.nixos.org</a> provides the latest tested commits\nfor each release - use when pinning to specific commits. List of active release\nchannels - use when tracking latest channel versions.</p>\n<p>The complete list of channels is available at\n<a href=\"https://channels.nixos.org/\">nixos.org/channels</a></p>\n<p>To find a relevant PR you can go to:</p>\n<ul>\n<li>\n<p><a href=\"https://github.com/NixOS/nixpkgs/pulls\">Nixpkgs Pull Requests</a></p>\n</li>\n<li>\n<p>The following example actually uses the\n<a href=\"https://github.com/NixOS/nix/pulls\">Nix Pull Requests</a> the process is the\nsame, but that is an important distinction.</p>\n</li>\n<li>\n<p>In the Filters enter <code>stack trace</code> for this example.</p>\n</li>\n<li>\n<p>The pull request I chose was <a href=\"https://github.com/nixos/nix/pull/8623\">8623</a></p>\n</li>\n</ul>\n<p><strong>Step 3 Add the Remote Repository (if necessary)</strong></p>\n<p>If the pull request is from a different repository than your local clone (as in\nthe case of the <code>nix</code> PR while working in a <code>nixpkgs</code> clone), you need to add\nthat repository as a remote. It‚Äôs common to name the main Nixpkgs remote\n<code>origin</code> and other related repositories like <code>nix</code> as <code>upstream</code>.</p>\n<p>Assuming you are in your <code>nixpkgs</code> clone and want to test a PR from the <code>nix</code>\nrepository:</p>\n<pre><code class=\"language-bash\">git remote add upstream https://github.com/NixOS/nix.git\n</code></pre>\n<p><strong>Step 4 Fetch the Pull Request Changes</strong></p>\n<p>Fetch the Pull Request Information:</p>\n<pre><code class=\"language-bash\">git fetch upstream refs/pull/8623/head:pr-8623\n</code></pre>\n<ul>\n<li>This command fetches the branch named <code>head</code> from the pull request <code>8623</code> in\nthe <code>upstream</code> remote and creates a local branch named <code>pr-8623</code> that tracks\nit.</li>\n</ul>\n<p><strong>Output</strong>:</p>\n<details>\n<summary> ‚úîÔ∏è Output (Click to Enlarge) </summary>\n<pre><code>remote: Enumerating objects: 104651, done.\nremote: Counting objects: 100% (45/45), done.\nremote: Compressing objects: 100% (27/27), done.\nremote: Total 104651 (delta 33), reused 20 (delta 18), pack-reused 104606 (from 1)\nReceiving objects: 100% (104651/104651), 61.64 MiB | 12.56 MiB/s, done.\nResolving deltas: 100% (74755/74755), done.\nFrom https://github.com/NixOS/nix\n * [new ref]             refs/pull/8623/head -&gt; pr-8623\n * [new tag]             1.0                 -&gt; 1.0\n * [new tag]             1.1                 -&gt; 1.1\n * [new tag]             1.10                -&gt; 1.10\n * [new tag]             1.11                -&gt; 1.11\n * [new tag]             1.11.1              -&gt; 1.11.1\n * [new tag]             1.2                 -&gt; 1.2\n * [new tag]             1.3                 -&gt; 1.3\n * [new tag]             1.4                 -&gt; 1.4\n * [new tag]             1.5                 -&gt; 1.5\n * [new tag]             1.5.1               -&gt; 1.5.1\n * [new tag]             1.5.2               -&gt; 1.5.2\n * [new tag]             1.5.3               -&gt; 1.5.3\n * [new tag]             1.6                 -&gt; 1.6\n * [new tag]             1.6.1               -&gt; 1.6.1\n * [new tag]             1.7                 -&gt; 1.7\n * [new tag]             1.8                 -&gt; 1.8\n * [new tag]             1.9                 -&gt; 1.9\n * [new tag]             2.0                 -&gt; 2.0\n * [new tag]             2.2                 -&gt; 2.2\n</code></pre>\n</details>\n<p><strong>Step 5 Checkout the Local Branch:</strong></p>\n<pre><code class=\"language-bash\">git checkout pr-8623\n</code></pre>\n<p>Or with the <code>gh</code> cli:</p>\n<pre><code class=\"language-bash\">gh pr checkout 8623\n</code></pre>\n<h2>Build and Test the Changes</h2>\n<ul>\n<li>Now we want to see if the code changes introduced by the pull request actually\nbuild correctly within the Nix ecosystem.</li>\n</ul>\n<pre><code class=\"language-bash\">nix build\n</code></pre>\n<p><strong>Output:</strong></p>\n<details>\n<summary> ‚úîÔ∏è Output (Click to Enlarge) </summary>\n<pre><code class=\"language-bash\">error: builder for '/nix/store/rk86daqgf6a9v6pdx6vcc5b580lr9f09-nix-2.20.0pre20240115_20b4959.drv' failed with exit code 2;\n   last 25 log lines:\n   &gt;\n   &gt;         _NIX_TEST_ACCEPT=1 make tests/functional/lang.sh.test\n   &gt;\n   &gt;     to regenerate the files containing the expected output,\n   &gt;     and then view the git diff to decide whether a change is\n   &gt;     good/intentional or bad/unintentional.\n   &gt;     If the diff contains arbitrary or impure information,\n   &gt;     please improve the normalization that the test applies to the output.\n   &gt; make: *** [mk/lib.mk:90: tests/functional/lang.sh.test] Error 1\n   &gt; make: *** Waiting for unfinished jobs....\n   &gt; ran test tests/functional/selfref-gc.sh... [PASS]\n   &gt; ran test tests/functional/store-info.sh... [PASS]\n   &gt; ran test tests/functional/suggestions.sh... [PASS]\n   &gt; ran test tests/functional/path-from-hash-part.sh... [PASS]\n   &gt; ran test tests/functional/gc-auto.sh... [PASS]\n   &gt; ran test tests/functional/path-info.sh... [PASS]\n   &gt; ran test tests/functional/flakes/show.sh... [PASS]\n   &gt; ran test tests/functional/fetchClosure.sh... [PASS]\n   &gt; ran test tests/functional/completions.sh... [PASS]\n   &gt; ran test tests/functional/build.sh... [PASS]\n   &gt; ran test tests/functional/impure-derivations.sh... [PASS]\n   &gt; ran test tests/functional/build-delete.sh... [PASS]\n   &gt; ran test tests/functional/build-remote-trustless-should-fail-0.sh... [PASS]\n   &gt; ran test tests/functional/build-remote-trustless-should-pass-2.sh... [PASS]\n   &gt; ran test tests/functional/nix-profile.sh... [PASS]\n   For full logs, run:\n     nix log /nix/store/rk86daqgf6a9v6pdx6vcc5b580lr9f09-nix-2.20.0pre20240115_20b4959.drv\n</code></pre>\n</details>\n<ul>\n<li><strong><code>nix build</code></strong> (Part of the Nix Unified CLI):\n<ul>\n<li>\n<p>Declarative: when used within a Nix flake (<code>flake.nix</code>), <code>nix build</code> is a\nbit more declarative. It understands the outputs defined in your flake.</p>\n</li>\n<li>\n<p>Clearer Output Paths: <code>nix build</code> typically places build outputs in the\n<code>./result</code> directory by default (similar to <code>nix-build</code>‚Äôs <code>result</code> symlink)</p>\n</li>\n<li>\n<p>Better Error Reporting: It gives more informative error messages.</p>\n</li>\n<li>\n<p>Future Direction</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Benefits of using <code>nix build</code>:</strong></p>\n<ul>\n<li>\n<p><strong>Flake Integration:</strong> <code>nix build</code> naturally understands the flake‚Äôs outputs.</p>\n</li>\n<li>\n<p><strong>Development Shells:</strong> When you are in a <code>nix develop</code> shell, <code>nix build</code> is\nthe more idiomatic way to build packages defined in your dev environment.</p>\n</li>\n<li>\n<p><strong>Consistency:</strong> Using the unified CLI promotes a more consistent workflow.</p>\n</li>\n</ul>\n<h2>Next Steps</h2>\n<p>As you can see this build failed, as for why the build failed, the key part of\nthe error message is:</p>\n<pre><code class=\"language-bash\">make: *** [mk/lib.mk:90: tests/functional/lang.sh.test] Error 1\n</code></pre>\n<ul>\n<li>This suggests that one of the functional tests (<code>lang.sh.test</code>) failed. This\nhappens when the expected output of the test doesn‚Äôt match the actual output.</li>\n</ul>\n<p>This can heppen when:</p>\n<ol>\n<li>\n<p>The test expectations are outdated due to changes in the codebase.</p>\n</li>\n<li>\n<p>The test captures environment-specific or transient outputs that are not\nproperly normalized.</p>\n</li>\n<li>\n<p>The test includes impure or non-deterministic information, making it hard to\nverify.</p>\n</li>\n</ol>\n<p>To address this, _NIX_TEST_ACCEPT=1 is used as an override mechanism that tells\nthe test framework: &gt; ‚ÄúAccept whatever output is generated as the new expected\nresult.‚Äù</p>\n<p>The message advises running:</p>\n<pre><code class=\"language-bash\">_NIX_TEST_ACCEPT=1 make tests/functional/lang.sh.test\n</code></pre>\n<ul>\n<li>This will regenerate the expected output files, allowing you to inspect what\nchanged with <code>git diff</code>:</li>\n</ul>\n<pre><code class=\"language-bash\">git diff tests/functional/lang.sh.test\n</code></pre>\n<ul>\n<li><strong>Verifies if Changes are Intentional:</strong> If the difference is reasonable and\nexpected (due to a legitimate update in the logic), you can commit these\nchanges to update the test suit. If not, you have to refine the test\nnormalization process further.</li>\n</ul>\n<p>If the changes seem valid, commit them:</p>\n<pre><code class=\"language-bash\">git add tests/functional/lang.sh.test\ngit commit -m \"Update expected test output for lang.sh.test\"\n</code></pre>\n<p>Running the following will provide the full logs:</p>\n<pre><code class=\"language-bash\">nix log /nix/store/rk86daqgf6a9v6pdx6vcc5b580lr9f09-nix-2.20.0pre20240115_20b4959.drv\n</code></pre>\n<h3>Conclusion</h3>\n<p>Testing Nixpkgs pull requests is a vital part of contributing to a healthy and\nreliable Nix ecosystem. By following these steps, you can help ensure that\nchanges are well-vetted before being merged, ultimately benefiting all Nix\nusers. Your efforts in testing contribute significantly to the quality and\nstability of Nixpkgs.</p>\n",
      "date_published": "2025-11-27T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/installation/unenc/unenc_impermanence.html",
      "url": "https://saylesss88.github.io/installation/unenc/unenc_impermanence.html",
      "title": "Impermanence (Unencrypted BTRFS)",
      "content_html": "<h1>Unencrypted BTRFS Impermanence with Flakes</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p>Figure 1: Impermanence Logo: Image of the Impermanence logo. Sourced from the</p>\n<p><a href=\"https://github.com/nix-community/impermanence\">Impermanence repo</a></p>\n<p>This guide is for an unencrypted setup, there are a few links at the end for\nencrypted setups. This guide follows the previous\n<a href=\"https://saylesss88.github.io/installation/unencrypted_setups.html\">minimal install guide</a>\nbut you should be able to adjust it carefully to meet your needs.</p>\n<p>This section details how to set up impermanence on your NixOS system using BTRFS\nsubvolumes. With impermanence, your operating system‚Äôs root filesystem will\nreset to a pristine state on each reboot, while designated directories and files\nremain persistent. This provides a highly reliable and rollback-friendly system.</p>\n<p>In NixOS, ‚Äústate‚Äù is any data or condition of the system that isn‚Äôt defined in\nyour declarative configuration. The impermanence approach aims to make this\nstate temporary (ephemeral) or easily resettable, so your system always matches\nyour configuration and can recover from unwanted changes or corruption.</p>\n<h2>Impermanence: The Concept and Its BTRFS Implementation</h2>\n<p>In a traditional Linux system, most of this state is stored on the disk and\npersists indefinitely unless manually deleted or modified. However, this can\nlead to configuration drift, where the system accumulates changes (e.g., log\nfiles, temporary files, or unintended configuration tweaks) that make it harder\nto reproduce or maintain.</p>\n<p>Impermanence, in the context of operating systems, refers to a setup where the\nmajority of the system‚Äôs root filesystem (<code>/</code>) is reset to a pristine state on\nevery reboot. This means any changes made to the system (e.g., installing new\npackages, modifying system files outside of configuration management, creating\ntemporary files) are discarded upon shutdown or reboot.</p>\n<h2>What Does Impermanence Do?</h2>\n<p>Impermanence is a NixOS approach that makes the system stateless (or nearly\nstateless) by wiping the root filesystem (<code>/</code>) on each boot, ensuring a clean,\npredictable starting point. Only explicitly designated data (persistent state)\nis preserved across reboots, typically stored in specific locations like the\n/nix/persist subvolume. This is possible because NixOS can boot with only the\n<code>/boot</code>, and <code>/nix</code> directories. This achieves:</p>\n<ol>\n<li>Clean Root Filesystem:</li>\n</ol>\n<ul>\n<li>\n<p>The root subvolume is deleted and recreated on each boot, erasing transient\nstate (e.g., temporary files, runtime data).</p>\n</li>\n<li>\n<p>This ensures the system starts fresh, reducing clutter and making it behave\ncloser to a declarative system defined by your NixOS configuration.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>Selective Persistence:</li>\n</ol>\n<ul>\n<li>\n<p>Critical state (e.g., user files, logs, system configuration) is preserved in\ndesignated persistent subvolumes (e.g., /nix/persist, /var/log, /var/lib) or\nfiles.</p>\n</li>\n<li>\n<p>You control exactly what state persists by configuring\n<code>environment.persistence.\"/nix/persist\"</code> or other mechanisms.</p>\n</li>\n<li>\n<p>‚ùó The understanding around persisting <code>/var/lib/nixos</code> seems to be evolving.\nSee,The importance of persisting <code>/var/lib/nixos</code> See also necessary system\nstate</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>Reproducibility and Security:</li>\n</ol>\n<ul>\n<li>\n<p>By wiping transient state, impermanence prevents unintended changes from\naccumulating, making the system more reproducible.</p>\n</li>\n<li>\n<p>It enhances security by ensuring sensitive temporary data (e.g., /tmp, runtime\ncredentials) is erased on reboot.</p>\n</li>\n</ul>\n<h3>Getting Started</h3>\n<ol>\n<li>Add impermanence to your flake.nix. You will change the hostname in the flake\nto match your networking.hostName.</li>\n</ol>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    disko.url = \"github:nix-community/disko/latest\";\n    disko.inputs.nixpkgs.follows = \"nixpkgs\";\n    impermanence.url = \"github:nix-community/impermanence\";\n  };\n\n  outputs = inputs@{ nixpkgs, ... }: {\n    nixosConfigurations = {\n      hostname = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n          inputs.disko.nixosModules.disko\n          inputs.impermanence.nixosModules.impermanence\n        ];\n      };\n    };\n  };\n}\n</code></pre>\n<ol start=\"2\">\n<li>Discover where your root subvolume is located with <code>findmnt</code>:</li>\n</ol>\n<p>Before configuring impermanence, it‚Äôs crucial to know the device path and\nsubvolume path of your main BTRFS partition where the root filesystem (/) is\nlocated. This information is needed for the mount command within the\nimpermanence script.</p>\n<pre><code class=\"language-bash\">findmnt /\nTARGET   SOURCE         FSTYPE OPTIONS\n/        /dev/disk/by-partlabel/disk-main-root[/root]\n                        btrfs  rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=275,sub\n</code></pre>\n<p>From the SOURCE column, note the full path, including the device (e.g.,\n<code>/dev/disk/by-partlabel/disk-main-root</code>) and the subvolume in brackets (e.g.,\n<code>[/root]</code>). You will use the device path in the next step</p>\n<p><code>/dev/disk/by-partlabel/disk-main-root</code> is a symlink to the actual device path\n(e.g. <code>/dev/nvme0n1p2</code>), but using the partlabel is generally more robust for\nscripts.</p>\n<ol start=\"3\">\n<li>Create an impermanence.nix:</li>\n</ol>\n<p>Now, create a new file named <code>impermanence.nix</code> in your configuration directory\n(i.e. your flake directory). This file will contain all the specific settings\nfor your impermanent setup, including BTRFS subvolume management and persistent\ndata locations. Since this file is right next to your <code>configuration.nix</code>,\nyou‚Äôll just add an <code>imports = [ ./impermanence.nix</code> ] to your\n<code>configuration.nix</code> apply it to your configuration.</p>\n<pre><code class=\"language-nix\">{lib, ...}: {\n  #  Reset root subvolume on boot\n  boot.initrd.postResumeCommands = lib.mkAfter ''\n    mkdir /btrfs_tmp\n      mount /dev/disk/by-partlabel/disk-main-root /btrfs_tmp # CONFIRM THIS IS CORRECT FROM findmnt\n      if [[ -e /btrfs_tmp/root ]]; then\n        mkdir -p /btrfs_tmp/old_roots\n        timestamp=$(date --date=\"@$(stat -c %Y /btrfs_tmp/root)\" \"+%Y-%m-%-d_%H:%M:%S\")\n        mv /btrfs_tmp/root \"/btrfs_tmp/old_roots/$timestamp\"\n      fi\n\n      delete_subvolume_recursively() {\n        IFS=$'\\n'\n        for i in $(btrfs subvolume list -o \"$1\" | cut -f 9- -d ' '); do\n          delete_subvolume_recursively \"/btrfs_tmp/$i\"\n        done\n        btrfs subvolume delete \"$1\"\n      }\n\n      for i in $(find /btrfs_tmp/old_roots/ -maxdepth 1 -mtime +30); do\n        delete_subvolume_recursively \"$i\"\n      done\n\n      btrfs subvolume create /btrfs_tmp/root\n      umount /btrfs_tmp\n  '';\n\n  # Use /persist as the persistence root, matching Disko's mountpoint\n  environment.persistence.\"/nix/persist\" = {\n    hideMounts = true;\n    directories = [\n      \"/etc\" # System configuration (Keep this here for persistence via bind-mount)\n      \"/var/spool\" # Mail queues, cron jobs\n      \"/srv\" # Web server data, etc.\n      \"/root\"\n    ];\n    files = [\n    ];\n  };\n}\n</code></pre>\n<p>With btrfs subvolumes since each directory is its own subvolume, when the root\nis wiped on reboot the subvolumes are untouched.</p>\n<h3>Applying Your Impermanence Configuration</h3>\n<p>Once you have completed all the steps and created or modified the necessary\nfiles (<code>flake.nix</code>, <code>impermanence.nix</code>), you need to apply these changes to your\nNixOS system.</p>\n<ol>\n<li>Navigate to your NixOS configuration directory (where your flake.nix is\nlocated).</li>\n</ol>\n<pre><code class=\"language-bash\">cd /path/to/your/flake\n</code></pre>\n<ol start=\"2\">\n<li>Rebuild and Switch: Execute the <code>nixos-rebuild switch</code> command. This command\nwill:</li>\n</ol>\n<ul>\n<li>\n<p>Evaluate your flake.nix and the modules it imports (including your new\nimpermanence.nix).</p>\n</li>\n<li>\n<p>Build a new NixOS system closure based on your updated configuration.</p>\n</li>\n<li>\n<p>Activate the new system configuration, making it the current running system.</p>\n</li>\n</ul>\n<blockquote>\n<p>‚ùó NOTE: On the first rebuild after setting up impermanence, you may find that\nyou‚Äôre not in the password database or cannot log in/sudo. This occurs because\nthe initial state of your new ephemeral root filesystem, including /etc (where\nuser passwords are stored), is fresh. It has to do with the timing of when\nenvironment.persistence takes effect during the first boot.</p>\n</blockquote>\n<blockquote>\n<p>To avoid this password issue, before your first nixos-rebuild switch for\nimpermanence, run:</p>\n<pre><code class=\"language-bash\">sudo mkdir -p /nix/persist/etc # Ensure the target directory exists\nsudo cp -a /etc/* /nix/persist/etc\n</code></pre>\n<ul>\n<li>This copies your current /etc directory contents (including existing user\npasswords) into your persistent &gt;&gt;storage.</li>\n<li>Crucially: You must also ensure that <code>/etc</code> is explicitly included in your\n<code>environment.persistence.\"/nix/persist\"</code>.directories list in your\n<code>impermanence.nix</code> like we did above, (or main configuration). This\nconfigures &gt;NixOS to persistently bind-mount <code>/nix/persist/etc</code> over <code>/etc</code>\non every subsequent boot. Once these steps are done and you reboot, your\nuser passwords should function correctly, and future rebuilds will &gt; not\npresent this problem.</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-bash\">sudo nixos-rebuild switch --flake .#hostname # Replace 'hostname' with your actual system hostname\n</code></pre>\n<ol start=\"3\">\n<li>Perform an Impermanence Test (Before Reboot):</li>\n</ol>\n<ul>\n<li>Before you reboot, create a temporary directory and file in a non-persistent\nlocation. Since you haven‚Äôt explicitly added <code>/imperm_test</code> to your\n<code>environment.persistence.\"/nix/persist\"</code> directories, this file should not\nsurvive a reboot.</li>\n</ul>\n<pre><code class=\"language-bash\">mkdir /imperm_test\necho \"This should be Gone after Reboot\" | sudo tee /imperm_test/testfile\nls -l /imperm_test/testfile # Verify the file exists\ncat /imperm_test/testfile # Verify content\n</code></pre>\n<ol start=\"4\">\n<li>Reboot Your System: For the impermanence setup to take full effect and for\nyour root filesystem to be reset for the first time, you must reboot your\nmachine.</li>\n</ol>\n<pre><code class=\"language-bash\">sudo reboot\n</code></pre>\n<ol start=\"5\">\n<li>Verify Impermanence (After Reboot):</li>\n</ol>\n<ul>\n<li>After the system has rebooted, check if the test directory and file still\nexist:</li>\n</ul>\n<pre><code class=\"language-bash\">ls -l /imperm_test/testfile\n</code></pre>\n<p>You should see an output like <code>ls: cannot access '/imperm_test/testfile'</code>: No\nsuch file or directory. This confirms that the <code>/imperm_test</code> directory and its\ncontents were indeed ephemeral and were removed during the reboot process,\nindicating your impermanence setup is working correctly!</p>\n<p>Your system should now come up with a fresh root filesystem, and only the data\nspecified in your <code>environment.persistence.\"/nix/persist\"</code> configuration will be\npersistent.</p>\n<h3>Recovery with nixos-enter and chroot</h3>\n<p>This is if you followed the minimal_install guide, it will need to be changed\nfor a different disk layout.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Chroot\">Chroot</a> is an operation that changes the\napparent root directory for the current running process and their children. A\nprogram that is run in such a modified environment cannot access files and\ncommands outside that environmental directory tree. This modified environment is\ncalled a chroot jail. ‚ÄìNixOS wiki</p>\n<p><code>nixos-enter</code> allows you to access a NixOS installation from a NixOS rescue\nsystem. To use, setup <code>/mnt</code> as described in the\n<a href=\"https://nixos.org/manual/nixos/stable/#sec-installation\">installation manual</a></p>\n<p>üõ†Ô∏è Recovery: Chroot into Your NixOS Btrfs+Impermanence System</p>\n<p>Take note of your layout from commands like:</p>\n<pre><code class=\"language-bash\">sudo fdisk -l\nlsblk\nsudo btrfs subvol list /\n</code></pre>\n<p>Also inspect your <code>disk-config.nix</code> to ensure you refer to the correct <code>subvol=</code>\nnames.</p>\n<p>If you need to repair your system (e.g., forgot root password, fix a broken\nconfig, etc.), follow these steps to chroot into your NixOS install:</p>\n<ol>\n<li>Boot a Live ISO</li>\n</ol>\n<p>Boot from a NixOS (or any recent Linux) live USB.</p>\n<p>Open a terminal and become root:</p>\n<pre><code class=\"language-bash\">sudo -i\n</code></pre>\n<ol start=\"2\">\n<li>Identify Your Devices</li>\n</ol>\n<p>Your main disk is <code>/dev/nvme0n1</code></p>\n<ul>\n<li>\n<p>EFI partition: <code>/dev/nvme0n1p1</code> (mounted at <code>/boot</code>)</p>\n</li>\n<li>\n<p>Root partition: <code>/dev/nvme0n1p2</code> (Btrfs, with subvolumes)</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>Mount the Btrfs Root Subvolume</li>\n</ol>\n<p>First, mount the Btrfs partition somewhere temporary (not as / yet):</p>\n<pre><code class=\"language-bash\">mount -o subvol=root,compress=zstd,noatime /dev/nvme0n1p2 /mnt\n</code></pre>\n<ol start=\"4\">\n<li>Mount Other Subvolumes</li>\n</ol>\n<p>Now mount your other subvolumes as defined in your <code>disko.nix</code>:</p>\n<pre><code class=\"language-bash\"># Mount Other Subvolumes\n# (Ensure /mnt directories are created for each *mountpoint*)\n\n# Home\nmkdir -p /mnt/home\nmount -o subvol=home,compress=zstd,noatime /dev/nvme0n1p2 /mnt/home\n\n# IMPORTANT: No separate mount for /mnt/home/user, as it's a nested subvolume\n# and handled by the /home mount.\n\n# Nix store\nmkdir -p /mnt/nix\nmount -o subvol=nix,compress=zstd,noatime /dev/nvme0n1p2 /mnt/nix\n\n# Nix persist\nmkdir -p /mnt/nix/persist\n# CRITICAL: Based our disko.nix, the subvolume name is 'persist', not 'nix/persist'\nmount -o subvol=persist,compress=zstd,noatime /dev/nvme0n1p2 /mnt/nix/persist\n\n# /var/log\nmkdir -p /mnt/var/log\nmount -o subvol=log,compress=zstd,noatime /dev/nvme0n1p2 /mnt/var/log\n\n# /var/lib\nmkdir -p /mnt/var/lib\n# Confirmed: The subvolume named 'lib' is mounted to /var/lib\nmount -o subvol=lib,compress=zstd,noatime /dev/nvme0n1p2 /mnt/var/lib\n</code></pre>\n<p>Note: If you get ‚Äúsubvolume not found,‚Äù check the subvolume names with\n<code>btrfs subvol list /mnt</code>.</p>\n<ol start=\"5\">\n<li>Mount the EFI Partition</li>\n</ol>\n<pre><code class=\"language-bash\">mkdir -p /mnt/boot mount /dev/nvme0n1p1 /mnt/boot\n</code></pre>\n<ol start=\"6\">\n<li>(Optional) Mount Virtual Filesystems</li>\n</ol>\n<pre><code class=\"language-bash\">mount --bind /dev /mnt/dev mount --bind /proc /mnt/proc mount --bind /sys\n/mnt/sys mount --bind /run /mnt/run\n</code></pre>\n<ol start=\"7\">\n<li>Chroot</li>\n</ol>\n<pre><code class=\"language-bash\">chroot /mnt /run/current-system/sw/bin/bash\n</code></pre>\n<p>or, if using a non-NixOS live system:</p>\n<pre><code class=\"language-bash\">nixos-enter\n</code></pre>\n<p>(You may need to install nixos-enter with nix-shell -p nixos-enter.) 8. You‚Äôre\nIn!</p>\n<p>You can now run nixos-rebuild, reset passwords, or fix configs as needed. üîé</p>\n<p>üìì Notes</p>\n<ul>\n<li>\n<p>Adjust <code>compress=zstd,noatime</code> if your config uses different mount options.</p>\n</li>\n<li>\n<p>For impermanence, make sure to mount all persistent subvolumes you need.</p>\n</li>\n<li>\n<p>If you use swap, you may want to enable it too (e.g., swapon /dev/zram0 if\nrelevant).</p>\n</li>\n</ul>\n<p>You can now recover, repair, or maintain your NixOS system as needed!</p>\n<h4>Related Material</h4>\n<ul>\n<li>\n<p><a href=\"https://wiki.nixos.org/wiki/Change_root\">Change root (chroot</a></p>\n</li>\n<li>\n<p><a href=\"https://www.mankier.com/8/nixos-enter\">nixos-enter</a></p>\n</li>\n<li>\n<p><a href=\"https://grahamc.com/blog/erase-your-darlings/\">erase your darlings</a></p>\n</li>\n<li>\n<p><a href=\"https://haseebmajid.dev/posts/2024-07-30-how-i-setup-btrfs-and-luks-on-nixos-using-disko/\">Guide for Btrfs with LUKS</a></p>\n</li>\n<li>\n<p><a href=\"https://notashelf.dev/posts/impermanence\">notashelf impermanence</a></p>\n</li>\n<li>\n<p><a href=\"https://wiki.nixos.org/wiki/Impermanence\">NixOS wiki Impermanence</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/nix-community/impermanence\">nix-community impermanence module</a></p>\n</li>\n</ul>\n",
      "date_published": "2025-11-24T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/Working_with_Nixpkgs_Locally.html",
      "url": "https://saylesss88.github.io/Working_with_Nixpkgs_Locally.html",
      "title": "Local Nixpkgs",
      "content_html": "<h1>Working with Nixpkgs Locally: Benefits and Best Practices</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><img src=\"images/server_rack.cleaned.png\" alt=\"server_rack\" /></p>\n<!-- ![gruv18](images/gruv18.png) -->\n<ul>\n<li>\n<p>Nixpkgs, the package repository for NixOS, is a powerful resource for building\nand customizing software.</p>\n</li>\n<li>\n<p>Working with a local copy enhances development, debugging, and contribution\nworkflows.</p>\n</li>\n<li>\n<p>This post covers setting up a local Nixpkgs repository, searching for\ndependencies, and leveraging its advantages, incorporating tips from the Nix\ncommunity.</p>\n</li>\n</ul>\n<h1>I. Why Work with Nixpkgs Locally?</h1>\n<ul>\n<li>\n<p>A local Nixpkgs repository offers significant advantages for Nix developers:</p>\n<h2>A. Faster Development Cycle</h2>\n<ul>\n<li>\n<p>Local searches for packages and dependencies are significantly quicker than\nquerying remote repositories or channels.</p>\n</li>\n<li>\n<p>This speedup is crucial for efficient debugging and rapid prototyping of Nix\nexpressions.</p>\n</li>\n</ul>\n<h2>B. Enhanced Version Control</h2>\n<ul>\n<li>\n<p>By pinning your local repository to specific commits or branches (e.g.,\n<code>nixos-unstable</code>), you ensure build reproducibility.</p>\n</li>\n<li>\n<p>This prevents unexpected issues arising from upstream changes in Nixpkgs.</p>\n</li>\n</ul>\n<h2>C. Flexible Debugging Capabilities</h2>\n<ul>\n<li>\n<p>You can directly test and modify package derivations within your local copy.</p>\n</li>\n<li>\n<p>This allows for quick fixes to issues like missing dependencies without\nwaiting for upstream updates or releases.</p>\n</li>\n</ul>\n<h2>D. Streamlined Contribution Workflow</h2>\n<ul>\n<li>\n<p>Developing and testing new packages or patches locally is essential before\nsubmitting them as pull requests to Nixpkgs.</p>\n</li>\n<li>\n<p>A local setup provides an isolated environment for experimentation.</p>\n</li>\n</ul>\n<h2>E. Up-to-Date Documentation Source</h2>\n<ul>\n<li>The source code and comments within the Nixpkgs repository often contain the\nmost current information about packages.</li>\n<li>This can sometimes be more up-to-date than official, external documentation.</li>\n</ul>\n<h2>F. Optimized Storage and Performance</h2>\n<ul>\n<li>Employing efficient cloning strategies (e.g., shallow clones) and avoiding\nunnecessary practices (like directly using Nixpkgs as a flake for local\ndevelopment) minimizes disk usage and build times.</li>\n</ul>\n</li>\n</ul>\n<h1>II. Flake vs. Non-Flake Syntax for Local Nixpkgs</h1>\n<ul>\n<li>\n<p>When working with Nixpkgs locally, the choice between Flake and non-Flake\nsyntax has implications for performance and storage:</p>\n<h2>A. Flake Syntax (<code>nix build .#&lt;package&gt;</code>)</h2>\n<ul>\n<li>\n<p>Treats the current directory as a flake, requiring evaluation of\n<code>flake.nix</code>.</p>\n</li>\n<li>\n<p>For local Nixpkgs, this evaluates the flake definition in the repository\nroot.</p>\n</li>\n<li>\n<p><strong>Performance and Storage Overhead:</strong> Flakes copy the entire working\ndirectory (including Git history if present) to <code>/nix/store</code> for evaluation.\nThis can be slow and storage-intensive for large repositories like Nixpkgs.</p>\n</li>\n</ul>\n<h2>B. Non-Flake Syntax (<code>nix-build -f . &lt;package&gt;</code> or <code>nix build -f . &lt;package&gt;</code>)</h2>\n<ul>\n<li>\n<p><code>-f .</code> specifies the Nix expression (e.g., <code>default.nix</code> or a specific file)\nin the current directory.</p>\n</li>\n<li>\n<p><strong>Efficiency:</strong> Evaluates the Nix expression directly <em>without</em> copying the\nentire worktree to <code>/nix/store</code>. This is significantly faster and more\nstorage-efficient for local development on large repositories.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2>III. Setting Up a Local Nixpkgs Repository Efficiently</h2>\n<ul>\n<li>Cloning Nixpkgs requires careful consideration due to its size.</li>\n</ul>\n<h2>A.a Initial Clone: Shallow Cloning</h2>\n<p>It is common to place your local clone in the <code>/src</code> directory:</p>\n<pre><code class=\"language-bash\">mkdir src &amp;&amp; cd src\n</code></pre>\n<blockquote>\n<p>‚ùó Warning, A shallow clone (<code>--depth 1</code>) is not recommended for general\ndevelopment or contributing changes back to Nixpkgs via pull requests. It‚Äôs\nprimarily suitable for:</p>\n<ul>\n<li>Quick checks or builds: If you only need to verify a package‚Äôs current state\nor build a specific version without needing historical context.</li>\n<li>CI/CD environments: Where disk space and clone time are critical, and only\nthe latest commit is needed for automated tests or builds.</li>\n</ul>\n</blockquote>\n<p>With that said, to avoid downloading the entire history, perform a shallow\nclone:</p>\n<pre><code class=\"language-bash\">git clone [https://github.com/NixOS/nixpkgs](https://github.com/NixOS/nixpkgs) --depth 1\ncd nixpkgs\n</code></pre>\n<h2>A.b A few Examples exploring Nixpkgs</h2>\n<p>While in the <code>nixpkgs</code> directory, you can check the version of a package:</p>\n<pre><code class=\"language-bash\">nix-instantiate --eval -A openssl.version\n\"3.4.1\"\n</code></pre>\n<p>Or to directly edit the file you can use <code>nix edit</code>:</p>\n<pre><code class=\"language-bash\">nix edit nixpkgs#openssl\n</code></pre>\n<p>It uses the nix registry and <code>openssl.meta.position</code> to locate the file.</p>\n<pre><code class=\"language-bash\">man nix3 registry\n</code></pre>\n<p>The above command will open the <code>openssl/default.nix</code> in your <code>$EDITOR</code>.</p>\n<hr />\n<h2>A.1 Full Fork and Clone of Nixpkgs</h2>\n<p>If you want to contribute to Nixpkgs, you need to set up a local version\nfollowing the\n<a href=\"https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md\">Contributing guide</a></p>\n<p>You‚Äôll need to, this is directly from the <code>Contributing.md</code>:</p>\n<ol>\n<li>\n<p><a href=\"https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo#forking-a-repository\">Fork</a>\nthe <a href=\"https://github.com/nixos/nixpkgs/\">Nixpkgs repository</a></p>\n</li>\n<li>\n<p><a href=\"https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo#cloning-your-forked-repository\">Clone the forked repo</a>\ninto a local <code>nixpkgs</code> directory.</p>\n</li>\n</ol>\n<pre><code class=\"language-bash\">git clone git@github.com:your-user/nixpkgs.git\n</code></pre>\n<ol start=\"3\">\n<li><a href=\"https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo#configuring-git-to-sync-your-fork-with-the-upstream-repository\">Configure the upstream Nixpkgs repo</a></li>\n</ol>\n<pre><code class=\"language-bash\">git remote add upstream git@github.com:NixOS/nixpkgs.git\n# Check them out\ngit remove -v\n</code></pre>\n<h3>The Three Master Branches</h3>\n<ol>\n<li><strong>Upstream Master</strong> (upstream/master):</li>\n</ol>\n<ul>\n<li>\n<p><strong>Where it is</strong>: On the official NixOS servers.</p>\n</li>\n<li>\n<p><strong>Role</strong>: The absolute source of truth. Thousands of people are pushing to\nthis daily.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>Local Master</strong> (master):</li>\n</ol>\n<ul>\n<li>\n<p><strong>Where it is</strong>: On your physical computer.</p>\n</li>\n<li>\n<p><strong>Role</strong>: Your working copy. This is the only one you can actually ‚Äúrebase‚Äù or\n‚Äúcommit‚Äù to directly.</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>Origin Master</strong> (origin/master):</li>\n</ol>\n<ul>\n<li>\n<p><strong>Where it is</strong>: On your GitHub fork (github.com/your-user/nixpkgs).</p>\n</li>\n<li>\n<p><strong>Role</strong>: A personal backup and a place to host your code so you can open Pull\nRequests.</p>\n</li>\n</ul>\n<h3>Create a branch</h3>\n<p>In the nixpkgs ecosystem, the ‚Äúcleanest‚Äù way to work is to <strong>never</strong> add your\nown commits to your local master.</p>\n<ul>\n<li>\n<p>Keep your <code>master</code> as a ‚Äúpure mirror‚Äù of <code>upstream/master</code>.</p>\n</li>\n<li>\n<p>Whenever you want to fix a package or add something new, create a feature\nbranch:</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">git checkout -b fix-my-package master\n</code></pre>\n<p>This way, syncing is as simple as a reset:</p>\n<pre><code class=\"language-bash\"># Total reset of your local master to match the official one\ngit fetch upstream\ngit checkout master\ngit reset --hard upstream/master\ngit push origin master --force\n</code></pre>\n<h3>Pushing a PR</h3>\n<p>When you‚Äôre ready to push changes you push to <code>origin/feature-branch</code>, visit\nyour fork on github.com and submit the PR.</p>\n<h2>B. Managing Branches with Worktrees</h2>\n<ul>\n<li>\n<p>Use Git worktrees to manage different branches efficiently:</p>\n<pre><code class=\"language-bash\">git fetch --all --prune --depth=1\ngit worktree add -b nixos-unstable nixos-unstable # For just unstable\n</code></pre>\n</li>\n<li>\n<p><strong>Explanation of <code>git worktree</code>:</strong> Allows multiple working directories\nattached to the same <code>.git</code> directory, sharing history and objects but with\nseparate checked-out files.</p>\n</li>\n<li>\n<p><code>git worktree add</code>: Creates a new working directory for the specified branch\n(<code>nixos-unstable</code> in this case).</p>\n</li>\n</ul>\n<h1>IV. Debugging Missing Dependencies: A Practical Example</h1>\n<details>\n<summary> Click to see icat Example </summary>\n<ul>\n<li>Let‚Äôs say you‚Äôre trying to build <code>icat</code> locally and encounter a missing\ndependency error:</li>\n</ul>\n<pre><code class=\"language-nix\">nix-build -A icat\n# ... (Error log showing \"fatal error: X11/Xlib.h: No such file or directory\")\n</code></pre>\n<ul>\n<li>The error <code>fatal error: X11/Xlib.h: No such file or directory</code> indicates a\nmissing X11 dependency.</li>\n</ul>\n<h2>A. Online Search with <code>search.nixos.org</code></h2>\n<ul>\n<li>The Nixpkgs package search website\n(<a href=\"https://search.nixos.org/packages\">https://search.nixos.org/packages</a>) is a\nvaluable first step.</li>\n<li>However, broad terms like ‚Äúx11‚Äù can yield many irrelevant results.</li>\n<li><strong>Tip:</strong> Utilize the left sidebar to filter by package sets (e.g., ‚Äúxorg‚Äù).</li>\n</ul>\n<h2>B. Local Source Code Search with <code>rg</code> (ripgrep)</h2>\n<ul>\n<li>\n<p>Familiarity with searching the Nixpkgs source code is crucial for finding\ndependencies.</p>\n</li>\n<li>\n<p>Navigate to your local <code>nixpkgs/</code> directory and use <code>rg</code>:</p>\n<pre><code class=\"language-bash\">rg \"x11 =\" pkgs # Case-sensitive search\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code>pkgs/tools/X11/primus/default.nix\n21:  primus = if useNvidia then primusLib_ else primusLib_.override { nvidia_x11 = null; };\n22:  primus_i686 = if useNvidia then primusLib_i686_ else primusLib_i686_.override { nvidia_x11 = null; };\n\npkgs/applications/graphics/imv/default.nix\n38:    x11 = [ libGLU xorg.libxcb xorg.libX11 ];\n</code></pre>\n</li>\n<li>\n<p>Refining the search (case-insensitive):</p>\n<pre><code class=\"language-bash\">rg -i \"libx11 =\" pkgs\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code># ... (Output showing \"xorg.libX11\")\n</code></pre>\n</li>\n<li>\n<p>The key result is <code>xorg.libX11</code>, which is likely the missing dependency.</p>\n</li>\n</ul>\n </details>\n<h1>V. Local Derivation Search with <code>nix-locate</code></h1>\n<details>\n<summary> Click to Expand nix-locate command Example</summary>\n<ul>\n<li>\n<p><code>nix-locate</code> (from the <code>nix-index</code> package) allows searching for derivations\non the command line.</p>\n<blockquote>\n<p><strong>Note:</strong> Install <code>nix-index</code> and run <code>nix-index</code> to create the initial\nindex.</p>\n</blockquote>\n<pre><code class=\"language-bash\">nix-locate libx11\n# ... (Output showing paths related to libx11)\n</code></pre>\n</li>\n<li>\n<p>Combining online and local search tools (<code>search.nixos.org</code>, <code>rg</code>,\n<code>nix-locate</code>) provides a comprehensive approach to finding dependencies.</p>\n</li>\n</ul>\n</details>\n<h1>VI. Key Benefits of Working with Nixpkgs Locally (Recap)</h1>\n<ul>\n<li>\n<p><strong>Speed:</strong> Faster searches and builds compared to remote operations.</p>\n</li>\n<li>\n<p><strong>Control:</strong> Full control over the Nixpkgs version.</p>\n</li>\n<li>\n<p><strong>Up-to-Date Information:</strong> Repository source often has the latest details.</p>\n</li>\n</ul>\n<h1>VII. Best Practices and Tips from the Community</h1>\n<details>\n<summary> ‚úîÔ∏è Click To Expand Best Practices and Tips from the community</summary>\n<ul>\n<li>\n<p><strong>Rebasing over Merging:</strong> Never merge upstream changes into your local\nbranch. Always rebase your branch onto the upstream (e.g., <code>master</code> or\n<code>nixos-unstable</code>) to avoid accidental large-scale pings in pull requests (Tip\nfrom <code>soulsssx3</code> on Reddit).</p>\n</li>\n<li>\n<p><strong>Tip from <code>ElvishJErrico</code>:</strong> Avoid using Nixpkgs directly as a flake for\nlocal development due to slow copying to <code>/nix/store</code> and performance issues\nwith garbage collection on large numbers of small files. Use\n<code>nix build -f . &lt;package&gt;</code> instead of <code>nix build .#&lt;package&gt;</code>.</p>\n</li>\n<li>\n<p><strong>Edge Cases for Flake Syntax:</strong> Flake syntax might be necessary in specific\nscenarios, such as NixOS installer tests where copying the Git history should\nbe avoided.</p>\n</li>\n<li>\n<p><strong>Base Changes on <code>nixos-unstable</code>:</strong> For better binary cache hits, base your\nchanges on the <code>nixos-unstable</code> branch instead of <code>master</code>. Consider the\nmerge-base for staging branches as well.</p>\n</li>\n<li>\n<p><strong>Consider <code>jujutsu</code>:</strong> Explore <a href=\"https://github.com/jj-vcs/jj\">jj-vcs</a>, a\nGit-compatible alternative that can offer a more intuitive workflow,\nespecially for large monorepos like Nixpkgs. While it has a learning curve, it\ncan significantly improve parallel work and branch management.</p>\n</li>\n<li>\n<p><a href=\"https://saylesss88.github.io/vcs/jujutsu.html\">Intro-To-Jujutsu</a></p>\n</li>\n</ul>\n</details>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/Debugging_and_Tracing_NixOS_Modules.html",
      "url": "https://saylesss88.github.io/Debugging_and_Tracing_NixOS_Modules.html",
      "title": "Debugging NixOS modules",
      "content_html": "<h1>Debugging Modules</h1>\n<p>This chapter covers debugging NixOS modules, focusing on tracing module options\nand evaluating merges.</p>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<h2>Debugging and Tracing NixOS Modules</h2>\n<p><img src=\"images/coding4.png\" alt=\"404\" /></p>\n<!-- ![gruv17](images/gruv17.png) -->\n<ul>\n<li>Other related post if you haven‚Äôt read my previous post on modules, that may\nbe helpful before reading this one:\n<ul>\n<li>\n<p><a href=\"https://saylesss88.github.io/posts/nix_modules_explained/\">nix-modules-explained</a></p>\n</li>\n<li>\n<p>This post is my notes following Nix Hour 40. If it seems a little chaotic,\ntry watching one. They are hard to follow if you‚Äôre not extremely familiar\nwith the concepts.</p>\n</li>\n<li>\n<p><a href=\"https://www.youtube.com/watch?v=aLy8id4wr-M&amp;t=2120s\">Nix Hour 40</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>Nix Code is particularly hard to <strong>debug</strong> because of (e.g. lazy evaluation,\ndeclarative nature, layered modules)</p>\n<ul>\n<li>The following simple Nix code snippet illustrates a basic NixOS module\ndefinition and how options are declared and configured. We‚Äôll use this example\nto demonstrate fundamental debugging techniques using <code>nix-instantiate</code>.</li>\n</ul>\n<pre><code class=\"language-nix\">let\n  lib = import &lt;nixpkgs/lib&gt;;\nin\nlib.evalModules {\n  modules = [\n    ({ lib, ... }: {\n      options.foo = lib.mkOption {\n        # type = lib.types.raw;\n        type = lib.types.anything;\n        # default = pkgs;\n      };\n      config.foo = {\n        bar = 10;\n        list = [1 2 3 ];\n        baz = lib.mkDefault \"baz\";\n      };\n    })\n    {\n      foo.baz = \"bar\";\n    }\n  ];\n}\n</code></pre>\n<ul>\n<li>\n<p>In the above code, adding <code>lib</code> to the function arguments isn‚Äôt required but\nif you were to move the module to another file it would fail without it\nbecause <code>lib</code> comes from outside of it. So it‚Äôs good practice to refer to\n<code>lib</code> in the modules themselves.</p>\n</li>\n<li>\n<p>You should <strong>always</strong> assign a type to your options, if you don‚Äôt know which\ntype to use you could use <code>raw</code>. <code>raw</code> is a type that doesn‚Äôt do any\nprocessing. So if you were to assign the entire packages set to the option\ne.g. <code>default = pkgs;</code> it wouldn‚Äôt recurseinto all the packages and try to\nevaluate them. There is also <code>anything</code>, that is useful if you do want to\nrecurse into the values.</p>\n</li>\n<li>\n<p>The following is an example of how you would run this inside vim/neovim, the\nrest of the examples will be from the command line:</p>\n</li>\n</ul>\n<pre><code class=\"language-vim\">:!nix-instantiate --eval -A config.foo --strict\n</code></pre>\n<p><strong>Output</strong>:</p>\n<details>\n<summary> Click to Expand the Output </summary>\n<pre><code class=\"language-bash\">{ bar = 10; baz = \"bar\"; list = [ 1 2 3 ]; }\n</code></pre>\n<p>To show the difference you could uncomment the <code>raw</code> type and comment the\n<code>anything</code> type and run the above command again you‚Äôll see that you get an\nerror:</p>\n<pre><code class=\"language-bash\">error: The option 'foo' is defined multiple times while it's expected to be\nunique\n</code></pre>\n<p>To execute this command on the command line:</p>\n<pre><code class=\"language-bash\">nix-instantiate --eval --strict -A config.foo\n</code></pre>\n<p>It will show you the start of a trace. To get the full trace add:</p>\n<pre><code class=\"language-bash\">nix-instantiate --eval --strict -A config.foo --show-trace\n</code></pre>\n</details>\n<h2>Example 2</h2>\n<details>\n<summary> Click to Expand Example 2 </summary>\n<p>In the previous example, we looked at a simplified module. Now, let‚Äôs examine a\nmore realistic scenario involving a basic NixOS configuration file\n(<code>configuration.nix</code>).</p>\n<p>This example will demonstrate how to use <code>nix-instantiate</code> to evaluate an entire\nsystem configuration and how <code>--show-trace</code> helps in diagnosing errors within\nthis context.</p>\n<p>Consider the following <code>configuration.nix</code> file:</p>\n<pre><code class=\"language-nix\"># configuration.nix\n{ lib, ... }: {\n  boot.loader.grub.device = \"nodev\";\n  fileSystems.\"/\".device = \"/devst\";\n  system.stateVersion = \"24.11\";\n}\n</code></pre>\n<ul>\n<li>This configuration snippet sets the GRUB bootloader device, defines a root\nfilesystem, and specifies the expected NixOS state version. To evaluate this\nentire system configuration, you can use <code>nix-instantiate</code> and point it to the\n<code>&lt;nixpkgs/nixos&gt;</code> entrypoint, providing our <code>configuration.nix</code> file as an\nargument. The <code>-A system</code> flag selects the top-level <code>system</code> attribute, which\nrepresents the instantiated system configuration.</li>\n</ul>\n<p><strong>Run</strong> it in with:</p>\n<pre><code class=\"language-bash\">nix-instantiate '&lt;nixpkgs/nixos&gt;' --arg configuration ./configuration.nix -A system\n</code></pre>\n<p><strong>Output</strong>:</p>\n<pre><code class=\"language-bash\">/nix/store/kfcwvvpdbsb3xcks1s76id16i1mc3l5k-nixos-system-nixos-25.05pre-git.drv\n</code></pre>\n<p>Ok, we can see that this successfully <em>instantiates</em>. Let‚Äôs introduce an error\nto trace:</p>\n<pre><code class=\"language-nix\">{ lib, ... }: {\n  boot.loader.grub.device = \"nodev\";\n  fileSystems.\"/\".device = \"/devst\";\n  system.stateVersion = builtins.genList \"24.11\" null;\n}\n</code></pre>\n<p><strong>Output</strong>:</p>\n<pre><code class=\"language-bash\">(stack trace truncated; use '--show-trace' to show the full, detailed trace)\nerror: expected an integer but found null: null\n</code></pre>\n<p>Rerun the command with <code>--show-trace</code> appended:</p>\n<p>Or on the command line</p>\n<pre><code class=\"language-bash\">nix-instantiate '&lt;nixpkgs/nixos&gt;' --arg configuration ./configuration.nix -A system --show-trace\n</code></pre>\n<ul>\n<li>This outputs a much longer trace than the first example. It shows you the file\nthe error occured in and you can see that in this case they are a lot of\ninternal functions. (e.g.\n<code>at /nix/store/ccfwxygjrarahgfv5865x2f828sjr5h0- source/lib/attrsets.nix:1529:14:</code>)</li>\n</ul>\n<p>To show your own error message you could do something like this:</p>\n<pre><code class=\"language-nix\">{lib, ...}: {\n  boot.loader.grub.device = \"nodev\";\n  fileSystems.\"/\".device = \"/devst\";\n  system.stateVersion = builtins.addErrorContext \"AAAAAAAAAAAAAAAAA\" (builtins.genList \"24.11\" null);\n}\n</code></pre>\n<p>Run it:</p>\n<pre><code class=\"language-bash\">nix-instantiate '&lt;nixpkgs/nixos&gt;' --arg configuration ./configuration.nix -A system --show-trace`\n</code></pre>\n<p><strong>Output</strong>:</p>\n<pre><code class=\"language-bash\"> ‚Ä¶ while evaluating the attribute 'value'\n     at /nix/store/ccfwxygjrarahgfv5865x2f828sjr5h0-source/lib/modules.nix:770:21:\n      769|             inherit (module) file;\n      770|             inherit value;\n         |                     ^\n      771|           }) module.config\n\n   ‚Ä¶ AAAAAAAAAAAAAAAAA\n\n   ‚Ä¶ while calling the 'genList' builtin\n     at /home/jr/tests/configuration.nix:4:71:\n        3|   fileSystems.\"/\".device = \"/devst\";\n        4|   system.stateVersion = builtins.addErrorContext \"AAAAAAAAAAAAAAAAA\"\n         (builtins.genList \"24.11\" null);\n         |                                                                       ^\n        5| }\n\n   ‚Ä¶ while evaluating the second argument passed to builtins.genList\n\n   error: expected an integer but found null: null\n</code></pre>\n<ul>\n<li>In the latest nix they actually inverted the error messages so the most\nrelevant parts will be at the bottom.</li>\n</ul>\n</details>\n<h2>Example 3</h2>\n<details>\n<summary> Click to Expand Example 3 </summary>\n<p>Let‚Äôs consider another example, this time demonstrating the definition of\nconfiguration options using <code>lib.mkOption</code> within a module structure.</p>\n<pre><code class=\"language-nix\"># default.nix\nlet\n  lib = import &lt;nixpkgs/lib&gt;;\nin\nlib.evalModules {\n  modules = [\n    ({ lib, ... }: {\n      options.ints = lib.mkOption {\n        type = lib.types.attrsOf lib.types.int;\n      };\n      options.strings = lib.mkOption {\n        type = lib.types.string;\n        # type = lib.types.attrsOf lib.types.string;\n        default = \"foo\";\n      };\n    })\n  ];\n}\n</code></pre>\n<p><strong>Instantiate</strong> this with:</p>\n<pre><code class=\"language-bash\">nix-instantiate --eval --strict -A config.strings\n</code></pre>\n<p><strong>Output</strong>:</p>\n<pre><code class=\"language-bash\">evaluation warning: The type `types.string` is deprecated.\nSee https://github.com/NixOS/nixpkgs/pull/66346 for better alternative types.\n\"foo\"\n</code></pre>\n<ul>\n<li>Unfortunately you won‚Äôt get the same depreciation warning from <code>lib.attrsOf</code></li>\n</ul>\n<p>Below is an interesting way to provide nixpkgs run it on the command line:</p>\n<pre><code class=\"language-bash\">export NIX_PATH=nixpkgs=channel:nixpkgs-unstable\necho $NIX_PATH\n</code></pre>\n<p><strong>Output</strong>:</p>\n<pre><code class=\"language-bash\">nixpkgs=channel:nixpkgs-unstable\n</code></pre>\n<p>The next two commands are to check that after using the above way to provide\n<code>nixpkgs-unstable</code> that they both point to the same store path, the following\ncommand will fetch nixpkgs from the channel above:</p>\n<pre><code class=\"language-bash\">nix-instantiate --find-file nixpkgs\n</code></pre>\n<p><strong>Output</strong> 1Ô∏è‚É£</p>\n<pre><code class=\"language-bash\">/nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source\n</code></pre>\n<pre><code class=\"language-bash\">nix-instantiate --eval channel:nixpkgs-unstable -A path\n</code></pre>\n<p><strong>Output</strong>: 2Ô∏è‚É£</p>\n<pre><code class=\"language-bash\">/nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source\n</code></pre>\n<ul>\n<li>As you can see both commands produce the same store path</li>\n</ul>\n<h2>Example 4</h2>\n<p>In our previous example, we encountered a deprecation warning for\n<code>lib.types.string</code>. This next example delves deeper into why that type was\ndeprecated and demonstrates the consequences of its behavior, along with the\nrecommended fix.</p>\n<pre><code class=\"language-nix\"># default.nix\nlet\n  lib = import &lt;nixpkgs/lib&gt;;\nin\n  lib.evalModules {\n    modules = [\n      ({lib, ...}: {\n        options.ints = lib.mkOption {\n          type = lib.types.attrsOf lib.types.int;\n        };\n        options.strings = lib.mkOption {\n          # type = lib.types.string;\n          type = lib.types.attrsOf lib.types.string;\n          default = {\n            x = \"foo\";\n          };\n        };\n        config = {\n          strings = lib.mkOptionDefault {\n            x = \"bar\";\n          };\n        };\n      })\n    ];\n  }\n</code></pre>\n<p>Evaluate it with:</p>\n<pre><code class=\"language-bash\">nix-instantiate --eval --strict -A config.strings\n</code></pre>\n<ul>\n<li>\n<p><code>types.string</code> depricated because it silently concatenates strings</p>\n</li>\n<li>\n<p>The above command has two options with the same priority level and evaluates\nto <code>{ x = \"foobar\"; }</code></p>\n</li>\n</ul>\n<p><strong>Output:</strong></p>\n<pre><code class=\"language-bash\">evaluation warning: The type `types.string` is deprecated. See https://github.\ncom/NixOS/nixpkgs/pull/66346 for better alternative types.\n{ x = \"foobar\"; }\n</code></pre>\n<ul>\n<li><code>types.str</code> was the replacement for the depricated <code>types.string</code>:</li>\n</ul>\n<pre><code class=\"language-nix\"># default.nix\nlet\n  lib = import &lt;nixpkgs/lib&gt;;\nin\n  lib.evalModules {\n    modules = [\n      ({lib, ...}: {\n        options.ints = lib.mkOption {\n          type = lib.types.attrsOf lib.types.int;\n        };\n        options.strings = lib.mkOption {\n          # type = lib.types.string;\n          type = lib.types.attrsOf lib.types.str;\n          # Sets the value with a lower priority: lib.mkOptionDefault\n          default = {\n            x = \"foo\";\n          };\n        };\n        config = {\n          strings = lib.mkOptionDefault {\n            x = \"bar\";\n          };\n        };\n      })\n    ];\n  }\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code class=\"language-bash\">error:\n‚Ä¶ while evaluating the attribute 'x'\n\n‚Ä¶ while evaluating the attribute 'value'\n at /nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source/lib/modules.nix:1148:41:\n 1147|\n 1148|     optionalValue = if isDefined then { value = mergedValue; } else { };\n     |                                         ^\n 1149|   };\n\n‚Ä¶ while calling the 'foldl'' builtin\n at /nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source/lib/options.nix:508:8:\n  507|     else\n  508|       (foldl' (\n     |        ^\n  509|         first: def:\n\n(stack trace truncated; use '--show-trace' to show the full, detailed trace)\n\nerror: The option `strings.x' has conflicting definition values:\n- In `&lt;unknown-file&gt;': \"foo\"\n- In `&lt;unknown-file&gt;': \"bar\"\nUse `lib.mkForce value` or `lib.mkDefault value` to change the priority on any of these definitions.\n\nshell returned 1\n</code></pre>\n</details>\n<h2>Summary</h2>\n<ul>\n<li>\n<p>So types in the module system aren‚Äôt just types in the conventional sense but\nthey also specify the emerging behavior of these values.</p>\n</li>\n<li>\n<p>If we switch the type in the above example to <code>types.lines</code> you get this\nreturned, <code>{ x = \"foo\\nbar\"; }</code></p>\n</li>\n<li>\n<p><code>mkOptionDefault</code> isn‚Äôt typically something you should generally use, instead\noptions have a <code>default</code> setting</p>\n</li>\n<li>\n<p>If you want to make sure that you set a default but if the user specifies it,\nit shouldn‚Äôt get overridden. You should not set it in the following:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">options.strings = lib.mkOption {\n  type = lib.types.attrsOf lib.types.lines;\n  default = {\n    x = \"foo\";\n  };\n}\n</code></pre>\n<p>Because the above uses <code>mkOptionDefault</code> but instead in under the <code>config</code>\nattribute like the following:</p>\n<pre><code class=\"language-nix\"># ...snip...\noptions.strings = lib.mkOption {\n  type = lib.types.attrsOf lib.types.lines;\n  # default = {\n    # x = \"foo\";\n  # };\n};\nconfig = {\n  strings = {\n    x = lib.mkDefault \"foo\";\n  };\n};\n# ...snip...\n</code></pre>\n<pre><code class=\"language-nix\">let\n  lib = import &lt;nixpkgs/lib&gt;;\nin\n  lib.evalModules {\n    modules = [\n      ({lib, ...}: {\n        options.ints = lib.mkOption {\n          type = lib.types.attrsOf lib.types.int;\n        };\n        options.strings = lib.mkOption {\n          # type = lib.types.string;\n          type = lib.types.attrsOf lib.types.str;\n          # Sets the value with a lower priority: lib.mkOptionDefault\n          #default = {\n          #  x = \"foo\";\n          #};\n        };\n        config.strings = {\n          x = \"foo\";\n        };\n      })\n      {\n        config.strings = {\n          y = \"bar\";\n        };\n      }\n    ];\n  }\n</code></pre>\n<p><strong>Output</strong>:</p>\n<ul>\n<li>This works now because there‚Äôs no difference between <code>x</code> and <code>y</code></li>\n</ul>\n<pre><code class=\"language-bash\">{ x = \"foo\"; y = \"bar\"; }\n</code></pre>\n<h2>More Functionality between modules</h2>\n<pre><code class=\"language-nix\">let\n  lib = import &lt;nixpkgs/lib&gt;;\nin\n  lib.evalModules {\n    modules = [\n      ({lib, ...}: {\n        options.ints = lib.mkOption {\n          type = lib.types.attrsOf lib.types.int;\n        };\n        options.strings = lib.mkOption {\n          # type = lib.types.string;\n          type = lib.types.attrsOf lib.types.str;\n          # Sets the value with a lower priority: lib.mkOptionDefault\n          #default = {\n          #  x = \"foo\";\n          #};\n        };\n        config.strings = {\n          x = lib.mkDefault \"foo\";\n        };\n      })\n      {\n        config.strings = {\n          x = \"x\";\n          y = \"bar\";\n        };\n      }\n    ];\n  }\n</code></pre>\n<ul>\n<li>The above command would cause a conflict without the <code>x = lib.mkDefault foo</code>\nAnd this is typically what you want to do for defaults and modules in things\nlike nested configuration.</li>\n</ul>\n<p><strong>Output:</strong></p>\n<pre><code class=\"language-bash\">{ x = \"x\"; y = \"bar\"; }\n</code></pre>\n<h3>Infinite recursion error</h3>\n<ol>\n<li>A common pitfall is to introduce a hard to debug error <code>infinite recursion</code>\nwhen shadowing a name. The simplest example for this is:</li>\n</ol>\n<blockquote>\n<pre><code class=\"language-nix\">let a = 1; in rec { a = a; }\n</code></pre>\n</blockquote>\n<blockquote>\n<p>üí°<strong>TIP</strong>: Avoid <code>rec</code>. Use <code>let ... in</code> Example:</p>\n<pre><code class=\"language-nix\">let\n a = 1;\nin {\n a = a;\n b = a + 2;\n}\n</code></pre>\n</blockquote>\n<details>\n<summary> Click to Expand a more involved infinite recursion error </summary>\n<p>We‚Äôll separate the logic for this example, this will be the <code>default.nix</code> this\nis where having <code>lib</code> defined in your inline modules is helpful because you can\njust delete the section and paste it into your <code>modules.nix</code>:</p>\n<pre><code class=\"language-nix\"># default.nix\nlet\n  lib = import &lt;nixpkgs/lib&gt;;\nin\n  lib.evalModules {\n    modules = [\n      ./module.nix\n    ];\n  }\n</code></pre>\n<p>And in the <code>module.nix</code>:</p>\n<pre><code class=\"language-nix\"># module.nix\n{ lib, pkgs, ...}: {\n  options.etc = lib.mkOption {\n    type = lib.types.attrsOf lib.types.path;\n    default = { };\n    description = ''\n      Specifies which paths are is /etc/\n    '';\n  };\n\n  config._module.args.pkgs = import &lt;nixpkgs&gt; {\n    config = {};\n    overlays = [];\n  };\n  config.etc.foo = pkgs.writeText \"foo\" ''\n    foo configuration\n  '';\n}\n</code></pre>\n<ul>\n<li>If you evaluate this with the following you will get an infinite recursion\nerror.</li>\n</ul>\n<pre><code class=\"language-bash\">nix-instantiate --eval --strict -A config.etc\n</code></pre>\n<ul>\n<li>This happens because <code>--strict</code> evaluates the <code>etc</code>, then it goes into the\n<code>attrsOf</code>, and the <code>path</code></li>\n</ul>\n<pre><code class=\"language-bash\">nix repl\nnix-repl&gt; :l &lt;nixpkgs&gt;\nnix-repl&gt; hello.out.out.out\n</code></pre>\n<p>In this example:</p>\n<ul>\n<li>\n<p><code>:l &lt;nixpkgs&gt;</code> loads the Nixpkgs library into the repl environment, making its\ndefinitions available.</p>\n</li>\n<li>\n<p><code>hello</code> refers to the <code>hello</code> package definition within Nixpkgs. Packages in\nNixpkgs are defined as <em>derivations</em>.</p>\n</li>\n<li>\n<p><code>.out</code> is a common attribute name for the <em>main output</em> of a derivation (e.g.,\nthe installed package). Some packages, especially those with complex build\nprocesses or multiple outputs, might have nested output attributes. In the\ncase of <code>hello</code>, accessing <code>.out.out.out</code> ultimately leads us to the\n<em>derivation</em> itself.</p>\n</li>\n</ul>\n<p>The key takeaway here is that when you evaluate a package in the <code>nix repl</code>,\nyou‚Äôre often interacting with its derivation or one of its output paths in the\nNix store. The <code>¬´derivation ...¬ª</code> indicates that <code>hello.out.out.out</code> evaluates\nto a derivation ‚Äì the blueprint for building the <code>hello</code> package. This is in\ncontrast to <code>--eval --strict</code>, which tries to fully evaluate values, potentially\nleading to infinite recursion if it encounters a derivation that refers back to\nitself indirectly during attribute evaluation.</p>\n<p><strong>Output:</strong></p>\n<pre><code class=\"language-bash\">¬´derivation /nix/store/b1vcpm321dwbwx6wj4n13l35f4y2wrfv-hello-2.12.1.drv¬ª\n</code></pre>\n<ul>\n<li>So it recurses through the entire thing and tries to evaluate its string.</li>\n</ul>\n<p>So we want to change the command from <code>--eval --strict</code> which is only based on\nevaluation to at least <code>nix-instantiate</code> which is based on derivations:</p>\n<pre><code class=\"language-bash\">nix-instantiate -A config.etc\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code class=\"language-bash\">warning: you did not specify '--add-root'; the result might be removed by the garbage collector\n/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv\n</code></pre>\n<ul>\n<li>We don‚Äôt really have a derivation yet for example:</li>\n</ul>\n<pre><code class=\"language-nix\"># module.nix\n{\n  lib,\n  pkgs,\n  ...\n}: {\n  options.etc = lib.mkOption {\n    type = lib.types.attrsOf (lib.types.attrsOf lib.types.path);\n    default = {};\n    description = ''\n      Specifies which paths are in /etc/\n    '';\n  };\n\n  config._module.args.pkgs = import &lt;nixpkgs&gt; {\n    config = {};\n    overlays = [];\n  };\n  config.etc.foo.bar = pkgs.writeText \"foo\" ''\n    foo configuration\n  '';\n}\n</code></pre>\n<p>Try to evaluate the above command with <code>nix-instantiate -A config.etc</code> and Nix\ndoesn‚Äôt even try to build it. With nested <code>attrsOf</code></p>\n<pre><code class=\"language-bash\">nix repl -f default.nix\nnix-repl&gt; config.etc\n{\n  foo = { ... };\n}\nnix-repl&gt; config.etc.foo\n{\n  bar = ¬´derivation /nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv¬ª;\n}\n</code></pre>\n<ul>\n<li>So <code>config.foo</code> is an attribute set and <code>config.etc.foo</code> is also an attribute\nset but it‚Äôs not a derivation by itself. So <code>nix-instantiate</code> does this one\nlevel of recursion here and it would have built <code>foo</code> value if it were a\nderivation.</li>\n</ul>\n</details>\n<h3>Example 5</h3>\n<details>\n<summary> Click to Expand Example 5 </summary>\n<p>We‚Äôll use the same <code>module.nix</code> and <code>default.nix</code> from the previous example.</p>\n<p>Building More Complex Configurations with Modules In this next example, we‚Äôll\nfocus on a common task in system configuration: managing files within the\n<code>/etc/</code> directory. We‚Äôll define a module that allows us to specify the content\nof arbitrary files in <code>/etc/</code> and then use a special Nix function to combine\nthese individual file definitions into a single, manageable entity.</p>\n<p>We‚Äôll introduce a new option, <code>options.etc</code>, which will allow us to define the\ncontent of files within <code>/etc/</code>. Then, we‚Äôll use <code>pkgs.linkFarm</code> to create a\nderivation that represents the entire <code>/etc/</code> directory as a collection of\nsymbolic links pointing to the individual file contents we‚Äôve defined. This\ndemonstrates how modules can abstract away the details of creating complex\nsystem configurations, providing a declarative and reproducible way to manage\neven fundamental aspects of the operating system.</p>\n<p>Let‚Äôs show how we can use Nix modules to declaratively manage the <code>/etc/</code>\ndirectory</p>\n<pre><code class=\"language-nix\"># default.nix\nlet\n  lib = import &lt;nixpkgs/lib&gt;;\nin\n  lib.evalModules {\n    modules = [\n      ./module.nix\n    ];\n  }\n\n</code></pre>\n<pre><code class=\"language-nix\"># module.nix\n{\n  lib,\n  pkgs,\n  config,\n  ...\n}: {\n  options.etc = lib.mkOption {\n    type = lib.types.attrsOf (lib.types.attrsOf lib.types.path);\n    default = {};\n    description = ''\n      Specifies which paths are in /etc/\n    '';\n  };\n  options.etcCombined = lib.mkOption {\n    type = lib.types.package;\n    default =\n      pkgs.linkFarm \"etc\"\n      (lib.mapAttrsToList (name: value: {\n        name = name;\n        path = value;\n      }) config.etc);\n  };\n\n  config._module.args.pkgs = import &lt;nixpkgs&gt; {\n    config = {};\n    overlays = [];\n  };\n  config.etc.foo = pkgs.writeText \"foo\" ''\n    foo configuration\n  '';\n  config.etc.bar = pkgs.writeText \"bar\" ''\n    bar configuration\n  '';\n}\n\n</code></pre>\n<p>Run it with:</p>\n<pre><code class=\"language-bash\">nix-instantiate -A config.etcCombined\n</code></pre>\n<p><strong>Output</strong>:</p>\n<pre><code class=\"language-bash\">/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv\n</code></pre>\n<ul>\n<li>So we can see that it will instantiate, lets see if it will build:</li>\n</ul>\n<pre><code class=\"language-bash\">nix-build -A config.etcCombined\n</code></pre>\n<p><strong>Output</strong>:</p>\n<pre><code class=\"language-bash\">these 3 derivations will be built:\n/nix/store/41yfxq4af1vrs0rrgfk5gc36kmjc7270-bar.drv\n/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv\n/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv\nbuilding '/nix/store/41yfxq4af1vrs0rrgfk5gc36kmjc7270-bar.drv'...\nbuilding '/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv'...\nbuilding '/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv'...\n/nix/store/ca3wyk5m3qhy8n1nbn0181m29qvp1klp-etc\n</code></pre>\n<pre><code class=\"language-bash\">nix-build -A config.etcCombined &amp;&amp; ls result/ -laa\n</code></pre>\n<p><strong>Output</strong>:</p>\n<pre><code class=\"language-bash\">/nix/store/ca3wyk5m3qhy8n1nbn0181m29qvp1klp-etc\ndr-xr-xr-x - root 31 Dec  1969 Óóø .\ndrwxrwxr-t - root 16 May 15:13 Óóø ..\nlrwxrwxrwx - root 31 Dec  1969 ÔÄñ bar -&gt; /nix/store/1fsjyc2hmilab1qw6jfkf6cb767kz858-bar\nlrwxrwxrwx - root 31 Dec  1969 ÔÄñ foo -&gt; /nix/store/wai5dycp0zx1lxg0rhpdxnydhiadpk05-foo\n</code></pre>\n<ul>\n<li>\n<p>We can see that <code>foo</code> and <code>bar</code> link to different derivations</p>\n</li>\n<li>\n<p>When trying to figure out which <code>default</code> to use for <code>etcCombined</code> infinisil\nwent to the Nixpkgs Reference Manual. Make sure to go to the correct version.</p>\n<ul>\n<li>\n<p><a href=\"https://nixos.org/manual/nixpkgs/stable/\">24.11pre-git</a></p>\n</li>\n<li>\n<p><a href=\"https://nixos.org/manual/nixpkgs/unstable/\">25.05pre-git</a> (i.e. unstable)</p>\n</li>\n<li>\n<p>Once at the website press <code>Ctrl+f</code> and type <code>symlinkjoin</code> and hit enter.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>Or in your local copy of Nixpkgs you could go to\n<code>nixpkgs/pkgs/build-support/ trivial-builders/default.nix</code>. Then use your\neditors search feature, with nvim and helix you press <code>/symlinkjoin</code> or\n<code>/linkFarm</code> hit enter then press <code>n</code> to cycle to the next match. It will bring\nyou to comments and up to date information.</p>\n<pre><code class=\"language-bash\"># linkFarm \"myexample\" [ { name = \"hello-test\"; path = pkgs.hello; }\n# { name = \"foobar\"; path = pkgs.stack; } ]\n</code></pre>\n</details>\n<h3>Tests</h3>\n<details>\n<summary> Click to Expand Test Example </summary>\n<ul>\n<li>How to create a Derivation with <code>passthru.tests</code> outside of Nixpkgs and then\nrun tests available to your package set?</li>\n</ul>\n<pre><code class=\"language-bash\">mkdir passthru-tests &amp;&amp; cd passthru-tests\n</code></pre>\n<p>Create a <code>default.nix</code> with the following:</p>\n<pre><code class=\"language-nix\"># default.nix\nlet\n  pkgs = import &lt;nixpkgs&gt; {};\n\n  package = pkgs.runCommand \"foo\" {\n    passthru.tests.simple = pkgs.runCommand \"foo-test\" {} ''\n      if [[ \"$(cat ${package})\" != \"foo\" ]]; then\n        echo \"Result is not foo\"\n        exit 1\n      fi\n      touch $out\n  '';\n  } ''\n    echo foo &gt; $out\n  '';\nin\npackage\n</code></pre>\n<p>See if it will build:</p>\n<pre><code class=\"language-bash\">nix-build\n</code></pre>\n<p>Try running the test:</p>\n<pre><code class=\"language-bash\">nix-build -A passthru.tests\n</code></pre>\n<pre><code class=\"language-bash\">this derivation will be built:\n/nix/store/pqpqq9x1wnsabzbsb52z4g4y4zy6p7yx-foo-test.drv\nbuilding '/nix/store/pqpqq9x1wnsabzbsb52z4g4y4zy6p7yx-foo-test.drv'...\n/nix/store/7bbw2ban0mgkh4d59yz3cnai4aavwvb6-foo-test\n</code></pre>\n<h3>Test 2</h3>\n<ul>\n<li><code>passthru.tests</code> is the convention for defining tests associated with a\nderivation. The attributes in <code>passthru</code> are preserved and accessible after\nthe derivation is built.</li>\n</ul>\n<pre><code class=\"language-nix\">let\n  pkgs = import &lt;nixpkgs&gt; {};\n\n  package =\n    pkgs.runCommand \"foo\" {\n      passthru.tests.simple = pkgs.runCommand \"foo-test\" {} ''\n        if [[ \"$(cat ${package})\" != \"foo\" ]]; then\n          echo \"Result is not foo\"\n          exit 1\n        fi\n        touch $out\n      '';\n\n      passthru.tests.version = pkgs.testers.testVersion {\n         package = package;\n         version = \"1.2\";\n     };\n\n      # pkgs.writeShellApplication\n      script = ''\n        #!${pkgs.runtimeShell}\n        echo \"1.2\"\n      '';\n      passAsFiles = [ \"script\" ];\n\n    } ''\n      cp \"$scriptPath\" \"$out\"\n    '';\nin\n  package\n</code></pre>\n<p>Try to build it:</p>\n<pre><code class=\"language-bash\">nix-build -A passthru.tests\n</code></pre>\n<ul>\n<li>\n<p><code>testers.testVersion</code> checks if an executable outputs a specific version\nstring.</p>\n</li>\n<li>\n<p><code>nix-build -A passthru.tests</code> specifically targets the derivations defined\nwithin the tests attribute of the main derivation.</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">these 3 derivations will be built:\n  /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv\n  /nix/store/s4iawjy5zpv89dbkc3zz7z3ngz4jq2cv-foo-test.drv\n  /nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z-foo-test-version.drv\nbuilding '/nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv'...\ncp: cannot stat '': No such file or directory\nerror: builder for '/nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv'\n failed with exit code 1;\n     last 1 log lines:\n     &gt; cp: cannot stat '': No such file or directory\n     For full logs, run:\n       nix log /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv\nerror: 1 dependencies of derivation '/nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z\n-foo-test-version.drv' failed to build\nerror: build of '/nix/store/s4iawjy5zpv89dbkc3zz7z3ngz4jq2cv-foo-test.drv',\n '/nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z-foo-test-version.drv' failed\n</code></pre>\n<p>Run <code>nix-build</code> with no arguments:</p>\n<pre><code class=\"language-bash\">nix-build\n</code></pre>\n<pre><code class=\"language-bash\">nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq '.[].env'\n</code></pre>\n<p><strong>Output</strong>:</p>\n<pre><code class=\"language-json\">{\n  \"__structuredAttrs\": \"\",\n  \"buildCommand\": \"cp \\\"$scriptPath\\\" \\\"$out\\\"\\n\",\n  \"buildInputs\": \"\",\n  \"builder\": \"/nix/store/xg75pc4yyfd5n2fimhb98ps910q5lm5n-bash-5.2p37/bin/bash\",\n  \"cmakeFlags\": \"\",\n  \"configureFlags\": \"\",\n  \"depsBuildBuild\": \"\",\n  \"depsBuildBuildPropagated\": \"\",\n  \"depsBuildTarget\": \"\",\n  \"depsBuildTargetPropagated\": \"\",\n  \"depsHostHost\": \"\",\n  \"depsHostHostPropagated\": \"\",\n  \"depsTargetTarget\": \"\",\n  \"depsTargetTargetPropagated\": \"\",\n  \"doCheck\": \"\",\n  \"doInstallCheck\": \"\",\n  \"enableParallelBuilding\": \"1\",\n  \"enableParallelChecking\": \"1\",\n  \"enableParallelInstalling\": \"1\",\n  \"mesonFlags\": \"\",\n  \"name\": \"foo\",\n  \"nativeBuildInputs\": \"\",\n  \"out\": \"/nix/store/9mcrnddb6lf1md14v4lj6s089i99l5k7-foo\",\n  \"outputs\": \"out\",\n  \"passAsFile\": \"buildCommand\",\n  \"passAsFiles\": \"script\",\n  \"patches\": \"\",\n  \"propagatedBuildInputs\": \"\",\n  \"propagatedNativeBuildInputs\": \"\",\n  \"script\": \"#!/nix/store/xg75pc4yyfd5n2fimhb98ps910q5lm5n-bash-5.2p37/bin/bash\\necho \\\"1.2\\\"\\n\",\n  \"stdenv\": \"/nix/store/lgydi1gl5wqcw6k4gyjbaxx7b40zxrsp-stdenv-linux\",\n  \"strictDeps\": \"\",\n  \"system\": \"x86_64-linux\"\n}\n</code></pre>\n<pre><code class=\"language-bash\">nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq\n '.[].env.buildCommand'\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code class=\"language-bash\">\"cp \\\"$scriptPath\\\" \\\"$out\\\"\\n\"\n</code></pre>\n<ul>\n<li>raw mode below</li>\n</ul>\n<pre><code class=\"language-bash\">nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq\n '.[].env.buildCommand' -r\n</code></pre>\n<p><strong>Output</strong>:</p>\n<pre><code class=\"language-bash\">cp \"$scriptPath\" \"$out\"\n</code></pre>\n<ul>\n<li>It turns out the correct command was <code>passAsFile</code> not <code>passAsFiles</code> but that\nchange wasn‚Äôt enough to fix it. <code>passAsFiles</code> expects a list of files, not a\nsingle file path. Running <code>nix-build -A passthru.tests</code> failed saying\n<code>&gt; foo --version returned a non-zero exit code.</code></li>\n</ul>\n<pre><code class=\"language-nix\">let\n  pkgs = import &lt;nixpkgs&gt; {};\n\n  package =\n    pkgs.runCommand \"foo\" {\n      #passthru.tests.simple = pkgs.runCommand \"foo-test\" {} ''\n      #  if [[ \"$(cat ${package})\" != \"foo\" ]]; then\n      #    echo \"Result is not foo\"\n      #    exit 1\n      #  fi\n      #  touch $out\n      #'';\n\n      passthru.tests.version = pkgs.testers.testVersion {\n        package = package;\n        version = \"1.2\";\n      };\n\n      # pkgs.writeShellApplication\n      script = ''\n        #!${pkgs.runtimeShell}\n        echo \"1.2\"\n      '';\n      passAsFile = [\"script\"];\n    } ''\n      mkdir -p \"$out/bin\"\n      cp \"$scriptPath\" \"$out/bin/foo\"\n      chmod +x \"$out/bin/foo\"\n    '';\nin\n  package\n</code></pre>\n<p>Build it:</p>\n<pre><code class=\"language-bash\">nix-build -A passthru.tests\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code class=\"language-bash\">these 2 derivations will be built:\n  /nix/store/lqrlcd64dmpzkggcfzlnsnwjd339czd3-foo.drv\n  /nix/store/c3kw4xbdlrig08jrdm5wis1dmv2gnqsd-foo-test-version.drv\nbuilding '/nix/store/lqrlcd64dmpzkggcfzlnsnwjd339czd3-foo.drv'...\nbuilding '/nix/store/c3kw4xbdlrig08jrdm5wis1dmv2gnqsd-foo-test-version.drv'...\n1.2\n/nix/store/zsbk5zawak68ailvkwi2gad2bqbqmdz9-foo-test-version\n</code></pre>\n</details>\n<h3>Key Takeaways for Debugging NixOS Modules</h3>\n<ul>\n<li>\n<p><strong><code>nix-instantiate</code> is Your Friend:</strong> Use <code>nix-instantiate</code> to evaluate your\nNixOS modules and pinpoint errors.</p>\n</li>\n<li>\n<p><strong>Unlock Details with <code>--show-trace</code>:</strong> When errors occur, always append\n<code>--show-trace</code> to get a comprehensive stack trace, revealing the origin of the\nproblem. Remember that in newer Nix versions, the most relevant parts of the\ntrace are often at the bottom.</p>\n</li>\n<li>\n<p><strong>Understand Option Types:</strong> Nix option types (<code>raw</code>, <code>anything</code>,\n<code>string</code>/<code>str</code>, <code>lines</code>, <code>attrsOf</code>) are not just about data types; they also\ndictate how values are merged and processed within the module system.</p>\n</li>\n<li>\n<p><strong>Be Mindful of <code>mkOptionDefault</code>:</strong> While useful in specific scenarios,\n<code>mkOptionDefault</code> sets a lower priority default. For standard defaults that\ncan be overridden by user configuration, define them directly within the\n<code>config</code> attribute using <code>lib.mkDefault</code>.</p>\n</li>\n<li>\n<p><strong>Use <code>builtins.addErrorContext</code>:</strong> Enhance your custom error messages by\nproviding specific context relevant to your module‚Äôs logic using\n<code>builtins.addErrorContext</code>.</p>\n</li>\n<li>\n<p><strong>Derivations vs. Evaluation:</strong> Be aware of the difference between evaluating\nexpressions (<code>--eval --strict</code>) and instantiating derivations\n(<code>nix-instantiate</code>). Strict evaluation can trigger infinite recursion if it\nencounters unevaluated derivations with cyclic dependencies during attribute\naccess.</p>\n</li>\n<li>\n<p><strong>Explore with <code>nix repl</code>:</strong> The <code>nix repl</code> allows you to interactively\nexplore Nix expressions and the outputs of derivations, providing insights\ninto the structure and values within Nixpkgs.</p>\n</li>\n</ul>\n<h4>Conclusion</h4>\n<p>This chapter has equipped you with essential techniques for debugging and\ntracing NixOS modules. We‚Äôve explored how to use <code>nix-instantiate</code> and\n<code>--show-trace</code> to pinpoint errors, how to interpret Nix‚Äôs often-verbose error\nmessages, and how to leverage the <code>nix repl</code> for interactive exploration.\nUnderstanding option types and the nuances of <code>mkOptionDefault</code> is crucial for\nwriting robust and predictable modules. We‚Äôve also touched upon the distinction\nbetween evaluation and instantiation, and how that impacts debugging.</p>\n<p>While these tools and techniques are invaluable for understanding and\ntroubleshooting your own Nix configurations, they also become essential when you\nwant to contribute to or modify the vast collection of packages and modules\nwithin <strong>Nixpkgs</strong> itself. Nixpkgs is where the majority of Nix packages and\nNixOS modules reside, and learning how to navigate and contribute to it opens up\na whole new level of control and customization within the Nix ecosystem.</p>\n<p>In the next chapter,\n<a href=\"https://saylesss88.github.io/Working_with_Nixpkgs_Locally_10.html\">Working with Nixpkgs Locally</a>,\nwe‚Äôll shift our focus to exploring and modifying Nixpkgs. We‚Äôll cover how to\nclone Nixpkgs, how to make changes to package definitions, and how to test those\nchanges locally before contributing them back upstream. This chapter will\nempower you to not just use existing Nix packages, but also to customize and\nextend them to fit your specific needs.</p>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/Comparing_Flakes_and_Traditional_Nix.html",
      "url": "https://saylesss88.github.io/Comparing_Flakes_and_Traditional_Nix.html",
      "title": "Comparing Flakes and Traditional Nix",
      "content_html": "<h1>Flakes vs. Traditional Nix</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<!-- ![nixWinter](images/nixWinter.png) -->\n<h2>Comparing Flakes and Traditional Nix</h2>\n<ul>\n<li>This post is based on notes from Nix-Hour #4, comparing Traditional Nix and\nFlakes, focusing on achieving pure build results. See the\n<a href=\"https://www.youtube.com/watch?v=atmoYyBAhF4\">YouTube video</a> for the original\ncontent. This guide adapts the information for clarity and ease of\nunderstanding.</li>\n</ul>\n<details>\n<summary> What is Purity in Nix? (click here) </summary>\n<ul>\n<li>\n<p>A key benefit of Nix Flakes is their <em>default</em> enforcement of <strong>pure\nevaluation</strong>.</p>\n</li>\n<li>\n<p>In Nix, an <strong>impure operation</strong> depends on something <em>outside</em> its explicit\ninputs. Examples include:</p>\n<ul>\n<li>User‚Äôs system configuration</li>\n<li>Environment variables</li>\n<li>Current time</li>\n</ul>\n</li>\n<li>\n<p>Impurity leads to unpredictable builds that may differ across systems or time.</p>\n</li>\n</ul>\n</details>\n<h2>Building a Simple ‚Äúhello‚Äù Package: Flakes vs. Traditional Nix</h2>\n<ul>\n<li>We‚Äôll demonstrate building a basic ‚Äúhello‚Äù package using both Flakes and\nTraditional Nix to highlight the differences in handling purity.</li>\n</ul>\n<h2>Using Nix Flakes</h2>\n<details>\n<summary> Building Hello with Flakes (click here) </summary>\n<ol>\n<li>\n<p><strong>Setup:</strong></p>\n<pre><code class=\"language-bash\">mkdir hello &amp;&amp; cd hello/\n</code></pre>\n</li>\n<li>\n<p><strong>Create <code>flake.nix</code> (Initial Impure Example):</strong></p>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  outputs = { self, nixpkgs }: {\n    myHello = (import nixpkgs {}).hello;\n  };\n}\n</code></pre>\n<ul>\n<li>Note: Flakes don‚Äôt have access to <code>builtins.currentSystem</code> directly.</li>\n</ul>\n</li>\n<li>\n<p><strong>Impure Build (Fails):</strong></p>\n<pre><code class=\"language-bash\">nix build .#myHello\n</code></pre>\n<ul>\n<li>This fails because Flakes enforce purity by default.</li>\n</ul>\n</li>\n<li>\n<p><strong>Force Impure Build:</strong></p>\n<pre><code class=\"language-bash\">nix build .#myHello --impure\n</code></pre>\n</li>\n<li>\n<p><strong>Making the Flake Pure:</strong></p>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs\";\n    flake-utils.url = \"github:numtide/flake-utils\";\n  };\n\n  outputs = { self, nixpkgs, flake-utils }:\n    flake-utils.lib.eachDefaultSystem (system:\n      let\n        pkgs = nixpkgs.legacyPackages.${system};\n      in {\n        packages.myHello = pkgs.hello;\n      }\n    );\n}\n</code></pre>\n<ul>\n<li><code>flake-utils</code> simplifies making flakes system-agnostic and provides the\n<code>system</code> attribute.</li>\n</ul>\n</li>\n<li>\n<p><strong>Pure Build (Success):</strong></p>\n<pre><code class=\"language-bash\">nix build .#myHello\n</code></pre>\n</li>\n</ol>\n  </details>\n<h2>Using Traditional Nix</h2>\n<details>\n<summary> Building hello with Traditional Nix </summary>\n<ol>\n<li>\n<p><strong>Setup:</strong></p>\n<pre><code class=\"language-bash\">mkdir hello2 &amp;&amp; cd hello2/\n</code></pre>\n</li>\n<li>\n<p><strong>Create <code>default.nix</code> (Initial Impure Example):</strong></p>\n<pre><code class=\"language-nix\"># default.nix\n{ myHello = (import &lt;nixpkgs&gt; { }).hello; }\n</code></pre>\n</li>\n<li>\n<p><strong>Build (Impure):</strong></p>\n<pre><code class=\"language-bash\">nix-build -A myHello\n</code></pre>\n</li>\n<li>\n<p><strong>Impurity Explained:</strong></p>\n<pre><code class=\"language-bash\">nix repl\nnix-repl&gt; &lt;nixpkgs&gt;\n/nix/var/nix/profiles/per-user/root/channels/nixos\n</code></pre>\n<ul>\n<li><code>&lt;nixpkgs&gt;</code> depends on the user‚Äôs environment (Nixpkgs channel), making it\nimpure. Even with channels disabled, it relies on a specific Nixpkgs\nversion in the store.</li>\n</ul>\n</li>\n<li>\n<p><strong>Achieving Purity: Using <code>fetchTarball</code></strong></p>\n<ul>\n<li>\n<p>GitHub allows downloading repository snapshots at specific commits,\ncrucial for reproducibility.</p>\n</li>\n<li>\n<p><strong>Get Nixpkgs Revision from <code>flake.lock</code> (from the Flake example):</strong></p>\n</li>\n</ul>\n<pre><code class=\"language-nix\"># flake.lock\n\"nixpkgs\": {\n  \"locked\": {\n    \"lastModified\": 1746372124,\n    \"narHash\": \"sha256-n7W8Y6bL7mgHYW1vkXKi9zi/sV4UZqcBovICQu0rdNU=\",\n    \"owner\": \"NixOS\",\n    \"repo\": \"nixpkgs\",\n    \"rev\": \"f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0\",\n    \"type\": \"github\"\n  },\n</code></pre>\n</li>\n<li>\n<p><strong>Modify <code>default.nix</code> for Purity:</strong></p>\n<pre><code class=\"language-nix\"># default.nix\nlet\n  nixpkgs = fetchTarball {\n    url = \"[https://github.com/NixOS/nixpkgs/archive/f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0.tar.gz](https://github.com/NixOS/nixpkgs/archive/f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0.tar.gz)\";\n    sha256 = \"0000000000000000000000000000000000000000000000000000\"; # Placeholder\n  };\nin {\n  myHello = (import nixpkgs {}).hello;\n}\n</code></pre>\n<ul>\n<li>Replace <code>&lt;nixpkgs&gt;</code> with <code>fetchTarball</code> and a specific revision. A\nplaceholder <code>sha256</code> is used initially.</li>\n</ul>\n</li>\n<li>\n<p><strong>Build (Nix provides the correct <code>sha256</code>):</strong></p>\n<pre><code class=\"language-bash\">nix-build -A myHello\n</code></pre>\n</li>\n<li>\n<p><strong>Verification:</strong> Both Flake and Traditional Nix builds now produce the same\noutput path.</p>\n</li>\n<li>\n<p><strong>Remaining Impurities in Traditional Nix:</strong></p>\n<ul>\n<li>Default arguments to <code>import &lt;nixpkgs&gt; {}</code> can introduce impurity:\n<ul>\n<li><code>overlays</code>: <code>~/.config/nixpkgs/overlays</code> (user-specific)</li>\n<li><code>config</code>: <code>~/.config/nixpkgs/config.nix</code> (user-specific)</li>\n<li><code>system</code>: <code>builtins.currentSystem</code> (machine-specific)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Making Traditional Nix Fully Pure:</strong></p>\n<pre><code class=\"language-nix\"># default.nix\n{system ? builtins.currentSystem}:\nlet\n  nixpkgs = fetchTarball {\n    url =\n      \"[https://github.com/NixOS/nixpkgs/archive/0243fb86a6f43e506b24b4c0533bd0b0de211c19.tar.gz](https://github.com/NixOS/nixpkgs/archive/0243fb86a6f43e506b24b4c0533bd0b0de211c19.tar.gz)\";\n    sha256 = \"1qvdbvdza7hsqhra0yg7xs252pr1q70nyrsdj6570qv66vq0fjnh\";\n  };\nin {\n  myHello = (import nixpkgs {\n    overlays = [];\n    config = {};\n    inherit system;\n  }).hello;\n}\n</code></pre>\n<ul>\n<li>Override impure defaults for <code>overlays</code>, <code>config</code>, and make <code>system</code> an\nargument.</li>\n</ul>\n</li>\n<li>\n<p><strong>Building with a Specific System:</strong></p>\n<pre><code class=\"language-bash\">nix-build -A myHello --argstr system x86_64-linux\n</code></pre>\n</li>\n<li>\n<p><strong>Pure Evaluation Mode in Traditional Nix:</strong></p>\n<pre><code class=\"language-bash\">nix-instantiate --eval --pure-eval --expr 'fetchGit { url = ./.; rev = \"b4fe677e255c6f89c9a6fdd3ddd9319b0982b1ad\"; }'\n</code></pre>\n<ul>\n<li>Example of using <code>--pure-eval</code>.</li>\n</ul>\n<pre><code class=\"language-bash\">nix-build --pure-eval --expr '(import (fetchGit { url = ./.; rev = \"b4fe677e255c6f89c9a6fdd3ddd9319b0982b1ad\"; }) { system = \"x86_64-linux\"; }).myHello'\n</code></pre>\n<ul>\n<li>Building with a specific revision and system.</li>\n</ul>\n</li>\n</ol>\n  </details>\n<h3>Updating Nixpkgs</h3>\n<details>\n<summary> Updating Nixpkgs with Flakes </summary>\n<pre><code class=\"language-bash\">nix flake update\n</code></pre>\n<pre><code class=\"language-nix\">nix build .#myHello --override-input nixpkgs github:NixOS/nixpkgs/nixos-24.11\n</code></pre>\n</details>\n<h3>Updating Traditional Nix (using <code>niv</code>)</h3>\n<details>\n<summary> Updating with niv </summary>\n<pre><code class=\"language-nix\">nix-shell -p niv\nniv init\n</code></pre>\n<pre><code class=\"language-nix\"># default.nix\n{ system ? builtins.currentSystem,\n  sources ? import nix/sources.nix,\n  nixpkgs ? sources.nixpkgs,\n  pkgs ? import nixpkgs {\n    overlays = [ ];\n    config = { };\n    inherit system;\n  }, }: {\n  myHello = pkgs.hello;\n}\n</code></pre>\n<p>And build it with:</p>\n<pre><code class=\"language-bash\">nix-build -A myHello\n</code></pre>\n<pre><code class=\"language-bash\">niv update nixpkgs --branch=nixos-unstable\nnix-build -A myHello\n</code></pre>\n</details>\n<details>\n<summary> Adding Home-Manager with Flakes (click here) </summary>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs\";\n    flake-utils.url = \"github:numtide/flake-utils\";\n    home-manager.url = \"github:nix-community/home-manager\";\n  };\n\n  outputs = { self, nixpkgs, flake-utils, home-manager, ... }:\n    flake-utils.lib.eachDefaultSystem (system:\n      let pkgs = nixpkgs.legacyPackages.${system};\n      in {\n        packages.myHello = pkgs.hello;\n        packages.x86_64-linux.homeManagerDocs =\n          home-manager.packages.x86_64-linux.docs-html;\n      });\n}\n</code></pre>\n<pre><code class=\"language-bash\">nix flake update\nnix flake show github:nix-community/home-manager\n</code></pre>\n<pre><code class=\"language-nix\">home-manager.inputs.follows = \"nixpkgs\";\n</code></pre>\n</details>\n<h4>Adding Home-Manager with Traditional Nix</h4>\n<details>\n<summary> Adding Home-Manager with Traditional Nix (click here) </summary>\n```nix\nniv add nix-community/home-manager\n```\n<pre><code class=\"language-nix\">nix repl\nnix-repl&gt; s = import ./nix/sources.nix\nnix-repl&gt; s.home-manager\n</code></pre>\n<pre><code class=\"language-nix\">{ system ? builtins.currentSystem, sources ? import nix/sources.nix\n  , nixpkgs ? sources.nixpkgs, pkgs ? import nixpkgs {\n    overlays = [ ];\n    config = { };\n    inherit system;\n  }, }: {\n  homeManagerDocs = (import sources.home-manager { pkgs = pkgs; }).docs;\n\n  myHello = pkgs.hello;\n}\n</code></pre>\n<pre><code class=\"language-bash\">nix-build -A homeManagerDocs\n</code></pre>\n</details>\n<h4>Conclusion</h4>\n<p>In this chapter, we‚Äôve explored the key differences between traditional Nix and\nNix Flakes, particularly focusing on how each approach handles purity,\ndependency management, and project structure. We‚Äôve seen that while traditional\nNix can achieve purity with careful configuration, Flakes enforce it by default,\noffering a more robust and standardized way to build reproducible environments.\nFlakes also streamline dependency management and provide a more structured\nproject layout compared to the often ad-hoc nature of traditional Nix projects.</p>\n<p>However, regardless of whether you‚Äôre working with Flakes or traditional Nix,\nunderstanding how to debug and trace issues within your Nix code is crucial.\nWhen things go wrong, you‚Äôll need tools and techniques to inspect the evaluation\nprocess, identify the source of errors, and understand how your modules and\nderivations are being constructed.</p>\n<p>In our next chapter,\n<a href=\"https://saylesss88.github.io/Debugging_and_Tracing_NixOS_Modules_9.html\">Debugging and Tracing Modules</a>,\nwe will delve into the world of Nix debugging. We‚Äôll explore various techniques\nand tools that can help you understand the evaluation process, inspect the\nvalues of expressions, and trace the execution of your Nix code, enabling you to\neffectively troubleshoot and resolve issues in both Flake-based and traditional\nNix projects.</p>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/functions/practical_functions.html",
      "url": "https://saylesss88.github.io/functions/practical_functions.html",
      "title": "Practical Nix Functions",
      "content_html": "<h1>Practical Nix Functions</h1>\n<details>\n<summary>\n‚úîÔ∏è\nIf you want to follow along with this example you'll have to place the following\nin your project directory. Section is collapsed to focus on functions:\n</summary>\n<p><img src=\"images/coding6.png\" alt=\"coding6\" /></p>\n<ol>\n<li>\n<p><a href=\"https://gitlab.com/api/v4/projects/4207231/packages/generic/graphviz-releases/2.49.3/graphviz-2.49.3.tar.gz\">graphviz</a></p>\n</li>\n<li>\n<p><a href=\"https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz\">hello</a></p>\n</li>\n<li>\n<p><code>autotools.nix</code>:</p>\n</li>\n</ol>\n<pre><code class=\"language-nix\"># autotools.nix\npkgs: attrs:\nwith pkgs; let\n  defaultAttrs = {\n    builder = \"${bash}/bin/bash\";\n    args = [./builder.sh];\n    setup = ./setup.sh;\n    baseInputs = [gnutar gzip gnumake gcc binutils-unwrapped coreutils gawk gnused gnugrep patchelf findutils];\n    buildInputs = [];\n    system = builtins.currentSystem;\n  };\nin\n  derivation (defaultAttrs // attrs)\n</code></pre>\n<ol start=\"4\">\n<li><code>setup.sh</code>:</li>\n</ol>\n<pre><code class=\"language-bash\"># setup.sh (This is a library of functions setting up the environment, not directly executable)\nunset PATH\nfor p in $baseInputs $buildInputs; do\n  if [ -d $p/bin ]; then\n    export PATH=\"$p/bin${PATH:+:}$PATH\"\n  fi\n  if [ -d $p/lib/pkgconfig ]; then\n    export PKG_CONFIG_PATH=\"$p/lib/pkgconfig${PKG_CONFIG_PATH:+:}$PKG_CONFIG_PATH\"\n  fi\ndone\n\nfunction unpackPhase() {\n  tar -xzf $src\n\n  for d in *; do\n    if [ -d \"$d\" ]; then\n      cd \"$d\"\n      break\n    fi\n  done\n}\n\nfunction configurePhase() {\n  ./configure --prefix=$out\n}\n\nfunction buildPhase() {\n  make\n}\n\nfunction installPhase() {\n  make install\n}\n\nfunction fixupPhase() {\n  find $out -type f -exec patchelf --shrink-rpath '{}' \\; -exec strip '{}' \\; 2&gt;/dev/null\n}\n\nfunction genericBuild() {\n  unpackPhase\n  configurePhase\n  buildPhase\n  installPhase\n  fixupPhase\n}\n</code></pre>\n<ol start=\"5\">\n<li>And finally <code>builder.sh</code>:</li>\n</ol>\n<pre><code class=\"language-bash\"># builder.sh (This is the actual builder script specified in the derivation and\n# what `nix-build` expects)\nset -e\nsource $setup\ngenericBuild\n</code></pre>\n</details>\n<p>This is another example from the Nix-Pill series shown in another way to show\nsome powerful aspects of functions.</p>\n<p>If you have a <code>default.nix</code> like this:</p>\n<pre><code class=\"language-nix\"># default.nix\n{\n  hello = import ./hello.nix;\n  graphviz = import ./graphviz.nix;\n}\n</code></pre>\n<p>It expects the files that it imports to look like this:</p>\n<pre><code class=\"language-nix\"># graphviz.nix\nlet\n  pkgs = import &lt;nixpkgs&gt; { };\n  mkDerivation = import ./autotools.nix pkgs;\nin\nmkDerivation {\n  name = \"graphviz\";\n  src = ./graphviz-2.49.3.tar.gz;\n}\n</code></pre>\n<p>And <code>hello.nix</code>:</p>\n<pre><code class=\"language-nix\"># hello.nix\nlet\n  pkgs = import &lt;nixpkgs&gt; { };\n  mkDerivation = import ./autotools.nix pkgs;\nin\nmkDerivation {\n  name = \"hello\";\n  src = ./hello-2.12.1.tar.gz;\n}\n</code></pre>\n<p>You would build these with:</p>\n<pre><code class=\"language-bash\">nix-build -A hello\nnix-build -A graphviz\n</code></pre>\n<p>As you can see both derivations are dependendent on <code>nixpkgs</code> which they\n<strong>both</strong> import directly. To centralize our dependencies and avoid redundant\nimports, we‚Äôll refactor our individual package definitions (<code>hello.nix</code>,\n<code>graphviz.nix</code>) into functions. Our <code>default.nix</code> will then be responsible for\nsetting up the common inputs (like <code>pkgs</code> and <code>mkDerivation</code>) and passing them\nas arguments when it imports and calls these package functions.</p>\n<p>Here is what our <code>default.nix</code> will look like:</p>\n<pre><code class=\"language-nix\">let\n  pkgs = import &lt;nixpkgs&gt; { };\n  mkDerivation = import ./autotools.nix pkgs;\nin\nwith pkgs;\n{\n  hello = import ./hello.nix { inherit mkDerivation; };\n  graphviz = import ./graphviz.nix {\n    inherit\n      mkDerivation\n      lib\n      gd\n      pkg-config\n      ;\n  };\n  graphvizCore = import ./graphviz.nix {\n    inherit\n      mkDerivation\n      lib\n      gd\n      pkg-config\n      ;\n    gdSupport = false;\n  };\n}\n</code></pre>\n<p>We define some local variables in the <code>let</code> expression and pass them around.</p>\n<p>The whole expression in the above <code>default.nix</code> returns an attribute set with\nthe keys <code>hello</code>, <code>graphviz</code>, and <code>graphvizCore</code></p>\n<p>We import <code>hello.nix</code> and <code>graphviz.nix</code>, which both return a function. We call\nthe functions, passing them a set of inputs with the <code>inherit</code> construct.</p>\n<p>Let‚Äôs change <code>hello.nix</code> into a function to match what the <code>default.nix</code> now\nexpects.</p>\n<pre><code class=\"language-nix\"># hello.nix\n{mkDerivation}:\nmkDerivation {\n  name = \"hello\";\n  src = ./hello-2.12.1.tar.gz;\n}\n</code></pre>\n<p>Now our <code>graphviz</code> attribute expects <code>graphviz.nix</code> to be a function that takes\nthe arguments listed in the above <code>default.nix</code>, here‚Äôs what <code>graphviz.nix</code> will\nlook like as a function:</p>\n<pre><code class=\"language-nix\"># graphviz.nix\n{\n  mkDerivation,\n  lib,\n  gdSupport ? true,\n  gd,\n  pkg-config,\n}:\nmkDerivation {\n  name = \"graphviz\";\n  src = ./graphviz-2.49.3.tar.gz;\n  buildInputs =\n    if gdSupport\n    then [\n      pkg-config\n      (lib.getLib gd)\n      (lib.getDev gd)\n    ]\n    else [];\n}\n</code></pre>\n<p>We factorized the import of <code>nixpkgs</code> and <code>mkDerivation</code>, and also added a\nvariant of <code>graphviz</code> with gd support disabled. The result is that both\n<code>hello.nix</code> and <code>graphviz.nix</code> are independent of the repository and\ncustomizable by passing specific inputs.</p>\n<p>Now, we can build the package with <code>gd</code> support disabled with the <code>graphvizCore</code>\nattribute:</p>\n<pre><code class=\"language-bash\">nix-build -A graphvizCore\n# or we can still build the package that now defaults to gd support\nnix-build -A graphviz\n</code></pre>\n<p>This example showed us how to turn expressions into functions. We saw how\nfunctions are passed around and shared between Nix expressions and derivations.</p>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/flakes/specialisations.html",
      "url": "https://saylesss88.github.io/flakes/specialisations.html",
      "title": "Multiple Profiles (Specialisations)",
      "content_html": "<h1>NixOS Specialisations For Multiple Profiles</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><strong>NixOS specialisations</strong> are a powerful feature that allow you to define\nalternative system configurations variations within a single NixOS setup. Each\nspecialisation can modify or extend the base configuration, and NixOS will\ngenerate separate boot entries for each, letting you choose at boot time (or\nswitch at runtime) which environment to use. This is ideal for testing,\nhardware-specific tweaks, or separating work and personal environments without\nmaintaining multiple configuration files</p>\n<h2>How Specialisations Work</h2>\n<p>Specialisations are defined as attributes under the <code>specialisation</code> option in\nyour configuration. Each key (e.g., <code>niri-test</code>) represents a named\nspecialisation, and its configuration attribute contains the NixOS options to\napply on top of the base system</p>\n<p>By default, a specialisation inherits the parent configuration and applies its\nchanges on top. You can also set <code>inheritParentConfig = false;</code> to create a\ncompletely separate configuration.</p>\n<p>After running <code>nixos-rebuild boot</code>, your bootloader will present extra entries\nfor each specialisation. Selecting one boots into the system with that\nspecialisation‚Äôs settings applied</p>\n<p>Runtime Switching: You can switch to a specialisation at runtime using\nactivation scripts, e.g.:</p>\n<pre><code class=\"language-bash\">nixos-rebuild switch --specialisation niri-test\n</code></pre>\n<p>or</p>\n<pre><code class=\"language-bash\">/run/current-system/specialisation/niri-test/bin/switch-to-configuration switch\n</code></pre>\n<blockquote>\n<p>Note: Some changes (like kernel switches) require a reboot to take effect</p>\n</blockquote>\n<p>Example: Let‚Äôs create a basic specialisation to try out the Niri Window Manager:</p>\n<p>First we have to add the <code>niri-flake</code> as an input to our <code>flake.nix</code> and add the\nmodule to install it:</p>\n<pre><code class=\"language-nix\"># flake.nix\ninputs = {\n     niri.url = \"github:sodiboo/niri-flake\";\n};\n</code></pre>\n<pre><code class=\"language-nix\"># configuration.nix\n{ pkgs, inputs, ... }: {\n# ... snip ...\nimports = [\n    inputs.niri.nixosModules.niri\n];\n\n# This is the top-level overlay\n  nixpkgs.overlays = [inputs.niri.overlays.niri];\n\n# ... snip ...\n\n  specialisation = {\n    niri-test.configuration = {\n      system.nixos.tags = [\"niri\"];\n\n      # Add the Niri overlay for this specialisation\n      nixpkgs.overlays = [inputs.niri.overlays.niri];\n\n      # Enable Niri session\n      programs.niri = {\n        enable = true;\n        package = pkgs.niri-unstable;\n      };\n\n      # Optionally, add a test user and greetd for login\n      users.users.niri = {\n        isNormalUser = true;\n        extraGroups = [\"networkmanager\" \"video\" \"wheel\"];\n        initialPassword = \"test\"; # for testing only!\n        createHome = true;\n      };\n\n      services.greetd = {\n        enable = true;\n        settings = rec {\n          initial_session = {\n            command = lib.mkForce \"${pkgs.niri}/bin/niri\";\n            user = lib.mkForce \"niri\";\n          };\n          default_session = initial_session;\n        };\n      };\n\n      environment.etc.\"niri/config.kdl\".text = ''\n        binds {\n          Mod+T { spawn \"alacritty\"; }\n          Mod+D { spawn \"fuzzel\"; }\n          Mod+Q { close-window; }\n          Mod+Shift+Q { exit; }\n        }\n      '';\n      environment.systemPackages = with pkgs; [\n        alacritty\n        waybar\n        fuzzel\n        mako\n        firefox\n      ];\n\n      programs.firefox.enable = true;\n\n      services.pipewire = {\n        enable = true;\n        alsa.enable = true;\n        pulse.enable = true;\n        # Optionally:\n        jack.enable = true;\n      };\n\n      hardware.alsa.enablePersistence = true;\n\n      networking.networkmanager.enable = true;\n    };\n  };\n}\n</code></pre>\n<p>I chose to use the nightly version so it was required to add the overlay at the\ntop-level as well as inside the <code>specialisation</code> block.</p>\n<p>On my system it sped up build times to first run:</p>\n<pre><code class=\"language-bash\">sudo nixos-rebuild switch --flake .\n# And Then Run\nsudo nixos-rebuild boot --flake .\n</code></pre>\n<p><strong>What this does</strong>:</p>\n<ul>\n<li>\n<p>Creates a boot entry called <code>niri-test</code> with the Niri Wayland compositor, a\ntest user, and a <code>greetd</code> login manager.</p>\n</li>\n<li>\n<p>Installs a set of packages and enables PipeWire with ALSA, PulseAudio, and\nJACK support.</p>\n</li>\n<li>\n<p>Provides a custom Niri configuration file for a few keybinds and enables\nNetworkManager.</p>\n</li>\n</ul>\n<h2>Using Your Specialisation After Boot</h2>\n<p>Once you have rebooted and selected your specialisation from the boot menu, you\ncan use your system as usual. If you want to add or remove programs, change\nsettings, or update your environment within a specialisation, simply:</p>\n<ol>\n<li>\n<p>Edit your configuration: Add or remove packages (e.g., add <code>ghostty</code> to\n<code>environment.systemPackages</code>) or change any other options inside the\nrelevant <code>specialisation</code> block in your NixOS configuration.</p>\n</li>\n<li>\n<p>Apply changes with a rebuild: Run the standard NixOS rebuild command. If you\nare currently running the specialisation you want to update, use:</p>\n</li>\n</ol>\n<pre><code class=\"language-bash\">sudo nixos-rebuild switch\n</code></pre>\n<p>This will apply your changes to the current specialisation</p>\n<p>If you want to build and activate a different specialisation from your current\nsession, use:</p>\n<pre><code class=\"language-bash\">sudo nixos-rebuild switch --specialisation name\n</code></pre>\n<p>Or, you can activate a specialisation directly with:</p>\n<pre><code class=\"language-bash\">sudo /run/current-system/specialisation/&lt;name&gt;/bin/switch-to-configuration switch\n</code></pre>\n<p>Replace <code>&lt;name&gt;</code> with your specialisation‚Äôs name.</p>\n<p>Reboot if needed: Most changes apply immediately, but some (like kernel or\n<code>initrd</code> changes) require a reboot for the specialisation to fully take effect</p>\n<p><strong>Tip</strong>:</p>\n<p>Each specialisation can have its own set of installed programs. Only those\nlisted in the <code>environment.systemPackages</code> (or enabled via modules) inside the\n<code>specialisation</code> block will be available when you boot into that context.</p>\n<p>You manage and update your specialisation just like your main NixOS system no\nspecial commands or workflow are required beyond specifying the specialisation\nwhen rebuilding or switching.</p>\n<h2>Use Cases for Specialisations</h2>\n<ul>\n<li>\n<p><strong>Hardware Profiles</strong>: Enable/disable drivers or services for specific\nhardware (e.g., eGPU, WiFi, or SR-IOV setups)</p>\n</li>\n<li>\n<p><strong>Desktop Environments</strong>: Quickly switch between different desktop\nenvironments or compositors (e.g., GNOME, Plasma, Niri)</p>\n</li>\n<li>\n<p><strong>Testing</strong>: Safely try out unstable packages, new kernels, or experimental\nfeatures without risking your main environment</p>\n</li>\n<li>\n<p><strong>User Separation</strong>: Create profiles for different users, each with their own\nsettings, packages, and auto-login</p>\n</li>\n<li>\n<p><strong>Secure Environments</strong>: Combine with encrypted partitions for more secure,\nisolated setups</p>\n</li>\n</ul>\n<h2>Securely Separated Contexts with NixOS Specialisations</h2>\n<p>I will just explain the concept here for completeness, if you want to implement\nthis I recommend following:</p>\n<p><a href=\"https://www.tweag.io/blog/2022-11-01-hard-user-separation-with-nixos/\">Tweag Hard User Separation with NixOS</a></p>\n<details>\n<summary> ‚úîÔ∏è Click To Expand Section on Separate Contexts </summary>\n<p>If you use the same computer in different contexts such as for work and for your\nprivate life you may worry about the risks of mixing sensitive environments. For\nexample, a cryptolocker received through a compromised work email could\npotentially encrypt your personal files, including irreplaceable family photos.</p>\n<p>A common solution is to install two different operating systems and dual-boot\nbetween them, keeping work and personal data isolated. However, this approach\nmeans you have two systems to maintain, update, and configure, which can be a\nsignificant hassle.</p>\n<p>NixOS offers a third alternative: With NixOS specialisations, you can manage two\n(or more) securely separated contexts within a single operating system. At boot\ntime, you select which context you want to use work or personal. Each context\ncan have its own encrypted root partition, user accounts, and configuration, but\nboth share the same Nix store for packages. This means:</p>\n<ul>\n<li>\n<p>No duplicated packages: Both contexts use the same system-wide package store,\nsaving space and simplifying updates.</p>\n</li>\n<li>\n<p>Single system to maintain: You update and manage only one NixOS installation,\nnot two.</p>\n</li>\n<li>\n<p>Strong security boundaries: Each context can have its own encrypted root, so a\ncompromise in one context (such as malware in your work environment) cannot\naccess the data in the other context.</p>\n</li>\n<li>\n<p>Flexible management: You can configure both contexts from either environment,\nmaking administration easier.</p>\n</li>\n</ul>\n<p>This approach combines the security of dual-booting with the convenience and\nefficiency of a single, unified system.</p>\n<p><strong>How It Works</strong>:</p>\n<ul>\n<li>\n<p>Encrypted Partitions: Each context (work and personal) has its own encrypted\nroot partition. The shared /nix/store partition is also encrypted, but can be\nunlocked by either context.</p>\n</li>\n<li>\n<p>Specialisations at Boot: NixOS generates multiple boot entries, one for each\ncontext. You simply choose your desired environment at boot time.</p>\n</li>\n<li>\n<p>Separation of Data: Your work and personal home directories, settings, and\ndocuments remain isolated from each other, while still benefiting from shared\nsystem packages.</p>\n</li>\n</ul>\n<p>Benefits Over Traditional Dual-Boot</p>\n<ul>\n<li>\n<p>Only one system to update and configure.</p>\n</li>\n<li>\n<p>No wasted disk space on duplicate packages.</p>\n</li>\n<li>\n<p>Seamless switching between contexts with a reboot.</p>\n</li>\n<li>\n<p>Consistent NixOS tooling and workflows in both environments.</p>\n</li>\n</ul>\n<p>What You Need</p>\n<ul>\n<li>\n<p>A physical or virtual machine supported by NixOS.</p>\n</li>\n<li>\n<p>Willingness to erase the system disk during setup.</p>\n</li>\n<li>\n<p>LVM (Logical Volume Manager) support: This setup requires using LVM for disk\npartitioning and management. LVM allows you to create multiple logical volumes\non a single physical disk, making it possible to securely separate your work\nand personal environments while sharing a common Nix store. You will use LVM\ncommands such as <code>pvcreate</code>, <code>vgcreate</code>, and <code>lvcreate</code> to prepare your disk\nlayout</p>\n</li>\n</ul>\n<p>In summary: With NixOS specialisations and careful disk partitioning, you can\nachieve secure, convenient, and efficient context separation‚Äîno need to\ncompromise between security and manageability.</p>\n</details>\n<h3>Tips and Best Practices</h3>\n<ul>\n<li>\n<p>Overriding Values: Use <code>lib.mkDefault</code> or <code>lib.mkForce</code> to make options\noverridable or forced in specialisations. I had to do it above because I have\ngreetd setup for my main configuration as well.</p>\n</li>\n<li>\n<p>Selective Configuration: If you want certain options only in the default\n(non-specialised) system, use:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">config = lib.mkIf (config.specialisation != {}) { ... }\n</code></pre>\n<ul>\n<li>\n<p>This condition checks if you‚Äôre in a specialisation.</p>\n</li>\n<li>\n<p>Any settings inside this block will <strong>not</strong> be inherited by specialisations,\nkeeping them exclusive to the main system.</p>\n</li>\n<li>\n<p>Runtime Limitations: Not all changes (e.g., kernel or <code>initrd</code>) can be fully\napplied at runtime; a reboot is required for those.</p>\n</li>\n<li>\n<p>Modularity: Specialisations work well with modular NixOS configs keep\nhardware, user, and service configs in separate files for easier management</p>\n</li>\n</ul>\n<p>References to Official Documentation and Community Resources</p>\n<ul>\n<li>\n<p><a href=\"https://www.tweag.io/blog/2022-08-18-nixos-specialisations/\">Tweag: Introduction to NixOS specialisations</a></p>\n</li>\n<li>\n<p><a href=\"https://wiki.nixos.org/wiki/Specialisation\">NixOS Wiki: Specialisation</a></p>\n</li>\n<li>\n<p><a href=\"https://www.tweag.io/blog/2022-11-01-hard-user-separation-with-nixos/\">Tweag Hard User Separation with NixOS</a></p>\n</li>\n</ul>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/flakes/overlays.html",
      "url": "https://saylesss88.github.io/flakes/overlays.html",
      "title": "Extending Flakes with Overlays",
      "content_html": "<h1>Extending Flakes with Custom Packages using Overlays</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><img src=\"../images/pokego.png\" alt=\"Pokego Logo\" />‚Äì<a href=\"https://github.com/rubiin/pokego\">pokego repo</a></p>\n<p>Overlays are Nix functions that accept two arguments, <code>final</code> and <code>prev</code> and\nreturn a set of packages. Overlays are similar to <code>packageOverrides</code> as a way to\ncustomize Nixpkgs, <code>packageOverrides</code> acts as an overlay with only the <code>prev</code>\nargument. Therefore, <code>packageOverrides</code> is appropriate for basic use, but\noverlays are more powerful and easier to distribute.</p>\n<p>Example:</p>\n<pre><code class=\"language-nix\">final: prev: {\n  firefox = prev.firefox.overrideAttrs (old: {\n    buildInputs = (old.buildInputs or []) ++ [ prev.vlc ];\n    env.FIREFOX_DISABLE_GMP_UPDATER = \"1\";\n  });\n}\n</code></pre>\n<p>To see the original derivation, run <code>nix edit -f \"&lt;nixpkgs&gt;\" firefox</code>.</p>\n<p>This modifies Firefox by:</p>\n<ul>\n<li>\n<p>Adding <code>vlc</code> to <code>buildInputs</code>, useful if a package requires additional\ndependencies.</p>\n</li>\n<li>\n<p>Setting an environment variable (<code>FIREFOX_DISABLE_GMP_UPDATER=1</code>) to disable\nautomatic updates of the Gecko Media Plugin.</p>\n</li>\n</ul>\n<p>It is very common to use overlays in Nix to install packages that aren‚Äôt\navailable in the standard Nixpkgs repository.</p>\n<p><strong>Overlays</strong> are one of the primary and recommended ways to extend and customize\nyour Nix environment. It‚Äôs important to remember that Nix overlays are made to\nallow you to modify or extend the package set provided by Nixpkgs (or other Nix\nsources) without directly altering the original package definitions. This is\ncrucial for maintaining reproducibility and avoiding conflicts. Overlays are\nessentially functions that take the previous package set and allow you to add,\nmodify, or remove packages.</p>\n<ul>\n<li>To better understand the structure of my <code>flake.nix</code> it may be helpful to\nfirst read <a href=\"https://tsawyer87.github.io/posts/nix_flakes_tips/\">This</a> blog\npost first.</li>\n</ul>\n<h2>Adding the overlays output to your Flake</h2>\n<p>I‚Äôll show the process of adding the <code>pokego</code> package that is not in Nixpkgs:</p>\n<ol>\n<li>In my <code>flake.nix</code> I have a custom inputs variable within my let block of my\nflake like so just showing the necessary parts for brevity:</li>\n</ol>\n<pre><code class=\"language-nix\"># flake.nix\n  outputs = my-inputs @ {\n    self,\n    nixpkgs,\n    treefmt-nix,\n    ...\n  }: let\n    system = \"x86_64-linux\";\n    host = \"magic\";\n    userVars = {\n      username = \"jr\";\n      gitUsername = \"saylesss88\";\n      editor = \"hx\";\n      term = \"ghostty\";\n      keys = \"us\";\n      browser = \"firefox\";\n      flake = builtins.getEnv \"HOME\" + \"/flake\";\n    };\n\n    inputs =\n      my-inputs\n      // {\n        pkgs = import inputs.nixpkgs {\n          inherit system;\n        };\n        lib = {\n          overlays = import ./lib/overlay.nix;\n          nixOsModules = import ./nixos;\n          homeModules = import ./home;\n          inherit system;\n        };\n      };\n      # ... snip ...\n</code></pre>\n<ul>\n<li>Why I Created <code>inputs.lib</code> in My <code>flake.nix</code>. In the above example, you‚Äôll\nnotice a <code>lib</code> attribute defined within the main <code>let</code> block.\n<ul>\n<li>\n<p>This might seem a bit unusual at first, as inputs are typically defined at\nthe top level of a flake. However, this structure provides a powerful way to\norganize and reuse common Nix functions and configurations across my flake.</p>\n</li>\n<li>\n<p>By bundling my custom logic and modules into <code>inputs.lib</code>, I can pass\n<code>inputs</code> (which now includes my custom <code>lib</code>) as a <code>specialArgs</code> to other\nmodules. This provides a clean way for all modules to access these shared\nresources. For example, in <code>configuration.nix</code>, <code>inputs.lib.overlays</code>\ndirectly references my custom overlay set.</p>\n</li>\n<li>\n<p>My <code>inputs.lib</code> is my own project-specific library, designed to hold\nfunctions and attribute sets relevant to my flake‚Äôs custom configurations.\nWhile <code>nixpkgs.lib</code> is globally available, my custom <code>lib</code> contains my\nunique additions.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>While defining <code>inputs</code> within the <code>let</code> block to achieve this structure is a\npersonal preference and works well for my setup, the core benefit is the\ncreation of a dedicated, centralized <code>lib</code> attribute that encapsulates my\nflake‚Äôs reusable Nix code, leading to a more organized and maintainable\nconfiguration.</p>\n<h2>The Actual Overlay</h2>\n<ol start=\"2\">\n<li>In the <code>overlay.nix</code> I have this helper function and the defined package:</li>\n</ol>\n<pre><code class=\"language-nix\"># overlay.nix\n_final: prev: let\n  # Helper function to import a package\n  callPackage = prev.lib.callPackageWith (prev // packages);\n\n  # Define all packages\n  packages = {\n    # Additional packages\n    pokego = callPackage ./pac_defs/pokego.nix {};\n  };\nin\n  packages\n</code></pre>\n<ol>\n<li><code>_final: prev:</code>: This is the function definition of the overlay.</li>\n</ol>\n<ul>\n<li>\n<p><code>_final</code>: This argument represents the final, merged package set after all\noverlays have been applied. It‚Äôs often unused within a single overlay, hence\nthe <code>_</code> prefix (a Nix convention for unused variables).</p>\n</li>\n<li>\n<p><code>prev</code>: This is the crucial argument. It represents the package set before\nthis overlay is applied. This allows you to refer to existing packages and\nfunctions from Nixpkgs.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p><code>let ... in packages</code>: This introduces a <code>let</code> expression, which defines\nlocal variables within the scope of this overlay function. The <code>in packages</code>\npart means that the overlay function will ultimately return the <code>packages</code>\nattribute set defined within the <code>let</code> block.</p>\n</li>\n<li>\n<p><code>callPackage = prev.lib.callPackageWith (prev // packages)</code>: This line\ndefines a helper function called <code>callPackage</code>.</p>\n</li>\n</ol>\n<ul>\n<li>\n<p><code>prev.lib.callPackageWith</code> Is a function provided by Nixpkgs‚Äô <code>lib</code>.\n<code>callPackageWith</code> is like <code>prev.lib.callPackage</code>, but allows the passing of\nadditional arguments that will then be passed to the package definition.</p>\n</li>\n<li>\n<p><code>(prev // packages)</code>: This is an attribute set merge operation. It takes the\n<code>prev</code> package set (Nixpkgs before this overlay) and merges it with the\n<code>packages</code> attribute set defined later in this overlay.</p>\n</li>\n<li>\n<p>By using <code>callPackageWith</code> with this merged attribute set, the <code>callPackage</code>\nfunction defined here is set up to correctly import package definitions,\nensuring they have access to both the original Nixpkgs and any other packages\ndefined within this overlay.</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>\n<p><code>packages = { ... };</code>: This defines an attribute set named <code>packages</code>. This\nset will contain all the new or modified packages introduced by this overlay.</p>\n</li>\n<li>\n<p><code>pokego = callPackages ./pac_defs/pokego.nix { };</code>: This is the core of how\nthe <code>pokego</code> package is added.</p>\n</li>\n</ol>\n<ul>\n<li>\n<p><code>pokego =</code>: This defines a new attribute named <code>pokego</code> within the packages\nattribute set. This name will be used to refer to the pokego package later.</p>\n</li>\n<li>\n<p><code>callPackage ./pac_defs/pokego.nix {}</code>: This calls the callPackage helper\nfunction defined earlier.</p>\n</li>\n<li>\n<p><code>./pac_defs/pokego.nix</code>: This is the path to another Nix file(<code>pokego.nix</code>)\nthat contains the actual package definition for pokego. This file would define\nhow to fetch, build, and install the pokego software</p>\n</li>\n<li>\n<p><code>{}</code>: This is an empty attribute set passed as additional arguments to the\n<code>pokego.nix</code> package definition. If <code>pokego.nix</code> expected any specific\nparameters (like versions or dependencies), you would provide them here. Since\nit‚Äôs empty, it implies pokego.nix either has no required arguments or uses\ndefault values.</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><code>in packages</code>: As mentioned earlier, the overlay function returns the\npackages attribute set. When this overlay is applied, the packages defined\nwithin this packages set (including pokego) will be added to the overall Nix\npackage set.</li>\n</ol>\n<h2>The pokego Package definition</h2>\n<p>The following is the <code>./pac_defs/pokego.nix</code>:</p>\n<pre><code class=\"language-nix\"># pokego.nix\n{\n  lib,\n  buildGoModule,\n  fetchFromGitHub,\n}:\nbuildGoModule rec {\n  pname = \"pokego\";\n  version = \"0.3.0\";\n\n  src = fetchFromGitHub {\n    owner = \"rubiin\";\n    repo = \"pokego\";\n    rev = \"v${version}\";\n    hash = \"sha256-cFpEi8wBdCzAl9dputoCwy8LeGyK3UF2vyylft7/1wY=\";\n  };\n\n  vendorHash = \"sha256-7SoKHH+tDJKhUQDoVwAzVZXoPuKNJEHDEyQ77BPEDQ0=\";\n\n  # Install shell completions\n  postInstall = ''\n    install -Dm644 completions/pokego.bash \"$out/share/bash-completion/completions/pokego\"\n    install -Dm644 completions/pokego.fish \"$out/share/fish/vendor_completions.d/pokego.fish\"\n    install -Dm644 completions/pokego.zsh \"$out/share/zsh/site-functions/_pokego\"\n  '';\n\n  meta = with lib; {\n    description = \"Command-line tool that lets you display Pok√©mon sprites in color directly in your terminal\";\n    homepage = \"https://github.com/rubiin/pokego\";\n    license = licenses.gpl3Only;\n    maintainers = with maintainers; [\n      rubiin\n      jameskim0987\n      vinibispo\n    ];\n    mainProgram = \"pokego\";\n    platforms = platforms.all;\n  };\n}\n</code></pre>\n<h2>Adding the overlay to your configuration</h2>\n<p>There are a few places you could choose to put the following, I choose to use my\n<code>configuration.nix</code> because of my setup:</p>\n<pre><code class=\"language-nix\"># configuration.nix\nnixpkgs.overlays = [inputs.lib.overlays]\n</code></pre>\n<h2>Installing Pokego</h2>\n<ul>\n<li>If you are managing your entire system configuration with NixOS, you would\ntypically add <code>pokego</code> to your <code>environment.systemPackages</code>.</li>\n</ul>\n<pre><code class=\"language-nix\"># configuration.nix\nenvironment.systemPackages = with pkgs; [\n  pokego\n]\n</code></pre>\n<ul>\n<li>If you prefer home-manager you can install <code>pokego</code> with home-manager also:</li>\n</ul>\n<pre><code class=\"language-nix\"># home.nix\nhome.packages = [\n  pkgs.pokego\n]\n</code></pre>\n<h3>Another Overlay Example</h3>\n<pre><code class=\"language-nix\">{\n  inputs = {\n    nixpkgs.url = \"https://flakehub.com/NixOS/nixpkgs/*.tar.gz\";\n\n    nix.url = \"https://flakehub.com/f/NixOS/nix/2.17.0.tar.gz\";\n  };\n\n  outputs = { self, nixpkgs, nix }:\n\n    let\n      system = \"aarch64-darwin\";\n      pkgs = import nixpkgs {\n        inherit system;\n        overlays = [\n          nix.overlays.default\n        ];\n      };\n    in\n    {\n     # `pkgs` is nixpkgs for the system, with nix's overlay applied\n    };\n}\n</code></pre>\n<ul>\n<li>\n<p>Normally,\n<code>pkgs = import nixpkgs { }`` imports Nixpkgs with default settings.  However, the example above customizes this import by passing arguments:  </code>pkgs\n= import nixpkgs { inherit system; overlays = [\nnix.overlays.default];}<code>.  This makes the pkgs variable represent nixpkgs specifically for the </code>aarch64-darwin`\nsystem, with the overlay from the nix flake applied.</p>\n</li>\n<li>\n<p>Consequently, any packages built using this customized <code>pkgs</code> will now depend\non or use the specific nix version (<code>2.17.0</code>) provided by the nix flake,\ninstead of the version that comes with the fetched <code>nixpkgs</code>. This technique\ncan be useful for ensuring a consistent environment or testing specific\npackage versions.</p>\n</li>\n</ul>\n<h2>Customizing Nixpkgs Imports and Overlays</h2>\n<p>While overlays are typically used to add or modify packages within a single\n<code>nixpkgs</code> instance, Nix‚Äôs lazy evaluation and flake inputs allow for even more\npowerful scenarios. You can have multiple versions of nixpkgs in a single flake,\nand they will only be evaluated when a package from that specific version is\nactually referenced. This complements overlays by giving you fine-grained\ncontrol over which nixpkgs instance an overlay applies to, or which <code>nixpkgs</code>\nversion a specific part of your project depends on.</p>\n<p>Consider this example where we import nixpkgs with a specific overlay applied\ndirectly at the import site:</p>\n<pre><code class=\"language-nix\">{\n  inputs = {\n    nixpkgs.url = \"[https://flakehub.com/NixOS/nixpkgs/*.tar.gz](https://flakehub.com/NixOS/nixpkgs/*.tar.gz)\"; # This will be the base nixpkgs\n\n    nix.url = \"[https://flakehub.com/f/NixOS/nix/2.17.0.tar.gz](https://flakehub.com/f/NixOS/nix/2.17.0.tar.gz)\"; # This flake provides an overlay for a specific Nix version\n  };\n\n  outputs = { self, nixpkgs, nix }:\n\n    let\n      system = \"aarch64-darwin\";\n      # Here, we import nixpkgs and apply the 'nix' flake's overlay.\n      # This 'pkgs' variable now holds a customized Nix package set.\n      # In this 'pkgs' set, the 'nix' package (and anything that depends on it)\n      # will be version 2.17.0 as defined by the 'nix' flake's overlay.\n      pkgs_with_custom_nix = import nixpkgs {\n        inherit system;\n        overlays = [\n          nix.overlays.default # Apply the overlay from the 'nix' flake here\n        ];\n      };\n    in\n    {\n      # We can then expose packages or devShells that use this customized `pkgs` set.\n      devShells.${system}.default = pkgs_with_custom_nix.mkShell {\n        packages = [\n          pkgs_with_custom_nix.nix # This 'nix' package is now version 2.17.0 due to the overlay!\n        ];\n        shellHook = ''\n          echo \"Using Nix version: &lt;span class=\"math-inline\"&gt;\\(nix \\-\\-version\\)\"\n'';\n};\n# You can also make this customized package set available as a top-level overlay\n# if other parts of your flake or configuration want to use it.\n# overlays.custom-nix-version = final: prev: {\n#   inherit (pkgs_with_custom_nix) nix; # Expose the specific nix package from our overlayed pkgs\n# };\n# You can also import multiple versions of nixpkgs and select packages from them:\n# pkgs-2505 = import (inputs.nixpkgs-2505 or nixpkgs) { inherit system; }; # Example, assuming 2505 is an input\n# packages.&lt;/span&gt;{system}.my-tool-2505 = pkgs-2505.myTool; # Using a package from a specific stable version\n    };\n}\n</code></pre>\n<p>Normally, <code>pkgs = import nixpkgs { }</code> imports Nixpkgs with default settings.\nHowever, the example above customizes this import by passing arguments:\n<code>pkgs = import nixpkgs { inherit system; overlays = [ nix.overlays.default];}</code>.\nThis makes the <code>pkgs_with_custom_nix</code> variable represent Nixpkgs specifically\nfor the <code>aarch64-darwin</code> system, with the overlay from the nix flake applied at\nthe time of import.</p>\n<p>Consequently, any packages built using this customized <code>pkgs_with_custom_nix</code>\nwill now depend on or use the specific Nix version (<code>2.17.0</code>) provided by the\nnix flake‚Äôs overlay, instead of the version that comes with the base <code>nixpkgs</code>\ninput. This technique is highly useful for ensuring a consistent environment or\ntesting specific package versions without affecting the entire system‚Äôs\n<code>nixpkgs</code> set.</p>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/installation/unenc/unencrypted_setups.html",
      "url": "https://saylesss88.github.io/installation/unenc/unencrypted_setups.html",
      "title": "Unencrypted Install (BTRFS)",
      "content_html": "<h1>Minimal BTRFS-Subvol Install with Disko and Flakes</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<h1>Unencrypted Setups</h1>\n<p>Figure 1: BTRFS Logo: Image of the BTRFS logo. Sourced from the BTRFS repo BTRFS\nlogo</p>\n<p>Why I Chose BTRFS I chose BTRFS because I was already familiar with it from\nusing it with Arch Linux and I found it to be very easy to use. From what I‚Äôve\nread, there are licensing issues between the Linux Kernel and ZFS which means\nthat ZFS is not part of the Linux Kernel; it‚Äôs maintained by the OpenZFS project\nand available as a separate kernel module. This can cause issues and make you\nthink more about your filesystem than I personally want to at this point.</p>\n<details>\n<summary>‚úîÔ∏è Click for BTRFS Subvolume Overview</summary>\n<p>A <strong>Btrfs subvolume</strong> is essentially a distinct section within a Btrfs\nfilesystem that maintains its own set of files and directories, along with a\nseparate inode numbering system. Unlike block-level partitions (such as LVM\nlogical volumes), Btrfs subvolumes operate at the file level and are based on\nfile extents.</p>\n<p><strong>Extents</strong> in Btrfs are contiguous blocks of data on disk that store the actual\ncontents of files. When files are created or modified, Btrfs manages these\nextents efficiently, allowing features like deduplication and snapshots.\nMultiple subvolumes can reference the same extents, meaning that identical data\nis not duplicated on disk, which saves space and improves performance.</p>\n<p>A <strong>snapshot</strong> in Btrfs is a special kind of subvolume that starts with the same\ncontent as another subvolume at the time the snapshot is taken. Snapshots are\ntypically writable by default, so you can make changes in the snapshot without\naffecting the original subvolume. This is possible because Btrfs tracks changes\nat the extent level, only creating new extents when files are modified (a\ntechnique called copy-on-write).</p>\n<p>Subvolumes in Btrfs behave much like regular directories from a user‚Äôs\nperspective, but they support additional operations such as renaming, moving,\nand nesting (placing subvolumes within other subvolumes). There are no\nrestrictions on nesting, though it can affect how snapshots are created and\nmanaged. Each subvolume is assigned a unique and unchangeable numeric ID\n(subvolid or rootid).</p>\n<p>You can access a Btrfs subvolume in two main ways:</p>\n<ul>\n<li>\n<p>As a normal directory within the filesystem.</p>\n</li>\n<li>\n<p>By mounting it directly as if it were a separate filesystem, using the subvol\nor subvolid mount options. When mounted this way, you only see the contents of\nthat subvolume, similar to how a bind mount works.</p>\n</li>\n</ul>\n<p>When a new Btrfs filesystem is created, it starts with a ‚Äútop-level‚Äù subvolume\n(with an internal ID of 5). This subvolume is always present and cannot be\ndeleted or replaced, and it is the default mount point unless changed with btrfs\nsubvolume set-default.</p>\n<p>Subvolumes can also have storage quotas set using Btrfs‚Äôs quota groups , but\notherwise, they all draw from the same underlying storage pool. Thanks to\nfeatures like deduplication and snapshots, subvolumes can share data efficiently\nat the extent level.While ZFS is a solid choice and offers some benefits over\nBTRFS, I recommend looking into it before making your own decision.</p>\n<p>If you have a ton of RAM you could most likely skip the minimal install and just\nset your system up as needed or just use\n<a href=\"https://elis.nu/blog/2020/05/nixos-tmpfs-as-root/\">tmpfs as root</a></p>\n</details>\n<h2>Getting Started with Disko</h2>\n<p>Disko allows you to declaratively partition and format your disks, and then\nmount them to your system. I recommend checking out the\n<a href=\"https://github.com/nix-community/disko/tree/master?tab=readme-ov-file\">README</a>\nas it is a disk destroyer if used incorrectly.</p>\n<p>We will mainly be following the\n<a href=\"https://github.com/nix-community/disko/blob/master/docs/quickstart.md\">disko quickstart guide</a></p>\n<p>Figure 2: <strong>Disko Logo</strong>: Image of the logo for Disko, the NixOS declarative\ndisk partitioning tool. Sourced from the\n<a href=\"https://github.com/nix-community/disko\">Disko project</a> disko logo</p>\n<ol>\n<li>Get the\n<a href=\"https://channels.nixos.org/nixos-25.05/latest-nixos-minimal-x86_64-linux.iso\">Nixos Minimal ISO</a>\nGet it on a usb stick, I use Ventoy with Ventoy2Disk.sh. The following is the\nlink to the\n<a href=\"https://sourceforge.net/projects/ventoy/files/v1.1.05/ventoy-1.1.05-linux.tar.gz/download\">Ventoy TarBall</a>\ndownload, untar it with <code>tar -xzf ventoy-1.1.05-linux.tar.gz</code>, and make it\nexecutable with <code>chmod +x Ventoy2Disk.sh</code>, and finally execute it with\n<code>sudo ./Ventoy2Disk.sh</code> Follow the prompts to finish the install.</li>\n</ol>\n<p>You‚Äôll have to run it on for the USB drive you‚Äôre trying to use, you can do that\nby unplugging the USB stick and running <code>lsblk</code>, then plug it in again and run:</p>\n<pre><code class=\"language-bash\">lsblk -f\nNAME          FSTYPE      FSVER LABEL   UUID                                 FSAVAIL FSUSE% MOUNTPOINTS\nsda\n‚îî‚îÄsda1        vfat        FAT32 MYUSB   46E8-9304\nsdb           vfat        FAT12         F054-697D                               1.4M     0% /run/media/jr/F054-697D\nnvme0n1\n‚îú‚îÄnvme0n1p1   vfat        FAT32         BCD8-8C51                               1.8G    12% /boot\n</code></pre>\n<ul>\n<li><code>sdb</code> is a USB plugin for a mouse. <code>sda</code> is the USB stick that I want to\ntarget here:</li>\n</ul>\n<pre><code class=\"language-bash\">sudo ./Ventoy2Disk.sh -i /dev/sda\n# Or to force overwrite an existing Ventoy entry\nsudo ./Ventoy2Disk.sh -I /dev/sda\n</code></pre>\n<ol start=\"2\">\n<li>The minimal installer uses wpa_supplicant instead of NetworkManager, to\nenable networking run the following:</li>\n</ol>\n<pre><code class=\"language-bash\">sudo systemctl start wpa_supplicant\nwpa_cli\n</code></pre>\n<pre><code class=\"language-bash\">&gt; add_network\n0\n\n&gt; set_network 0 ssid \"myhomenetwork\"\nOK\n\n&gt; set_network 0 psk \"mypassword\"\nOK\n\n&gt; enable_network 0\nOK\n</code></pre>\n<p>To exit type <code>quit</code>, then check your connection with <code>ping google.com</code>.</p>\n<p>Another option is to do the following, so either the above method or the below\nmethod after starting <code>wpa_supplicant</code>:</p>\n<pre><code class=\"language-bash\"># Alternative for quick setup (less interactive, but often faster)\nsudo wpa_passphrase \"myhomenetwork\" \"mypassword\" &gt;&gt; /etc/wpa_supplicant/wpa_supplicant-wlan0.conf\nsudo systemctl restart wpa_supplicant@wlan0.service\n</code></pre>\n<ol start=\"3\">\n<li>Get your Disk Name with lsblk</li>\n</ol>\n<p>The output should be something like:</p>\n<pre><code class=\"language-bash\">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nnvme0n1     259:0    0   1,8T  0 disk\n</code></pre>\n<ol start=\"4\">\n<li>Copy the disk configuration to your machine. You can choose one from the\nexamples directory.</li>\n</ol>\n<ul>\n<li><strong>Option A</strong>: (Simpler for new users) I also created a starter repo containing\nmuch of what‚Äôs needed. If you choose this option follow the README.md included\nwith the repo.</li>\n</ul>\n<pre><code class=\"language-bash\">cd ~\ngit clone https://github.com/saylesss88/my-flake.git\n</code></pre>\n<blockquote>\n<p>Make sure to change line 7 in disk-config.nix to what you got from step 3\ndevice = ‚Äú/dev/nvme0n1‚Äù;</p>\n</blockquote>\n<ul>\n<li><strong>Option B</strong>: (More flexible, more manual steps) Skip cloning the repo above\nand for the btrfs-subvolume default layout, run the following:</li>\n</ul>\n<pre><code class=\"language-bash\">cd /tmp\ncurl https://raw.githubusercontent.com/nix-community/disko/refs/heads/master/example/btrfs-subvolumes.nix -o /tmp/disk-config.nix\n</code></pre>\n<ol start=\"5\">\n<li>Make Necessary changes, I set mine up for impermanence with the following:</li>\n</ol>\n<pre><code class=\"language-bash\">nano /tmp/disk-config.nix\n</code></pre>\n<pre><code class=\"language-nix\">{\n  disko.devices = {\n    disk = {\n      main = {\n        type = \"disk\";\n        device = \"/dev/nvme0n1\";\n        content = {\n          type = \"gpt\";\n          partitions = {\n            ESP = {\n              priority = 1;\n              name = \"ESP\";\n              start = \"1M\";\n              end = \"512M\";\n              type = \"EF00\";\n              content = {\n                type = \"filesystem\";\n                format = \"vfat\";\n                mountpoint = \"/boot\";\n                mountOptions = [\"umask=0077\"];\n              };\n            };\n            root = {\n              size = \"100%\";\n              content = {\n                type = \"btrfs\";\n                extraArgs = [\"-f\"]; # Override existing partition\n                # Subvolumes must set a mountpoint in order to be mounted,\n                # unless their parent is mounted\n                subvolumes = {\n                  # Subvolume name is different from mountpoint\n                  \"/root\" = {\n                    mountpoint = \"/\";\n                    mountOptions = [\"subvol=root\" \"compress=zstd\" \"noatime\"];\n                  };\n                  # Subvolume name is the same as the mountpoint\n                  \"/home\" = {\n                    mountOptions = [\"subvol=home\" \"compress=zstd\" \"noatime\"];\n                    mountpoint = \"/home\";\n                  };\n                  # Sub(sub)volume doesn't need a mountpoint as its parent is mounted\n                  \"/home/user\" = {};\n                  # Parent is not mounted so the mountpoint must be set\n                  \"/nix\" = {\n                    mountOptions = [\n                      \"subvol=nix\"\n                      \"compress=zstd\"\n                      \"noatime\"\n                    ];\n                    mountpoint = \"/nix\";\n                  };\n                  \"/nix/persist\" = {\n                    mountpoint = \"/nix/persist\";\n                    mountOptions = [\"subvol=persist\" \"compress=zstd\" \"noatime\"];\n                  };\n                  \"/log\" = {\n                    mountpoint = \"/var/log\";\n                    mountOptions = [\"subvol=log\" \"compress=zstd\" \"noatime\"];\n                  };\n                  \"/lib\" = {\n                    mountpoint = \"/var/lib\";\n                    mountOptions = [\"subvol=lib\" \"compress=zstd\" \"noatime\"];\n                  };\n                  # This subvolume will be created but not mounted\n                  \"/test\" = {};\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  fileSystems.\"/nix/persist\".neededForBoot = true;\n  fileSystems.\"/var/log\".neededForBoot = true;\n  fileSystems.\"/var/lib\".neededForBoot = true;\n}\n</code></pre>\n<ul>\n<li>For <code>/tmp</code> on RAM use something like the following. I‚Äôve found that having\ndisko manage swaps causes unnecessary issues. Using zram follows the ephemeral\nroute:</li>\n</ul>\n<pre><code class=\"language-nix\">{\n  lib,\n  config,\n  ...\n}: let\n  cfg = config.custom.zram;\nin {\n  options.custom.zram = {\n    enable = lib.mkEnableOption \"Enable utils module\";\n  };\n\n  config = lib.mkIf cfg.enable {\n    zramSwap = {\n      enable = true;\n      # one of \"lzo\", \"lz4\", \"zstd\"\n      algorithm = \"zstd\";\n       priority = 5;\n       memoryPercent = 50;\n    };\n  };\n}\n</code></pre>\n<p>And in your <code>configuration.nix</code> you would add:</p>\n<pre><code class=\"language-nix\"># configuration.nix\ncustom = {\n    zram.enable = true;\n};\n</code></pre>\n<p>After adding the above module, you can see it with:</p>\n<pre><code class=\"language-bash\">swapon --show\nNAME       TYPE      SIZE USED PRIO\n/dev/zram0 partition 7.5G   0B    5\n</code></pre>\n<ol start=\"6\">\n<li>Run disko to partition, format and mount your disks. Warning this will wipe\nEVERYTHING on your disk. Disko doesn‚Äôt work with dual boot.</li>\n</ol>\n<pre><code class=\"language-bash\">sudo nix --experimental-features \"nix-command flakes\" run github:nix-community/disko/latest -- --mode destroy,format,mount /tmp/disk-config.nix\n</code></pre>\n<p>Check it with the following:</p>\n<pre><code class=\"language-bash\">mount | grep /mnt\n</code></pre>\n<p>The output for an nvme0n1 disk would be similar to the following:</p>\n<pre><code class=\"language-bash\">#... snip ...\n/dev/nvme0n1p2 on /mnt type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=285,subvol=/root)\n/dev/nvme0n1p2 on /mnt/persist type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=261,subvol=/persist)\n/dev/nvme0n1p2 on /mnt/etc type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=261,subvol=/persist)\n/dev/nvme0n1p2 on /mnt/nix type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=260,subvol=/nix)\n/dev/nvme0n1p2 on /mnt/var/lib type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=258,subvol=/lib)\n/dev/nvme0n1p2 on /mnt/var/log type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=259,subvol=/log)\n/dev/nvme0n1p2 on /mnt/nix/store type btrfs (ro,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=260,subvol=/nix)\n# ... snip ...\n</code></pre>\n<ol start=\"7\">\n<li>Generate necessary files, here we use ‚Äìno-filesystems because disko handles\nthe fileSystems attribute for us.</li>\n</ol>\n<pre><code class=\"language-bash\">nixos-generate-config --no-filesystems --root /mnt\n</code></pre>\n<p>It may be helpful to add a couple things to your <code>configuration.nix</code> now,\nrebuild and then move on. Such as, your hostname, git, an editor of your choice.\nAfter your additions run <code>sudo nixos-rebuild</code> switch to apply the changes. If\nyou do this, you can skip the <code>nix-shell -p</code> command coming up.</p>\n<pre><code class=\"language-bash\">sudo mv /tmp/disk-config.nix /mnt/etc/nixos\n</code></pre>\n<h2>Setting a Flake for your minimal Install</h2>\n<ol start=\"8\">\n<li>Create the flake in your home directory, then move it to /mnt/etc/nixos. This\navoids needing to use sudo for every command while in the /mnt/etc/nixos\ndirectory.</li>\n</ol>\n<pre><code class=\"language-bash\">cd ~\nmkdir flake &amp;&amp; cd flake\nnix-shell -p git yazi helix\nexport NIX_CONFIG='experimental-features = nix-command flakes'\nexport EDITOR='hx'\nhx flake.nix\n</code></pre>\n<blockquote>\n<p>You‚Äôll change hostname = nixpkgs.lib.nixosSystem to your chosen hostname,\n(e.g. magic = nixpkgs.lib.nixosSystem). This will be the same as your\nnetworking.hostName = ‚Äúmagic‚Äù; in your configuration.nix that we will set up\nshortly.</p>\n</blockquote>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    disko.url = \"github:nix-community/disko/latest\";\n    disko.inputs.nixpkgs.follows = \"nixpkgs\";\n    # impermanence.url = \"github:nix-community/impermanence\";\n  };\n\n  outputs = inputs@{ nixpkgs, ... }: {\n    nixosConfigurations = {\n      # Change `my-hostname` to match `networking.hostName`\n      my-hostname = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n          inputs.disko.nixosModules.disko\n          # inputs.impermanence.nixosModules.impermanence\n        ];\n      };\n    };\n  };\n}\n</code></pre>\n<p>Move all the files into your flake:</p>\n<pre><code class=\"language-bash\">cd /mnt/etc/nixos/\nsudo mv disk-config.nix hardware-configuration.nix configuration.nix ~/flake\n</code></pre>\n<ol start=\"9\">\n<li>Edit configuration.nix with what is required, the following is required, I\nclone my original flake repo and move the pieces into place but it‚Äôs fairly\neasy to just type it all out:</li>\n</ol>\n<ul>\n<li>\n<p>Bootloader, (e.g., boot.loader.systemd-boot.enable = true;)</p>\n</li>\n<li>\n<p>User, the example uses username change this to your chosen username. If you\ndon‚Äôt set your hostname it will be nixos.</p>\n</li>\n<li>\n<p>Networking, networking.networkmanager.enable = true;</p>\n</li>\n<li>\n<p><code>hardware-configuration.nix</code> &amp; <code>disk-config.nix</code> for this setup</p>\n</li>\n<li>\n<p><code>initialHashedPassword</code>: Run <code>mkpasswd --method=yescrypt</code>, then enter your\ndesired password. Example output,</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">mkpasswd --method=yescrypt &gt; /tmp/pass.txt\n</code></pre>\n<ul>\n<li>You can check the quality with pwscore:</li>\n</ul>\n<pre><code class=\"language-bash\">nix-shell -p libpwquality\n\npwscore\nvery-secure-password\n100\n</code></pre>\n<p>read the hashed password into the file with :r /tmp/pass.txt and move it into\nplace.</p>\n<pre><code class=\"language-nix\"># configuration.nix\n{\n  config,\n  lib,\n  pkgs,\n  inputs,\n  ...\n}: {\n  imports = [\n    # Include the results of the hardware scan.\n    ./hardware-configuration.nix\n    ./disk-config.nix\n  ];\n\n  networking.hostName = \"my-hostname\"; # This will match the `hostname` of your flake\n\n  networking.networkmanager.enable = true;\n\n  boot.loader.systemd-boot.enable = true; # (for UEFI systems only)\n  # List packages installed in system profile.\n  # You can use https://search.nixos.org/ to find more packages (and options).\n  environment.systemPackages = with pkgs; [\n    vim # Do not forget to add an editor to edit configuration.nix! The Nano editor is also installed by default.\n    #   wget\n    git\n  ];\n\n  time.timeZone = \"America/New_York\";\n\n# Change `nixos` to your chosen username, change the group to match\n  users.users.nixos = {\n    isNormalUser = true;\n    extraGroups = [ \"wheel\" \"networkmanager\" ]; # Add \"wheel\" for sudo access\n    initialHashedPassword = \"COPY_YOUR_MKPASSWD_OUTPUT_HERE\"; # &lt;-- This is where it goes!\n    # home = \"/home/nixos\"; # Optional: Disko typically handles home subvolumes\n  };\n  # Create a matching group\n  users.groups.nixos = {};\n\n  console.keyMap = \"us\";\n\n  nixpkgs.config.allowUnfree = true;\n\n  system.stateVersion = \"25.05\";\n}\n</code></pre>\n<p>Shred pass.txt:</p>\n<pre><code class=\"language-bash\">shred /tmp/pass.txt\nrm /tmp/pass.txt\n</code></pre>\n<ol start=\"10\">\n<li>Move the flake to /mnt/etc/nixos and run nixos-install:</li>\n</ol>\n<pre><code class=\"language-bash\">sudo mv ~/flake /mnt/etc/nixos/\nsudo nixos-install --flake /mnt/etc/nixos/flake .#hostname\n# if the above command doesn't work try this:\nsudo nixos-install --flake /mnt/etc/nixos/flake#hostname\n</code></pre>\n<p>You will be prompted to enter a new password if everything succeeds.</p>\n<p>If everything checks out, reboot the system and you should be prompted to enter\nyour user and password to login to a shell to get started.</p>\n<p>The flake will be placed at <code>/etc/nixos/flake</code>, I choose to move it to my home\ndirectory. Since the file was first in <code>/etc</code> you‚Äôll need to adjust the\npermissions with something like <code>sudo chown nixos:nixos ~/flake</code>. This is based\noff of the example above where we created both a nixos user and group.</p>\n<p>You can check the layout of your btrfs system with:</p>\n<pre><code class=\"language-bash\">sudo btrfs subvolume list /\n</code></pre>\n<ul>\n<li>You may notice some old_roots in the output, which are snapshots, which are\nlikely created before system upgrades or reboots for rollback purposes. They\ncan be deleted or rolled back as needed.</li>\n</ul>\n<p><a href=\"https://btrfs.readthedocs.io/en/latest/Subvolumes.html\">BTRFS Subvolumes</a></p>\n<p>To continue following along and set up impermanence\n<a href=\"https://saylesss88.github.io/installation/unencrypted/impermanence.html\">Click Here</a></p>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/installation/enc/USB_keyfile.html",
      "url": "https://saylesss88.github.io/installation/enc/USB_keyfile.html",
      "title": "USB Keyfile Unlock",
      "content_html": "<h1>USB Stick Keyfile</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p>This allows you to use a USB stick for your keyfile, with a backup in case you\nwant or need it. There is a setting <code>fallbackToPassword</code> that protects you in\ncase something fails with the USB key.</p>\n<p>First, I‚Äôll show how to set up a dedicated USB stick for a keyfile. (i.e., one\nthat is only used for this). After that I will show the process of adding the\nkeyfile to a USB stick with existing data on it that you don‚Äôt want to lose.</p>\n<p><strong>Generate the keyfile</strong></p>\n<pre><code class=\"language-bash\">sudo dd if=/dev/urandom of=/root/usb-luks.key bs=4096 count=1\n</code></pre>\n<h2>Keyfile Enrollment Methods</h2>\n<p>This is for a dedicated USB stick that we will wipe first then add the key.</p>\n<p>Disko defaults to LUKS2</p>\n<pre><code class=\"language-bash\"># cryptsetup works for both LUKS1 and LUKS2 formats but doesn't work for\n# TPM2, FIDO2, and smartcards\nsudo cryptsetup luksAddKey /dev/disk/by-partlabel/luks /root/usb-luks.key\n</code></pre>\n<p><strong>OR</strong></p>\n<details>\n<summary> ‚úîÔ∏è Click to expand Experimental TPM2 auto-unlock for LUKS </summary>\n<blockquote>\n<p>‚ö†Ô∏è WARNING: Security Implications of TPM2 Auto-Unlock</p>\n</blockquote>\n<blockquote>\n<p>Enabling TPM2 auto-unlock fundamentally changes your system‚Äôs security model.\nWhile this feature protects against certain forms of malicious software\ninjection by tying the decryption key to the system‚Äôs boot state, it\neliminates the need for a user password at boot. This creates a significant\nrisk if your machine is stolen or seized, do not use this feature if the\nphysical security of your machine is a concern. This is still at a stage where\nyou can expect rough edges and workarounds.</p>\n</blockquote>\n<blockquote>\n<p>‚ö†Ô∏è WARNING: Do NOT use TPM auto-unlock if your CPU is vulnerable to faulTPM!\nAll AMD Zen2 and Zen3 Processors are known to be affected with AMD Zen1 likely\nalso affected and Zen4 unknown! Misconfigurations are also common, do your own\nresearch!</p>\n</blockquote>\n<ul>\n<li>\n<p><a href=\"https://ieeexplore.ieee.org/document/10190531\">faulTPM:Exposing AMD fTPMs‚Äô Deepest Secrets</a></p>\n</li>\n<li>\n<p><a href=\"https://www.techpowerup.com/308124/amd-faultpm-exploit-targets-zen-2-and-zen-3-processors\">AMD faulTPM Exploit Targets Zen 2 and Zen 3 Processors</a></p>\n</li>\n</ul>\n<p>You can add an additional layer by encrypting user data, such as individual home\nfolders, with a different mechanism, such as <code>fscrypt-experimental</code> or\n<code>systemd-homed</code>. Or, you can use a TPM pin to benefit from the security\nproperties of the TPM, while avoiding completely unattended unlocking.\n‚Äì<a href=\"https://wiki.archlinux.org/title/Trusted_Platform_Module\">Arch Wiki</a></p>\n<p>I am reading that <code>fscrypt</code> is no longer experimental.</p>\n<pre><code class=\"language-nix\">security.pam.enableFscrypt = true;\n</code></pre>\n<pre><code class=\"language-bash\">sudo fscrypt setup --all-users\nsudo mv /home/&lt;user&gt; /home/old&lt;user&gt;\nsudo mkdir /home/&lt;user&gt;\nsudo chown &lt;user&gt;:users /home/&lt;user&gt;\nsudo fscrypt encrypt --source pam_passphrase --user &lt;user&gt; --skip-unlock /home/&lt;user&gt;/\n</code></pre>\n<p>‚Äì‚òùÔ∏è<a href=\"https://discourse.nixos.org/t/experienced-with-systemd-homed-or-other-encrypted-home/63516/2\">Discourse</a></p>\n<p>It is fairly complex as to how TPM2 auto-unlock can improve security in some\nways, it has to do with how Linux distributions fail to authenticate the boot\nprocess past the initrd.Even with encryption and Secure Boot enabled, the initrd\nstage often remains unverified, meaning a tampered initrd could be substituted\nwithout detection.</p>\n<ul>\n<li><a href=\"https://0pointer.net/blog/brave-new-trusted-boot-world.html\">Brave New Trusted Boot World</a></li>\n</ul>\n<p>TPMs protect secrets by releasing them only if the boot process can be\nauthenticated through ‚Äúmeasurements.‚Äù During boot, each component involved\n(firmware, bootloader, kernel, etc.) is hashed, and these hashes are extended\ninto special TPM registers called Platform Configuration Registers (PCRs). These\nPCRs hold a cumulative, tamper-evident record of the boot process state.</p>\n<p>If any part of the boot sequence changes (even slightly), the PCR values will\ndiffer from the expected, causing the TPM to refuse to release the bound secret\n(such as a disk decryption key). This ensures that the system only boots or\nunlocks secrets when its software stack is known and trusted, providing strong\nprotection against tampering or unauthorized modifications. The values aren‚Äôt\nonly protected by these PCRs but encrypted with a ‚Äúseed key‚Äù that‚Äôs generated on\nthe TPM chip itself, and cannot leave the TPM.</p>\n<p>Check TPM support:</p>\n<pre><code class=\"language-bash\">cat /sys/class/tpm/tpm0/device/description\nTPM 2.0 Device\n</code></pre>\n<p>Check for necessary software dependencies:</p>\n<pre><code class=\"language-bash\">systemd-analyze has-tpm2\n</code></pre>\n<p>Find your encrypted partition with <code>lsblk</code>:</p>\n<pre><code class=\"language-bash\">lsblk\n</code></pre>\n<p>First, you need to use the <code>systemd-cryptenroll</code> command to add a TPM2 key to\nyour encrypted LUKS partition. This process binds a key slot on your disk to the\nstate of your TPM2 chip‚Äôs PCRs (Platform Configuration Registers).</p>\n<pre><code class=\"language-bash\"># This command adds a new key to the LUKS volume, using a key generated by the TPM2 chip.\n# It binds the key to PCRs 0,2,7,and 15 ensuring the key is only released if the firmware\n# and Secure Boot state of your system is unchanged.\nsudo systemd-cryptenroll --tpm2-device=auto --tpm2-pcrs=0+2+7+15 /dev/disk/by-partlabel/luks\n</code></pre>\n<p>There are quite a few options for the above command, some use the following with\nless pcrs and a wipe feature:</p>\n<pre><code class=\"language-bash\">sudo systemd-cryptenroll --wipe-slot=tpm2 --tpm2-device=auto --tpm2-pcrs=0+7 /dev/disk/by-partlabel/luks\n</code></pre>\n<ul>\n<li>\n<p>Using less pcrs could prevent breakage but reduces security. Check out the PCR\nDefinitions below and decide if you require additional PCRs or less.</p>\n</li>\n<li>\n<p><code>wipe-slot</code> tells the system to delete any key associated with the TPM2 chip\nfrom the LUKS volume‚Äôs keyslot before adding a new one.</p>\n</li>\n</ul>\n<p>You can choose a more complex <code>--tpm2-pcrs</code> for more security but it makes the\nconfiguration more fragile because any legitimate system update altering any\nmeasured component tied to these PCRs will prevent the TPM from releasing the\nkey and lock you out, unless you re-enroll the key with the updated PCR values.</p>\n<ul>\n<li>\n<p><a href=\"https://uapi-group.org/specifications/specs/linux_tpm_pcr_registry/\">PCR Definitions</a></p>\n</li>\n<li>\n<p><a href=\"https://0pointer.net/blog/authenticated-boot-and-disk-encryption-on-linux.html\">Authenticated Boot and FDE</a>\nThis article explains the limitations and remedies very well.</p>\n</li>\n</ul>\n<p>That said, I do often see people mention a firmware update breaking their TPM2\nauto-unlock functionality. Keep this in mind and have a backup plan. This is\nalso incompatible with the encrypted impermanence setup shared in this book, the\n<code>boot.initrd.postDeviceCommands</code> conflict.</p>\n<p>Change <code>YourUser</code> to your username and ensure that <code>cryptroot</code> is the name of\nyours, if you followed this books encrypted disko install it should be:</p>\n<pre><code class=\"language-nix\">  # Adds your user to the 'tss' group, allowing you to interact with the TPM\n  users.users.YourUser.extraGroups = [ \"tss\" ];\n  # Enables TPM2 services and tools on your system\n  security.tpm2.enable = true;\n  # Ensure the necessary kernel modules are in the initrd\n  boot.initrd.kernelModules = [\"tpm_tis\"];\n  # switches the initrd to a systemd-based environment, required for TPM2\n  boot.initrd.systemd.enable = true;\n  # ‚ùó Tell the initrd to use the TPM2 key for the encrypted root\n  boot.initrd.luks.devices.cryptroot = {\n    device = \"/dev/disk/by-partlabel/luks\";\n    # These options tell systemd-cryptsetup to automatically try to unlock the device\n    # using the TPM2 key. 'tpm2-measure=yes' ensures the PCRs are verified but only works if you use one disk\n    crypttabExtraOpts = [\"tpm2-device=auto\" \"tpm2-measure=yes\"];\n    fallbackToPassword = true;\n  };\n  environment.systemPackages = [ pkgs.tpm2-tss ];\n</code></pre>\n<blockquote>\n<p>‚ùó NOTE: <code>cryptroot</code> needs to match what your encrypted partition is named, I\nhave seen quite a few different names here.</p>\n</blockquote>\n<p>If you use this, you can‚Äôt also use the USB Keyfile or the included impermanence\nguide.</p>\n</details>\n<p><strong>Description</strong></p>\n<ul>\n<li>\n<p><code>/dev/disk/by-partlabel/luks</code> refers to your encrypted partition by its\npartition label, which is stable and less likely to change than\n<code>/dev/nvme0n1p2</code></p>\n</li>\n<li>\n<p><code>/root/usb-luks.key</code> is the keyfile we generated.</p>\n</li>\n<li>\n<p>You‚Äôll be prompted to enter your existing LUKS passphrase to authorize adding\nthe new key.</p>\n</li>\n<li>\n<p>Now our LUKS volume will accept both our existing passphrase and the new\nkeyfile (from the USB stick) for unlocking.</p>\n</li>\n</ul>\n<ol>\n<li><strong>Clear Data on USB stick and replace with 0‚Äôs</strong></li>\n</ol>\n<pre><code class=\"language-bash\">lsblk\nNAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nsda           8:0    1   239M  0 disk\nsdb           8:16   1   1.4M  0 disk  /run/media/jr/7CD1-149A # Example USB mount\nzram0       253:0    0   7.5G  0 disk  [SWAP]\nnvme0n1     259:0    0 476.9G  0 disk\n‚îú‚îÄnvme0n1p1 259:1    0   512M  0 part  /boot\n‚îî‚îÄnvme0n1p2 259:2    0 476.4G  0 part\n  ‚îî‚îÄcryptroot 254:0  0 476.4G  0 crypt /persist  # Main Btrfs mount\n                                               # (other subvolumes are within /persist and bind-mounted by impermanence)\n# unplug the device and run lsblk again so your sure\n</code></pre>\n<ol start=\"2\">\n<li>Before wiping you must unmount any mounted partitions:</li>\n</ol>\n<pre><code class=\"language-bash\">sudo umount /dev/sda1\n</code></pre>\n<pre><code class=\"language-bash\"># Overwrite with Zeros (fast, sufficient for most uses)\nsudo dd if=/dev/zero of=/dev/sda bs=4M status=progress\n# Or overwrite with Random Data (More Secure, Slower)\nsudo dd if=/dev/urandom of=/dev/sda bs=4M status=progress\n# Or for the most secure way run multiple passes of\nsudo shred -v -n 3 /dev/sda\n</code></pre>\n<ol start=\"3\">\n<li>Create a New Partition and Format (Optional)</li>\n</ol>\n<pre><code class=\"language-bash\">sudo fdisk /dev/sda\n</code></pre>\n<ol>\n<li>\n<p>Press <code>o</code> to create a new empty DOS partition table (if you are creating\npartitions on a fresh disk or want to wipe existing partitions and start\nover). Be very careful with this step as it will erase all existing\npartition information on the disk.</p>\n</li>\n<li>\n<p>Press <code>n</code> to create a new partition.</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>You will then be prompted for the partition type:</p>\n<ul>\n<li>\n<p><code>p</code> for a primary partition (you can have up to 4 primary partitions)</p>\n</li>\n<li>\n<p><code>e</code> for an extended partition (which can contain logical partitions)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Next, you‚Äôll be asked for the partition number (e.g., 1, 2, 3, 4).</p>\n</li>\n<li>\n<p>Then, you‚Äôll be asked for the first sector (press Enter to accept the default,\nwhich is usually the first available sector after the previous partition or\nthe beginning of the disk).</p>\n</li>\n<li>\n<p>Finally, you‚Äôll be asked for the last sector or size (you can specify a size\nlike +10G for 10 Gigabytes, +512M for 512 Megabytes, or press Enter to use the\nrest of the available space).</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>Press <code>w</code> to write the changes to the partition table and exit fdisk.</li>\n</ol>\n<p>After pressing <code>w</code>, the kernel needs to be aware of the new partition table.\nSometimes this happens automatically, but if you encounter issues, a reboot or a\ncommand like <code>partprobe</code> (if available and needed) can help.</p>\n<p>Formats as FAT32:</p>\n<pre><code class=\"language-bash\">sudo mkfs.vfat /dev/sda1\n# or as ext4\nsudo mkfs.ext4 /dev/sda1\n</code></pre>\n<p>I chose <code>vfat</code> so I ran <code>sudo mkfs.vfat /dev/sda1</code>. In my case this changed the\ndevice path to <code>/run/media/jr/7CD1-149A</code> so it‚Äôs important to find your own UUID\nwith the following command:</p>\n<pre><code class=\"language-bash\">sudo blkid /dev/sda1\n/dev/sda1: SEC_TYPE=\"msdos\" UUID=\"B7B4-863B\" BLOCK_SIZE=\"512\" TYPE=\"vfat\" PARTUUID=\"7d1f9d7f-01\"\n</code></pre>\n<ul>\n<li>\n<p>As you can see the above UUID is <code>\"B7B4-863B\"</code></p>\n</li>\n<li>\n<p>Remove and re-insert the USB stick, this ensures the system recognizes the new\npartition and filesystem.</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>Copy the keyfile to your USB Stick</li>\n</ol>\n<pre><code class=\"language-bash\">sudo cp /root/usb-luks.key /run/media/jr/B7B4-863B/\nsync\n</code></pre>\n<ol start=\"5\">\n<li>Update your NixOS Configuration</li>\n</ol>\n<p>Note the output of <code>blkid /dev/sda1</code> and if you have a backup device list that\nalso:</p>\n<p>The following is from the wiki edited for my setup, it was created by Tzanko\nMatev:</p>\n<pre><code class=\"language-nix\">let\n  PRIMARYUSBID = \"B7B4-863B\";\n  BACKUPUSBID = \"Ventoy\";\nin {\n\n  boot.initrd.kernelModules = [\n    \"uas\"\n    \"usbcore\"\n    \"usb_storage\"\n    \"vfat\"\n    \"nls_cp437\"\n    \"nls_iso8859_1\"\n  ];\n\n  boot.initrd.postDeviceCommands = lib.mkBefore ''\n    mkdir -p /key\n    sleep 2\n    mount -n -t vfat -o ro $(findfs UUID=${PRIMARYUSBID}) /key || \\\n    mount -n -t vfat -o ro $(findfs UUID=${BACKUPUSBID}) /key || echo \"No USB key found\"\n  '';\n\n  boot.initrd.luks.devices.cryptroot = {\n    device = \"/dev/disk/by-partlabel/luks\";\n    keyFile = \"/key/usb-luks.key\";\n    fallbackToPassword = true;\n    allowDiscards = true;\n    preLVM = false; # Crucial!\n  };\n}\n</code></pre>\n<p>If you have issues or just want to remove the key take note of the path used to\nadd it so you don‚Äôt have to enter the whole key:</p>\n<pre><code class=\"language-bash\">sudo cryptsetup luksRemoveKey /dev/disk/by-partlabel/luks --key-file /root/usb-luks.key\n</code></pre>\n<ol start=\"6\">\n<li>Securely Remove the Keyfile from Your System:</li>\n</ol>\n<pre><code class=\"language-bash\">sudo shred --remove --zero /root/usb-luks.key\n</code></pre>\n<h2>Instructions for Using a USB Stick with Existing Data</h2>\n<ol>\n<li>Generate the Keyfile</li>\n</ol>\n<pre><code class=\"language-bash\">sudo dd if=/dev/urandom of=/root/usb-luks.key bs=4096 count=1\n</code></pre>\n<ol start=\"2\">\n<li>Add the Keyfile to your LUKS Volume</li>\n</ol>\n<pre><code class=\"language-bash\">sudo cryptsetup luksAddKey /dev/disk/by-partlabel/luks /root/usb-luks.key\n</code></pre>\n<p>(enter your existing passphrase when prompted)</p>\n<ol start=\"3\">\n<li>Copy the Keyfile to the USB Stick</li>\n</ol>\n<ul>\n<li>\n<p>Plug in the USB Stick and note its mount point\n(e.g.,<code>/run/media/$USER/YourLabel</code>)</p>\n</li>\n<li>\n<p>Copy the keyfile:</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">sudo cp /root/usb-luks.key /run/media/$USER/YourLabel/\nsync\n</code></pre>\n<ul>\n<li>\n<p>You run the above as 2 commands, the second being <code>sync</code>.</p>\n</li>\n<li>\n<p>You can rename it if you wish (e.g., <code>luks.key</code>)</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>Securely Delete the Local Keyfile</li>\n</ol>\n<pre><code class=\"language-bash\">sudo shred --remove --zero /root/usb-luks.key\n</code></pre>\n<ul>\n<li>You need to ensure the keyfile is accessible in the initrd. Since automounting\n(like <code>/run/media/...</code>) does not happen in <code>initrd</code>, you must manually mount\nthe USB in the <code>initrd</code> using its <code>UUID</code> or label.</li>\n</ul>\n<p>Find the USB Partition UUID:</p>\n<pre><code class=\"language-bash\">lsblk -o NAME,UUID\n# or\nblkid /dev/sda1\n</code></pre>\n<p>Suppose the UUID is <code>B7B4-863B</code></p>\n<p>Add to your <code>configuration.nix</code>:</p>\n<pre><code class=\"language-nix\">boot.initrd.kernelModules = [ \"usb_storage\" \"vfat\" \"nls_cp437\" \"nls_iso8859_1\" ];\n\nboot.initrd.postDeviceCommands = lib.mkBefore ''\n  mkdir -p /key\n  sleep 1\n  mount -n -t vfat -o ro $(findfs UUID=B7B4-863B) /key || echo \"USB not found\"\n'';\n\nboot.initrd.luks.devices.cryptroot = {\n  device = \"/dev/disk/by-partlabel/luks\";\n  keyFile = \"/key/usb-luks.key\"; # or whatever you named it\n  fallbackToPassword = true;\n  allowDiscards = true;\n};\n</code></pre>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/installation/enc/sops-nix.html",
      "url": "https://saylesss88.github.io/installation/enc/sops-nix.html",
      "title": "Secrets Management (Sops-Nix)",
      "content_html": "<h1>Sops-Nix encrypted secrets</h1>\n<details>\n<summary> Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><a href=\"https://github.com/getsops/sops?ref=blog.gitguardian.com\">SOPS</a>, short for\n<strong>S</strong>ecrets<strong>OP</strong>eration<strong>S</strong>, is an editor of encrypted files that supports\nquite a few BINARY formats and encrypts with AWS KMS, GCP KMS, Azure Key Vault,\nage, and PGP.</p>\n<p>Managing secrets‚Äîlike API keys, SSH deploy keys, and password hashes is a\ncritical part of system configuration, but it‚Äôs also one of the trickiest to do\nsecurely and reproducibly. Traditionally, secrets might be stored in ad hoc\nlocations, referenced by absolute paths, or managed manually outside of version\ncontrol. This approach makes it hard to share, rebuild, or audit your\nconfiguration, and increases the risk of accidental leaks or inconsistencies\nbetween systems.</p>\n<p><code>sops-nix</code> solves these problems by integrating Mozilla SOPS directly into your\nNixOS configuration. Instead of relying on hardcoded file paths or copying\nsecrets around, you declare your secrets in your Nix code, encrypt them with\nstrong keys, and let <code>sops-nix</code> handle decryption and placement at activation\ntime.</p>\n<p>Encryption with strong keys, as used by sops-nix, makes brute force attacks\ncomputationally unfeasible with current technology‚Äîthe time and resources\nrequired to try every possible key would be astronomically high. However, this\nprotection relies on using strong, secret keys and good security practices;\nadvances in technology or poor key management can weaken this defense.</p>\n<blockquote>\n<p>‚ùó <strong>CRITICAL SECURITY NOTE:</strong> While the encryption itself is robust, this\nprotection fundamentally relies on using <strong>strong, secret keys</strong> and\n<strong>diligent security practices</strong>. If your PGP passphrase is weak, your Age\nprivate key is easily guessable, or the cleartext secret itself is very short\nand has low entropy (e.g., ‚Äú12345‚Äù, ‚Äútrue‚Äù, ‚Äúadmin‚Äù), an attacker might be\nable to compromise your secrets regardless of the encryption.</p>\n</blockquote>\n<ol>\n<li>Add sops to your <code>flake.nix</code>:</li>\n</ol>\n<pre><code class=\"language-nix\">{\n  inputs.sops-nix.url = \"github:Mic92/sops-nix\";\n  inputs.sops-nix.inputs.nixpkgs.follows = \"nixpkgs\";\n\n  outputs = { self, nixpkgs, sops-nix }: {\n    # change `yourhostname` to your actual hostname\n    nixosConfigurations.yourhostname = nixpkgs.lib.nixosSystem {\n      # customize to your system\n      system = \"x86_64-linux\";\n      modules = [\n        ./configuration.nix\n        sops-nix.nixosModules.sops\n      ];\n    };\n  };\n}\n</code></pre>\n<ol start=\"2\">\n<li>Add <code>sops</code> and <code>age</code> to your <code>environment.systemPackages</code>:</li>\n</ol>\n<pre><code class=\"language-nix\">environment.systemPackages = [\n    pkgs.sops\n    pkgs.age\n];\n</code></pre>\n<ol start=\"3\">\n<li>Generate a key (This is your <strong>private key</strong> and <strong>MUST NEVER BE COMMITTED TO\nGIT OR SHARED</strong>):</li>\n</ol>\n<pre><code class=\"language-bash\">mkdir -p ~/.config/sops/age\nage-keygen -o ~/.config/sops/age/keys.txt\n</code></pre>\n<p>To get the Public Keys Value, run the following command:</p>\n<pre><code class=\"language-bash\">age-keygen -y ~/.config/sops/age/keys.txt\nage12zlz6lvcdk6eqaewfylg35w0syh58sm7gh53q5vvn7hd7c6nngyseftjxl\n</code></pre>\n<p>Copy the <code>age</code> value it gives you back.</p>\n<ol start=\"4\">\n<li>Create a <code>.sops.yaml</code> in the same directory as your <code>flake.nix</code>:</li>\n</ol>\n<pre><code class=\"language-yaml\"># .sops.yaml\nkeys:\n  # Your personal age public key (from age-keygen -y ~/.config/sops/age/keys.txt)\n  - &amp;personal_age_key age12zlz6lvcdk6eqaewfylg35w0syh58sm7gh53q5vvn7hd7c6nngyseftjxl\n\n  # You can also use PGP keys if you prefer, but age is often simpler\n  # - &amp;personal_pgp_key 0xDEADBEEFCAFE0123\n\ncreation_rules:\n  # This rule applies to any file named 'secrets.yaml' directly in the 'secrets/' directory\n  # or 'secrets/github-deploy-key.yaml' etc.\n  - path_regex: \"secrets/.*\\\\.yaml$\"\n    key_groups:\n      - age:\n          - *personal_age_key\n        # Add host keys for decryption on the target system\n        # sops-nix will automatically pick up the system's SSH host keys\n        # as decryption keys if enabled in your NixOS config.\n        # So you typically don't list them explicitly here unless you\n        # want to restrict it to specific fingerprints, which is rare.\n        # This part ensures your *personal* key can decrypt it.\n</code></pre>\n<p>Save it and move on, this file and <code>sops.nix</code> are safe to version control.</p>\n<ol start=\"5\">\n<li>sops-nix‚Äôs automatic decryption feature using system SSH host keys only works\nwith ed25519 host keys for deriving Age decryption keys. Therefore, for\nsystem decryption, ensure your using ed25519 not rsa keys:</li>\n</ol>\n<pre><code class=\"language-bash\">ssh-keygen -t ed25519 -C \"your_email@example.com\"\n# for multiple keys run something like\nssh-keygen -t ed25519 -f ~/nix-book-deploy-key -C \"deploy-key-nix-book-repo\"\n</code></pre>\n<ol start=\"6\">\n<li>Copy the <strong>PRIVATE</strong> key for each and add them to your secrets directory:</li>\n</ol>\n<p>While in your flake directory:</p>\n<pre><code class=\"language-bash\">mkdir secrets\nsops secrets/github-deploy-key.yaml  # For your github ssh key\n</code></pre>\n<p>When you call a <code>sops</code> command, it will handle the encryption/decryption\ntransparently and open the cleartext file in an editor.</p>\n<p>Editing will happen in the editor that <code>$SOPS_EDITOR</code> or <code>$EDITOR</code> is set to,\nsops will wait for the editor to exit, and then try to reencrypt the file.</p>\n<p>The above command will open a default sops <code>github-deploy-key.yaml</code> in your\n<code>$EDITOR</code>:</p>\n<p>Erase the default <code>sops</code> filler and type <code>github_deploy_key_ed25519: |</code>, move\nyour cursor 1 line down and type <code>:r ~/.ssh/id_ed25519</code> to read the private key\ninto the file and repeat as needed.</p>\n<pre><code class=\"language-yaml\">github_deploy_key_ed25519: |\n  -----BEGIN OPENSSH PRIVATE KEY-----\n  ...\n  -----END OPENSSH PRIVATE KEY-----\n\ngithub_deploy_key_ed25519_nix-book: |\n  -----BEGIN OPENSSH PRIVATE KEY-----\n  ...\n  -----END OPENSSH PRIVATE KEY-----\n</code></pre>\n<p>The <code>-----BEGIN</code> and the rest of the private key <strong>must</strong> be indented 2 spaces</p>\n<p>Ensure sops can decrypt it:</p>\n<pre><code class=\"language-bash\">sops -d secrets/github-deploy-key.yaml\n</code></pre>\n<blockquote>\n<p>‚ùó WARNING: Only ever enter your private keys through the <code>sops</code> command. If\nyou forget and paste them in without the <code>sops</code> command then run <code>git add</code> at\nany point, your git history will have contained an unencrypted secret which is\na nono. Always use the <code>sops</code> command when dealing with files in the <code>secrets</code>\ndirectory, save the file and inspect that it is encrypted on save. If not\nsomething went wrong with the <code>sops</code> process, <strong>do not add it to Git</strong>. If you\ndo, you will be required to rewrite your entire history which can be bad if\nyou‚Äôre collaborating with others. <code>git-filter-repo</code> is one such solution that\nrewrites your history. Just keep this in mind. This happens because Git has a\nprotection that stops you from doing stupid things.</p>\n</blockquote>\n<p>Generate an encrypted password hash with:</p>\n<pre><code class=\"language-bash\">mkpasswd --method=yescrypt &gt; /tmp/password-hash.txt\n# Enter your chosen password and copy the encrypted hash it gives you back\n</code></pre>\n<pre><code class=\"language-bash\">sops secrets/password-hash.yaml      # For your `hashedPasswordFile`\n</code></pre>\n<p>The above command will open your <code>$EDITOR</code> with the file <code>password-hash.yaml</code>,\nadd the following content to it. Replace <code>PasteEncryptedHashHere</code> with the\noutput of the <code>mkpasswd</code> command above:</p>\n<p>Delete the default <code>sops</code> filler, type <code>password_hash:</code> and leave your cursor\nafter the <code>:</code> and type <code>:r /tmp/password-hash.txt</code></p>\n<pre><code class=\"language-yaml\">password_hash: PasteEncryptedHashHere\n</code></pre>\n<p>Ensure sops can decrypt it:</p>\n<pre><code class=\"language-bash\">sops -d secrets/password-hash.yaml\n</code></pre>\n<ol start=\"7\">\n<li>Create a <code>sops.nix</code> and import it or add this directly to your\n<code>configuration.nix</code>:</li>\n</ol>\n<p>My <code>sops.nix</code> is located at <code>~/flake/hosts/hostname/sops.nix</code> and the secrets\ndirectory is located at <code>~/flake/secrets</code> so the path from <code>sops.nix</code> to\n<code>secrets/pasword-hash.yaml</code> would be <code>../../secrets/password-hash.yaml</code></p>\n<p>Another step you can take is to copy your key to a persistent location,\npreparing for impermanence:</p>\n<pre><code class=\"language-bash\">sudo mkdir /persist/sops/age\nsudo cp ~/.config/sops/age/keys.txt /persist/sops/age/keys.txt\n</code></pre>\n<p>Then you would change the <code>age.keyFile = \"/persist/sops/age/keys.txt\"</code> to match\nthis location below.</p>\n<pre><code class=\"language-nix\"># ~/flake/hosts/magic/sops.nix  # magic is my hostname\n# hosts/magic/ is also where my configuration.nix is\n{...}: {\n  sops = {\n    defaultSopsFile = ../../.sops.yaml; # Or the correct path to your .sops.yaml\n    # Don't mix sshKeyPaths and keyFile\n    age.sshKeyPaths = [];\n    age.keyFile = \"/persist/sops/age/keys.txt\";\n\n    secrets = {\n      \"password_hash\" = {\n        sopsFile = ../../secrets/password-hash.yaml; # &lt;-- Points to your password hash file\n        owner = \"root\";\n        group = \"root\";\n        mode = \"0400\";\n        neededForUsers = true;\n      };\n      \"github_deploy_key_ed25519_nix-book\" = {\n        sopsFile = ../../secrets/github-deploy-key.yaml;\n        key = \"github_deploy_key_ed25519_nix-book\";\n        owner = \"root\";\n        group = \"root\";\n        mode = \"0400\";\n      };\n      \"github_deploy_key_ed25519\" = {\n        sopsFile = ../../secrets/github-deploy-key.yaml;\n        key = \"github_deploy_key_ed25519\";\n        owner = \"root\";\n        group = \"root\";\n        mode = \"0400\";\n      };\n    };\n  };\n}\n</code></pre>\n<p>Import <code>sops.nix</code> into your <code>configuration.nix</code> or equivalent:</p>\n<pre><code class=\"language-nix\"># configuration.nix\nimports = [\n  ./sops.nix # Assuming sops.nix is in the same directory as configuration.nix, adjust path as needed\n  # ... other imports\n];\n</code></pre>\n<blockquote>\n<p>‚ùó NOTE: You may see in the sops quickstart guide that if you‚Äôre using\nimpermanence, the key used for secret decryption (<code>sops.age.keyFile</code>) must be\nin a persistent directory, loaded early enough during the boot process. If you\nare using the btrfs subvolume layout you don‚Äôt need to worry about this\nbecause your home will be on its own partition when only the root partition is\nwiped on reboot. Adding <code>neededForUsers = true;</code> tells <code>sops-nix</code> to decrypt\nand make that secret available earlier in the boot process specifically,\nbefore user and group accounts are created.</p>\n</blockquote>\n<p>You typically use <code>age.sshKeyPaths</code> for <strong>system-level secrets</strong> with a\npersistent SSH host key</p>\n<p>For <strong>user-level secrets</strong>, use <code>age.keyFile</code> pointing to your Age private key,\nstored in a safe persistent location.</p>\n<p>For reproducibility, keep your key files in a persistent, predictable path and\ndocument which keys are used for which secrets in your <code>.sops.yaml</code>.</p>\n<p>If you don‚Äôt need both <code>age.keyFile</code> and <code>age.sshKeyPaths</code> it can reduce\ncomplexity to use one or the other. Although most people may choose one, it‚Äôs\nnot bad to use both it just adds complexity.</p>\n<p>And finally use the password-hash for your <code>hashedPasswordFile</code> for your user,\nmy user is <code>jr</code> so I added this:</p>\n<pre><code class=\"language-nix\"># ... snip ...\n    users.users = {\n      # ${username} = {\n      jr = {\n        homeMode = \"755\";\n        isNormalUser = true;\n        # description = userVars.gitUsername;\n        hashedPasswordFile = config.sops.secrets.password_hash.path;\n  # ...snip...\n</code></pre>\n<p>By integrating SOPS with NixOS through <code>sops-nix</code>, you gain a modern, secure,\nand reproducible way to manage sensitive secrets. Unlike traditional approaches\nwhere secrets are often scattered in ad hoc locations, referenced by absolute\npaths, or managed outside version control, <code>sops-nix</code> keeps your secrets\nencrypted, declarative, and version-control friendly.</p>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/installation/enc/encrypted_impermanence.html",
      "url": "https://saylesss88.github.io/installation/enc/encrypted_impermanence.html",
      "title": "Impermanence (Encrypted)",
      "content_html": "<h1>Encrypted Impermanence</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<blockquote>\n<p>‚ùó Important Note: This guide details a setup involving encrypted partitions\nand impermanent NixOS. While powerful, such configurations require careful\nattention to detail. Incorrect steps, especially concerning encryption keys or\npersistent data paths, can lead to <strong>permanent data loss</strong>. Please read all\ninstructions thoroughly before proceeding and consider backing up any critical\ndata beforehand. This has only been tested with the disk layout described in\n<a href=\"https://saylesss88.github.io/installation/encrypted_manual.html\">Encrypted Setups</a></p>\n</blockquote>\n<p>As a system operates, it gradually accumulates state on its root partition. This\nstate is stored in various directories such as <code>/etc</code> and <code>/var</code>, capturing all\nthe configuration changes, logs, and other modifications‚Äîwhether they‚Äôre\nwell-documented or the result of ad-hoc adjustments made while setting up and\nrunning services.</p>\n<p><strong>Impermanence</strong>,in the context of operating systems, refers to a setup where\nthe majority of the system‚Äôs root filesystem (<code>/</code>) is reset to a pristine state\non every reboot. This means any changes made to the system (e.g., installing new\npackages, modifying system files outside of configuration management, creating\ntemporary files) are discarded upon shutdown or reboot.</p>\n<p>Having an impermanent root and <code>/tmp</code> has some security benefits as well. By\nreducing your persistent footprint you reduce your chance of leaving behind\nsensitive activity or data. Since Nix can boot with only <code>/nix</code> and <code>/boot</code>,\nexperienced users familiar with ‚Äústateless‚Äù systems can take advantage of this\nsmaller attack surface.</p>\n<p>Although this setup does not use <code>/tmp</code> as the root filesystem, the root itself\nis restored to its original state upon each reboot, as it was at installation.\nHowever, by configuring <code>/tmp</code> to reside in RAM, you ensure that temporary files\nincluding sensitive data like passwords are stored only in volatile memory and\nare automatically cleared on shutdown or reboot. This significantly enhances the\nsecurity of temporary data by preventing it from ever being written to disk.</p>\n<h3>Getting Started</h3>\n<ol>\n<li>Add impermanence to your <code>flake.nix</code>. You will change the <code>hostname</code> in the\nflake to match your <code>networking.hostName</code>.</li>\n</ol>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    disko.url = \"github:nix-community/disko/latest\";\n    disko.inputs.nixpkgs.follows = \"nixpkgs\";\n    impermanence.url = \"github:nix-community/impermanence\";\n  };\n\n  outputs = inputs@{ nixpkgs, ... }: {\n    nixosConfigurations = {\n      hostname = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n          inputs.disko.nixosModules.disko\n          inputs.impermanence.nixosModules.impermanence\n        ];\n      };\n    };\n  };\n}\n</code></pre>\n<ol start=\"2\">\n<li>Discover where your root subvolume is located with <code>findmnt</code>:</li>\n</ol>\n<p>If you followed the\n<a href=\"https://saylesss88.github.io/installation/encrypted_manual.html\">Encrypted Setups</a>\nguide, your encrypted subvolume should be located at:\n<code>/dev/mapper/cryptroot /mnt</code></p>\n<ul>\n<li>Your encrypted Btrfs partition, once unlocked by LUKS, will be available at\n<code>/dev/mapper/cryptroot</code> as configured here in the <code>disk-config.nix</code>:</li>\n</ul>\n<pre><code class=\"language-nix\"># disk-config2.nix\n# ... snip ...\n            luks = {\n              size = \"100%\";\n              label = \"luks\";\n              content = {\n                type = \"luks\";\n                name = \"cryptroot\";\n                content = {\n# ... snip ...\n</code></pre>\n<p>Double check that the paths exist:</p>\n<pre><code class=\"language-bash\">cd /dev/mapper/crypt&lt;TAB&gt;  # autocomplete should fill out /dev/mapper/cryptroot\n</code></pre>\n<ol start=\"3\">\n<li>Create an <code>impermanence.nix</code>:</li>\n</ol>\n<p>Now, create a new file named <code>impermanence.nix</code> in your configuration directory\n(i.e. your flake directory). This file will contain all the specific settings\nfor your impermanent setup, including BTRFS subvolume management and persistent\ndata locations. Since this file is right next to your <code>configuration.nix</code>,\nyou‚Äôll just add an <code>imports = [ ./impermanence.nix ]</code> to your\n<code>configuration.nix</code> apply it to your configuration.</p>\n<pre><code class=\"language-nix\">{\n  config,\n  lib,\n  ...\n}: {\n  boot.initrd.postDeviceCommands = lib.mkAfter ''\n    echo \"Rollback running\" &gt; /mnt/rollback.log\n     mkdir -p /mnt\n     mount -t btrfs /dev/mapper/cryptroot /mnt\n\n     # Recursively delete all nested subvolumes inside /mnt/root\n     btrfs subvolume list -o /mnt/root | cut -f9 -d' ' | while read subvolume; do\n       echo \"Deleting /$subvolume subvolume...\" &gt;&gt; /mnt/rollback.log\n       btrfs subvolume delete \"/mnt/$subvolume\"\n     done\n\n     echo \"Deleting /root subvolume...\" &gt;&gt; /mnt/rollback.log\n     btrfs subvolume delete /mnt/root\n\n     echo \"Restoring blank /root subvolume...\" &gt;&gt; /mnt/rollback.log\n     btrfs subvolume snapshot /mnt/root-blank /mnt/root\n\n     umount /mnt\n  '';\n\n  environment.persistence.\"/persist\" = {\n    directories = [\n      \"/etc\"\n      \"/var/spool\"\n      \"/srv\"\n      \"/etc/NetworkManager/system-connections\"\n      \"/var/lib/bluetooth\"\n    ];\n    files = [\n      # \"/etc/machine-id\"\n      # Add more files you want to persist\n    ];\n  };\n\n# optional quality of life setting\n  security.sudo.extraConfig = ''\n    Defaults lecture = never\n  '';\n}\n</code></pre>\n<ul>\n<li><code>/mnt/rollback.log</code>: this log will be available during the boot process for\ndebugging if the rollback fails, but won‚Äôt persist.</li>\n</ul>\n<p>With the above impermanence script, the btrfs subvolumes are deleted recursively\nand replaced with the <code>root-blank</code> snapshot we took during the install.</p>\n<p>I have commented out <code>\"/etc/machine-id\"</code> because we already copied over all of\nthe files to their persistent location and the above setting would work once and\nthen cause a conflict.</p>\n<h2>configuration.nix changes</h2>\n<pre><code class=\"language-nix\"># configuration.nix\n  boot.initrd.luks.devices = {\n    cryptroot = {\n      device = \"/dev/disk/by-partlabel/luks\";\n      allowDiscards = true;\n      preLVM = true;\n    };\n  };\n</code></pre>\n<ul>\n<li>This defines how your system‚Äôs initial ramdisk (<code>initrd</code>) should handle a\nspecific encrypted disk during the boot process. It helps with timing and is a\nmore robust way of telling Nix that we are using an encrypted disk.</li>\n</ul>\n<p>The following is optional to enable <code>autoScrub</code> for btrfs, the wiki shows\n<code>interval = \"monthly\";</code> FYI.</p>\n<pre><code class=\"language-nix\"># configuration.nix\n  services.btrfs.autoScrub = {\n    enable = true;\n    interval = \"weekly\";\n    fileSystems = [\"/\"];\n  };\n</code></pre>\n<ul>\n<li>Remember to ensure that your <code>hostname</code> in your <code>configuration.nix</code> matches\nthe <code>hostname</code> in your <code>flake.nix</code>.</li>\n</ul>\n<h3>Applying Your Impermanence Configuration</h3>\n<p>Once you have completed all the steps and created or modified the necessary\nfiles (<code>flake.nix</code>, <code>impermanence.nix</code>), you need to apply these changes to your\nNixOS system.</p>\n<ol>\n<li>Navigate to your NixOS configuration directory (where your <code>flake.nix</code> is\nlocated).</li>\n</ol>\n<pre><code class=\"language-bash\">cd /path/to/your/flake\n</code></pre>\n<ol start=\"2\">\n<li>Rebuild and Switch: Execute the <code>nixos-rebuild switch</code> command. This command\nwill:</li>\n</ol>\n<ul>\n<li>\n<p>Evaluate your <code>flake.nix</code> and the modules it imports (including your new\n<code>impermanence.nix</code>).</p>\n</li>\n<li>\n<p>Build a new NixOS system closure based on your updated configuration.</p>\n</li>\n<li>\n<p>Activate the new system configuration, making it the current running system.</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">sudo nixos-rebuild switch --flake .#hostname # Replace 'hostname' with your actual system hostname\n</code></pre>\n<ol start=\"3\">\n<li>Perform an Impermanence Test (Before Reboot):</li>\n</ol>\n<ul>\n<li>Before you reboot, create a temporary directory and file in a non-persistent\nlocation. Since you haven‚Äôt explicitly added <code>/imperm_test</code> to your\n<code>environment.persistence.\"/persist\"</code> directories, this file should not survive\na reboot.</li>\n</ul>\n<pre><code class=\"language-bash\">mkdir /imperm_test\necho \"This should be Gone after Reboot\" | sudo tee /imperm_test/testfile\nls -l /imperm_test/testfile # Verify the file exists\ncat /imperm_test/testfile # Verify content\n</code></pre>\n<ol start=\"4\">\n<li>Reboot Your System: For the impermanence setup to take full effect and for\nyour root filesystem to be reset for the first time, you must reboot your\nmachine.</li>\n</ol>\n<pre><code class=\"language-bash\">sudo reboot\n</code></pre>\n<ol start=\"5\">\n<li>Verify Impermanence (After Reboot):</li>\n</ol>\n<ul>\n<li>After the system has rebooted, check if the test directory and file still\nexist:</li>\n</ul>\n<pre><code class=\"language-bash\">ls -l /imperm_test/testfile\n</code></pre>\n<p>You should see an output like <code>ls: cannot access '/imperm_test/testfile'</code>: No\nsuch file or directory. This confirms that the <code>/imperm_test</code> directory and its\ncontents were indeed ephemeral and were removed during the reboot process,\nindicating your impermanence setup is working correctly!</p>\n<p>Your system should now come up with a fresh root filesystem, and only the data\nspecified in your <code>environment.persistence.\"/persist\"</code> configuration will be\npersistent.</p>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/installation/enc/enc_install.html",
      "url": "https://saylesss88.github.io/installation/enc/enc_install.html",
      "title": "Encrypted Install",
      "content_html": "<h1>Encrypted Setups</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p>NixOS supports file systems that are encrypted using LUKS (Linux Unified Key\nSetup). This guide walks you through an encrypted NixOS installation using Disko\nfor disk management and Btrfs for subvolumes. It is designed for users who want\nfull disk encryption and a modern filesystem layout. If you prefer an\nunencrypted setup, you can skip the LUKS and encryption steps, but this guide\nfocuses on security and flexibility.</p>\n<ul>\n<li>For Unencrypted layout\n<a href=\"https://saylesss88.github.io/installation/unencrypted/unencrypted.html\">Click Here</a></li>\n</ul>\n<p>If you choose to set up impermanence, ensure it matches your install. Encrypted\nSetup with Encrypted Impermanence and Unencrypted Setup with Unencrypted\nImpermanence.</p>\n<blockquote>\n<p>‚ùó NOTE: This is a bit convoluted, there are a few paths you can follow. If\nyou choose to use the starter repo (<a href=\"https://github.com/saylesss88/my-flake\">https://github.com/saylesss88/my-flake</a>)\njust follow the included README and use this for reference.</p>\n</blockquote>\n<h2>What does LUKS Encryption Protect?</h2>\n<p>It‚Äôs important to understand what disk encryption protects and what it doesn‚Äôt\nprotect so you don‚Äôt have any misconceptions about how safe your data is.</p>\n<ul>\n<li>\n<p><a href=\"https://wiki.nixos.org/wiki/Full_Disk_Encryption\">NixOS Wiki FDE</a></p>\n</li>\n<li>\n<p><a href=\"https://wiki.archlinux.org/title/Data-at-rest_encryption\">Arch Wiki Data-at-rest encryption</a></p>\n</li>\n<li>\n<p><a href=\"https://0pointer.net/blog/authenticated-boot-and-disk-encryption-on-linux.html\">Authenticated Booot and DE on Linux</a></p>\n</li>\n<li>\n<p><a href=\"https://oddlama.org/blog/bypassing-disk-encryption-with-tpm2-unlock/\">Bypassing FDE with TPM2 Unlock</a></p>\n</li>\n</ul>\n<p><strong>What LUKS Protects</strong>:</p>\n<ul>\n<li>\n<p><strong>Data Confidentiality at Rest</strong>: LUKS encrypts entire block devices (such as\ndisk partitions or whole drives), ensuring that all data stored on the\nencrypted device is unreadable without the correct decryption key or\npassphrase. This protects sensitive information from unauthorized access if\nthe device is lost, stolen, or physically accessed by an attacker.</p>\n</li>\n<li>\n<p><strong>Physical Security</strong>: If someone gains physical possession of your device\n(for example, by stealing your laptop or removing a hard drive), LUKS ensures\nthe data remains inaccessible and appears as random, meaningless bytes without\nthe correct credentials.</p>\n</li>\n<li>\n<p><strong>Protection Against Offline Attacks</strong>: LUKS defends against attackers who\nattempt to bypass the operating system by booting from another device or\nremoving the drive and mounting it elsewhere. Without the decryption key, the\ndata remains protected.</p>\n</li>\n</ul>\n<p><strong>What LUKS Does Not Protect</strong>:</p>\n<ul>\n<li>\n<p><strong>Data in Use</strong>: Once the system is booted and the encrypted device is\nunlocked, the data becomes accessible to the operating system and any user or\nprocess with the necessary permissions. LUKS does not protect against attacks\non a running system, such as malware, remote exploits, or unauthorized users\nwith access to an unlocked session.</p>\n</li>\n<li>\n<p><strong>File-Level Access Control</strong>: LUKS encrypts entire partitions or disks, not\nindividual files or directories. It does not provide granular file-level\nencryption or access control within the operating system.</p>\n</li>\n<li>\n<p><strong>Network Attacks</strong>: LUKS only protects data stored on disk. It does not\nencrypt data transmitted over networks or protect against network-based\nattacks.</p>\n</li>\n<li>\n<p><strong>Bootloader and EFI Partitions</strong>: The initial bootloader or EFI system\npartition cannot be encrypted with LUKS, so some parts of the boot process may\nremain exposed unless additional measures are taken. (i.e., Secure Boot,\nadditional passwords, TPM2)</p>\n</li>\n</ul>\n<p>To Sum it Up: LUKS encryption protects the confidentiality of all data stored on\nan encrypted block device by making it unreadable without the correct passphrase\nor key. This ensures that, if your device is lost or stolen, your data remains\nsecure and inaccessible to unauthorized users. However, LUKS does not protect\ndata once the system is unlocked and running, nor does it provide file-level\nencryption or protect against malware and network attacks. For comprehensive\nsecurity, LUKS should be combined with strong access controls and other security\nbest practices.</p>\n<h2>The Install</h2>\n<ol>\n<li>\n<p>Get the\n<a href=\"https://channels.nixos.org/nixos-25.05/latest-nixos-minimal-x86_64-linux.iso\">Nixos Minimal ISO</a>\nGet it on a usb stick, I use Ventoy with Ventoy2Disk.sh. The following is the\nlink to the\n<a href=\"https://sourceforge.net/projects/ventoy/files/v1.1.05/ventoy-1.1.05-linux.tar.gz/download\">Ventoy TarBall</a>\ndownload, untar it with <code>tar -xzf ventoy-1.1.05-linux.tar.gz</code>, and make it\nexecutable with <code>chmod +x Ventoy2Disk.sh</code>, and finally execute it with\n<code>sudo bash Ventoy2Disk.sh</code> Follow the prompts to finish the install.</p>\n</li>\n<li>\n<p>Configuring Networking</p>\n</li>\n</ol>\n<p>The minimal installer uses <code>wpa_supplicant</code> instead of NetworkManager. Choose\none of the following methods to enable networking:</p>\n<pre><code class=\"language-bash\">sudo systemctl start wpa_supplicant\nwpa_cli\n</code></pre>\n<h3>Option A: Interactive <code>wpa_cli</code></h3>\n<pre><code class=\"language-bash\">&gt; add_network\n0\n\n&gt; set_network 0 ssid \"myhomenetwork\"\nOK\n\n&gt; set_network 0 psk \"mypassword\"\nOK\n\n&gt; enable_network 0\nOK\n</code></pre>\n<p>To exit type <code>quit</code>, then check your connection with <code>ping google.com</code>.</p>\n<h3>Option B: Non-Interactive <code>wpa_passphrase</code></h3>\n<p>This method is quicker for known networks and persists the configuration for the\nlive environment.</p>\n<p>First, identify your wireless interface name (e.g., <code>wlan0</code>) using <code>ip a</code>.</p>\n<pre><code class=\"language-bash\">sudo systemctl start wpa_supplicant # Ensure wpa_supplicant is running\n# This command generates the config and appends it to a file specific to wlan0\nsudo wpa_passphrase \"myhomenetwork\" \"mypassword\" | sudo tee /etc/wpa_supplicant/wpa_supplicant-wlan0.conf\nsudo systemctl restart wpa_supplicant@wlan0.service\n</code></pre>\n<p>After either method, exit <code>wpa_cli</code> with <code>quit</code>. Then test your connection:</p>\n<pre><code class=\"language-bash\">ping 1.1.1.1\n</code></pre>\n<ol start=\"3\">\n<li>Get your Disk Name with <code>lsblk</code></li>\n</ol>\n<p>The output should be something like:</p>\n<pre><code class=\"language-bash\">NAME ¬† ¬† ¬† ¬†MAJ:MIN RM ¬† SIZE RO TYPE MOUNTPOINTS\nnvme0n1 ¬† ¬† 259:0 ¬† ¬†0 ¬† 1,8T ¬†0 disk\n</code></pre>\n<blockquote>\n<p>‚ùó From here, you can either</p>\n</blockquote>\n<ol start=\"4\">\n<li>Copy the disk configuration to your machine. You can choose one from the\n<a href=\"https://github.com/nix-community/disko/tree/master/example\">examples directory</a>.</li>\n</ol>\n<p>There is still a starter repo that can save you some typing, make sure to\ncarefully review if you decide to use it:</p>\n<pre><code class=\"language-bash\">export NIX_CONFIG='experimental-features = nix-command flakes'\nexport EDITOR='hx' # or 'vi'\nnix-shell -p git yazi helix mkpasswd\ngit config --global user.name \"gitUsername\"\ngit config --global user.email \"gitEmail\"\n# OPTIONAL starter repo containing disk-config set up for impermanence\ngit clone https://github.com/saylesss88/my-flake.git\n</code></pre>\n<p>I prefer <code>helix</code> here as it‚Äôs defaults are great. (i.e., auto closing brackets\nand much more)</p>\n<p>If you choose to use the starter repo you won‚Äôt need to run the next command as\nit is already populated in the repo and should use the\n<a href=\"https://github.com/saylesss88/my-flake\">Starter Repo README</a> most of the rest\nof the guide is for manual disko without the starter repo.</p>\n<p>If you click on the layout you want then click the <code>Raw</code> button near the top,\nthen copy the <code>url</code> and use it in the following command:</p>\n<pre><code class=\"language-bash\">cd /tmp\ncurl https://raw.githubusercontent.com/nix-community/disko/refs/heads/master/example/luks-btrfs-subvolumes.nix -o /tmp/disk-config.nix\n</code></pre>\n<p>The above curl command is to the <code>luks-btrfs-subvolumes.nix</code> layout.</p>\n<ol start=\"5\">\n<li>Make Necessary changes, I prepared mine for impermanence with the following:</li>\n</ol>\n<pre><code class=\"language-bash\">hx /tmp/disk-config.nix\n</code></pre>\n<p>Make sure you identify your system disk name with <code>lsblk</code> and change the\n<code>device</code> attribute below to match your disk.</p>\n<pre><code class=\"language-bash\">lsblk\nnvme0n1       259:0    0 476.9G  0 disk\n‚îú‚îÄnvme0n1p1   259:1    0   512M  0 part  /boot\n‚îî‚îÄnvme0n1p2   259:2    0 476.4G  0 part\n</code></pre>\n<p>My disk is <code>nvme0n1</code>, change below to match yours:</p>\n<pre><code class=\"language-nix\">{\n  disko.devices = {\n    disk = {\n      nvme0n1 = {\n        type = \"disk\";\n        # Make sure this is correct with `lsblk`\n        device = \"/dev/nvme0n1\";\n        content = {\n          type = \"gpt\";\n          partitions = {\n            ESP = {\n              label = \"boot\";\n              name = \"ESP\";\n              size = \"1G\";\n              type = \"EF00\";\n              content = {\n                type = \"filesystem\";\n                format = \"vfat\";\n                mountpoint = \"/boot\";\n                mountOptions = [\n                  \"defaults\"\n                ];\n              };\n            };\n            luks = {\n              size = \"100%\";\n              label = \"luks\";\n              content = {\n                type = \"luks\";\n                name = \"cryptroot\";\n                content = {\n                  type = \"btrfs\";\n                  extraArgs = [\"-L\" \"nixos\" \"-f\"];\n                  subvolumes = {\n                    \"/root\" = {\n                      mountpoint = \"/\";\n                      mountOptions = [\"subvol=root\" \"compress=zstd\" \"noatime\"];\n                    };\n                    \"/root-blank\" = {\n                      mountOptions = [\"subvol=root-blank\" \"nodatacow\" \"noatime\"];\n                    };\n                    \"/home\" = {\n                      mountpoint = \"/home\";\n                      mountOptions = [\"subvol=home\" \"compress=zstd\" \"noatime\"];\n                    };\n                    \"/nix\" = {\n                      mountpoint = \"/nix\";\n                      mountOptions = [\"subvol=nix\" \"compress=zstd\" \"noatime\"];\n                    };\n                    \"/persist\" = {\n                      mountpoint = \"/persist\";\n                      mountOptions = [\"subvol=persist\" \"compress=zstd\" \"noatime\"];\n                    };\n                    \"/log\" = {\n                      mountpoint = \"/var/log\";\n                      mountOptions = [\"subvol=log\" \"compress=zstd\" \"noatime\"];\n                    };\n                    \"/lib\" = {\n                      mountpoint = \"/var/lib\";\n                      mountOptions = [\"subvol=lib\" \"compress=zstd\" \"noatime\"];\n                    };\n                    \"/persist/swap\" = {\n                      mountpoint = \"/persist/swap\";\n                      mountOptions = [\"subvol=swap\" \"noatime\" \"nodatacow\" \"compress=no\"];\n                      swap.swapfile.size = \"18G\";\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n\n  fileSystems.\"/persist\".neededForBoot = true;\n  fileSystems.\"/var/log\".neededForBoot = true;\n  fileSystems.\"/var/lib\".neededForBoot = true;\n}\n</code></pre>\n<p>I have 16G of RAM so to be safe for hibernation I chose to give it some extra\nspace. The boot partition is 1G, this extra space is for specialisations and\nlanzaboote.</p>\n<p>or for a swapfile:</p>\n<pre><code class=\"language-nix\">swapDevices = [\n  {\n    device = \"/persist/swap/swapfile\";\n    size = 18 * 1024; # Size in MB (18GB)\n    # or\n    # size = 16384; # Size in MB (16G);\n  }\n];\n</code></pre>\n<h2>Setting up zram and /tmp on RAM</h2>\n<p>While <code>/tmp</code> is handled by <code>tmpfs</code> (as shown the below <code>configuration.nix</code>), you\ncan further enhance memory efficiency with <code>zram</code> for compressed swap, as shown\nbelow.</p>\n<blockquote>\n<pre><code class=\"language-nix\">{\n  lib,\n  config,\n  ...\n}: let\n  cfg = config.custom.zram;\nin {\n  options.custom.zram = {\n    enable = lib.mkEnableOption \"Enable utils module\";\n  };\n\n  config = lib.mkIf cfg.enable {\n    zramSwap = {\n      enable = true;\n      # one of \"lzo\", \"lz4\", \"zstd\"\n      algorithm = \"zstd\";\n       priority = 5;\n       memoryPercent = 50;\n    };\n  };\n}\n</code></pre>\n<p>And in your <code>configuration.nix</code> you would add:</p>\n<pre><code class=\"language-nix\"># configuration.nix\ncustom = {\n    zram.enable = true;\n};\n</code></pre>\n</blockquote>\n<p>After adding the above module and rebuilding, you can see it with:</p>\n<pre><code class=\"language-bash\">swapon --show\nNAME       TYPE      SIZE USED PRIO\n/dev/zram0 partition 7.5G   0B    5\n</code></pre>\n<ol start=\"6\">\n<li>Run disko to partition, format and mount your disks. <strong>Warning</strong> this will\nwipe <strong>EVERYTHING</strong> on your disk. Disko doesn‚Äôt work with dual boot.</li>\n</ol>\n<pre><code class=\"language-bash\">sudo nix --experimental-features \"nix-command flakes\" run github:nix-community/disko/latest -- --mode destroy,format,mount /tmp/disk-config.nix\n</code></pre>\n<p>Check it with the following:</p>\n<pre><code class=\"language-bash\">mount | grep /mnt\n</code></pre>\n<p>The output for an <code>nvme0n1</code> disk would be similar to the following:</p>\n<pre><code class=\"language-bash\">#... snip ...\n/dev/nvme0n1p2 on /mnt type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=285,subvol=/root)\n/dev/nvme0n1p2 on /mnt/persist type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=261,subvol=/persist)\n/dev/nvme0n1p2 on /mnt/etc type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=261,subvol=/persist)\n/dev/nvme0n1p2 on /mnt/nix type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=260,subvol=/nix)\n/dev/nvme0n1p2 on /mnt/var/lib type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=258,subvol=/lib)\n/dev/nvme0n1p2 on /mnt/var/log type btrfs (rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=259,subvol=/log)\n/dev/nvme0n1p2 on /mnt/nix/store type btrfs (ro,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=260,subvol=/nix)\n# ... snip ...\n</code></pre>\n<ol start=\"7\">\n<li>Generate necessary files, here we use <code>--no-filesystems</code> because disko\nhandles the <code>fileSystems</code> attribute for us.</li>\n</ol>\n<pre><code class=\"language-bash\">nixos-generate-config --no-filesystems --root /mnt\n</code></pre>\n<ul>\n<li>The above command will place a <code>configuration.nix</code> and\n<code>hardware-configuration.nix</code> in <code>/mnt/etc/nixos/</code></li>\n</ul>\n<p>It may be helpful to add a couple things to your <code>configuration.nix</code> now, while\nit‚Äôs in its default location. You can just add what you want and rebuild once\nwith <code>sudo nixos-rebuild switch</code> and move on. (i.e. <code>git</code>, an editor, etc.).</p>\n<h3>Setting a Flake for your minimal Install</h3>\n<ol start=\"8\">\n<li>Create the flake in your home directory to avoid needing to use sudo for\nevery command:</li>\n</ol>\n<pre><code class=\"language-bash\">cd   # Move to home directory\nmkdir flake\ncd /mnt/etc/nixos/\nsudo mv hardware-configuration.nix configuration.nix ~/flake/\nsudo mv /tmp/disk-config.nix ~/flake/\n</code></pre>\n<pre><code class=\"language-bash\">cd flake\nhx flake.nix\n</code></pre>\n<blockquote>\n<p>You‚Äôll change <code>hostName = nixpkgs.lib.nixosSystem</code> to your chosen hostname,\n(e.g. <code>magic = nixpkgs.lib.nixosSystem</code>). This will be the same as your\n<code>networking.hostName = \"magic\";</code> in your <code>configuration.nix</code> that we will set\nup shortly.</p>\n</blockquote>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    disko.url = \"github:nix-community/disko/latest\";\n    disko.inputs.nixpkgs.follows = \"nixpkgs\";\n    # impermanence.url = \"github:nix-community/impermanence\";\n  };\n\n  outputs = inputs@{ nixpkgs, ... }: {\n    nixosConfigurations = {\n      # Change `hostName` to your chosen host name\n      nixos = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n          inputs.disko.nixosModules.disko\n          # inputs.impermanence.nixosModules.impermanence\n        ];\n      };\n    };\n  };\n}\n</code></pre>\n<ol start=\"9\">\n<li>Edit <code>configuration.nix</code> with what is required, the following are required, I\nclone my original flake repo and move the pieces into place but it‚Äôs fairly\neasy to just type it all out:</li>\n</ol>\n<ul>\n<li>\n<p>Bootloader, (e.g., <code>boot.loader.systemd-boot.enable = true;</code>)</p>\n</li>\n<li>\n<p>User, the example uses <code>username</code> change this to your chosen username. If you\ndon‚Äôt set your hostname it will be <code>nixos</code>.</p>\n</li>\n<li>\n<p>Networking, <code>networking.networkmanager.enable = true;</code></p>\n</li>\n<li>\n<p><code>hardware-configuration.nix</code> &amp; <code>disk-config.nix</code> for this setup</p>\n</li>\n<li>\n<p>If you type this out by hand and mess up a single character, you will have to\nstart over completely. A fairly safe way to do this is with <code>vim</code> or <code>hx</code> and\nredirect the hashed pass to a <code>/tmp/pass.txt</code>, you can then read it into your\n<code>users.nix</code>:</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">mkpasswd --method=yescrypt &gt; /tmp/pass.txt\n# Enter your chosen password\n</code></pre>\n<p>And then when inside <code>configuration.nix</code>, move to the line where you want the\nhashed password and type <code>:r /tmp/pass.txt</code> to read the hash into your current\nfile.</p>\n<pre><code class=\"language-nix\"># configuration.nix\n{\n  config,\n  lib,\n  pkgs,\n  inputs,\n  ...\n}: {\n  imports = [\n    # Include the results of the hardware scan.\n    ./hardware-configuration.nix\n    ./disk-config.nix\n  ];\n\n  # systemd Stage 1: if enabled, it handles unlocking of LUKS-encrypted volumes during boot.\n    boot.initrd.luks.devices = {\n    cryptroot = {\n      device = \"/dev/disk/by-partlabel/luks\";\n      allowDiscards = true;\n    };\n  };\n\n  # This complements using zram, putting /tmp on RAM\n    boot = {\n    tmp = {\n      useTmpfs = true;\n      tmpfsSize = \"50%\";\n    };\n  };\n\n  # Enable autoScrub for btrfs\n    services.btrfs.autoScrub = {\n    enable = true;\n    interval = \"weekly\";\n    fileSystems = [\"/\"];\n  };\n\n\n  # Change me!\n  networking.hostName = \"nixos\"; # This will match the `hostname` of your flake\n\n  networking.networkmanager.enable = true;\n\n  boot.loader.systemd-boot.enable = true; # (for UEFI systems only)\n  # List packages installed in system profile.\n  # You can use https://search.nixos.org/ to find more packages (and options).\n  environment.systemPackages = with pkgs; [\n    vim # Do not forget to add an editor to edit configuration.nix! The Nano editor is also installed by default.\n    #   wget\n    git\n  ];\n\n  time.timeZone = \"America/New_York\";\n\n# Change me to your chosen username (i.e. change nixosUser to your username)\n  users.users.nixosUser = {\n    isNormalUser = true;\n    extraGroups = [ \"wheel\" \"networkmanager\" ]; # Add \"wheel\" for sudo access\n    initialHashedPassword = \"READ_MKPASSWD_OUTPUT_HERE\"; # &lt;-- This is where it goes!\n    # home = \"/home/nixos\"; # Optional: Disko typically handles home subvolumes\n  };\n  # Change me to match your chosen username\n  users.group.nixosUser = {};\n\n  console.keyMap = \"us\";\n\n  nixpkgs.config.allowUnfree = true;\n\n  system.stateVersion = \"25.05\";\n}\n</code></pre>\n<p>Although, just adding the <code>disk-config.nix</code> works for prompting you for your\nencryption passphrase adding the following is a more robust way of ensuring Nix\nis aware of this:</p>\n<pre><code class=\"language-nix\">    boot.initrd.luks.devices = {\n    cryptroot = {\n      device = \"/dev/disk/by-partlabel/luks\";\n      allowDiscards = true;\n    };\n  };\n</code></pre>\n<ol start=\"10\">\n<li>Move the flake to <code>/mnt/etc/nixos</code> and run <code>nixos-install</code>:</li>\n</ol>\n<pre><code class=\"language-bash\">sudo mv ~/flake /mnt/etc/nixos/\n</code></pre>\n<ul>\n<li>Give everything a quick once over, insuring your host is set in both your\n<code>flake.nix</code>, and <code>configuration.nix</code>. Ensure you changed the username in the\n<code>configuration.nix</code> from <code>nixos</code> to your chosen name, this is the name you‚Äôll\nuse to login after you enter your encryption passphrase.</li>\n</ul>\n<p>The below command uses <code>#nixos</code> because that‚Äôs what the defaults are, you‚Äôll\nchange it to your chosen hostname.</p>\n<pre><code class=\"language-bash\">sudo nixos-install --flake /mnt/etc/nixos/flake#nixos\n</code></pre>\n<ul>\n<li>You will be prompted to enter a new password if everything succeeds.</li>\n</ul>\n<h2>Create a Blank Snapshot of /root</h2>\n<p>This is essential if you plan on using impermanence with this encrypted setup.\nWe take a snapshot of <code>/root</code> while it‚Äôs a clean slate, right after we run disko\nto format the disk.</p>\n<p>To access all of the subvolumes, we have to mount the Btrfs partitions\ntop-level.</p>\n<ol>\n<li>Unlock the LUKS device, if not already unlocked as it should be from running\ndisko:</li>\n</ol>\n<pre><code class=\"language-bash\">sudo cryptsetup open /dev/disk/by-partlabel/luks cryptroot\n</code></pre>\n<ol start=\"2\">\n<li>Mount the Btrfs top-level (<code>subvolid=5</code>):</li>\n</ol>\n<pre><code class=\"language-bash\">sudo mount -o subvolid=5 /dev/mapper/cryptroot /mnt\n</code></pre>\n<ol start=\"3\">\n<li>List the contents:</li>\n</ol>\n<pre><code class=\"language-bash\">ls /mnt\n# you should see something like\nroot   home  nix  persist  log  lib  ...\n</code></pre>\n<ol start=\"4\">\n<li>Now we can take a snapshot of the <code>root</code> subvolume:</li>\n</ol>\n<pre><code class=\"language-bash\">sudo btrfs subvolume snapshot -r /mnt/root /mnt/root-blank\n</code></pre>\n<ol start=\"5\">\n<li>Verify Your Blank Snapshot:</li>\n</ol>\n<p>Before continuing, make sure your blank snapshot exists. This is crucial for\nimpermanence to work properly.</p>\n<pre><code class=\"language-bash\">sudo btrfs subvolume list /mnt\n</code></pre>\n<p>You should see output containing both <code>root</code> and <code>root-blank</code> subvolumes:</p>\n<pre><code class=\"language-bash\">ID 256 gen ... path root\nID 257 gen ... path root-blank\n</code></pre>\n<p>Check that the snapshot is read only, this ensures that our snapshot will remain\nthe same as the day we took it. It was set <code>ro</code> in disko but lets check anyways:</p>\n<pre><code class=\"language-bash\">sudo btrfs property get -ts /mnt/root-blank\n# output should be\nro=true\n</code></pre>\n<ol start=\"5\">\n<li>Make sure to unmount:</li>\n</ol>\n<pre><code class=\"language-bash\">sudo umount /mnt\n</code></pre>\n<ul>\n<li>\n<p>If everything checks out, reboot the system and you should be prompted to\nenter your <code>user</code> and <code>password</code> to login to a shell to get started.</p>\n</li>\n<li>\n<p>The flake will be placed at <code>/etc/nixos/flake</code> after the install and reboot, I\nchoose to move it to my home directory. Since the file was first in <code>/etc</code>\nyou‚Äôll need to adjust the permissions with something like\n<code>sudo chown -R $USER:$USER ~/flake</code> and then you can work on it without\nprivilege escalation. This requires that you create a group for your user as\ndone in the <code>configuration.nix</code> above.</p>\n</li>\n<li>\n<p>You can check the layout of your btrfs system with:</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">sudo btrfs subvolume list /\n</code></pre>\n<h2>Persisting Critical System State</h2>\n<p>The following is a one time operation, we‚Äôre just getting it out of the way now.\nThis moves all of the important system state to a persistant location, further\npreparing for impermanence.</p>\n<p>It‚Äôs essential that you have first run the <code>nixos-install</code> command to populate\nthese directories before copying them over.</p>\n<pre><code class=\"language-bash\">sudo mkdir -p /mnt/persist/etc\nsudo mkdir -p /mnt/persist/var/lib\nsudo mkdir -p /mnt/persist/var/log\nsudo mkdir -p /mnt/persist/home\nsudo mkdir -p /mnt/persist/root\nsudo cp -a /mnt/etc/. /mnt/persist/etc/\nsudo cp -a /mnt/var/lib/. /mnt/persist/var/lib\nsudo cp -a /mnt/var/log/. /mnt/persist/var/log\nsudo cp -a /mnt/home/. /mnt/persist/home/\nsudo cp -a /mnt/root/. /mnt/persist/root/\n</code></pre>\n<p>Since we are in a live environment, after the install and reboot the <code>/mnt</code>\nprefix will be removed.</p>\n<h2>Reboot</h2>\n<p>Now that everything is done, we can safely reboot and ensure that our LUKS\npassword/passphrase is accepted as well as our userlevel password and username.</p>\n<p>After reboot, you can continue to setup\n<a href=\"https://saylesss88.github.io/installation/enc/sops-nix.html\">Sops Encrypted Secrets</a>\nand\n<a href=\"https://saylesss88.github.io/installation/enc/lanzaboote.html\">Lanzaboote Secure Boot</a></p>\n<ul>\n<li>\n<p>To set up impermanence for this specific layout, follow the link\n<a href=\"https://saylesss88.github.io/installation/enc/encrypted_impermanence.html\">Encrypted Impermanence</a></p>\n</li>\n<li>\n<p><a href=\"https://btrfs.readthedocs.io/en/latest/Subvolumes.html\">BTRFS Subvolumes</a></p>\n</li>\n<li>\n<p><a href=\"https://www.freedesktop.org/software/systemd/man/latest/systemd-cryptenroll.html\">systemd-cryptenroll man page</a></p>\n</li>\n<li>\n<p><a href=\"https://uapi-group.org/specifications/specs/linux_tpm_pcr_registry/\">Linux TPM PCR Registry</a></p>\n</li>\n<li>\n<p><a href=\"https://oddlama.org/blog/bypassing-disk-encryption-with-tpm2-unlock/\">Bypassing FDE with TPM2</a></p>\n</li>\n</ul>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/nixpkgs/overlay.html",
      "url": "https://saylesss88.github.io/nixpkgs/overlay.html",
      "title": "Version overrides with Overlays",
      "content_html": "<h1>Nixpkgs Overlays</h1>\n<p>The following is done with a local clone of Nixpkgs located at <code>~/src/nixpkgs</code>.</p>\n<p>In this example, we will create an overlay to override the version of\n<code>btrfs-progs</code>. In the root directory of our local clone of Nixpkgs\n(i.e.<code>~/src/nixpkgs</code>) we can run the following command to locate <code>btrfs-progs</code>\nwithin Nixpkgs:</p>\n<pre><code class=\"language-bash\">fd 'btrfs-progs' .\n./pkgs/by-name/bt/btrfs-progs/\n</code></pre>\n<p>Open the <code>package.nix</code> in the above directory and copy the <code>src</code> block within\nthe <code>stdenv.mkDerivation</code> block like so:</p>\n<pre><code class=\"language-nix\"># package.nix\n  version = \"6.14\";\n\n  src = fetchurl {\n    url = \"mirror://kernel/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v${version}.tar.xz\";\n    hash = \"sha256-31q4BPyzbikcQq2DYfgBrR4QJBtDvTBP5Qzj355+PaE=\";\n  };\n</code></pre>\n<p>When we use the above <code>src</code> block in our overlay we‚Äôll need to add\n<code>src = self.fetchurl</code> for our overlay to have access to <code>fetchurl</code>.</p>\n<p>We will replace the version with our desired version number. To find another\nversion that actually exists we need to check their github repos\n<a href=\"https://github.com/kdave/btrfs-progs/releases\">btrfs-progs Releases</a>. I can see\nthat the previous version was <code>v6.13</code>, lets try that.</p>\n<pre><code class=\"language-bash\">cd ~/src/nixpkgs\nhx overlay.nix\n</code></pre>\n<p>We will change the version to <code>6.13</code> for demonstration purposes. All that is\nreally required is changing the version and 1 character in the <code>hash</code> which\nwould cause a refetch and recalculation of the hash. We will use an empty string\nto follow convention:</p>\n<pre><code class=\"language-nix\"># overlay.nix\nself: super: {\n  btrfs-progs = super.btrfs-progs.overrideAttrs (old: rec {\n      version = \"6.13\";\n\n      # Notice the `self` added here\n      src = self.fetchurl {\n        url = \"mirror://kernel/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v${version}.tar.xz\";\n        hash = \"\";\n      };\n    };\n  });\n}\n</code></pre>\n<p>To build this with the file right from the root of the local Nixpkgs (i.e.\n<code>~/src/nixpkgs</code>) you could run the following. Running the command this way\navoids the impurity of looking it up in the <code>~/.config</code> directory:</p>\n<pre><code class=\"language-bash\">nix-build -A btrfs-progs --arg overlays '[ (import ./overlay.nix) ]'\n</code></pre>\n<p>The compiler will give you back the correct <code>hash</code>:</p>\n<pre><code class=\"language-bash\">specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\ngot:    sha256-ZbPyERellPgAE7QyYg7sxqfisMBeq5cTb/UGx01z7po=\n</code></pre>\n<p>Replace the empty <code>hash</code> with the new hash value we just got from the compiler\nso the <code>overlay.nix</code> would look like this:</p>\n<pre><code class=\"language-nix\">self: super: {\n  btrfs-progs = super.btrfs-progs.overrideAttrs (old: rec {\n    version = \"6.13\";\n\n    src = self.fetchurl {\n      url = \"mirror://kernel/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v${version}.tar.xz\";\n      hash = \"sha256-ZbPyERellPgAE7QyYg7sxqfisMBeq5cTb/UGx01z7po=\";\n    };\n  });\n}\n</code></pre>\n<p>Try building it again:</p>\n<pre><code class=\"language-bash\">nix-build -A btrfs-progs --arg overlays '[ (import ./overlay.nix) ]'\nchecking for references to /build/ in /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13...\ngzipping man pages under /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/share/man/\npatching script interpreter paths in /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13\n/nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/bin/fsck.btrfs: interpreter directive changed from \"#!/bin/sh -f\" to \"/nix/store/xy4jjgw87sbgwylm5kn047d9gkbhsr9x-bash-5.2p37/bin/sh -f\"\nstripping (with command strip and flags -S -p) in  /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/lib /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/bin\n/nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13\n</code></pre>\n<p>We can inspect it with the repl:</p>\n<pre><code class=\"language-bash\">cd ~/src/nixpkgs\nnix repl\nnix-repl&gt; :a import ./. { overlays = [ (import ./overlay.nix) ]; }\nnix-repl&gt; btrfs-progs\n¬´derivation /nix/store/6yxhj84cwcsnrd87rcxbd6w08l9ikc6p-btrfs-progs-6.13.drv¬ª\nnix-repl&gt; btrfs-progs.drvAttrs.buildInputs\n[\n  ¬´derivation /nix/store/yg4llzkcla5rppv8r1iikyamfxg3g4sg-acl-2.3.2.drv¬ª\n  ¬´derivation /nix/store/vqczbcwjnid6bs4cv3skl7kyd6kkzcfx-attr-2.5.2.drv¬ª\n  ¬´derivation /nix/store/xrvx0azszpdh2x0lnldakqx25vfxab19-e2fsprogs-1.47.2.drv¬ª\n  ¬´derivation /nix/store/iil4b8adk615zhp6wmzjx16z1v2f8f4j-util-linux-minimal-2.41.drv¬ª\n  ¬´derivation /nix/store/wwld8wp91m26wz69gp8vzh090sh5ygxd-lzo-2.10.drv¬ª\n  ¬´derivation /nix/store/w4ncw24gdfkbx9779xpgjli5sagi506m-systemd-minimal-libs-257.5.drv¬ª\n  ¬´derivation /nix/store/dmh4lvmq6n8hy56q93kplvnfnlwqzzv5-zlib-1.3.1.drv¬ª\n  ¬´derivation /nix/store/h8iwhnr636dwb72qqcyzp111ajjxgzr2-zstd-1.5.7.drv¬ª\n]\nnix-repl&gt; btrfs-progs.drvAttrs.version\n\"6.13\"\nnix-repl&gt; btrfs-progs.drvAttrs.src\n¬´derivation /nix/store/y5nkz1xczxha4xl93qq3adndyc46dcvf-btrfs-progs-v6.13.tar.xz.drv¬ª\n</code></pre>\n<p>Using <code>:a</code> adds the attributes from the resulting set into scope and avoids\nbringing the entire <code>nixpkgs</code> set into scope.</p>\n<p>To see whats available, you can for example type <code>btrfs-progs.drvAttrs.</code> then\nhit <code>TAB</code>.</p>\n<p>Another way to do this is to move our overlay to the\n<code>~/.config/nixpkgs/overlays</code> directory and rename the file like the following,\nagian this adds an impurity because it relies on your <code>~/.config</code> directory\nwhich is different from user to user:</p>\n<pre><code class=\"language-bash\">mv overlay.nix ~/.config/nixpkgs/overlays/btrfs-progs.nix\ncd ~/src/nixpkgs\nnix-build -A btrfs-progs\nchecking for references to /build/ in /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13...\ngzipping man pages under /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/share/man/\npatching script interpreter paths in /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13\n/nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/bin/fsck.btrfs: interpreter directive changed from \"#!/bin/sh -f\" to \"/nix/store/xy4jjgw87sbgwylm5kn047d9gkbhsr9x-bash-5.2p37/bin/sh -f\"\nstripping (with command strip and flags -S -p) in  /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/lib /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/bin\n/nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13\n</code></pre>\n<h2>Overlays with Flakes</h2>\n<p>In a flake, overlays are defined in the <code>outputs.overlays</code> attribute set of the\n<code>flake.nix</code>.</p>\n<p>They are then applied to <code>nixpkgs</code> inputs using\n<code>inputs.nixpkgs.follows = \"nixpkgs\";</code> (or similar) and the overlays attribute on\nthe input.</p>\n<p>Example of flake usage:</p>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  description = \"My NixOS flake with custom overlays\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n  };\n\n  outputs = { self, nixpkgs, ... }: {\n\n    overlays.myCustomOverlay = final: prev: {\n      btrfs-progs = prev.btrfs-progs.overrideAttrs (old: rec {\n        version = \"6.13\";\n        src = self.fetchurl {\n          url = \"mirror://kernel/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v${version}.tar.xz\";\n          hash = \"sha256-ZbPyERellPgAE7QyYg7sxqfisMBeq5cTb/UGx01z7po=\";\n        };\n      });\n    };\n\n    nixosConfigurations.my-system = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      modules = [\n        # Apply the overlay\n        { nixpkgs.overlays = [ self.overlays.myCustomOverlay ]; }\n        ./configuration.nix\n      ];\n    };\n  };\n}\n</code></pre>\n<pre><code class=\"language-bash\">nix flake show\npath:/home/jr/btrfs-progs?lastModified=1749655369&amp;narHash=sha256-ln6dLiqo7TxStQSXgcIwfbdt7STGw4ZHftZRfWpY/JQ%3D\n‚îú‚îÄ‚îÄ‚îÄnixosConfigurations\n‚îÇ   ‚îî‚îÄ‚îÄ‚îÄmy-system: NixOS configuration\n‚îî‚îÄ‚îÄ‚îÄoverlays\n    ‚îî‚îÄ‚îÄ‚îÄmyCustomOverlay: Nixpkgs overlay\n</code></pre>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/nixpkgs/local_package.html",
      "url": "https://saylesss88.github.io/nixpkgs/local_package.html",
      "title": "Building Local Packages",
      "content_html": "<details>\n<summary> ‚úîÔ∏è Table of Contents</summary>\n<!-- toc -->\n</details>\n<h1>Creating and Building a Local Package within a Nixpkgs Clone</h1>\n<p>This chapter demonstrates the fundamental pattern for creating a package. Every\npackage recipe is a file that declares a function. This function takes the\npackages dependencies as argument.</p>\n<p>In this example we‚Äôll make a simple package with <code>coreutils</code> and build it.\nDemonstrating the process of building and testing a local package.</p>\n<p>This chapter will assume you have already have a cloned fork of Nixpkgs. I\nchoose to clone mine to the <code>~/src/</code> directory.</p>\n<p>You can check out the <code>nixpkgs/pkgs/README.md</code>\n<a href=\"https://github.com/NixOS/nixpkgs/tree/master/pkgs\">Here</a></p>\n<p>The Nixpkgs Contributing Guide can be found\n<a href=\"https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md\">Here</a></p>\n<h2>Create your Package directory and a <code>default.nix</code></h2>\n<p>For this example, we‚Äôll create a package called <code>testPackage</code> and will place it\nin the <code>nixpkgs/pkgs/misc</code> directory.</p>\n<pre><code class=\"language-bash\">cd ~/src/nixpkgs/pkgs/misc\nmkdir testPackage &amp;&amp; cd testPackage\nhx default.nix\n</code></pre>\n<pre><code class=\"language-nix\"># default.nix\n{\n  runCommand,\n  coreutils,\n}:\nrunCommand \"testPackage\" {\n  nativeBuildInputs = [\n    coreutils\n  ];\n} ''\n\n  echo 'This is a Test' &gt; $out\n''\n</code></pre>\n<p>Now we need to add our <code>testPackage</code> to <code>all-packages.nix</code></p>\n<pre><code class=\"language-bash\">cd pkgs/top-level\nhx all-packages.nix\n</code></pre>\n<p><code>all-packages.nix</code> is a centralized module that defines all available package\nexpressions.</p>\n<p>We‚Äôll add our package in the list alphabetically:</p>\n<pre><code class=\"language-nix\"># all-packages.nix\n# `/msc` # editor search inside file\n# Scroll down to t's\n# snip ...\ntermusic = callPackage ../applications/autio/termusic { };\n\n# we add our package here\ntestPackage = callPackage ../misc/testPackage { };\n\ntfk8s = callPackage ../applications/misc/tfk8s { };\n# snip ...\n</code></pre>\n<blockquote>\n<p><code>callPackage</code> is a core utility in Nixpkgs. It takes a Nix expression (like\nour <code>default.nix</code> file, which defines a function) and automatically provides\nthe function with any arguments it declares, by looking them up within the\n<code>pkgs</code> set (or the scope where <code>callPackage</code> is invoked). This means you only\nneed to list the dependencies your package needs in its <code>default.nix</code> function\nsignature, and <code>callPackage</code> will ‚Äúinject‚Äù the correct versions of those\npackages. This is what the <code>callPackage</code> Nix Pill demonstrates at a lower\nlevel.</p>\n</blockquote>\n<h2>Understanding <code>pkgs/by-name/</code> and other locations</h2>\n<p>Nixpkgs uses different conventions for package placement:</p>\n<ul>\n<li>\n<p><strong>Older categories (e.g., <code>pkgs/misc/</code>, <code>pkgs/applications/</code>):</strong> Packages\nwithin these directories typically use <code>default.nix</code> as their definition file\n(e.g., <code>pkgs/misc/testPackage/default.nix</code>). <strong>These packages are NOT\nautomatically included</strong> in the top-level <code>pkgs</code> set; they <em>must</em> be This\nchapter will assume you have already have a cloned fork of Nixpkgs. explicitly\nadded via a <code>callPackage</code> entry in <code>pkgs/top-level/all-packages.nix</code>. This is\nthe method demonstrated in this chapter for our <code>testPackage</code>.</p>\n</li>\n<li>\n<p><strong>The new <code>pkgs/by-name/</code> convention:</strong> This is the <em>preferred location for\nnew packages</em>.</p>\n<ul>\n<li>\n<p>Packages here are placed in a directory structure like\n<code>pkgs/by-name/&lt;first-two-letters&gt;/&lt;package-name&gt;/</code>.</p>\n</li>\n<li>\n<p>Crucially, their main definition file is named <code>package.nix</code> (e.g.,\n<code>pkgs/by-name/te/testPackage/package.nix</code>).</p>\n</li>\n<li>\n<p><strong>Packages placed within <code>pkgs/by-name/</code> are automatically discovered and\nexposed</strong> by Nixpkgs‚Äô top-level <code>pkgs</code> set. They <strong>do not</strong> require a manual\n<code>callPackage</code> entry in <code>all-packages.nix</code>. This results in a more modular\nand scalable approach, reducing manual maintenance.</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>‚ùó : While this example uses <code>pkgs/misc/</code> to demonstrate explicit\n<code>callPackage</code> usage, when contributing a <em>new</em> package to Nixpkgs, you should\nnearly always place it within <code>pkgs/by-name/</code> and name its definition file\n<code>package.nix</code>.</p>\n</blockquote>\n<ul>\n<li>\n<p><a href=\"https://github.com/NixOS/nixpkgs/blob/master/pkgs/by-name/README.md\">pkgs/by-name/README</a></p>\n</li>\n<li>\n<p>There are some\n<a href=\"https://github.com/NixOS/nixpkgs/blob/master/pkgs/by-name/README.md#limitations\">Limitations</a>\nto this approach.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/NixOS/nixpkgs-vet\">nixpkgs-vet</a></p>\n</li>\n</ul>\n<p>Previously, packages were manually added to <code>all-packages.nix</code>. While this is no\nlonger needed in most cases, understanding the old method provides useful\ncontext for troubleshooting legacy configurations or custom integrations.</p>\n<h2>Try Building the Package</h2>\n<p>Move to the root directory of Nixpkgs:</p>\n<pre><code class=\"language-bash\">cd ~/src/nixpkgs\n</code></pre>\n<p>Try building it:</p>\n<pre><code class=\"language-bash\">nix-build -A testPackage\nthis derivation will be built:\nthis derivation will be built:\n  /nix/store/yrbjsxmgzkl24n75sqjfxbpv5cs3b9hc-testPackage.drv\nbuilding '/nix/store/yrbjsxmgzkl24n75sqjfxbpv5cs3b9hc-testPackage.drv'...\n/nix/store/3012zlv30vn6ifihr1jxbg5z3ysw0hl3-testPackage\n</code></pre>\n<p><code>runCommand</code> is a simple builder, it takes 3 arguments. The first is the package\nname the second is the derivation attributes, and the third is the script to\nrun.</p>\n<pre><code class=\"language-bash\">cat ~/src/nixpkgs/result\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n       ‚îÇ File: result\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n   1   ‚îÇ This is a Test\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n</code></pre>\n<pre><code class=\"language-bash\">nix-instantiate --eval -A testPackage.meta.position\n\"/home/jr/src/nixpkgs/pkgs/misc/testPackage/default.nix:6\"\n</code></pre>\n<p>Tools like <code>nix search</code> and the Nixpkgs website use the <code>meta</code> information for\ndocumentation and discoverability. It can also be useful for debugging and helps\nto provide better error messages. The above command shows that the\n<code>meta.position</code> attribute points to the file and line where the package\ndefinition begins, which is very useful for debugging.</p>\n<p>Typically a file will have a <code>meta</code> attribute that looks similar to the\nfollowing:</p>\n<pre><code class=\"language-nix\">meta = with lib; {\n    homepage = \"https://www.openssl.org/\";\n    description = \"A cryptographic library that implements the SSL and TLS protocols\";\n    license = licenses.openssl;\n    platforms = platforms.all;\n} // extraMeta;\n</code></pre>\n<p>For example, the following shows how Nix is able to discover different parts of\nyour configuration:</p>\n<p>Launch the <code>nix repl</code> and load your local flake:</p>\n<pre><code class=\"language-bash\">cd /src\nnix repl\nnix-repl&gt; :lf nixpkgs\nnix-repl&gt; outputs.legacyPackages.x86_64-linux.openssl.meta.position\n\"/nix/store/syvnmj3hhckkbncm94kfkbl76qsdqqj3-source/pkgs/development/libraries/openssl/default.nix:303\"\nnix-repl&gt; builtins.unsafeGetAttrPos \"description\" outputs.legacyPackages.x86_64-linux.openssl.meta\n{\n  column = 9;\n  file = \"/nix/store/syvnmj3hhckkbncm94kfkbl76qsdqqj3-source/pkgs/development/libraries/openssl/default.nix\";\n  line = 303;\n}\n</code></pre>\n<p>Lets create just the <code>meta.description</code> for demonstration purposes.</p>\n<h2>Adding the meta attribute</h2>\n<p>Since we don‚Äôt have a <code>meta</code> attribute this points to a default value that‚Äôs\nincorrect.</p>\n<p>Let‚Äôs add the <code>meta</code> attribute and try it again:</p>\n<pre><code class=\"language-nix\"># default.nix\n{\n  runCommand,\n  coreutils,\n}:\nrunCommand \"testPackage\" {\n  nativeBuildInputs = [\n    coreutils\n  ];\n\n  meta = {\n    description = \"test package\";\n};\n} ''\n\n  echo 'This is a Test' &gt; $out\n''\n</code></pre>\n<pre><code class=\"language-nix\">nix-instantiate --eval -A testPackage.meta.position\n\"/home/jr/src/nixpkgs/pkgs/misc/testPackage/default.nix:11\"\n</code></pre>\n<p>Now it points us to the 11‚Äôth line, right where our <code>meta.description</code> is.</p>\n<p>Let‚Äôs stage our package so nix recognises it:</p>\n<pre><code class=\"language-bash\">cd ~/nixpkgs\ngit add pkgs/misc/testPackage/\nnix edit .#testPackage\n</code></pre>\n<p>I used <code>nix edit</code> here to ensure it was picked up properly.</p>\n<p>The <code>default.nix</code> that we‚Äôve been working on should open in your <code>$EDITOR</code></p>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/nixpkgs/fork_clone_contribute.html",
      "url": "https://saylesss88.github.io/nixpkgs/fork_clone_contribute.html",
      "title": "Fork, Clone, Contribute",
      "content_html": "<h1>Fork, Clone, Contribute</h1>\n<ul>\n<li>\n<p>In the <a href=\"https://github.com/NixOS/nixpkgs\">Nixpkgs</a> Repository.</p>\n</li>\n<li>\n<p>Click Fork, then Create a new Fork.</p>\n</li>\n<li>\n<p>Uncheck the box ‚ÄúOnly fork the <code>master</code> branch‚Äù, for development we will need\nmore branches.</p>\n<ul>\n<li>If you only fork master, you won‚Äôt have the <code>nixos-XX.YY</code> release branches\navailable on your fork when you later try to create a PR against them, or\nwhen you want to create a feature branch from them on your fork.</li>\n</ul>\n</li>\n<li>\n<p>Click <code>&lt;&gt; Code</code> and Clone the Repo. <code>sayls8</code> is the name of my GitHub, yours\nwill obviously be different.</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">git clone git@github.com:sayls8/nixpkgs.git\n</code></pre>\n<p>Figure out the branch that should be used for this change by going through\n<a href=\"https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md#branch-conventions\">this section</a></p>\n<p>When in doubt use <code>master</code>, that‚Äôs where most changes should go. This can be\nchanged later by\n<a href=\"https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md#rebasing-between-branches-ie-from-master-to-staging\">rebasing</a></p>\n<p>Add <a href=\"https://github.com/NixOS/nixpkgs\">Nixpkgs</a> as your upstream:</p>\n<pre><code class=\"language-bash\">cd nixpkgs\n\ngit remote add upstream https://github.com/NixOS/nixpkgs.git\n# Make sure you have the latest changes from upstream Nixpkgs\ngit fetch upstream\n# Show currently configured remote repository\ngit remote -v\norigin  git@github.com:sayls8/nixpkgs.git (fetch)\norigin  git@github.com:sayls8/nixpkgs.git (push)\nupstream        https://github.com/NixOS/nixpkgs.git (fetch)\nupstream        https://github.com/NixOS/nixpkgs.git (push)\n</code></pre>\n<p><strong>Understanding Your Remotes</strong></p>\n<p>This output confirms that:</p>\n<ul>\n<li>\n<p><code>origin</code> is your personal fork on GitHub (<code>sayls8/nixpkgs.git</code>). When you\n<code>git push origin ...</code>, your changes go here.</p>\n</li>\n<li>\n<p><code>upstream</code> is the official Nixpkgs repository (<code>NixOS/nixpkgs.git</code>). When you\n<code>git fetch upstream</code>, you‚Äôre getting the latest updates from the main project.</p>\n</li>\n</ul>\n<p>This setup ensures you can easily pull updates from the original project and\npush your contributions to your own fork.</p>\n<pre><code class=\"language-bash\"># Shows a ton of remote branches\ngit branch -r | grep upstream\n# Narrow it down\ngit branch -r | grep upstream | grep nixos-\n</code></pre>\n<p>Next Steps for Contributing</p>\n<ol>\n<li>Ensure <code>master</code> is up to date with <code>upstream</code></li>\n</ol>\n<pre><code class=\"language-bash\">git checkout master\ngit pull upstream master\ngit push origin master\n</code></pre>\n<ul>\n<li>\n<p><code>git pull upstream master</code> is equivalent to running <code>git fetch upstream</code>\nfollowed by <code>git merge upstream/master</code> into your current branch (<code>master</code>).</p>\n</li>\n<li>\n<p><code>git push origin master</code> updates your forks remote with the fetched changes.</p>\n</li>\n</ul>\n<p>This keeps your fork in sync to avoid conflicts.</p>\n<p>If targeting another branch, replace <code>master</code> with <code>nixos-24.11</code> for example.</p>\n<ol start=\"2\">\n<li>Create a Feature Branch</li>\n</ol>\n<pre><code class=\"language-bash\">git checkout master\ngit checkout -b my-feature-branch # name should represent the feature\n</code></pre>\n<ol start=\"3\">\n<li>Make and Test Changes</li>\n</ol>\n<p><a href=\"https://github.com/NixOS/nixpkgs/blob/master/pkgs/README.md#conventions\">Packaging Conventions</a></p>\n<p><strong>New package</strong>: Add to\n<code>pkgs/by-name/&lt;first-two-letters&gt;/&lt;package-name&gt;/default.nix</code>.</p>\n<p><strong>Example structure</strong>:</p>\n<pre><code class=\"language-nix\">{ lib, stdenv, fetchFromGitHub }: stdenv.mkDerivation {\npname = \"xyz\"; version = \"1.2.3\"; src = fetchFromGitHub { ... }; ... }\n</code></pre>\n<p><strong>Update package</strong>: Edit version and <code>sha256</code> in the package‚Äôs <code>default.nix</code>.\nUse <code>nix-prefetch-url</code> to update hashes:</p>\n<pre><code class=\"language-bash\">nix-prefetch-url &lt;source-url&gt;\n</code></pre>\n<p><strong>Fix a bug</strong>: Modify files in <code>pkgs/</code>, <code>nixos/modules/</code>, or elsewhere.</p>\n<p><strong>Test locally</strong>:</p>\n<p>Build:</p>\n<pre><code class=\"language-bash\">nix-build -A &lt;package-name&gt;\n</code></pre>\n<p><strong>Test in a shell</strong>:</p>\n<pre><code class=\"language-bash\">nix-shell -p &lt;package-name&gt;\n</code></pre>\n<p>For NixOS modules:</p>\n<pre><code class=\"language-bash\">nixos-rebuild test\n</code></pre>\n<p>Follow the Nixpkgs Contributing Guide.</p>\n<ol start=\"4\">\n<li><strong>Commit and Push</strong></li>\n</ol>\n<p>Commit with a clear message, make sure to follow\n<a href=\"https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md#commit-conventions\">commit conventions</a>:</p>\n<p><strong>Commit Conventions</strong></p>\n<ul>\n<li>\n<p>Create a commit for each logical unit.</p>\n</li>\n<li>\n<p>Check for unnecessary whitespace with <code>git diff --check</code> before committing.</p>\n</li>\n<li>\n<p>If you have commits <code>pkg-name: oh, forgot to insert whitespace</code>: squash\ncommits in this case. Use <code>git rebase -i</code>. See\n<a href=\"https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History#_squashing\">Squashing Commits</a>\nfor additional information.</p>\n</li>\n<li>\n<p>For consistency, there should not be a period at the end of the commit\nmessage‚Äôs summary line (the first line of the commit message).</p>\n</li>\n<li>\n<p>When adding yourself as maintainer in the same pull request, make a separate\ncommit with the message maintainers: <code>add &lt;handle&gt;</code>. Add the commit before\nthose making changes to the package or module. See\n<a href=\"https://github.com/NixOS/nixpkgs/blob/master/maintainers/README.md\">Nixpkgs Maintainers</a>\nfor details.</p>\n</li>\n</ul>\n<p>Format the commit messages in the following way:</p>\n<pre><code class=\"language-bash\">(pkg-name): (from -&gt; to | init at version | refactor | etc)\n\n(Motivation for change. Link to release notes. Additional information.)\n</code></pre>\n<p>a) For example, for the <code>airshipper</code> package:</p>\n<pre><code class=\"language-bash\">git add pkgs/by-name/ai/airshipper/\ngit commit -m \"airshipper: init at 0.1.0\"\n\nAdds the airshipper tool for managing game assets.\nUpstream homepage: https://github.com/someuser/airshipper\"\n</code></pre>\n<p>b) Updating <code>airshipper</code> to a new version</p>\n<pre><code class=\"language-bash\">git add pkgs/by-name/ai/airshipper/\ngit commit -m \"airshipper: 0.1.0 -&gt; 0.2.0\n\nUpdated airshipper to version 0.2.0. This release includes:\n- Improved asset fetching logic\n- Bug fixes for network errors\n\nRelease notes: https://github.com/someuser/airshipper/releases/tag/v0.2.0\"\n</code></pre>\n<p>c) Fixing a bug in <code>airshipper</code>‚Äôs package definition</p>\n<pre><code class=\"language-bash\">git add pkgs/by-name/ai/airshipper/\ngit commit -m \"airshipper: fix: build with latest glibc\n\nResolved build failures on unstable channel due to changes in glibc.\nPatched source to use updated API calls.\n\"\n</code></pre>\n<p>Examples:</p>\n<ul>\n<li>\n<p><code>nginx: init at 2.0.1</code></p>\n</li>\n<li>\n<p><code>firefox: 122.0 -&gt; 123.0</code></p>\n</li>\n<li>\n<p><code>vim: fix build with gcc13</code></p>\n</li>\n</ul>\n<p>Push:</p>\n<pre><code class=\"language-bash\">git push origin my-feature-branch\n</code></pre>\n<p>When you push your feature branch, it will output a link that you can follow to\ncomplete the PR on GitHub.</p>\n<p>If you have the <code>gh-cli</code> set up you can also do this from the command line:</p>\n<pre><code class=\"language-bash\">gh pr create --repo NixOS/nixpkgs --base master --head sayls8:feat/my-package\n</code></pre>\n<ol start=\"5\">\n<li>Create a Pull Request</li>\n</ol>\n<p>Go to <a href=\"https://github.com/sayls8/nixpkgs\">https://github.com/sayls8/nixpkgs</a>. (your fork) Click the PR prompt for\nmy-feature-branch. Set the base branch to <code>NixOS/nixpkgs:master</code> (or\n<code>nixos-24.11</code>). Write a PR description: Purpose of the change. Related issues\n(e.g., Fixes #1234). Testing steps (e.g., <code>nix-build -A &lt;package-name&gt;</code>). Submit\nand respond to feedback.</p>\n<ol start=\"6\">\n<li>Handle Updates</li>\n</ol>\n<p>For reviewer feedback or upstream changes:</p>\n<p>Edit, commit, and push:</p>\n<pre><code class=\"language-bash\">git add . git commit -m \"&lt;package-name&gt;: address feedback\" git push origin my-feature-branch\n</code></pre>\n<p>Rebase if needed:</p>\n<pre><code class=\"language-bash\">git fetch upstream\ngit rebase upstream/master  # or upstream/nixos-24.11\ngit push origin my-feature-branch --force\n</code></pre>\n<ol start=\"7\">\n<li>Cleanup</li>\n</ol>\n<p>After PR merge:</p>\n<p>Delete branch:</p>\n<pre><code class=\"language-bash\">git push origin --delete my-feature-branch\n</code></pre>\n<p>Sync master:</p>\n<pre><code class=\"language-bash\">git checkout master\ngit pull upstream master\ngit push origin master\n</code></pre>\n<p>Addressing the Many Branches</p>\n<ul>\n<li>\n<p>No need to manage all branches: The <code>nixos-branches</code> are just metadata from\nupstream. You only check out the one you need (e.g., <code>master</code> or\n<code>nixos-24.11</code>).</p>\n</li>\n<li>\n<p>Focus on relevant branches: The filter (<code>grep nixos-</code>) shows the key release\nbranches. Ignore -small branches and older releases unless specifically\nrequired. Confirm latest stable: If you‚Äôre targeting a stable branch,\n<code>nixos-24.11</code> is likely the latest (or <code>nixos-25.05</code> if it‚Äôs active). Verify\nvia NixOS status.</p>\n</li>\n</ul>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/Understanding_Top-Level_Attributes.html",
      "url": "https://saylesss88.github.io/Understanding_Top-Level_Attributes.html",
      "title": "Top-Level Attributes",
      "content_html": "<h1>Understanding Top-Level Attributes in NixOS Modules</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<!-- ![coding1](images/coding1.png) -->\n<img src=\"images/gruv9.png\" width=\"800\" height=\"600\">\n<p>This explanation is based on insights from Infinisil, a prominent figure in the\nNix community, to help clarify the concept of top-level attributes within NixOS\nmodules.</p>\n<h3>The Core of a NixOS System: <code>system.build.toplevel</code></h3>\n<details>\n<summary> ‚úîÔ∏è `system.build.toplevel` Explained (Click to Expand) </summary>\n<p>In a NixOS system, everything is built from a single ‚Äúsystem derivation.‚Äù The\ncommand <code>nix-build '&lt;nixpkgs/nixos&gt;' -A system</code> initiates this build process.</p>\n<p>The <code>-A system</code> part tells Nix to focus on the <code>system</code> attribute defined in the\n<code>'&lt;nixpkgs/nixos&gt;'</code> file (which is essentially <code>./default.nix</code> within the\nNixpkgs repository).</p>\n<p>This <code>system</code> attribute is specifically the NixOS option <code>system.build.toplevel</code>\n. Think of <code>system.build.toplevel</code> as the <strong>very top of the configuration\nhierarchy</strong> for your entire NixOS system. Almost every setting you configure\neventually influences this top-level derivation, often through a series of\nintermediate steps.</p>\n<p><strong>Key Takeaway:</strong> <code>system.build.toplevel</code> is the ultimate output that defines\nyour entire NixOS system.</p>\n</details>\n<h3>How Options Relate: A Chain of Influence</h3>\n<p>Options in NixOS are not isolated; they often build upon each other.</p>\n<details>\n<summary>Example: Nginx Option Chain (Click to Expand)</summary>\n<p>Here‚Äôs an example of how a high-level option can lead down to a low-level system\nconfiguration:</p>\n<ul>\n<li>You enable Nginx with <code>services.nginx.enable = true;</code>.</li>\n<li>This setting influences the lower-level option <code>systemd.services.nginx</code>.</li>\n<li>Which, in turn, affects the even lower-level option\n<code>systemd.units.\"nginx.service\"</code>.</li>\n<li>Ultimately, this leads to the creation of a systemd unit file within\n<code>environment.etc.\"systemd/system\"</code>.</li>\n<li>Finally, this unit file ends up as <code>result/etc/systemd/system/nginx.service</code>\nwithin the final <code>system.build.toplevel</code> derivation.</li>\n</ul>\n</details>\n<p><strong>Key Takeaway:</strong> Higher-level, user-friendly options are translated into\nlower-level system configurations that are part of the final system build.</p>\n<h3>The NixOS Module System: Evaluating Options</h3>\n<p>So, how do these options get processed and turned into the final system\nconfiguration? That‚Äôs the job of the <strong>NixOS module system</strong>, located in the\n<code>./lib</code> directory of Nixpkgs (specifically in <code>modules.nix</code>, <code>options.nix</code>, and\n<code>types.nix</code>).</p>\n<p>Interestingly, the module system isn‚Äôt exclusive to NixOS; you can use it to\nmanage option sets in your own Nix projects.</p>\n<p>Here‚Äôs a simplified example of using the module system outside of NixOS:</p>\n<pre><code class=\"language-nix\">let\n  systemModule = { lib, config, ... }: {\n    options.toplevel = lib.mkOption {\n      type = lib.types.str;\n    };\n\n    options.enableFoo = lib.mkOption {\n      type = lib.types.bool;\n      default = false;\n    };\n\n    config.toplevel = ''\n      Is foo enabled? ${lib.boolToString config.enableFoo}\n    '';\n  };\n\n  userModule = {\n    enableFoo = true;\n  };\n\nin (import &lt;nixpkgs/lib&gt;).evalModules {\n  modules = [ systemModule userModule ];\n}\n</code></pre>\n<p><strong>You can evaluate the <code>config.toplevel</code> option from this example using:</strong></p>\n<pre><code class=\"language-bash\">nix-instantiate --eval file.nix -A config.toplevel\n</code></pre>\n<p><strong>Key Takeaway</strong>: The NixOS module system is responsible for evaluating and\nmerging option configurations from different modules.</p>\n<h3>How the Module System Works: A Simplified Overview</h3>\n<p>The module system processes a set of ‚Äúmodules‚Äù through these general steps:</p>\n<details>\n<summary> ‚úîÔ∏è Detailed Steps (Click to Expand)</summary>\n<ol>\n<li>\n<p><strong>Importing Modules</strong>: It recursively finds and includes all modules\nspecified in <code>imports = [ ... ];</code> statements.</p>\n</li>\n<li>\n<p><strong>Declaring Options</strong>: It collects all option declarations defined using\n<code>options = { ... };</code> from all the modules and merges them. If the same option\nis declared in multiple modules, the module system handles this (details\nomitted for simplicity).</p>\n</li>\n<li>\n<p><strong>Defining Option Values</strong>: For each declared option, it gathers all the\nvalue assignments (defined using <code>config = { ... };</code> or directly at the top\nlevel if no <code>options</code> or <code>config</code> are present) from all modules and merges\nthem according to the option‚Äôs defined type.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Important Note</strong>: Option evaluation is lazy, meaning an option‚Äôs value is\nonly computed when it‚Äôs actually needed. It can also depend on the values of\nother options.</p>\n</blockquote>\n</details>\n<p><strong>Key Takeaway</strong>: The module system imports, declares, and then evaluates option\nvalues from various modules to build the final configuration.</p>\n<p><strong>Top-Level Attributes in a Module: <code>imports</code>, <code>options</code>, and <code>config</code></strong></p>\n<p>Within a NixOS module (the files that define parts of your system configuration)\n, the attributes defined directly at the top level of the module‚Äôs function have\nspecific meanings:</p>\n<ul>\n<li>\n<p><code>imports</code>: This attribute is a list of other module files to include. Their\noptions and configurations will also be part of the evaluation.</p>\n</li>\n<li>\n<p><code>options</code>: This attribute is where you declare new configuration options. You\ndefine their type, default value, description, etc., using functions like\n<code>lib.mkOption</code> or <code>lib.mkEnableOption</code>.</p>\n</li>\n<li>\n<p><code>config</code>: This attribute is where you assign values to the options that have\nbeen declared (either in the current module or in imported modules).</p>\n</li>\n</ul>\n<p><strong>Key Takeaway</strong>: The top-level attributes <code>imports</code>, <code>options</code>, and <code>config</code>\nare the primary ways to structure a NixOS module.</p>\n<p><strong>The Rule: Move Non-Option Attributes Under <code>config</code></strong></p>\n<p>If you define either an <code>options</code> or a <code>config</code> attribute at the top level of\nyour module, any other attributes that are not option declarations must be moved\ninside the config attribute.</p>\n<details>\n<summary> ‚úîÔ∏è Examples of Correct and Incorrect Usage (Click to Expand)</summary>\n<p>Let‚Äôs look at an example of what not to do:</p>\n<pre><code class=\"language-nix\">{ pkgs, lib, config, ... }:\n{\nimports = [];\n\n# Defining an option at the top level\n\noptions.mine.desktop.enable = lib.mkEnableOption \"desktop settings\";\n\n# This will cause an error because 'environment' and 'appstream'\n\n# are not 'options' and 'config' is also present at the top level.jjjj\n\nenvironment.systemPackages =\nlib.mkIf config.appstream.enable [ pkgs.git ];\n\nappstream.enable = true;\n}\n</code></pre>\n<p>This will result in the error:\n<code>error: Module has an unsupported attribute 'appstream' This is caused by introducing a top-level 'config' or 'options' attribute. Add configuration attributes immediately on the top level instead, or move all of them into the explicit 'config' attribute</code>.</p>\n<p><strong>Key Takeaway</strong>: When you have <code>options</code> or <code>config</code> at the top level, all\nvalue assignments need to go inside the config block.</p>\n<p><strong>The Correct Way</strong>): Using the <code>config</code> Attribute</p>\n<p>To fix the previous example, you need to move the value assignments for\n<code>environment.systemPackages</code> and <code>appstream.enable</code> inside the config attribute:</p>\n<pre><code class=\"language-nix\">{ pkgs, lib, config, ... }:\n{\nimports = [];\n\n# Defining an option at the top level\n\noptions.mine.desktop.enable = lib.mkEnableOption \"desktop settings\";\n\nconfig = {\nenvironment.systemPackages =\nlib.mkIf config.appstream.enable [ pkgs.git ];\n\n    appstream.enable = true;\n\n};\n}\n</code></pre>\n<p>Now, Nix knows that you are declaring an option (<code>options.mine.desktop.enable</code>)\nand then setting values for other options (<code>environment.systemPackages</code>,\n<code>appstream.enable</code>) within the <code>config</code> block.</p>\n<p><strong>Key Takeaway</strong>: The <code>config</code> attribute is used to define the values of\noptions.</p>\n<p><strong>Implicit <code>config</code>: When <code>options</code> is Absent</strong></p>\n<p>If your module does not define either <code>options</code> or <code>config</code> at the top level,\nthen any attributes you define directly at the top level are implicitly treated\nas being part of the config.</p>\n<p>For example, this is valid:</p>\n<pre><code class=\"language-nix\">{ pkgs, lib, config, ... }:\n{\nenvironment.systemPackages =\nlib.mkIf config.appstream.enable [ pkgs.git ];\n\nappstream.enable = true;\n}\n</code></pre>\n<p>Nix will implicitly understand that <code>environment.systemPackages</code> and\n<code>appstream.enable</code> are configuration settings.</p>\n<p><strong>Key Takeaway</strong>: If no explicit options or config are present, top-level\nattributes are automatically considered part of the configuration.</p>\n<p><strong>Removing an Option: What Happens to <code>config</code></strong></p>\n<p>Even if you remove the <code>options</code> declaration from a module that has a <code>config</code>\nsection, the <code>config = { environment.systemPackages = ... };</code> part will still\nfunction correctly, assuming the option it‚Äôs referencing (<code>appstream.enable</code> in\nthis case) is defined elsewhere (e.g., in an imported module).</p>\n</details>\n<p><strong>Key Takeaway</strong>: The <code>config</code> section defines values for options, regardless of\nwhether those options are declared in the same module.</p>\n<h4>Conclusion</h4>\n<p>Understanding the nuances of top-level attributes within NixOS modules,\nparticularly <code>imports</code>, <code>options</code>, and <code>config</code>, is fundamental to structuring\nand managing your system‚Äôs configuration effectively. As we‚Äôve seen, the module\nsystem provides a powerful and declarative way to define and evaluate system\nsettings, ultimately contributing to the construction of the\n<code>system.build.toplevel</code> derivation that represents your entire NixOS\nenvironment.</p>\n<p>The concepts of option declaration and value assignment, along with the crucial\nrule of organizing non-option attributes under the <code>config</code> attribute when\n<code>options</code> is present, provide a clear framework for building modular and\nmaintainable configurations.</p>\n<p>Now that we have a solid grasp of how NixOS modules are structured and how they\ncontribute to the final system derivation, it‚Äôs a natural next step to explore\nthe tangible results of these configurations: the software and system components\nthemselves. These are built and managed by a core concept in Nix, known as\n<strong>derivations</strong>.</p>\n<p>In the next chapter,\n<a href=\"https://saylesss88.github.io/Package_Definitions_Explained_6.html\">Package Definitions Explained</a>\nwe will shift our focus from the abstract configuration to the concrete software\npackages. We will learn how Nix uses <em>package definitions</em> to create\n<em>derivations</em>, which are the actual build plans that produce the software we use\non our NixOS systems. This will bridge the gap between configuring your system\nand understanding how the software within it is managed.</p>\n",
      "date_published": "2025-11-21T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/Understanding_Nix_Functions.html",
      "url": "https://saylesss88.github.io/Understanding_Nix_Functions.html",
      "title": "Understanding Nix Functions",
      "content_html": "<h2>Understanding Nix Functions</h2>\n<details>\n<summary> ‚úîÔ∏è Table of Contents</summary>\n<!-- toc -->\n</details>\n<!-- <img src=\"images/nixLogo.png\" width=\"400\" height=\"300\"> -->\n<p><img src=\"images/trees2.cleaned.png\" alt=\"trees2\" /></p>\n<p><strong>Functions</strong> are the building blocks of Nix, appearing everywhere in Nix\nexpressions and configurations. Mastering them is essential for writing\neffective Nix code and understanding tools like NixOS and Home Manager. This\nchapter explores how Nix functions work, focusing on their <strong>single-argument\nnature</strong>, <strong>currying</strong>, <strong>partial application</strong>, and their role in <strong>modules</strong>.</p>\n<h2>What are Nix Functions?</h2>\n<p>A <strong>Nix Function</strong> is a rule that takes an input (called an <strong>argument</strong>) and\nproduces an <strong>output</strong> based on that input. Unlike many programming languages,\nNix functions are designed to take exactly one argument at a time. This unique\napproach, combined with a technique called currying, allows Nix to simulate\nmulti-argument functions in a flexible and reusable way.</p>\n<h2>Builtins</h2>\n<details>\n<summary> ‚úîÔ∏è Nix Builtin Functions (Click to Expand)</summary>\n<p>The Nix expression evaluator has a bunch of functions and constants built in:</p>\n<ul>\n<li>\n<p><code>toString e</code>: (Convert the expression <code>e</code> to a string)</p>\n</li>\n<li>\n<p><code>import path</code>: (Load, parse and return the Nix expression in the file <code>path</code>)</p>\n</li>\n<li>\n<p><code>throw x</code>: (Throw an error message <code>x</code>. Usually stops evaluation)</p>\n</li>\n<li>\n<p><code>map f list</code>: (Apply the function <code>f</code> to each element in the <code>list</code>)</p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/manual/nix/2.18/language/builtins\">Built-in Functions</a></p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/manual/nix/2.26/language/operators\">Nix Operators</a></p>\n</li>\n</ul>\n</details>\n<h2>Lambdas</h2>\n<p>Nix functions are anonymous (lambdas) (e.g., <code>x: x + 2</code>), and technically take a\nsingle parameter. However, that single parameter is very often an attribute set,\nallowing you to effectively pass multiple named inputs by destructuring (e.g.,\n<code>{ arg1, arg2 }: arg1 + arg2</code>).</p>\n<p>Type the parameter name, followed by a colon, and finally the body of the\nfunction.</p>\n<pre><code class=\"language-nix\">nix-repl&gt; param: param * 2\n&lt;&lt;lambda @ &lt;&lt;string&gt;&gt;:1:1&gt;&gt;\n\nnix-repl&gt; (param: param * 2) 2\n4\n</code></pre>\n<p>The above example shows that everything in Nix returns a value. When you call a\nfunction directly (without first assigning the function itself to a variable),\nthe result of that call is immediately evaluated and displayed/used.</p>\n<p>In order to make our function reusable and be able to pass different values at\ndifferent times we have to assign our function to a variable:</p>\n<pre><code class=\"language-nix\">nix-repl&gt; twoTimes = param: param * 2\n</code></pre>\n<p>Now, we can reference our function by it‚Äôs name and pass our required parameter:</p>\n<pre><code class=\"language-nix\">nix-repl&gt; twoTimes\n¬´lambda @ ¬´string¬ª:1:2¬ª\nnix-repl&gt; twoTimes 2\n4\nnix-repl&gt; twoTimes 4\n8\n</code></pre>\n<p>We defined a function <code>param: param * 2</code> takes one parameter <code>param</code>, and\nreturns <code>param * 2</code>. We then assigned this function to the variable <code>twoTimes</code>.\nLastly, we called the function with a few different arguments showing it‚Äôs\nreusability.</p>\n<h2>Understanding Function Structure: The Role of the Colon</h2>\n<p>The colon (<code>:</code>) acts as a clear separator within a function definition:</p>\n<ul>\n<li>\n<p><strong>Left of the Colon:</strong> This is the function‚Äôs <strong>argument</strong>. It‚Äôs a placeholder\nname for a value that will be provided when the function is called.</p>\n</li>\n<li>\n<p><strong>Right of the Colon:</strong> This is the <strong>function body</strong>. It‚Äôs the expression\nthat will be evaluated when the function is invoked.</p>\n</li>\n</ul>\n<p><strong>Think of function arguments as naming values that aren‚Äôt known in advance.</strong>\nThese names are placeholders that get filled with specific values when the\nfunction is used.</p>\n<p><strong>Example:</strong></p>\n<pre><code class=\"language-nix\">greet = personName: \"Hello, ${personName}!\";\n</code></pre>\n<ul>\n<li>\n<p>Here, <code>personName</code> is the <strong>argument</strong> (the placeholder).</p>\n</li>\n<li>\n<p><code>\"Hello, ${personName}!\"</code>, is the <strong>function body</strong> (which uses the\nplaceholder to create the greeting).</p>\n</li>\n</ul>\n<p>When you call the function, (click to see Output):</p>\n<pre><code class=\"language-nix\">greet \"Anonymous\"\n~ \"Hello, Anonymous!\"\n</code></pre>\n<ul>\n<li>\n<p>The value <code>\"Anonymous\"</code> is substituted for the <code>personName</code> placeholder within\nthe function body.</p>\n</li>\n<li>\n<p>This structure is the foundation of all Nix functions, whether simple or\ncomplex.</p>\n</li>\n</ul>\n<h3>Single-Argument Functions: The Basics</h3>\n<p>The simplest form of a Nix function takes a single argument. In Nix, function\ndefinitions like <code>x: x + 1</code> or <code>personName: \"Hello, ${personName}!\";</code> are\n<strong>anonymous lambda functions</strong>. They exist as values until they are assigned to\na variable.</p>\n<ul>\n<li>Click to see Output:</li>\n</ul>\n<pre><code class=\"language-nix\"># This is an anonymous lambda function value:\n# x: x + 1\ninc = x: x + 1;          # here we assigned our lambda to a variable `inc`\ninc 5\n~ 6\n</code></pre>\n<ul>\n<li>\n<p><code>x</code> is the argument.</p>\n</li>\n<li>\n<p><code>x + 1</code> is the function body.</p>\n</li>\n</ul>\n<p>This straightforward design makes single-argument functions easy to understand\nand use. But what if you need a function that seems to take multiple arguments?\nThat‚Äôs where <strong>currying</strong> comes in.</p>\n<h3>Simulating Multiple Arguments: Currying</h3>\n<p>To create functions that appear to take multiple arguments, Nix uses currying.\nThis involves nesting single-argument functions, where each function takes one\nargument and returns another function that takes the next argument, and so on.</p>\n<pre><code class=\"language-nix\">nix-repl&gt; multiply = x: (y: x*y)\nnix-repl&gt; multiply\n¬´lambda¬ª\nnix-repl&gt; multiply 4\n¬´lambda¬ª\nnix-repl&gt; (mul 4) 5\n20\n</code></pre>\n<p>We defined a function that takes the parameter <code>x</code>, the body returns another\nfunction. This other function takes a parameter <code>y</code> and returns <code>x*y</code>.\nTherefore, calling <code>multiply 4</code> returns a function like: <code>x: 4*y</code>. In turn, we\ncall the returned function with <code>5</code>, and get the expected result.</p>\n<h4>Currying example 2</h4>\n<pre><code class=\"language-nix\"># concat is equivalent to:\n# concat = x: (y: x + y);\nconcat = x: y: x + y;\nconcat 6 6    # Evaluates to 12\n12\n</code></pre>\n<p>Here, <code>concat</code> is actually <strong>two nested functions</strong></p>\n<ol>\n<li>\n<p>The <strong>first function</strong> takes <code>x</code> and returns another function.</p>\n</li>\n<li>\n<p>The <strong>second function</strong> takes <code>y</code> and performs <code>x + y</code></p>\n</li>\n</ol>\n<p>Nix interprets the colons (<code>:</code>) as separators for this chain of single-argument\nfunctions.</p>\n<p>Here‚Äôs how it works step by step:</p>\n<ul>\n<li>\n<p>When you call <code>concat 6</code>, the outer function binds <code>x</code> to <code>6</code> and returns a\nnew function: <code>y: 6 + y</code>.</p>\n</li>\n<li>\n<p>When you call that function with <code>6</code> (i.e., <code>concat 6 6</code>), it computes\n<code>6 + 6</code>, resulting in <code>12</code>.</p>\n</li>\n</ul>\n<p>This chaining is why Nix functions are so powerful‚Äîit allows you to build\nflexible, reusable functions.</p>\n<p>Currying is a powerful feature in Nix that enables you to partially apply\narguments to functions, leading to increased reusability. This behavior is a\ndirect consequence of Nix functions being ‚Äúfirst-class citizens‚Äù (a concept\nwe‚Äôll delve into later), and it proves invaluable for decomposing intricate\nlogic into a series of smaller, more focused functions.</p>\n<p><strong>Key Insight</strong>: Every colon in a function definition separates a <strong>single\nargument</strong> from its <strong>function body</strong>, even if that body is another function\ndefinition.</p>\n<h4>Greeting Example</h4>\n<p>Let‚Äôs explore currying with a more relatable example in the <code>nix repl</code>:</p>\n<pre><code class=\"language-nix\">nix repl\nnix-repl&gt; greeting = prefix: name: \"${prefix}, ${name}!\";\n\nnix-repl&gt; greeting \"Hello\"\n&lt;&lt;lambda @ &lt;&lt;string&gt;&gt;:1:10&gt;&gt; # partial application returns a lambda\n\nnix-repl&gt; greeting \"Hello\" \"Alice\"\n\"Hello, Alice!\"         # providing both arguments returns the expected result\n</code></pre>\n<p>This function is a chain of two single-argument functions:</p>\n<ol>\n<li>\n<p>The outer function takes <code>prefix</code> (e.g. <code>\"Hello\"</code>) and returns a function\nthat expects <code>name</code>.</p>\n</li>\n<li>\n<p>The inner function takes <code>name</code> (e.g. <code>\"Alice\"</code>) and combines it with\n<code>prefix</code> to produce the final string.</p>\n</li>\n</ol>\n<p>Thanks to <strong>lexical scope</strong> (where inner functions can access variables from\nouter functions), the inner function ‚Äúremembers‚Äù the <code>prefix</code> value.</p>\n<h4>Partial Application: Using Functions Incrementally</h4>\n<p>Because of <strong>currying</strong>, you can apply arguments to a Nix function one at a\ntime. This is called <em>partial application</em>. When you provide only some of the\nexpected arguments, you get a new function that ‚Äúremembers‚Äù the provided\narguments and waits for the rest.</p>\n<p><strong>Example:</strong></p>\n<p>Using our <code>greeting</code> function again:</p>\n<pre><code class=\"language-nix\">nix repl\nnix-repl&gt; greeting = prefix: name: \"${prefix}, ${name}!\";\nnix-repl&gt; helloGreeting = greeting \"Hello\";\nnix-repl&gt; helloGreeting \"Alice\"\n\"Hello, Alice\"\n</code></pre>\n<ul>\n<li><code>helloGreeting</code> is now a new function. It has already received the <code>prefix</code>\nargument (<code>\"Hello\"</code>), when we provide the second argument we get\n<code>\"Hello, Alice!\"</code></li>\n</ul>\n<p><strong>Benefits of Partial Application:</strong></p>\n<p>Partial application provides significant benefits by enabling you to derive\nspecialized functions from more general ones through the process of fixing\ncertain parameters. Additionally, it serves as a powerful tool for adapting\nexisting functions to fit the precise argument requirements of higher-order\nfunctions like <code>map</code> and <code>filter</code>.</p>\n<h4>Nix Functions being ‚Äúfirst class citizens‚Äù</h4>\n<p>In the context of Nix, the phrase ‚ÄúNix treats functions as first-class citizens‚Äù\nmeans that functions in Nix are treated as values, just like numbers, strings,\nor lists. They can be manipulated, passed around, and used in the same flexible\nways as other data types. This concept comes from functional programming and has\nspecific implications in Nix.</p>\n<p><strong>What It Means in Nix</strong></p>\n<ol>\n<li>Functions Can Be <strong>Assigned to Variables</strong>:</li>\n</ol>\n<ul>\n<li>\n<p>You can store a function in a variable, just like you would store a number or\nstring.</p>\n</li>\n<li>\n<p>Example:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">greet = name: \"Hello, ${name}!\";\n</code></pre>\n<ul>\n<li>Here, greet is a variable that holds a function.</li>\n</ul>\n<ol start=\"2\">\n<li>Functions Can Be <strong>Passed as Arguments</strong>:</li>\n</ol>\n<ul>\n<li>\n<p>You can pass a function to another function as an argument, allowing for\nhigher-order functions (functions that operate on other functions).</p>\n</li>\n<li>\n<p>Example:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">applyTwice = f: x: f (f x);\ninc = x: x + 1;\napplyTwice inc 5 # Output: 7 (increments 5 twice: 5 ‚Üí 6 ‚Üí 7)\n~ 7\n</code></pre>\n<ul>\n<li>Here, applyTwice takes a function <code>f</code> (in this case, <code>inc</code>) and applies it to\n<code>x</code> twice.</li>\n</ul>\n<ol start=\"3\">\n<li>Functions Can Be <strong>Returned from Functions</strong>:</li>\n</ol>\n<ul>\n<li>\n<p>Functions can produce other functions as their output, which is key to\ncurrying in Nix.</p>\n</li>\n<li>\n<p>Example:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">greeting = prefix: name: \"${prefix}, ${name}!\";\nhelloGreeting = greeting \"Hello\";  # Returns a function\nhelloGreeting \"Alice\"  # Output: \"Hello, Alice!\"\n~ \"Hello, Alice!\"\n</code></pre>\n<ul>\n<li>The greeting function returns another function when partially applied with\nprefix.</li>\n</ul>\n<ol start=\"4\">\n<li>Functions <strong>Are Values in Expressions</strong>:</li>\n</ol>\n<ul>\n<li>\n<p>Functions can be used anywhere a value is expected, such as in attribute sets\nor lists.</p>\n</li>\n<li>\n<p>Example:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">myFuncs = {\n  add = x: y: x + y;\n  multiply = x: y: x * y;\n};\nmyFuncs.add 3 4  # Output: 7\n~ 7\n</code></pre>\n<ul>\n<li>\n<p>Here, functions are stored as values in an attribute set.</p>\n</li>\n<li>\n<p>To try this in the <code>repl</code> just remove the semi-colon (<code>;</code>)</p>\n</li>\n</ul>\n<p><strong>Why This Matters in Nix</strong>:</p>\n<p>This functional approach is fundamental to Nix‚Äôs unique build system. In Nix,\n<strong>package builds (called derivations)</strong> are essentially functions. They take\nspecific <strong>inputs</strong> (source code, dependencies, build scripts) and\ndeterministically produce <strong>outputs</strong> (a built package).</p>\n<p>This design ensures <strong>atomicity</strong>: if a build does not succeed completely and\nperfectly, it produces no output at all. This prevents situations common in\nother package managers where partial updates or corrupted builds can leave your\nsystem in an inconsistent or broken state.</p>\n<p>Many NixOS and Home Manager modules are functions, and their first-class status\nmeans they can be combined, reused, or passed to other parts of the\nconfiguration system.</p>\n<p>Now that we understand the ‚Äúfirst-class‚Äù nature of Nix Functions let‚Äôs see how\nthey fit into NixOS and Home Manager modules.</p>\n<h4>The Function Nature of NixOS and Home Manager Modules</h4>\n<p>It‚Äôs crucial to understand that most NixOS and Home Manager modules are\nfundamentally <strong>functions</strong>.</p>\n<p>These module functions typically accept a single argument: <strong>an attribute set</strong>\n(remember this, it‚Äôs important to understand).</p>\n<p><strong>Example</strong>:</p>\n<p>A practical NixOS module example for Thunar with plugins:</p>\n<pre><code class=\"language-nix\"># thunar.nix\n{pkgs, ...}: {\n  programs = {\n    thunar = {\n      enable = true;\n      plugins = with pkgs.xfce; [\n        thunar-archive-plugin\n        thunar-volman\n      ];\n    };\n  };\n}\n</code></pre>\n<ul>\n<li>To use this module I would need to import it into my <code>configuration.nix</code> or\nequivalent, shown here for completeness.</li>\n</ul>\n<pre><code class=\"language-nix\"># configuration.nix\n# ... snip ...\nimports = [ ../nixos/thunar.nix ];\n# ... snip ...\n</code></pre>\n<ul>\n<li>\n<p>This is actually a pretty good example of <code>with</code> making it a bit harder to\nreason where the plugins are from. You might instinctively try to trace a path\nlike <code>programs.thunar.plugins.pkgs.xfce</code> because you saw <code>pkgs.xfce</code> in the\n<code>with</code> statement. But that‚Äôs now how <code>with</code> works. The <code>pkgs.xfce</code> path exists\n<em>outside</em> the <code>plugins</code> list, defining the source of the items, not their\nnested structure within the list.</p>\n</li>\n<li>\n<p>To follow best practices you could write the above plugins section as:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">plugins = [\n  pkgs.xfce.thunar-archive-plugin\n  pkgs.xfce.thunar-volman\n];\n</code></pre>\n<ul>\n<li>Now it‚Äôs clear that each plugin comes directly from <code>pkgs</code> and each will\nresolve to a derivation.\n<ul>\n<li>To be clear either way is fine, especially in such a small self contained\nmodule. If it were in a single file <code>configuration.nix</code> it would be a bit\nmore confusing to trace. Explicitness is your friend with Nix and\nmaintaining reproducability. <code>with</code> isn‚Äôt always bad but should be avoided\nat the top of a file for example to bring <code>nixpkgs</code> into scope, use <code>let</code>\ninstead.</li>\n</ul>\n</li>\n</ul>\n<p>The entire module definition is a function that takes one argument (an attribute\nset):<code>{ pkgs, ... }</code>. When this module is included in your configuration, the\nNixOS module system calls this function with a specific attribute set. This\nattribute set contains the available packages (<code>pkgs</code>), and other relevant\ninformation. The module then uses these values to define parts of your system.</p>\n<h3>Understanding passing and getting back arguments</h3>\n<p>For this example we will build the Hello derivation from the Nix Pills series.</p>\n<p>Create an <code>autotools.nix</code> with the following contents:</p>\n<pre><code class=\"language-nix\">pkgs: attrs: let\n  defaultAttrs = {\n    builder = \"${pkgs.bash}/bin/bash\";\n    args = [./builder.sh];\n    baseInputs = with pkgs; [\n      gnutar\n      gzip\n      gnumake\n      gcc\n      coreutils\n      gawk\n      gnused\n      gnugrep\n      binutils.bintools\n    ];\n    buildInputs = [];\n    system = builtins.currentSystem;\n  };\nin\n  derivation (defaultAttrs // attrs)\n</code></pre>\n<p>Let‚Äôs create the hello derivation:</p>\n<pre><code class=\"language-nix\">let\n  pkgs = import &lt;nixpkgs&gt; {};\n  mkDerivation = import ./autotools.nix pkgs;\nin\n  mkDerivation {\n    name = \"hello\";\n    src = ./hello-2.12.1.tar.gz;\n  }\n</code></pre>\n<ul>\n<li>You can get the tarball\n<a href=\"https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz\">here</a>, place it in the\nsame directory as <code>autotools.nix</code></li>\n</ul>\n<p>And finally the <code>builder.sh</code> that <code>autotools.nix</code> declares for the <code>args</code>\nattribute:</p>\n<pre><code class=\"language-bash\">#!/bin/bash\nset -e\nunset PATH\nfor p in $buildInputs $baseInputs; do\n    export PATH=$p/bin${PATH:+:}$PATH\ndone\n\ntar -xf $src\n\nfor d in *; do\n    if [ -d \"$d\" ]; then\n        cd \"$d\"\n        break\n    fi\ndone\n\n./configure --prefix=$out\nmake\nmake install\n</code></pre>\n<p>When you write:</p>\n<pre><code class=\"language-nix\">mkDerivation = import ./autotools.nix pkgs;\n</code></pre>\n<ul>\n<li>\n<p><code>import ./autotools.nix</code>: This evaluates the <code>autotools.nix</code> file. Because it\nstarts with <code>pkgs: attrs: ...</code>, it means that <code>autotools.nix</code> evaluates to a\nfunction that expects one argument named <code>pkgs</code>.</p>\n</li>\n<li>\n<p><code>... pkgs</code>: We are immediately calling that function (the one returned by\n<code>import ./autotools.nix</code>) and passing it our <code>pkgs</code> variable (which is the\nresult of <code>import &lt;nixpkgs&gt; {}</code>).</p>\n</li>\n</ul>\n<p><strong>This illustrates the concept of Currying in Nix</strong>:</p>\n<p>The function defined in <code>autotools.nix</code> (<code>pkgs: attrs: ...</code>) is a curried\nfunction. It‚Äôs a function that, when given its first argument (<code>pkgs</code>), returns\nanother function (which then expects <code>attrs</code>).</p>\n<p>The result of import <code>./autotools.nix pkgs</code> is that second, inner function:\n<code>attrs: derivation (defaultAttrs // attrs)</code>. This inner function is then bound\nto the <code>mkDerivation</code> variable, making it ready to be called with just the\nspecific attributes for your package (like <code>name</code> and <code>src</code>).</p>\n<p><strong>Understanding the <code>attrs</code> Argument</strong></p>\n<p>Now let‚Äôs focus on the second argument of our <code>autotools.nix</code> function: <code>attrs</code>.</p>\n<p>Recall the full function signature in <code>autotools.nix</code>:</p>\n<pre><code class=\"language-nix\">pkgs: attrs: let\n  # ... defaultAttrs definition ...\nin\n  derivation (defaultAttrs // attrs)\n</code></pre>\n<ol>\n<li>What <code>attrs</code> Represents:</li>\n</ol>\n<ul>\n<li>\n<p>Once <code>autotools.nix</code> has received its <code>pkgs</code> argument (and returned the inner\nfunction), this inner function is waiting for its final argument, which we\ncall <code>attrs</code>.</p>\n</li>\n<li>\n<p><code>attrs</code> is simply an attribute set (a key-value map in Nix). It‚Äôs designed to\nreceive all the specific properties of the individual package you want to\nbuild using this helper.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>How <code>attrs</code> is Used:</li>\n</ol>\n<ul>\n<li>\n<p>Look at the final line of <code>autotools.nix</code>:\n<code>derivation (defaultAttrs // attrs)</code>.</p>\n</li>\n<li>\n<p>The <code>//</code> operator in Nix performs an attribute set merge. It takes all\nattributes from <code>defaultAttrs</code> and combines them with all attributes from\n<code>attrs</code>.</p>\n</li>\n<li>\n<p>Crucially, if an attribute exists in both <code>defaultAttrs</code> and <code>attrs</code>, the\nvalue from <code>attrs</code> (the second operand) takes precedence and overrides the\ndefault value.</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>Applying attrs in the hello Derivation:</li>\n</ol>\n<ul>\n<li>In the <code>hello</code> derivation, we call <code>mkDerivation</code> like this:</li>\n</ul>\n<pre><code class=\"language-nix\">        mkDerivation {\n          name = \"hello\";\n          src = ./hello-2.12.1.tar.gz;\n        }\n</code></pre>\n<ul>\n<li>\n<p>The attribute set <code>{ name = \"hello\"; src = ./hello-2.12.1.tar.gz; }</code> is what\ngets passed as the <code>attrs</code> argument to the <code>mkDerivation</code> function (which,\nremember, is the inner function returned by <code>autotools.nix</code>).</p>\n</li>\n<li>\n<p>When derivation <code>(defaultAttrs // attrs)</code> is evaluated for ‚Äúhello‚Äù, the <code>name</code>\nand <code>src</code> provided in the <code>attrs</code> set will be merged with all the\n<code>defaultAttrs</code> (like <code>builder</code>, <code>args</code>, <code>baseInputs</code>, etc.).</p>\n</li>\n</ul>\n<p>In summary:</p>\n<ul>\n<li>\n<p>The <code>pkgs</code> argument configures the general environment and available tools for\nthe builder.</p>\n</li>\n<li>\n<p>The <code>attrs</code> argument is where you provide the unique details for each specific\npackage you intend to build using this <code>autotools.nix</code> helper. It allows you\nto specify things like the package‚Äôs name, source code, version, and any\ncustom build flags, while still benefiting from all the sensible defaults\nprovided by <code>autotools.nix</code>. This separation makes <code>autotools.nix</code> a reusable\nand flexible ‚Äútemplate‚Äù for creating derivations.</p>\n</li>\n</ul>\n<h4>Conclusion</h4>\n<p>Having explored the fundamental nature of functions in Nix, we can now see this\nconcept applies to more complex areas like NixOS configuration and derivations.\nIn the next chapter,\n<a href=\"https://saylesss88.github.io/NixOS_Modules_Explained_3.html\">NixOS Modules Explained</a>.\nWe will learn about NixOS Modules which are themselves functions most of the\ntime.</p>\n<h4>Resources</h4>\n<details>\n<summary> ‚úîÔ∏è Resources (Click to Expand) </summary>\n<ul>\n<li>\n<p><a href=\"https://nix.dev/tutorials/nix-language.html\">nix.dev Nix Lang Basics</a></p>\n</li>\n<li>\n<p><a href=\"https://nixos.org/guides/nix-pills/05-functions-and-imports.html\">nix pills Functions and Imports</a></p>\n</li>\n<li>\n<p><a href=\"https://zero-to-nix.com/concepts/nix-language/\">zero-to-nix Nix Lang</a></p>\n</li>\n<li>\n<p><a href=\"https://nixcloud.io/tour/?id=functions%2Fintroduction\">A tour of Nix ‚ÄúFunctions‚Äù</a></p>\n</li>\n<li>\n<p><a href=\"https://learnxinyminutes.com/nix/\">learn Nix in y minutes</a></p>\n</li>\n<li>\n<p><a href=\"https://noogle.dev/\">noogle function library</a></p>\n</li>\n</ul>\n</details>\n",
      "date_published": "2025-11-21T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/Package_Definitions_Explained.html",
      "url": "https://saylesss88.github.io/Package_Definitions_Explained.html",
      "title": "Package Definitions Explained",
      "content_html": "<h2>Package Definitions Explained</h2>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><img src=\"images/coding2.png\" alt=\"coding2\" /></p>\n<!-- ![gruv1](images/gruv1.png) -->\n<p>In Nix, the concept of a <strong>package</strong> can refer to two things:</p>\n<ul>\n<li>\n<p>A collection of files and data that constitute a piece of software or an\nartifact.</p>\n</li>\n<li>\n<p>A Nix <strong>expression</strong> that describes how to create such a collection. This\nexpression acts as a blueprint before the package exists in a tangible form.</p>\n</li>\n</ul>\n<p>The process begins with writing a <strong>package definition</strong> using the Nix language.\nThis definition contains the necessary instructions and metadata about the\nsoftware you intend to ‚Äúpackage.‚Äù</p>\n<h2>The Journey from Definition to Package</h2>\n<details>\n<summary> ‚úîÔ∏è Click to Expand</summary>\n<ol>\n<li>\n<p><strong>Package Definition:</strong></p>\n<ul>\n<li>\n<p>This is essentially a function written in the Nix language.</p>\n</li>\n<li>\n<p>Nix language shares similarities with JSON but includes the crucial\naddition of functions.</p>\n</li>\n<li>\n<p>It acts as the blueprint for creating a package.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Derivation:</strong></p>\n<ul>\n<li>\n<p>When the package definition is evaluated by Nix, it results in a\n<strong>derivation</strong>.</p>\n</li>\n<li>\n<p>A derivation is a concrete and detailed build plan.</p>\n</li>\n<li>\n<p>It outlines the exact steps Nix needs to take: fetching source code,\nbuilding dependencies, compiling code, and ultimately producing the\ndesired output (the package).</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Realization (Building the Package):</strong></p>\n<ul>\n<li>\n<p>You don‚Äôt get a pre-built ‚Äúpackage‚Äù directly from the definition or the\nderivation.</p>\n</li>\n<li>\n<p>The package comes into being when Nix <strong>executes</strong> the derivation. This\nprocess is often referred to as ‚Äúrealizing‚Äù the derivation.</p>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>Analogy:</strong> Think of a package definition as an architectural blueprint, the\nderivation as the detailed construction plan, and the realized package as the\nfinished building.</p>\n</details>\n## Skeleton of a Derivation\n<p>The most basic derivation structure in Nix looks like this:</p>\n<pre><code class=\"language-nix\">{ stdenv }:\n\nstdenv.mkDerivation { }\n</code></pre>\n<ul>\n<li>\n<p>This is a function that expects an attribute set containing <code>stdenv</code> as its\nargument.</p>\n</li>\n<li>\n<p>It then calls <code>stdenv.mkDerivation</code> (a function provided by <code>stdenv</code>) to\nproduce a derivation.</p>\n</li>\n<li>\n<p>Currently, this derivation doesn‚Äôt specify any build steps or outputs.</p>\n</li>\n<li>\n<p>Further Reading:</p>\n</li>\n<li>\n<p><a href=\"https://ryantm.github.io/nixpkgs/stdenv/stdenv/\">The Standard Environment</a></p>\n</li>\n<li>\n<p><a href=\"https://nixos.org/guides/nix-pills/19-fundamentals-of-stdenv.html\">Fundamentals of Stdenv</a></p>\n</li>\n</ul>\n<h2>Example: A Simple ‚ÄúHello‚Äù Package Definition</h2>\n<p>Here‚Äôs a package definition for the classic ‚Äúhello‚Äù program:</p>\n<pre><code class=\"language-nix\"># hello.nix\n{\n  stdenv,\n  fetchzip,\n}:\n\nstdenv.mkDerivation {\n  pname = \"hello\";\n  version = \"2.12.1\";\n\n  src = fetchzip {\n    url = \"[https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz](https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz)\";\n    sha256 = \"\";\n  };\n}\n</code></pre>\n<ul>\n<li>\n<p>This is a Nix function that takes stdenv and fetchzip as arguments.</p>\n</li>\n<li>\n<p>It uses <code>stdenv.mkDerivation</code> to define the build process for the ‚Äúhello‚Äù\npackage.</p>\n<ul>\n<li>\n<p><code>pname</code>: The package name.</p>\n</li>\n<li>\n<p><code>version</code>: The package version.</p>\n</li>\n<li>\n<p><code>src</code>: Specifies how to fetch the source code using <code>fetchzip</code>.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Handling Dependencies: Importing Nixpkgs</strong></p>\n<ul>\n<li>\n<p>If you try to build <code>hello.nix</code> directly with <code>nix-build hello.nix</code>, it will\nfail because <code>stdenv</code> and <code>fetchzip</code> are part of Nixpkgs, which isn‚Äôt included\nin this isolated file.</p>\n</li>\n<li>\n<p>To make this package definition work, you need to pass the correct arguments\n(<code>stdenv</code>, <code>fetchzip</code>) to the function.</p>\n</li>\n</ul>\n<p>The recommended approach is to create a <code>default.nix</code> file in the same\ndirectory:</p>\n<pre><code class=\"language-nix\"># default.nix\n\nlet\n  nixpkgs = fetchTarball \"[https://github.com/NixOS/nixpkgs/tarball/nixos-24.05](https://github.com/NixOS/nixpkgs/tarball/nixos-24.05)\";\n  pkgs = import nixpkgs { config = {}; overlays = []; };\nin\n{\n  hello = pkgs.callPackage ./hello.nix { };\n}\n</code></pre>\n<ul>\n<li>\n<p>This <code>default.nix</code> imports Nixpkgs.</p>\n</li>\n<li>\n<p>It then uses <code>pkgs.callPackage</code> to call the function in <code>hello.nix</code>, passing\nthe necessary dependencies from Nixpkgs.</p>\n</li>\n<li>\n<p>You can now build the ‚Äúhello‚Äù package using: <code>nix-build -A hello</code>. The <code>-A</code>\nflag tells Nix to build the attribute named hello from the top-level\nexpression in default.nix.</p>\n</li>\n</ul>\n<p><strong>Realizing the Derivation and Handling sha256</strong></p>\n<ul>\n<li>\n<p><strong>Evaluation vs. Realization</strong>: While ‚Äúevaluate‚Äù refers to Nix processing an\nexpression, ‚Äúrealize‚Äù often specifically means building a derivation and\nproducing its output in the Nix store.</p>\n</li>\n<li>\n<p>When you first run <code>nix-build -A hello</code>, it will likely fail due to a missing\nsha256 hash for the source file. Nix needs this hash for security and\nreproducibility. The error message will provide the correct sha256 value.</p>\n</li>\n<li>\n<p><strong>Example Error</strong>:</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">  nix-build -A hello\n  error: hash mismatch in fixed-output derivation '/nix/store/pd2kiyfa0c06giparlhd1k31bvllypbb-source.drv':\n  specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\n  got: sha256-1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=\n  error: 1 dependencies of derivation '/nix/store/b4mjwlv73nmiqgkdabsdjc4zq9gnma1l-hello-2.12.1.drv' failed to build\n</code></pre>\n<ul>\n<li>Replace the empty <code>sha256 = \"\";</code> in <code>hello.nix</code> with the provided correct\nvalue: <code>sha256 = \"1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=\";</code>.</li>\n</ul>\n<p><strong>Building and Running the Result</strong></p>\n<p>After updating the <code>sha256</code>, you can successfully build the package:</p>\n<pre><code class=\"language-bash\">nix-build -A hello\n</code></pre>\n<p>The output will be a result symlink pointing to the built package in the Nix\nstore. You can then run the ‚Äúhello‚Äù program:</p>\n<pre><code class=\"language-bash\">./result/bin/hello\nHello, world!\n</code></pre>\n<h3>Swaytools Package Definition</h3>\n<p><strong>Example: The swaytools Package Definition</strong></p>\n<p>Let‚Äôs examine a more complex, real-world package definition from Nixpkgs:\n<code>nixpkgs/pkgs/tools/wayland/swaytools/default.nix</code>.</p>\n<pre><code class=\"language-nix\"># default.nix\n{\n  lib,\n  setuptools,\n  buildPythonApplication,\n  fetchFromGitHub,\n  slurp,\n}:\n\nbuildPythonApplication rec {\n  pname = \"swaytools\";\n  version = \"0.1.2\";\n\n  format = \"pyproject\";\n\n  src = fetchFromGitHub {\n    owner = \"tmccombs\";\n    repo = \"swaytools\";\n    rev = version;\n    sha256 = \"sha256-UoWK53B1DNmKwNLFwJW1ZEm9dwMOvQeO03+RoMl6M0Q=\";\n  };\n\n  nativeBuildInputs = [ setuptools ];\n\n  propagatedBuildInputs = [ slurp ];\n\n  meta = with lib; {\n    homepage = \"https://github.com/tmccombs/swaytools\";\n    description = \"Collection of simple tools for sway (and i3)\";\n    license = licenses.gpl3Only;\n    maintainers = with maintainers; [ atila ];\n    platforms = platforms.linux;\n  };\n}\n</code></pre>\n<h3>Breakdown of the Above default.nix</h3>\n<details>\n<summary>Click to Expand</summary>\n<p>1 <strong>Function Structure</strong>:</p>\n<ul>\n<li>\n<dl>\n<dt>The file starts with a function taking an attribute set of dependencies from\nNixpkgs: <code>{ lib, setuptools, buildPythonApplication, fetchFromGitHub, slurp }</code></dt>\n<dd>.</dd>\n</dl>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>Derivation Creation</strong>:</li>\n</ol>\n<ul>\n<li>It calls <code>buildPythonApplication</code>, a specialized helper for Python packages\n(similar to <code>stdenv.mkDerivation</code> but pre-configured for Python). The <code>rec</code>\nkeyword allows attributes within the derivation to refer to each other.</li>\n</ul>\n<ol start=\"3\">\n<li><strong>Package Metadata</strong>:</li>\n</ol>\n<ul>\n<li>\n<p><code>pname</code> and <code>version</code> define the package‚Äôs name and version.</p>\n</li>\n<li>\n<p>The <code>meta</code> attribute provides standard package information like the homepage,\ndescription, license, maintainers, and supported platforms.</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li><strong>Source Specification</strong>:</li>\n</ol>\n<ul>\n<li>The <code>src</code> attribute uses <code>fetchFromGitHub</code> to download the source code from\nthe specified repository and revision, along with its <code>sha256</code> hash for\nverification.</li>\n</ul>\n<ol start=\"5\">\n<li><strong>Build and Runtime Dependencies</strong>:</li>\n</ol>\n<ul>\n<li>\n<p><code>nativeBuildInputs</code>: Lists tools required during the build process (e.g.,\n<code>setuptools</code> for Python).</p>\n</li>\n<li>\n<p><code>propagatedBuildInputs</code>: Lists dependencies needed at runtime (e.g., <code>slurp</code>).</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><strong>Build Format</strong>:</li>\n</ol>\n<ul>\n<li><code>format = \"pyproject\";</code> indicates that the package uses a <code>pyproject.toml</code>\nfile for its Python build configuration.</li>\n</ul>\n<p><strong>Integration within Nixpkgs</strong></p>\n<ul>\n<li>\n<p><strong>Location</strong>: The swaytools definition resides in\n<code>pkgs/tools/wayland/swaytools/default.nix</code>.</p>\n</li>\n<li>\n<p><strong>Top-Level Inclusion</strong>: It‚Äôs made available as a top-level package in\n<code>pkgs/top-level/all-packages.nix</code> like this:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\"># all-packages.nix\nswaytools = python3Packages.callPackage ../tools/wayland/swaytools { };\n</code></pre>\n<ul>\n<li><code>python3Packages.callPackage</code> is used here because <code>swaytools</code> is a Python\npackage, and it ensures the necessary Python-related dependencies are correctly\npassed to the <code>swaytools</code> definition.</li>\n</ul>\n</details>\n<h2>Conclusion</h2>\n<p>In this chapter, we‚Äôve journeyed through the fundamental concept of package\ndefinitions in Nix. We‚Äôve seen how these Nix expressions act as blueprints,\nleading to the creation of derivations ‚Äì the detailed plans for building\nsoftware. Finally, we touched upon the realization process where Nix executes\nthese derivations to produce tangible packages in the Nix store. Examining the\nsimple ‚Äúhello‚Äù package and the more complex ‚Äúswaytools‚Äù definition provided\npractical insights into the structure and key attributes involved in defining\nsoftware within the Nix ecosystem.</p>\n<p>The crucial step in this process, the transformation from a package definition\nto a concrete build plan, is embodied by the <strong>derivation</strong>. This detailed\nspecification outlines every step Nix needs to take to fetch sources, build\ndependencies, compile code, and produce the final package output. Understanding\nthe anatomy and lifecycle of a derivation is key to unlocking the full power and\nflexibility of Nix.</p>\n<p>In the <strong>next chapter</strong>,\n<a href=\"https://saylesss88.github.io/Intro_to_Nix_Derivations_7.html\">Introduction to Nix Derivations</a>,\nwe will delve deeper into the structure and components of these derivations. We\nwill explore the attributes that define a build process, how dependencies are\nmanaged within a derivation, and how Nix ensures the reproducibility and\nisolation of your software builds through this fundamental concept.</p>\n<h2>Resources</h2>\n<ul>\n<li><a href=\"https://nix.dev/tutorials/packaging-existing-software.html\">Packaging Existing Software</a></li>\n</ul>\n",
      "date_published": "2025-11-21T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/NixOS_Modules_Explained.html",
      "url": "https://saylesss88.github.io/NixOS_Modules_Explained.html",
      "title": "Nix Module System Explained",
      "content_html": "<h1>NixOS Modules</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<!-- ![gruv3](images/gruv3.png) -->\n<p><img src=\"images/buildings1.png\" alt=\"buildings\" /></p>\n<p><strong>TL;DR</strong>: In this chapter, we will break down the Nix module system used by\nboth NixOS and Home-Manager. We will discuss using home-manager as a module and\nthe flexibility that modules give us. We will touch on options and break down\nthe <code>vim</code> module from the Nixpkgs collection. Finally we will display how to\ntest modules with the repl.</p>\n<p>Your <code>configuration.nix</code> is a module. For the Nixpkgs collection most modules\nare in <code>nixos/modules</code>.</p>\n<p>The suggested way of using <code>home-manager</code> according to their manual is as a\n<a href=\"https://nix-community.github.io/home-manager/index.xhtml#sec-install-nixos-module\">NixOS module</a>.\nBoth home-manager and NixOS use the same module system.</p>\n<h2>Module Structure</h2>\n<pre><code class=\"language-nix\">{\n  imports = [\n    # Paths to other modules.\n    # Compose this module out of smaller ones.\n  ];\n\n  options = {\n    # Option declarations.\n    # Declare what settings a user of this module can set.\n    # Usually this includes a global \"enable\" option which defaults to false.\n  };\n\n  config = {\n    # Option definitions.\n    # Define what other settings, services and resources should be active.\n    # Usually these depend on whether a user of this module chose to \"enable\" it\n    # using the \"option\" above.\n    # Options for modules imported in \"imports\" can be set here.\n  };\n}\n</code></pre>\n<p><code>imports</code>, <code>options</code>, and <code>config</code> are the top-level attributes of a Nix module.\nThey are the primary, reserved keys that the Nix module system recognizes and\nprocesses to combine different configurations into a single, cohesive system or\nuser environment. <code>config</code> is the same <code>config</code> you receive as a module argument\n(e.g. <code>{ pkgs, config, ... }:</code> at the top of your module function)</p>\n<p>Understanding <code>config</code>:</p>\n<p><code>config</code> is the big constantly updated blueprint of your entire system.</p>\n<p>Every time you bring in a new module, it adds its own settings and options to\nthis blueprint. So, when a module receives the <code>config</code> argument, it‚Äôs getting\nthe complete picture of everything you‚Äôve asked NixOS to set up so far.</p>\n<p>This allows the module to:</p>\n<ul>\n<li>\n<p>See what other parts of your system are doing.</p>\n</li>\n<li>\n<p>Make smart decisions based on those settings.</p>\n</li>\n<li>\n<p>Add its own pieces to the overall plan, building on what‚Äôs already there.</p>\n</li>\n<li>\n<p>Most modules are functions that take an attribute set and return an attribute\nset.</p>\n</li>\n</ul>\n<p>To turn the above module into a function accepting an attribute set just add the\nfunction arguments to the top, click the eye to see the whole module:</p>\n<pre><code class=\"language-nix\">{ config, pkgs, ... }:\n~ {\n~   imports = [\n~     # Paths to other modules.\n~     # Compose this module out of smaller ones.\n~   ];\n~\n~   options = {\n~     # Option declarations.\n~     # Declare what settings a user of this module can set.\n~     # Usually this includes a global \"enable\" option which defaults to false.\n~   };\n~\n~   config = {\n~     # Option definitions.\n~     # Define what other settings, services and resources should be active.\n~     # Usually these depend on whether a user of this module chose to \"enable\" it\n~     # using the \"option\" above.\n~     # Options for modules imported in \"imports\" can be set here.\n~   };\n~ }\n</code></pre>\n<p>It may require the attribute set to contain:</p>\n<ul>\n<li>\n<p><code>config</code>: The configuration of the entire system.</p>\n</li>\n<li>\n<p><code>options</code>: All option declarations refined with all definition and declaration\nreferences.</p>\n</li>\n<li>\n<p><code>pkgs</code>: The attribute set extracted from the Nix package collection and\nenhanced with the <code>nixpkgs.config</code> option.</p>\n</li>\n<li>\n<p><code>modulesPath</code>: The location of the module directory of NixOS.</p>\n</li>\n</ul>\n<h2>Modularize your configuration.nix</h2>\n<p>Many people start of using a single <code>configuration.nix</code> and eventually their\nsingle file configuration gets too large to search through and maintain\nconveniently.</p>\n<p>This is where <strong>modules</strong> come in allowing you to break up your configuration\ninto logical parts. Your <code>boot.nix</code> will contain settings and options related to\nthe actual boot process. You‚Äôre <code>services.nix</code> will only have services and so\non‚Ä¶</p>\n<ul>\n<li>These modules are placed in a logical path relative to either your\n<code>configuration.nix</code> or equivalent or if you‚Äôre using flakes relative to your\n<code>flake.nix</code> or equivalent.\n<ul>\n<li>The <code>imports</code> mechanism takes paths to other modules as its argument and\ncombines them to be included in the evaluation of the system configuration.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<pre><code class=\"language-nix\">{ ... }:\n{\n  imports = [\n     # Paths to other modules\n\n     # They can be relative paths\n     ./otherModule.nix\n\n     # Or absolute\n     /path/to/otherModule.nix\n\n     # Or to a directory\n     ../modules/home/shells/nushell\n  ];\n}\n</code></pre>\n</blockquote>\n<blockquote>\n<p>‚ùó: The <strong>imports</strong> mechanism includes and evaluates the Nix expression found\nat the given path <em>as a module</em>. If that path is a directory, it will\nautomatically look for and evaluate a <code>default.nix</code> file within that directory\n<em>as a module</em>. It is common to have that <code>default.nix</code> be a function that only\nimports and combines all the modules in said directory. Like the above\nexample, in the nushell directory would be a <code>default.nix</code> that is\nautomatically imported and evaluated.</p>\n</blockquote>\n<p><strong>Crucial Distinction: <code>imports</code> vs. <code>import</code></strong>:</p>\n<p>Beginners often confuse the modules attribute <code>imports = [./module.nix]</code> here\nwith the Nix builtins function <code>import module.nix</code>. The first expects a path to\na file containing a NixOS module (having the same specific structure we‚Äôre\ndescribing here), while the second loads whatever Nix expression is in that file\n(no expected structure). ‚ÄìNixOS Wiki.</p>\n<p>Considering <code>configuration.nix</code> is a module, it can be imported like any other\nmodule and this is exactly what you do when getting started with flakes.</p>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = inputs@{ nixpkgs, home-manager, ... }: {\n    nixosConfigurations = {\n      hostname = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n          home-manager.nixosModules.home-manager\n          {\n            home-manager.useGlobalPkgs = true;\n            home-manager.useUserPackages = true;\n            home-manager.users.jdoe = ./home.nix;\n\n            # Optionally, use home-manager.extraSpecialArgs to pass\n            # arguments to home.nix\n          }\n        ];\n      };\n    };\n  };\n}\n</code></pre>\n<p><code>modules = [...]</code> in <code>flake.nix</code>: This is effectively the initial <code>imports</code> list\nfor your entire NixOS system or Home Manager user configuration. It tells the\nNix module system: ‚ÄúStart by collecting and merging the configurations defined\nin these specific modules.‚Äù</p>\n<p>The above example is what you get from running:\n<code>nix flake new /etc/nixos -t github:nix-community/home-manager#nixos</code></p>\n<p>If you notice the <code>home-manager.nixosModules.home-manager</code>, that is what imports\nhome-manager as a module.</p>\n<p>You could also make the actual home-manager module and import it like this:</p>\n<pre><code class=\"language-nix\"># home-manager.nix\n{ inputs, outputs, ... }: {\n  imports = [\n    # Import home-manager's NixOS module\n    inputs.home-manager.nixosModules.home-manager\n  ];\n\n  home-manager = {\n    extraSpecialArgs = { inherit inputs outputs; };\n    users = {\n      # Import your home-manager configuration\n      your-username = import ../home-manager/home.nix;\n    };\n  };\n}\n</code></pre>\n<p>This ‚Äúmodule‚Äù isn‚Äôt much different from the one included in the <code>flake.nix</code>\nabove, it is just shown here to show the flexibility of modules. They can be as\nbig and complex or as small and simple as you want. You can break up every\nsingle program or component of your configuration into individual modules or\nhave modules that bundle similar programs the choice is yours.</p>\n<p>Then in your <code>configuration.nix</code> or equivalent you would add <code>home-manager.nix</code>\nto your imports list and you would have home-manager as a NixOS module.</p>\n<details>\n<summary>\n‚úîÔ∏è Refresher (Click to Expand):\n</summary>\n<p>An <strong>attribute set</strong> is a collection of name-value pairs called <em>attributes</em>:</p>\n<p>Attribute sets are written enclosed in curly braces <code>{}</code>. Attribute names and\nattribute values are separated by an equal sign <code>=</code>. Each value can be an\narbitrary expression, terminated by a semicolon <code>;</code>.</p>\n<blockquote>\n<p><strong>Example</strong>:<a href=\"https://nix.dev/manual/nix/2.24/language/syntax#attrs-literal\">nix.dev reference</a>\nThis defines an attribute set with attributes named:</p>\n<ul>\n<li><code>x</code> with the value <code>123</code>, an integer</li>\n<li><code>text</code> with the value <code>\"Hello\"</code>, a string</li>\n<li><code>y</code> where the value is the result of applying the function <code>f</code> to the\nattribute set <code>{bla = 456; }</code></li>\n</ul>\n<pre><code class=\"language-nix\">{\n x = 123;\n text = \"Hello\";\n y = f { bla = 456; };\n}\n</code></pre>\n<pre><code class=\"language-nix\">{ a = \"Foo\"; b = \"Bar\"}.a\n~ \"Foo\"\n</code></pre>\n</blockquote>\n<p>Attributes can appear in any order. An attribute name may only occur once in\neach attribute set.</p>\n<blockquote>\n<p>‚ùó Remember <code>{}</code> is a valid attribute set in Nix.</p>\n</blockquote>\n<p>The following is a <strong>function</strong> with an attribute set argument, remember that\nanytime you see a <code>:</code> in Nix code it means this is a function. To the left is\nthe <strong>function arguments</strong> and to the right is the <strong>function body</strong>:</p>\n<pre><code class=\"language-nix\">{ a, b }: a + b\n</code></pre>\n<p>The simplest possible <strong>NixOS Module</strong>:</p>\n<pre><code class=\"language-nix\">{ ... }:\n{\n}\n</code></pre>\n</details>\n<p>NixOS produces a full system configuration by combining smaller, more isolated\nand reusable components: <strong>Modules</strong>. If you want to understand Nix and NixOS\nmake sure you grasp modules!</p>\n<p>A NixOS module defines configuration options and behaviors for system\ncomponents, allowing users to extend, customize, and compose configurations\ndeclaratively.</p>\n<p>A <strong>module</strong> is a file containing a Nix expression with a specific structure. It\n<em>declares</em> options for other modules to define (give a value). Modules were\nintroduced to allow extending NixOS without modifying its source code.</p>\n<p>To define any values, the module system first has to know which ones are\nallowed. This is done by declaring options that specify which attributes can be\nset and used elsewhere.</p>\n<p>If you want to write your own modules, I recommend setting up\n<a href=\"https://github.com/nix-community/nixd?tab=readme-ov-file\">nixd</a> or\n<a href=\"https://github.com/oxalica/nil\">nil</a> with your editor of choice. This will\nallow your editor to warn you about missing arguments and dependencies as well\nas syntax errors.</p>\n<h3>Declaring Options</h3>\n<p>Options are declared under the top-level <code>options</code> attribute with\n<code>lib.mkOption</code>.</p>\n<p><a href=\"https://nixos.org/manual/nixpkgs/stable/#function-library-lib.options.mkOption\">mkOption</a>\nCreates an Option attribute set. It accepts an attribute set with certain keys\nsuch as, <code>default</code>, <code>package</code>, and <code>example</code>.</p>\n<pre><code class=\"language-nix\"># options.nix\n{ lib, ... }:\n{\n  options = {\n    name = lib.mkOption { type = lib.types.str; };\n  };\n}\n</code></pre>\n<blockquote>\n<p><code>lib</code> provides helper functions from <code>nixpkgs.lib</code> and the ellipsis (<code>...</code>) is\nfor arbitrary arguments which means that this function is prepared to accept\n<strong>any additional arguments</strong> that the caller might provide, even if those\narguments are not explicitly named or used within the module‚Äôs body. They make\nthe modules more flexible, without the <code>...</code> each module would have to\nexplicitly list every possible argument it might receive, which would be\ncumbersome and error-prone. So <code>{lib, ... }:</code> means that ‚ÄúI need the <code>lib</code>\nargument‚Äù <strong>and</strong> I acknowledge that the module system might pass other\narguments automatically (like <code>config</code>, <code>pkgs</code>, etc.) and I‚Äôm fine with them\nbeing there, even if I don‚Äôt use them directly in this specific module file.</p>\n</blockquote>\n<h3>Defining Values</h3>\n<p>Options are <strong>set</strong> or <strong>defined</strong> under the top-level <code>config</code> attribute:</p>\n<pre><code class=\"language-nix\"># config.nix\n{ ... }:\n{\n  config = {\n    name = \"Slick Jones\";\n  };\n}\n</code></pre>\n<p>In this <strong>option declaration</strong>, we created an option <code>name</code> of type <em>string</em> and\nset that same option to a string.</p>\n<p><strong>Option Definitions</strong> can be in a separate file than <strong>Option Declarations</strong></p>\n<h3>Evaluating Modules</h3>\n<p>Modules are <strong>evaluated</strong> with\n<a href=\"https://nixos.org/manual/nixpkgs/stable/#module-system-lib-evalModules\">lib.evalModules</a>\n<code>lib.evalModules</code> evaluates a set of modules, typically once per application\n(e.g. once for NixOS and once for Home-Manager).</p>\n<h2>Checking out the Vim module provided by Nixpkgs</h2>\n<p>The following is <code>nixpkgs/nixos/modules/programs/vim.nix</code>, a module that is\nincluded in the Nixpkgs collection:</p>\n<pre><code class=\"language-nix\">{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\n\nlet\n  cfg = config.programs.vim;\nin\n{\n  options.programs.vim = {\n    enable = lib.mkEnableOption \"Vi IMproved, an advanced text\";\n\n    defaultEditor = lib.mkEnableOption \"vim as the default editor\";\n\n    package = lib.mkPackageOption pkgs \"vim\" { example = \"vim-full\"; };\n  };\n\n  # TODO: convert it into assert after 24.11 release\n  config = lib.mkIf (cfg.enable || cfg.defaultEditor) {\n    warnings = lib.mkIf (cfg.defaultEditor &amp;&amp; !cfg.enable) [\n      \"programs.vim.defaultEditor will only work if programs.vim.enable is\n       enabled, which will be enforced after the 24.11 release\"\n    ];\n    environment = {\n      systemPackages = [ cfg.package ];\n      variables.EDITOR = lib.mkIf cfg.defaultEditor (lib.mkOverride 900 \"vim\");\n      pathsToLink = [ \"/share/vim-plugins\" ];\n    };\n  };\n}\n</code></pre>\n<p>It provides options to enable Vim, set it as the default editor, and specify the\nVim package to use.</p>\n<details>\n<summary> ‚úîÔ∏è Breakdown of the vim module.(Click to Expand)</summary>\n1. Module Inputs and Structure:\n<pre><code class=\"language-nix\">{\n  config,\n  lib,\n  pkgs,\n  ...\n}\n</code></pre>\n<p><strong>Inputs</strong>: The module takes the above inputs and <code>...</code> (catch-all for other\nargs)</p>\n<ul>\n<li>\n<p><code>config</code>: Allows the module to read option values (e.g.\n<code>config.programs.vim.enable</code>). It provides access to the evaluated\nconfiguration.</p>\n</li>\n<li>\n<p><code>lib</code>: The Nixpkgs library, giving us helper functions like <code>mkEnableOption</code> ,\n<code>mkIf</code>, and <code>mkOverride</code>.</p>\n</li>\n<li>\n<p><code>pkgs</code>: The Nixpkgs package set, used to access packages like <code>pkgs.vim</code></p>\n</li>\n<li>\n<p><code>...</code>: Allows the module to accept additional arguments, making it flexible\nfor extension in the future.</p>\n</li>\n</ul>\n<blockquote>\n<p>Key Takeaways: A NixOS module is typically a function that can include\n<code>config</code>, <code>lib</code>, and <code>pkgs</code>, but it doesn‚Äôt require them. The <code>...</code> argument\nensures flexibility, allowing a module to accept extra inputs without breaking\nfuture compatibility. Using <code>lib</code> simplifies handling options (mkEnableOption,\nmkIf, mkOverride) and helps follow best practices. Modules define options,\nwhich users can set in their configuration, and <code>config</code>, which applies\nchanges based on those options.</p>\n</blockquote>\n<ol start=\"2\">\n<li>Local Configuration Reference:</li>\n</ol>\n<pre><code class=\"language-nix\">let\n  cfg = config.programs.vim;\nin\n</code></pre>\n<p>This is a local alias. Instead of typing <code>config.programs.vim</code> over and over,\nthe module uses <code>cfg</code>.</p>\n<ol start=\"3\">\n<li>Option Declaration</li>\n</ol>\n<pre><code class=\"language-nix\">options.programs.vim = {\n  enable = lib.mkEnableOption \"Vi IMproved, an advanced text\";\n  defaultEditor = lib.mkEnableOption \"vim as the default editor\";\n  package = lib.mkPackageOption pkgs \"vim\" { example = \"vim-full\"; };\n};\n</code></pre>\n<p>This defines three user-configurable options:</p>\n<ul>\n<li>\n<p><code>enable</code>: Turns on Vim support system-wide.</p>\n</li>\n<li>\n<p><code>defaultEditor</code>: Sets Vim as the system‚Äôs default <code>$EDITOR</code>.</p>\n</li>\n<li>\n<p><code>package</code>: lets the user override which Vim package is used.</p>\n</li>\n</ul>\n<blockquote>\n<p><code>mkPackageOption</code> is a helper that defines a package-typed option with a\ndefault (<code>pkgs.vim</code>) and provides docs + example. Using <code>lib.mkEnableOption</code>\nmakes it clear exactly where this function is coming from. Same with\n<code>lib.mkIf</code> and as you can see they can be further down the configuration,\nfurther from where you defined <code>with lib;</code> making it less clear where they\ncome from. Explicitness is your friend when it comes to reproducability and\nclarity.</p>\n</blockquote>\n<ol start=\"4\">\n<li>Conditional Configuration</li>\n</ol>\n<pre><code class=\"language-nix\">config = lib.mkIf (cfg.enable || cfg.defaultEditor) {\n</code></pre>\n<ul>\n<li>This block is only activated if <em>either</em> <code>programs.vim.enable</code> or\n<code>defaultEditor</code> is set.</li>\n</ul>\n<ol start=\"5\">\n<li>Warnings</li>\n</ol>\n<pre><code class=\"language-nix\">warnings = lib.mkIf (cfg.defaultEditor &amp;&amp; !cfg.enable) [\n  \"programs.vim.defaultEditor will only work if programs.vim.enable is enabled,\n   which will be enforced after the 24.11 release\"\n];\n</code></pre>\n<p>Gives you a soft warning if you try to set <code>defaultEditor = true</code> without also\nenabling Vim.</p>\n<ol start=\"6\">\n<li>Actual System Config Changes</li>\n</ol>\n<pre><code class=\"language-nix\">environment = {\n  systemPackages = [ cfg.package ];\n  variables.EDITOR = lib.mkIf cfg.defaultEditor (lib.mkOverride 900 \"vim\");\n  pathsToLink = [ \"/share/vim-plugins\" ];\n};\n</code></pre>\n<p>It adds Vim to your <code>systemPackages</code>, sets <code>$EDITOR</code> if <code>defaultEditor</code> is true,\nand makes <code>/share/vim-plugins</code> available in the environment.</p>\n</details>\n<p>The following is a bat home-manager module that I wrote:</p>\n<pre><code class=\"language-nix\"># bat.nix\n{\n  pkgs,\n  config,\n  lib,\n  ...\n}: let\n  cfg = config.custom.batModule;\nin {\n  options.custom.batModule.enable = lib.mkOption {\n    type = lib.types.bool;\n    default = false;\n    description = \"Enable bat module\";\n  };\n\n  config = lib.mkIf cfg.enable {\n    programs.bat = {\n      enable = true;\n      themes = {\n        dracula = {\n          src = pkgs.fetchFromGitHub {\n            owner = \"dracula\";\n            repo = \"sublime\"; # Bat uses sublime syntax for its themes\n            rev = \"26c57ec282abcaa76e57e055f38432bd827ac34e\";\n            sha256 = \"019hfl4zbn4vm4154hh3bwk6hm7bdxbr1hdww83nabxwjn99ndhv\";\n          };\n          file = \"Dracula.tmTheme\";\n        };\n      };\n      extraPackages = with pkgs.bat-extras; [\n        batdiff\n        batman\n        prettybat\n        batgrep\n      ];\n    };\n  };\n}\n</code></pre>\n<p>Now I could add this to my <code>home.nix</code> to enable it:</p>\n<pre><code class=\"language-nix\"># home.nix\ncustom = {\n  batModule.enable = true;\n}\n</code></pre>\n<p>If I set this option to true the bat configuration is dropped in place. If it‚Äôs\nnot set to true, it won‚Äôt put the bat configuration in the system. Same as with\noptions defined in modules within the Nixpkgs repository.</p>\n<p>If I had set the default to <code>true</code>, it would automatically enable the module\nwithout requiring an explicit <code>custom.batModule.enable = true;</code> call in my\n<code>home.nix</code>.</p>\n<h3>Module Composition</h3>\n<p>NixOS achieves its full system configuration by combining the configurations\ndefined in various modules. This composition is primarily handled through the\n<code>imports</code> mechanism.</p>\n<p><code>imports</code>: This is a standard option within a NixOS or Home Manager\nconfiguration (often found in your configuration.nix or home.nix). It takes a\nlist of paths to other Nix modules. When you include a module in the imports\nlist, the options and configurations defined in that module become part of your\noverall system configuration.</p>\n<p>You declaratively state the desired state of your system by setting options\nacross various modules. The NixOS build system then evaluates and merges these\noption settings. The culmination of this process, which includes building the\nentire system closure, is represented by the derivation built by\n<code>config.system.build.toplevel</code>.</p>\n<h3>NixOS Modules and Dependency Locking with npins</h3>\n<details>\n<summary> ‚úîÔ∏è npins example (Click to Expand)</summary>\nAs our NixOS configurations grow in complexity, so too does the challenge of\nmanaging the dependencies they rely on. Ensuring consistency and reproducibility\nnot only applies to individual packages but also to the versions of Nixpkgs and\nother external resources our configurations depend upon.\n<p>Traditionally, NixOS configurations often implicitly rely on the version of\nNixpkgs available when <code>nixos-rebuild</code> is run. However, for more robust and\nreproducible setups, especially in collaborative environments or when rolling\nback to specific configurations, explicitly locking these dependencies to\nspecific versions becomes crucial.</p>\n<p>In the following example, we‚Äôll explore how to use a tool called <code>npins</code> to\nmanage and lock the dependencies of a NixOS configuration, ensuring a more\npredictable and reproducible system. This will involve setting up a project\nstructure and using npins to pin the specific version of Nixpkgs our\nconfiguration relies on.</p>\n<p>This is the file structure:</p>\n<pre><code class=\"language-bash\">‚ùØ tree\n.\n‚îú‚îÄ‚îÄ configuration.nix\n‚îú‚îÄ‚îÄ default.nix\n‚îú‚îÄ‚îÄ desktop.nix\n‚îî‚îÄ‚îÄ npins\n    ‚îú‚îÄ‚îÄ default.nix\n    ‚îî‚îÄ‚îÄ sources.json\n</code></pre>\n<p>This uses <code>npins</code> for dependency locking. Install it and run this in the project</p>\n<p>directory:</p>\n<pre><code class=\"language-bash\">npins init\n</code></pre>\n<p>Create a <code>default.nix</code> with the following:</p>\n<pre><code class=\"language-nix\"># default.nix\n{ system ? builtins.currentSystem, sources ? import ./npins, }:\nlet\n  pkgs = import sources.nixpkgs {\n    config = { };\n    overlays = [ ];\n  };\n  inherit (pkgs) lib;\nin lib.makeScope pkgs.newScope (self: {\n\n  shell = pkgs.mkShell { packages = [ pkgs.npins self.myPackage ]; };\n\n    # inherit lib;\n\n  nixosSystem = import (sources.nixpkgs + \"/nixos\") {\n    configuration = ./configuration.nix;\n  };\n\n  moduleEvale = lib.evalModules {\n    modules = [\n      # ...\n    ];\n  };\n})\n</code></pre>\n<p>A <code>configuration.nix</code> with the following:</p>\n<pre><code class=\"language-nix\"># configuration.nix\n{\n  boot.loader.grub.device = \"nodev\";\n  fileSystems.\"/\".device = \"/devst\";\n  system.stateVersion = \"25.05\";\n\n  # declaring options means to declare a new option\n  # defining options means to define a value of an option\n  imports = [\n    # ./main.nix\n     ./desktop.nix # Files\n    # ./minimal.nix\n  ];\n\n  # mine.desktop.enable = true;\n}\n</code></pre>\n<p>And a <code>desktop.nix</code> with the following:</p>\n<pre><code class=\"language-nix\"># desktop.nix\n{ pkgs, lib, config, ... }:\n\n{\n  imports = [];\n\n  # Define an option to enable or disable desktop configuration\n  options.mine.desktop.enable = lib.mkEnableOption \"desktop settings\";\n\n  # Configuration that applies when the option is enabled\n  config = lib.mkIf config.mine.desktop.enable {\n    environment.systemPackages = [ pkgs.git ];\n  };\n}\n</code></pre>\n<p><code>mkEnableOption</code> defaults to false. Now in your <code>configuration.nix</code> you can\nuncomment <code>mine.desktop.enable = true;</code> to enable the desktop config and\nvice-versa.</p>\n<p>You can test that this works by running:</p>\n<pre><code class=\"language-bash\">nix-instantiate -A nixosSystem.system\n</code></pre>\n<p><code>nix-instantiate</code> performs only the evaluation phase of Nix expressions. During\nthis phase, Nix interprets the Nix code, resolves all dependencies, and\nconstructs derivations but does not execute any build actions. Useful for\ntesting.</p>\n<p>To check if this worked and <code>git</code> is installed in systemPackages you can load it\ninto <code>nix repl</code> but first you‚Äôll want <code>lib</code> to be available so uncomment this in\nyour <code>default.nix</code>:</p>\n<pre><code class=\"language-nix\"># default.nix\ninherit lib;\n</code></pre>\n<p>Rerun <code>nix-instantiate -A nixosSystem.system</code></p>\n<p>Then load the repl and check that <code>git</code> is in <code>systemPackages</code>:</p>\n<pre><code class=\"language-bash\">nix repl -f .\nnix-repl&gt; builtins.filter (pkg: lib.hasPrefix \"git\" pkg.name) nixosSystem.config.environment.systemPackages\n</code></pre>\n<p>This shows the path to the derivation</p>\n<p>Check that mine.desktop.enable is true</p>\n<pre><code class=\"language-nix\">nix-repl&gt; nixosSystem.config.mine.desktop.enable\ntrue\n</code></pre>\n<p>As demonstrated with npins, explicitly managing the dependencies of your NixOS\nmodules is a powerful technique for ensuring the long-term stability and\nreproducibility of your system configurations. By pinning specific versions of\nNixpkgs and other resources, you gain greater control over your environment and\nreduce the risk of unexpected changes due to upstream updates.</p>\n</details>\n<h3>Best Practices</h3>\n<p>You‚Äôll see the following all throughout Nix code and is convenient although it\ndoesn‚Äôt follow best practices. One reason is static analysis can‚Äôt reason about\nthe code (e.g. Because it implicitly brings all attributes into scope, tools\ncan‚Äôt verify which ones are actually being used), because it would have to\nactually evaluate the files to see which names are in scope:</p>\n<pre><code class=\"language-nix\"># utils.nix\n{ pkgs, ... }: {\n  environment.systemPackages = with pkgs; [\n    rustup\n    evcxr\n    nix-prefetch-git\n  ];\n}\n</code></pre>\n<p>Another reason the above expression is considered an ‚Äúanti-pattern‚Äù is when more\nthen one <code>with</code> is used, it‚Äôs no longer clear where the names are coming from.</p>\n<p>Scoping rules for <code>with</code> are not intuitive, see\n<a href=\"https://github.com/NixOS/nix/issues/490\">issue</a> ‚Äìnix.dev This can make\ndebugging harder, as searching for variable origins becomes ambiguous (i.e. open\nto more than one interpretation).</p>\n<p>The following follows best practices:</p>\n<pre><code class=\"language-nix\">{pkgs, ... }: {\n  environment.systemPackages = builtins.attrValues {\n    inherit (pkgs)\n      rustup\n      evcxr\n      nix-prefetch-git;\n  };\n}\n</code></pre>\n<ul>\n<li><a href=\"https://noogle.dev/f/builtins/attrValues\">Noogle builtins.attrValues</a></li>\n</ul>\n<details>\n<summary> ‚úîÔ∏è Above Command Summary (Click to Expand) </summary>\n<pre><code class=\"language-nix\">{\n  inherit (pkgs) rustup evcxr nix-prefetch-git;\n}\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code class=\"language-nix\">{\n  rustup = pkgs.rustup;\n  evcxr = pkgs.evcxr;\n  nix-prefetch-git = pkgs.nix-prefetch-git;\n}\n</code></pre>\n<p>Applying <code>builtins.attrValues</code> produces:</p>\n<pre><code class=\"language-nix\">[ pkgs.evcxr pkgs.nix-prefetch-git pkgs.rustup ]\n</code></pre>\n<p>As you can see only the values are included in the list, not the keys. This is\nmore explicit and declarative but can be more complicated, especially for a\nbeginner.</p>\n<p><code>builtins.attrValues</code> returns the values of all attributes in the given set,\nsorted by attribute name. The above expression turns into something like the\nfollowing avoiding bringing every attribute name from <code>nixpkgs</code> into scope.</p>\n<p>A more straightforward example:</p>\n<pre><code class=\"language-nix\">attrValues {c = 3; a = 1; b = 2;}\n=&gt; [1 2 3]\n</code></pre>\n</details>\n<p>This approach avoids unintended name clashes or confusion when debugging.</p>\n<p>Upon looking into this a bit further, most people use the following format to\navoid the ‚Äúanti-pattern‚Äù from using <code>with pkgs;</code>:</p>\n<pre><code class=\"language-nix\"># utils.nix\n{ pkgs, ... }: {\n  environment.systemPackages = [\n    pkgs.rustup\n    pkgs.evcxr\n    pkgs.nix-prefetch-git\n  ];\n}\n</code></pre>\n<p>While the performance differences might be negligible on modern computers,\nadopting this best practice from the start is highly recommended. The above\napproach is more explicit, it‚Äôs clear exactly where each package is coming from.</p>\n<p>If maintaining strict scope control matters, use <code>builtins.attrValues</code>.</p>\n<p>If readability and simplicity are more your priority, explicitly referencing\n<code>pkgs.&lt;packageName&gt;</code> might be better. Now you can choose for yourself.</p>\n<h4>Conclusion</h4>\n<p>As we have seen throughout this chapter, modules are the building blocks of your\nNixOS system and are themselves often functions. There are a few different ways\nto use these modules to build your system. In the next chapter,\n<a href=\"https://saylesss88.github.io/Nix_Flakes_Explained_4.html\">Nix Flakes Explained</a>\nwe will learn about Nix Flakes as a more modern and comprehensive entrypoint for\nmanaging your entire system and its dependencies.</p>\n<p>To further deepen your understanding of NixOS Modules and the broader ecosystem\nof tools and best practices surrounding them, the following resources offer\nvaluable insights and information.</p>\n<h4>Resources on Modules</h4>\n<details>\n<summary> ‚úîÔ∏è Resources (Click to Expand) </summary>\n<ul>\n<li>\n<p><a href=\"https://nixos.org/manual/nixos/stable/#sec-writing-modules\">WritingNixOsModules</a></p>\n</li>\n<li>\n<p><a href=\"https://nixos.wiki/wiki/NixOS_modules\">NixWikiNixOSModules</a></p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/tutorials/module-system/a-basic-module/index.html\">nix.dev A basic module</a></p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/tutorials/module-system/deep-dive#module-system-deep-dive\">ModuleSystemDeepDive</a></p>\n</li>\n<li>\n<p><a href=\"https://xeiaso.net/talks/asg-2023-nixos/\">xeiaso Nixos Modules for fun &amp; profit</a></p>\n</li>\n<li>\n<p><a href=\"https://nixos-and-flakes.thiscute.world/other-usage-of-flakes/module-system\">NixOS Flakes Book Module System</a></p>\n</li>\n</ul>\n<h1>Videos</h1>\n<p><a href=\"https://www.youtube.com/watch?v=N7hFP_40DJo&amp;t=17s\">NixHour Writing NixOS modules</a>\n‚Äì This example is from this video\n<a href=\"https://infinisil.com/modules.mp4\">infinisilModules</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=cZjOzOHb2ow\">tweagModuleSystemRecursion</a></p>\n</details>\n",
      "date_published": "2025-11-21T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/Nix_Flakes_Explained.html",
      "url": "https://saylesss88.github.io/Nix_Flakes_Explained.html",
      "title": "Nix Flakes Explained",
      "content_html": "<h1>Nix Flakes Explained</h1>\n<details>\n<summary> ‚úîÔ∏è Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><img src=\"images/trees3.cleaned.png\" alt=\"trees3\" /></p>\n<!-- <img src=\"images/gruv15.png\" width=\"800\" height=\"600\"> -->\n<h2>Nix Flakes</h2>\n<p>If you‚Äôre completely new, take a look at\n<a href=\"https://nixos.wiki/wiki/flakes#Installing_flakes\">this</a> to get flakes on your\nsystem.</p>\n<p>For the Nix Flake man page type <code>man nix3 flake</code> and for a specific feature,\ntype something like <code>man nix3 flake-lock</code>.</p>\n<p>Flakes replace stateful channels (which cause much confusion among novices) and\nintroduce a more intuitive and consistent CLI, making them a perfect opportunity\nto start using Nix. ‚Äì Alexander Bantyev\n<a href=\"https://serokell.io/blog/practical-nix-flakes\">Practical Nix Flakes</a></p>\n<p>The ‚Äústate‚Äù being remembered and updated by channels is the specific revision of\nthe Nixpkgs repository that your local Nix installation considers ‚Äúcurrent‚Äù for\na given channel. When this state changes on your machine, your builds diverge\nfrom others whose machines have a different, independently updated channel\nstate.</p>\n<p>Channels are also constantly updated on the remote servers. So, ‚Äúnixos-unstable‚Äù\ntoday refers to a different set of packages and versions than ‚Äúnixos-unstable‚Äù\ndid yesterday or will tomorrow.</p>\n<p>Flakes solve this by making the exact revision of <code>nixpkgs</code> (and other\ndependencies) an explicit input within your <code>flake.nix</code> file, pinned in the\n<code>flake.lock</code>. This means the state is explicitly defined in the configuration\nitself, not implicitly managed by a global system setting.</p>\n<p>Evaluation time is notoriously slow on NixOS, the problem was that in the past\nNix evaluation wasn‚Äôt hermetic preventing effective evaluation caching. A <code>.nix</code>\nfile can import other Nix files or by looking them up in the Nix search path\n(<code>$NIX_PATH</code>). This causes a cached result to be inconsistent unless every file\nis perfectly kept track of. Flakes solve this problem by ensuring fully hermetic\nevaluation.</p>\n<p>‚ÄúHermetic‚Äù means that the output of an evaluation (the derivation itself)\ndepends <em>only</em> on the explicit inputs provided, not on anything external like\nenvironment variables or pulling in files only on your system. This is the\nproblem that Nix solves and the problem that flakes are built around.</p>\n<h2>What is a Nix Flake?</h2>\n<p><strong>Nix flakes</strong> are independent components in the Nix ecosystem. They define\ntheir own <strong>dependencies</strong> (inputs) and what they produce (outputs), which can\ninclude <strong>packages</strong>, <strong>deployment configurations</strong>, or <strong>Nix functions</strong> for\nother flakes to use.</p>\n<p>Flakes provide a standardized framework for building and managing software,\nmaking all project inputs explicit for greater reproducibility and\nself-containment.</p>\n<p>At its core, a flake is a source tree (like a Git repository) that contains a\n<code>flake.nix</code> file in its root directory. This file provides a standardized way to\naccess Nix artifacts such as packages and modules.</p>\n<p>Flakes provide a standard way to write Nix expressions (and therefore packages)\nwhose dependencies are version-pinned in a lock file, improving reproducibility\nof Nix installations. ‚Äì NixOS Wiki</p>\n<p>Think of <code>flake.nix</code> as the central entry point of a flake. It not only defines\nwhat the flake produces but also declares its dependencies.</p>\n<h3>Key Concepts</h3>\n<p><code>flake.nix</code>: <strong>The Heart of a Flake</strong></p>\n<p>The <code>flake.nix</code> file is mandatory for any flake. It must contain an attribute\nset with at least one required attribute: <code>outputs</code>. It can also optionally\ninclude <code>description</code> and <code>inputs</code>.</p>\n<p><strong>Basic Structure:</strong></p>\n<pre><code class=\"language-nix\">{\n  description = \"Package description\";\n  inputs = { /* Dependencies go here */ };\n  outputs = { /* What the flake produces */ };\n  nixConfig = { /* Advanced configuration options */ };\n}\n</code></pre>\n<p>I typically see <code>nixConfig</code> used for extra-substituters for cachix. This is a\ngeneral-purpose way to define Nix configuration options that apply when this\nflake is evaluated or built. It ties into your <code>/etc/nix/nix.conf</code> or\n<code>~/.config/nix/nix.conf</code>.</p>\n<p>For example, create a directory and add a <code>flake.nix</code> with the following\ncontents, yes this is a complete <code>flake.nix</code> demonstrating <em>outputs</em> being the\nonly required attribute:</p>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  outputs = _: { multiply = 2 * 2; };\n}\n</code></pre>\n<p>Now evaluate it with:</p>\n<pre><code class=\"language-bash\">nix eval .#multiply\n4\n</code></pre>\n<p>In the <code>outputs = _: { ... };</code> line, the <code>_</code> (underscore) is a placeholder\nargument. It represents the inputs that the outputs function could receive (like\n<code>inputs</code>, <code>self</code>, <code>pkgs</code>, etc.), but in this specific case, we‚Äôre not using any\nof them to define the multiply attribute. It‚Äôs a common convention in Nix to use\n<code>_</code> when an argument is required by a function but intentionally ignored.</p>\n<p>In the command <code>nix eval .#multiply</code>:</p>\n<ul>\n<li>\n<p>the <code>.</code> signifies the current directory, indicating that Nix should look for a\n<code>flake.nix</code> file in the directory where you‚Äôre running the command.</p>\n</li>\n<li>\n<p>The <code>#</code> is used to select a specific attribute from the <code>outputs</code> of the\nflake. In this case, it‚Äôs telling Nix to evaluate the <code>multiply</code> attribute.</p>\n</li>\n</ul>\n<p>In the next example we will create a <code>devShells</code> output as well as a <code>packages</code>\noutput.</p>\n<p><strong><code>flake.lock</code> auto-generated lock file</strong></p>\n<p>All flake inputs are pinned to specific revisions in a lockfile called\n<code>flake.lock</code> This file stores the revision info as JSON.</p>\n<p>The <code>flake.lock</code> file ensures that Nix flakes have purely deterministic outputs.\nA <code>flake.nix</code> file without an accompanying <code>flake.lock</code> should be considered\nincomplete and a kind of proto-flake. Any Nix CLI command that is run against\nthe flake‚Äîlike <code>nix build</code>, <code>nix develop</code>, or even <code>nix flake show</code>‚Äîgenerates a\n<code>flake.lock</code> for you.</p>\n<p>Here‚Äôs an example section of a <code>flake.lock</code> file that pins Nixpkgs to a specific\nrevision:</p>\n<pre><code class=\"language-bash\">$ cat flake.lock\n{\n  \"nodes\": {\n    \"nixpkgs\": {\n      \"info\": {\n        \"lastModified\": 1587398327,\n        \"narHash\": \"sha256-mEKkeLgUrzAsdEaJ/1wdvYn0YZBAKEG3AN21koD2AgU=\"\n      },\n      \"locked\": {\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"5272327b81ed355bbed5659b8d303cf2979b6953\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-20.03\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"root\": {\n      \"inputs\": {\n        \"nixpkgs\": \"nixpkgs\"\n      }\n    }\n  },\n  \"root\": \"root\",\n  \"version\": 5\n}\n</code></pre>\n<p>Any future build of this flake will use the version of <code>nixpkgs</code> recorded in the\nlock file. If you add new inputs, they will be automatically added when you run\na nix flake command like <code>nix flake show</code>. But it won‚Äôt replace existing locks.</p>\n<p>If you need to update a locked input to the latest version:</p>\n<pre><code class=\"language-bash\">nix flake lock --update-input nixpkgs\nnix build\n</code></pre>\n<p>The above command allows you to update individual inputs, and <code>nix flake update</code>\nwill update the whole lock file.</p>\n<h3>Helper functions that are good to know for working with Flakes</h3>\n<p><code>lib.genAttrs</code>: A function, given the name of the attribute, returns the\nattribute‚Äôs value</p>\n<p>Example:</p>\n<pre><code class=\"language-nix\">nix repl\nnix-repl&gt; :l &lt;nixpkgs&gt;\nnix-repl&gt; lib.genAttrs [ \"boom\" \"bash\" ] (name: \"sonic\" + name)\n</code></pre>\n<p><strong>Output</strong>:</p>\n<pre><code class=\"language-nix\">{\n  bash = \"sonicbash\";\n  boom = \"sonicboom\";\n}\n</code></pre>\n<p>You will often see the following:</p>\n<p>A common use for this with flakes is to have a list of different systems:</p>\n<pre><code class=\"language-nix\">     systems = [\n       \"x86_64-linux\"\n       \"aarch64-linux\"\n       \"x86_64-darwin\"\n       \"aarch64-darwin\"\n     ];\n</code></pre>\n<p>And use it to generate an attribute set for each listed system:</p>\n<pre><code class=\"language-nix\">eachSystem = lib.genAttrs systems;\n</code></pre>\n<p>The above command creates an attribute set by mapping over a list of system\nstrings. If you notice, you provide it a list (i.e. [ 1 2 3 ]) and the function\nreturns a set (i.e. <code>{ ... }</code>)</p>\n<p>Why <code>genAttrs</code> is useful:</p>\n<ul>\n<li>\n<p>It lets you define attributes (like <code>packages</code>, <code>checks</code>, <code>devShells</code>) per\nsupported system in a DRY(don‚Äôt repeat yourself), structured way.</p>\n</li>\n<li>\n<p><code>lib.mapAttrs</code>: A function, given an attribute‚Äôs name and value, returns a new\n<code>nameValuePair</code>.</p>\n</li>\n</ul>\n<p>Example:</p>\n<pre><code class=\"language-nix\">nix-repl&gt; builtins.mapAttrs (name: value: name + \"-\" + value) { x = \"foo\"; y = \"bar\"; }\n</code></pre>\n<p><strong>Output</strong>:</p>\n<pre><code class=\"language-nix\">{\n  x = \"x-foo\";\n  y = \"y-bar\";\n}\n</code></pre>\n<p><code>pkgs.mkShell</code>: is a specialized <code>stdenv.mkDerivation</code> that removes some\nrepetition when using it with <code>nix-shell</code> (or <code>nix develop</code>)</p>\n<p>Example:</p>\n<pre><code class=\"language-nix\">{ pkgs ? import &lt;nixpkgs&gt; {} }:\npkgs.mkShell {\n  packages = [ pkgs.gnumake ];\n\n  inputsFrom = [ pkgs.hello pkgs.gnutar ];\n\n  shellHook = ''\n    export DEBUG=1\n  '';\n}\n</code></pre>\n<h4>A Simple flake that outputs a devshell and a package</h4>\n<p>In a new directory create a <code>flake.nix</code></p>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  outputs = {\n    self,\n    nixpkgs,\n  }: let\n    pkgs = nixpkgs.legacyPackages.x86_64-linux;\n  in {\n\n    packages.x86_64-linux.default = pkgs.kakoune; # You could define a meta-package here\n\n    devShells.x86_64-linux.default = pkgs.mkShell {\n      packages = [\n        pkgs.kakoune\n        pkgs.git\n        pkgs.ripgrep\n        pkgs.fzf\n      ];\n    };\n  };\n}\n</code></pre>\n<p><code>mkShell</code> is a wrapper around <code>mkDerivation</code></p>\n<p>This flake offers two main outputs for <code>x86_64-linux</code> systems:</p>\n<ol>\n<li>\n<p>A <strong>standard package</strong> (<code>packages.x86_64-linux.default</code>): This simple example\njust re-exports <code>kakoune</code> from <code>nixpkgs</code>. You could build your own apps here.</p>\n</li>\n<li>\n<p>A <strong>development shell</strong> (<code>devShells.x86_64-linux.default</code>): This provides a\nconvenient environment where you have specific tools available without\ninstalling them globally on your system.</p>\n</li>\n</ol>\n<p>To use this flake you have a few options:</p>\n<ul>\n<li>\n<p><code>nix run</code> will launch kakoune</p>\n</li>\n<li>\n<p><code>nix develop</code> will activate the development environment providing all of the\npkgs listed under <code>mkShell</code>.</p>\n</li>\n<li>\n<p>Or more explicitly <code>nix develop .#devShells.x86_64-linux.default</code>, does the\nsame thing as the command above.</p>\n</li>\n</ul>\n<h4>Flake References</h4>\n<details>\n<summary> ‚úîÔ∏è Flake References (Click to Expand) </summary>\n<p><strong>Flake references</strong> (flakerefs) are a way to specify the location of a flake.\nThey have two different formats:</p>\n<blockquote>\n<p><strong>Attribute set representation</strong>:</p>\n<pre><code class=\"language-nix\">{\n  type = \"github\";\n  owner = \"NixOS\";\n  repo = \"nixpkgs\";\n}\n</code></pre>\n<p>or <strong>URL-like syntax</strong>:</p>\n<pre><code class=\"language-nix\">github:NixOS/nixpkgs\n</code></pre>\n<p>These are used on the command line as a more convenient alternative to the\nattribute set representation. For instance, in the command</p>\n<pre><code class=\"language-nix\">nix build github:NixOS/nixpkgs#hello\n</code></pre>\n<p><code>github:NixOS/nixpkgs</code> is a flake reference (while <code>hello</code> is an output\nattribute). They are also allowed in the <code>inputs</code> attribute of a flake, e.g.</p>\n<pre><code class=\"language-nix\">inputs.nixpkgs.url = \"github:NixOS/nixpkgs\";\n</code></pre>\n<p>is equivalent to</p>\n<pre><code class=\"language-nix\">inputs.nixpkgs = {\n  type = \"github\";\n  owner = \"NixOS\";\n  repo = \"nixpkgs\";\n};\n</code></pre>\n<p>‚Äì\n<a href=\"https://nix.dev/manual/nix/2.24/command-ref/new-cli/nix3-flake#flake-references\">nix.dev flake-references</a></p>\n</blockquote>\n</details>\n<h4>Nix Flake Commands</h4>\n<details>\n<summary> ‚úîÔ∏è Flake Commands (Click to Expand) </summary>\n<blockquote>\n<p><code>nix flake</code> provides subcommands for creating, modifying and querying <em>Nix\nFlakes</em>. Flakes are the unit for packaging Nix code in a reproducible and\ndiscoverable way. They can have dependencies on other flakes, making it\npossible to have multi-repository Nix projects.</p>\n</blockquote>\n<p>‚Äî From\n<a href=\"https://nix.dev/manual/nix/2.28/command-ref/new-cli/nix3-flake\">nix.dev Reference Manual</a></p>\n<ul>\n<li>\n<p>The main thing to note here is that <code>nix flake</code> is used to manage Nix flakes\nand that Flake commands are whitespace separated rather than hyphen <code>-</code>\nseparated.</p>\n</li>\n<li>\n<p>Flakes do provide some advantages when it comes to discoverability of outputs.</p>\n</li>\n<li>\n<p>For Example, two helpful commands to inspect a flake are:</p>\n<ul>\n<li>\n<p><a href=\"https://nix.dev/manual/nix/2.28/command-ref/new-cli/nix3-flake-show\">nix flake show</a>\ncommand: Show the outputs provided by a flake.</p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/manual/nix/2.28/command-ref/new-cli/nix3-flake-check\">nix flake check</a>\ncommand: check whether the flake evaluates and run its tests.</p>\n</li>\n<li>\n<p>Any Nix CLI command that is run against a flake ‚Äì like <code>nix build</code>,\n<code>nix develop</code>, <code>nix flake show</code> ‚Äì generate a <code>flake.lock</code> file for you.</p>\n<ul>\n<li>The <code>flake.lock</code> file ensures that all flake inputs are pinned to specific\nrevisions and that Flakes have purely deterministic outputs.</li>\n</ul>\n</li>\n</ul>\n<p>Example:</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">nix shell nixpkgs#ponysay --command ponysay \"Flakes Rock!\"\n</code></pre>\n<p>This works because of the [flake registry] that maps symbolic identifiers like\n<code>nixpkgs</code> to actual locations such as <code>https://github.com/NixOS/nixpkgs</code>. So the\nfollowing are equivalent:</p>\n<pre><code class=\"language-bash\">nix shell nixpkgs#ponysay --command ponysay Flakes Rock!\nnix shell github:NixOS/nixpkgs#ponysay --command ponysay Flakes Rock!\n</code></pre>\n<p>To override the <code>nixpkgs</code> registry with your own local copy you could:</p>\n<pre><code class=\"language-bash\">nix registry add nixpkgs ~/src/local-nixpkgs\n</code></pre>\n</details>\n<h3>Attribute Sets: The Building Blocks</h3>\n<details>\n<summary> ‚úîÔ∏è Attribute set Refresher (Click to Expand) </summary>\n<p><strong>Attribute sets</strong> are fundamental in Nix. They are simply collections of\nname-value pairs wrapped in curly braces <code>{}</code>.</p>\n<ul>\n<li>Example, (click to see Output):</li>\n</ul>\n<pre><code class=\"language-nix\">let\n  my_attrset = { foo = \"bar\"; };\nin\nmy_attrset.foo\n~ \"bar\"\n</code></pre>\n<p><strong>Top-Level Attributes of a Flake</strong>:</p>\n<p>Flakes have specific <strong>top-level attributes</strong> that can be accessed directly\n(without dot notation). The most common ones are <code>inputs</code>, <code>outputs</code>, and\n<code>nixConfig</code>.</p>\n  </details>\n<h3>Deeper Dive into the Structure of <code>flake.nix</code></h3>\n<!-- ![Flakes](images/Flakes.png) -->\n<p><code>inputs</code>: <strong>Declaring Dependencies</strong></p>\n<p>The <code>inputs</code> attribute set specifies the other flakes that your current flake\ndepends on.</p>\n<p>Each key in the <code>inputs</code> set is a name you choose for the dependency, and the\nvalue is a reference to that flake (usually a URL or a Git Repo).</p>\n<p>To access something from a dependency, you generally go through the <code>inputs</code>\nattribute (e.g., <code>inputs.helix.packages</code>).</p>\n<p>See\n<a href=\"https://saylesss88.github.io/flakes/flake_inputs_4.1.html\">Nix Flake inputs</a>\nfor a flake inputs deep dive.</p>\n<p><strong>Example:</strong> This declares dependencies on the <code>nixpkgs</code> and <code>import-cargo</code>\nflakes:</p>\n<pre><code class=\"language-nix\">inputs = {\n  import-cargo.url = \"github:edolstra/import-cargo\";\n  nixpkgs.url = \"nixpkgs\";\n};\n</code></pre>\n<p>When Nix evaluates your flake, it fetches and evaluates each input. These\nevaluated inputs are then passed as an attribute set to the outputs function,\nwith the keys matching the names you gave them in the inputs set.</p>\n<p>The special input <code>self</code> is a reference to the <code>outputs</code> and the source tree of\nthe current flake itself.</p>\n<p><strong><code>outputs</code>: Defining What Your Flake Provides</strong></p>\n<p>The <strong><code>outputs</code></strong> attribute defines what your flake makes available. This can\ninclude packages, NixOS modules, development environments (<code>devShells</code>) and\nother Nix derivations.</p>\n<p>Flakes can output arbitrary Nix values. However, certain outputs have specific\nmeanings for Nix commands and must adhere to particular types (often\nderivations, as described in the\n<a href=\"https://nixos.wiki/wiki/Flakes\">output schema</a>).</p>\n<p>You can inspect the outputs of a flake using the command:</p>\n<pre><code class=\"language-nix\">nix flake show\n</code></pre>\n<blockquote>\n<p>This command takes a flake URI and displays its outputs in a tree structure,\nshowing the attribute paths and their corresponding types.</p>\n</blockquote>\n<p><strong>Understanding the <code>outputs</code> Function</strong></p>\n<p>Beginners often mistakenly think that self and nixpkgs within\n<code>outputs = { self, nixpkgs, ... }: { ... }</code> are the outputs themselves. Instead,\nthey are the <em>input arguments</em> (often called <em>output arguments</em>) to the outputs\nfunction.</p>\n<p>The outputs function in <code>flake.nix</code> always takes a single argument, which is an\nattribute set. The syntax <code>{ self, nixpkgs, ... }</code> is Nix‚Äôs way of destructuring\nthis single input attribute set to extract the values associated with the keys\n<code>self</code> and <code>nixpkgs</code>.</p>\n<p>Flakes output your whole system configuration, packages, as well as Nix\nfunctions for use elsewhere.</p>\n<ul>\n<li>\n<p>For example, the <code>nixpkgs</code> repository has its own <code>flake.nix</code> file that\noutputs many helper functions via the <code>lib</code> attribute.</p>\n</li>\n<li>\n<p>For a deep dive into flake outputs, see\n<a href=\"https://saylesss88.github.io/flakes/flake_outputs_4.2.html\">Nix Flake Outputs</a></p>\n</li>\n</ul>\n<blockquote>\n<p>The <code>lib</code> convention The convention of using <code>lib</code> to output functions is\nobserved not just by Nixpkgs but by many other Nix projects. You‚Äôre free,\nhowever, to output functions via whichever attribute you prefer. ‚Äì\n<a href=\"https://zero-to-nix.com/concepts/flakes/#inputs\">Zero to Nix Flakes</a></p>\n</blockquote>\n<p>Some flake outputs are required to be system specific (i.e. ‚Äúx86_64-linux‚Äù for\n(64-bit AMD/Intel Linux) including packages, development environments, and NixOS\nconfigurations)</p>\n<p><strong>Variadic Attributes (‚Ä¶) and @-patterns</strong></p>\n<p>The <code>...</code> syntax in the input arguments of the outputs function indicates\nvariadic attributes, meaning the input attribute set can contain more attributes\nthan just those explicitly listed (like <code>lib</code> and <code>nixpkgs</code>).</p>\n<p><strong>Example:</strong></p>\n<pre><code class=\"language-nix\">mul = { a, b, ... }: a * b;\nmul { a = 3; b = 4; c = 2; } # 'c' is an extra attribute\n</code></pre>\n<p>However, you cannot directly access these extra attributes within the function\nbody unless you use the @-pattern:</p>\n<ul>\n<li>(Click for Output)</li>\n</ul>\n<pre><code class=\"language-nix\">mul = s@{ a, b, ... }: a  b  s.c; # 's' now refers to the entire input set\nmul { a = 3; b = 4; c = 2; } # Output: 24\n~ 24\n</code></pre>\n<p>When used in the outputs function argument list (e.g.,\n<code>outputs = { pkgs, ... } @ inputs)</code>, the @-pattern binds the entire input\nattribute set to a name (in this case, <code>inputs</code>) while also allowing you to\ndestructure specific attributes like pkgs.</p>\n<p><strong>What <code>outputs = { pkgs, ... } @ inputs: { ... };</code> does:</strong></p>\n<ol>\n<li>\n<p><strong>Destructuring:</strong> It tries to extract the value associated with the key\n<code>pkgs</code> from the input attribute set and binds it to the variable <code>pkgs</code>. The\n<code>...</code> allows for other keys in the input attribute set to be ignored during\nthis direct destructuring.</p>\n</li>\n<li>\n<p><strong>Binding the Entire Set:</strong> It binds the entire input attribute set to the\nvariable inputs.</p>\n<ul>\n<li>Example <code>flake.nix</code>:</li>\n</ul>\n</li>\n</ol>\n<pre><code class=\"language-nix\">{\ninputs.nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\ninputs.home-manager.url = \"github:nix-community/home-manager\";\n\noutputs = { self, nixpkgs, ... } @ attrs: { # A `packages` output for the x86_64-linux platform\npackages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello;\n\n    # A `nixosConfigurations` output (for a NixOS system named \"fnord\")\n    nixosConfigurations.fnord = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      specialArgs = attrs;\n      modules = [ ./configuration.nix ];\n    };\n\n};\n}\n</code></pre>\n<p><strong>Platform Specificity in Outputs</strong></p>\n<p>Flakes ensure that their outputs are consistent across different evaluation\nenvironments. Therefore, any package-related output must explicitly specify the\ntarget platform (a combination of architecture and OS, <code>x86_64-linux</code>).</p>\n<p><strong>legacyPackages Explained</strong></p>\n<p><code>legacyPackages</code> is a way for flakes to interact with the traditional, less\nstructured package organization of nixpkgs. Instead of packages being directly\nat the top level (e.g., <code>pkgs.hello</code>), <code>legacyPackages</code> provides a\nplatform-aware way to access them within the flake‚Äôs structured output format\n(e.g., <code>nixpkgs.legacyPackages.x86_64-linux.hello</code>). It acts as a bridge between\nthe flake‚Äôs expected output structure and nixpkgs‚Äôs historical organization.</p>\n<p><strong>The Sole Argument of outputs</strong></p>\n<p>It‚Äôs crucial to remember that the outputs function accepts only one argument,\nwhich is an attribute set. The <code>{ self, nixpkgs, ... }</code> syntax is simply\ndestructuring that single input attribute set.</p>\n<p><strong>Outputs of the Flake (Return Value)</strong></p>\n<p>The outputs of the flake refer to the attribute set that is returned by the\n<code>outputs</code> function. This attribute set can contain various named outputs like\n<code>packages</code>, <code>nixosConfigurations</code>, <code>devShells</code>, etc.</p>\n<p><strong>Imports: Including Other Nix Expressions</strong></p>\n<p>The <code>import</code> function in Nix is used to evaluate the Nix expression found at a\nspecified path (usually a file or directory) and return its value.</p>\n<p>Basic Usage: import <code>./path/to/file.nix</code></p>\n<p><strong>Passing Arguments During Import</strong></p>\n<p><code>import &lt;nixpkgs&gt; {}</code> is calling two functions, not one.</p>\n<ol>\n<li><code>import &lt;nixpkgs&gt;</code>: The first function call</li>\n</ol>\n<ul>\n<li>\n<p><code>import</code> is a built-in Nix function. Its job is to load and evaluate a Nix\nexpression from a specified path.</p>\n</li>\n<li>\n<p><code>&lt;nixpkgs&gt;</code> is a flake reference. When you use <code>import &lt;nixpkgs&gt;</code>, Nix\nevaluates the <code>default.nix</code> file (or sometimes <code>lib/default.nix</code>) found at\nthat location.</p>\n</li>\n<li>\n<p>The <code>default.nix</code> in <code>nixpkgs</code> evaluates to a function. This function is\ndesigned to be configurable, allowing you to pass arguments like <code>system</code>,\n<code>config</code>, etc. to customize how <code>nixpkgs</code> behaves and what packages it\nprovides.</p>\n</li>\n<li>\n<p>So, <code>import &lt;nixpkgs&gt;</code> doesn‚Äôt give you the <code>nixpkgs</code> package set directly; it\ngives you the function that generates the <code>nixpkgs</code> package set derivation.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><code>{}</code>: The second function call (and its argument)</li>\n</ol>\n<ul>\n<li>\n<p><code>{}</code> denotes an empty attribute set</p>\n</li>\n<li>\n<p>When an attribute set immediately follows a function, it means you are calling\nthat function and passing the attribute set as its single argument.</p>\n</li>\n</ul>\n<p>So, the <code>{}</code> after <code>import &lt;nixpkgs&gt;</code> is not part of the <code>import</code> function\niteself. It‚Äôs the argument being passed to the function that <code>import &lt;nixpkgs&gt;</code>\njust returned.</p>\n<p>You can also pass an attribute set as an argument to the Nix expression being\nimported:</p>\n<pre><code class=\"language-nix\">let\nmyHelpers = import ./lib/my-helpers.nix { pkgs = nixpkgs; };\nin\n# ... use myHelpers\n</code></pre>\n<p>In this case, the Nix expression in <code>./lib/my-helpers.nix</code> is likely a function\nthat expects an argument (often named <code>pkgs</code> by convention):</p>\n<pre><code class=\"language-nix\"># ./lib/my-helpers.nix\n\n{ pkgs }:\nlet\nmyPackage = pkgs.stdenv.mkDerivation {\nname = \"my-package\"; # ...\n};\nin\nmyPackage\n</code></pre>\n<p>By passing <code>{ pkgs = nixpkgs; }</code> during the import, you are providing the\nnixpkgs value from your current <code>flake.nix</code> scope to the pkgs parameter expected\nby the code in <code>./lib/my-helpers.nix</code>.</p>\n<p><strong>Importing Directories (<code>default.nix</code>)</strong></p>\n<p>When you use import with a path that points to a directory, Nix automatically\nlooks for a file named <code>default.nix</code> within that directory. If found, Nix\nevaluates the expressions within <code>default.nix</code> as if you had specified its path\ndirectly in the import statement.</p>\n<ul>\n<li>For more advanced examples see\n<a href=\"https://saylesss88.github.io/flakes/flake_examples_4.3.html\">Nix Flake Examples</a></li>\n</ul>\n<h5>Conclusion: Unifying Your Nix Experience with Flakes</h5>\n<p>For some examples of more advanced outputs like <code>devShells</code> and <code>checks</code>, check\nout this blog post that I wrote:\n<a href=\"https://tsawyer87.github.io/posts/nix_flakes_tips/\">Nix Flakes Tips and Tricks</a></p>\n<p>In this chapter, we‚Äôve explored Nix Flakes as a powerful and modern approach to\nmanaging Nix projects, from development environments to entire system\nconfigurations. We‚Äôve seen how they provide structure, dependency management,\nand reproducibility through well-defined inputs and outputs. Flakes offer a\ncohesive way to organize your Nix code and share it with others.</p>\n<p>As we‚Äôve worked with the flake.nix file, you‚Äôve likely noticed its structure ‚Äì a\ntop-level attribute set defining various outputs like devShells, packages,\nnixosConfigurations, and more. These top-level attributes are not arbitrary;\nthey follow certain conventions and play specific roles within the Flake\necosystem.</p>\n<p>In the next chapter,\n<a href=\"https://saylesss88.github.io/Understanding_Top-Level_Attributes_5.html\">Understanding Top-Level Attributes</a>\nwe will delve deeper into the meaning and purpose of these common top-level\nattributes. We‚Äôll explore how they are structured, what kind of expressions they\ntypically contain, and how they contribute to the overall functionality and\norganization of your Nix Flakes. Understanding these attributes is key to\neffectively leveraging the full potential of Nix Flakes.</p>\n<h5>Further Resources</h5>\n<details>\n<summary> ‚úîÔ∏è Resources (Click to Expand)</summary>\n<ul>\n<li>\n<p><a href=\"https://serokell.io/blog/practical-nix-flakes\">practical-nix-flakes</a></p>\n</li>\n<li>\n<p><a href=\"https://xeiaso.net/blog/nix-flakes-1-2022-02-21/\">Nix Flakes an Introduction</a></p>\n</li>\n<li>\n<p><a href=\"https://www.tweag.io/blog/2020-07-31-nixos-flakes/\">tweag nix-flakes</a></p>\n</li>\n<li>\n<p><a href=\"https://nixos.wiki/wiki/Flakes\">NixOS-wiki Flakes</a></p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/concepts/flakes.html\">nix.dev flakes</a></p>\n</li>\n<li>\n<p><a href=\"https://vtimofeenko.com/posts/practical-nix-flake-anatomy-a-guided-tour-of-flake.nix/\">anatomy-of-a-flake</a></p>\n</li>\n<li>\n<p><a href=\"https://jade.fyi/blog/flakes-arent-real/\">flakes-arent-real</a></p>\n</li>\n<li>\n<p><a href=\"https://mhwombat.codeberg.page/nix-book/#_attribute_set_operations\">wombats-book-of-nix</a></p>\n</li>\n<li>\n<p><a href=\"https://zero-to-nix.com/concepts/flakes/\">zero-to-nix flakes</a></p>\n</li>\n<li>\n<p><a href=\"https://nixos-and-flakes.thiscute.world/\">nixos-and-flakes-book</a></p>\n</li>\n<li>\n<p><a href=\"https://flakehub.com/\">FlakeHub</a></p>\n</li>\n</ul>\n<p><img src=\"images/nixosnix.png\" alt=\"FlakeHub\" /></p>\n</details>\n",
      "date_published": "2025-11-21T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    }
  ]
}