<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hardening NixOS - nix-book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <a href="#" class="top-link" id="back-to-top">↑</a>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">nix-book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hardening-nixos"><a class="header" href="#hardening-nixos">Hardening NixOS</a></h1>
<details>
<summary> Click to Expand Table of Contents</summary>
<ul>
<li><a href="#minimal-installation-with-luks">Minimal Installation with LUKS</a></li>
<li><a href="#manual-encrypted-install-following-the-manual">Manual Encrypted Install Following the Manual</a></li>
<li><a href="#guided-encrypted-btrfs-subvol-install-using-disko">Guided Encrypted BTRFS Subvol install using disko</a></li>
<li><a href="#installing-software">Installing Software</a></li>
<li><a href="#users-and-suid-binaries">Users and SUID Binaries</a>
<ul>
<li><a href="#capabilities">Capabilities</a></li>
</ul>
</li>
<li><a href="#impermanence">Impermanence</a></li>
<li><a href="#replace-timesyncd-with-a-chron-job-that-enables-network-time-security-nts">Replace timesyncd with a chron job that enables Network Time Security (NTS)</a></li>
<li><a href="#secure-boot">Secure Boot</a>
<ul>
<li><a href="#the-kernel">The Kernel</a></li>
</ul>
</li>
<li><a href="#choosing-your-kernel">Choosing your Kernel</a>
<ul>
<li><a href="#the-hardened-kernel">The Hardened Kernel</a></li>
<li><a href="#sysctl">sysctl</a></li>
</ul>
</li>
<li><a href="#kernel-security-settings">Kernel Security Settings</a></li>
<li><a href="#further-hardening-with-sysctl">Further Hardening with sysctl</a></li>
<li><a href="#hardening-boot-parameters">Hardening Boot Parameters</a></li>
<li><a href="#hardened-memory-allocator">Hardened Memory Allocator</a></li>
<li><a href="#hardening-systemd">Hardening Systemd</a></li>
<li><a href="#lynis-and-other-tools">Lynis and other tools</a></li>
<li><a href="#securing-ssh">Securing SSH</a></li>
<li><a href="#key-generation">Key generation</a>
<ul>
<li><a href="#ssh-keygen">ssh-keygen</a></li>
<li><a href="#openssh-server">OpenSSH Server</a></li>
</ul>
</li>
<li><a href="#encrypted-secrets">Encrypted Secrets</a>
<ul>
<li><a href="#sops-nix-guide">Sops-nix Guide</a></li>
</ul>
</li>
<li><a href="#auditd">Auditd</a></li>
<li><a href="#usb-port-protection">USB Port Protection</a></li>
<li><a href="#doas-over-sudo">Doas over sudo</a></li>
<li><a href="#firejail">Firejail</a></li>
<li><a href="#flatpak">Flatpak</a></li>
<li><a href="#selinuxapparmor-mac-mandatory-access-control">SeLinux/AppArmor MAC (Mandatory Access Control)</a></li>
<li><a href="#resources">Resources</a>
<ul>
<li><a href="#advanced-hardening-with-nix-mineral-community-project">Advanced Hardening with <code>nix-mineral</code> (Community Project)</a></li>
</ul>
</li>
</ul>
</details>
<!-- ![guy fawks hacker](../images/guy_fawks.png) -->
<p>Securing your NixOS system begins with a philosophy of minimalism, explicit
configuration, and proactive control.</p>
<blockquote>
<p>⚠️ Warning: I am not a security expert. This guide presents various options
for hardening NixOS, but it is your responsibility to evaluate whether each
adjustment suits your specific needs and environment. Security hardening and
process isolation can introduce stability challenges, compatibility issues, or
unexpected behavior. Additionally, these protections often come with
performance tradeoffs. Always conduct thorough research, there are no plug and
play one size fits all security solutions.</p>
</blockquote>
<blockquote>
<p>That said, I typically write about what I'm implementing myself to deepen
understanding and share what works for me. <code>--Source</code> means the proceeding
paragraph came from <code>--Source</code>, you can often click to check for yourself. If
you use some common sense with a bit of caution you could end up with a more
secure NixOS system that fits your needs.</p>
</blockquote>
<blockquote>
<p>Much of this guide draws inspiration or recommendations from the well-known
<a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html">Linux Hardening Guide</a>
by Madaidan's Insecurities. Madaidan’s work is widely regarded in technical
and security circles as one of the most comprehensive and rigorously
researched sources on practical Linux security, frequently cited for its depth
and actionable advice. For example, much of the original basis for hardening
for <a href="https://github.com/cynicsketch/nix-mineral">nix-mineral</a> came from this
guide as well. This can be a starting point but shouldn't be blindly followed
either, always do your own research, things change frequently.</p>
</blockquote>
<p>For an article with apposing perspectives, see
<a href="https://chyrp.cgps.ch/en/debunking-madaidans-insecurities/">debunking-madaidans-insecurities</a>.
We can learn from both and hopefully find something in between that is closer to
the truth.</p>
<blockquote>
<p>❗ <strong>Note on SELinux and AppArmor</strong>: While NixOS can provide a high degree of
security through its immutable and declarative nature, it's important to
understand the limitations regarding Mandatory Access Control (MAC)
frameworks. Neither SELinux nor AppArmor are fully supported or widely used in
the NixOS ecosystem. You can do a lot to secure NixOS but if anonymity and
isolation are paramount, I recommend booting into a
<a href="https://tails.net/">Tails USB stick</a>. Or using
<a href="https://www.whonix.org/">Whonix</a>.</p>
</blockquote>
<p>☝️ The unique file structure of NixOS, particularly the immutable <code>/nix/store</code>,
makes it difficult to implement and manage the file-labeling mechanisms that
these frameworks rely on. There are ongoing community efforts to improve
support, but as of now, they are considered experimental and not a standard part
of a typical NixOS configuration. For an immutable distro that implements
SELinux by default at a system level as well as many other hardening techniques,
see <a href="https://secureblue.dev/">Fedora secureblue</a>.</p>
<p>Containers and VMs are beyond the scope of this chapter but can also enhance
security and sandboxing if configured correctly. See
<a href="https://saylesss88.github.io/nix/kvm.html">Running NixOS in a VM</a> for more
details on running NixOS in a Secureblue VM for additional security.</p>
<p>It's crucial to <strong>document every change</strong> you make. By creating smaller,
feature-complete commits, each with a descriptive message, you're building a
clear history. This approach makes it far simpler to revert a breaking change
and quickly identify what went wrong. Over time, this discipline allows you to
create security-focused checklists and ensure all angles are covered, building a
more robust and secure system.</p>
<p>Check out the
<a href="https://saylesss88.github.io/nix/index.html">Hardening NixOS Baseline Hardening README</a>
for baseline hardening recommendations and best practices.</p>
<p>There is something to be said about the window manager you use. GNOME, KDE
Plasma, and Sway secure privileged Wayland protocols like screencopy. This means
that on environments outside of GNOME, KDE, and Sway, applications can access
screen content of the entire desktop. This implicitly includes the content of
other applications. It's primarily for this reason that Silverblue, Kinoite, and
Sericea images are recommended. COSMIC has plans to fix this.
--<a href="https://secureblue.dev/images">secureblue Images</a></p>
<p>For example, to disable Xwayland for sway on home-manager you would add:</p>
<pre><code class="language-nix">wayland.windowManager.sway = {
  enable = true;
  extraConfig = ''
    xwayland disable
  '';
}
</code></pre>
<ul>
<li>You may get an error saying you're only able to disable xwayland at boot,
restart your system and you'll be all set.</li>
</ul>
<p>You can explicitly disable <code>xdg-desktop-portal-wlr</code> with systemd in your
<code>configuration.nix</code> like this:</p>
<pre><code class="language-nix"># configuration.nix
systemd.user.services."xdg-desktop-portal-wlr" = {
  enable = false;  # Masks/stops the wlr service
};
</code></pre>
<h2 id="minimal-installation-with-luks"><a class="header" href="#minimal-installation-with-luks">Minimal Installation with LUKS</a></h2>
<p>Begin with NixOS’s minimal installation image. This gives you a base system with
only essential tools and no extras that could introduce vulnerabilities.</p>
<h2 id="manual-encrypted-install-following-the-manual"><a class="header" href="#manual-encrypted-install-following-the-manual">Manual Encrypted Install Following the Manual</a></h2>
<p>Encryption is the process of using an algorithm to scramble plaintext data into
ciphertext, making it unreadable except to a person who has the key to decrypt
it.</p>
<p><strong>Data at rest</strong> is data in storage, such as a computer's or a servers hard
disk.</p>
<p><strong>Data at rest encryption</strong> (typically hard disk encryption), secures the
documents, directories, and files behind an encryption key. Encrypting your data
at rest prevents data leakage, physical theft, unauthorized access, and more as
long as the key management scheme isn't compromised.</p>
<ul>
<li>
<p><a href="https://channels.nixos.org/nixos-25.05/latest-nixos-minimal-x86_64-linux.iso">Minimal ISO Download (64-bit Intel/AMD)</a></p>
</li>
<li>
<p><a href="https://nixos.org/manual/nixos/stable/#sec-installation">NixOS Manual Installation</a></p>
</li>
<li>
<p><a href="https://wiki.nixos.org/wiki/Full_Disk_Encryption">NixOS Wiki Full Disk Encryption</a></p>
</li>
<li>
<p>The
<a href="https://www.nsa.gov/Press-Room/Press-Releases-Statements/Press-Release-View/Article/3498776/post-quantum-cryptography-cisa-nist-and-nsa-recommend-how-to-prepare-now/">NSA, CISA, and NIST warn</a>
that nation-state actors are likely stockpiling encrypted data now, preparing
for a future when quantum computers could break today’s most widely used
encryption algorithms. Sensitive data with long-term secrecy needs is
especially at risk.</p>
</li>
<li>
<p>This is a wake-up call to use the strongest encryption available today and to
plan early for post-quantum security.</p>
</li>
<li>
<p><a href="https://www.nist.gov/news-events/news/2024/08/nist-releases-first-3-finalized-post-quantum-encryption-standards">NIST First 3 Post-Quantum Encryption Standards</a>
Organizations and individuals should prepare to migrate cryptographic systems
to these new standards as soon as practical.</p>
</li>
<li>
<p>They chose
<a href="https://www.nist.gov/news-events/news/2022/07/nist-announces-first-four-quantum-resistant-cryptographic-algorithms">Four Quantum-Resistant Cryptographic Algorithms</a>
warning that public-key cryptography is especially vulnerable and widely used
to protect digital information.</p>
</li>
</ul>
<h2 id="guided-encrypted-btrfs-subvol-install-using-disko"><a class="header" href="#guided-encrypted-btrfs-subvol-install-using-disko">Guided Encrypted BTRFS Subvol install using disko</a></h2>
<p>Use LUKS encryption to protect your data at rest, the following guide is a
minimal disko encrypted installation:
<a href="https://saylesss88.github.io/installation/enc/enc_install.html">Encrypted Install</a></p>
<h2 id="installing-software"><a class="header" href="#installing-software">Installing Software</a></h2>
<p>Most users don't fully understand that running any software without sandboxing
gives it unrestricted access to their user data and system resources. There is a
widespread lack of awareness that Linux apps generally run with the full
permissions of the user. It's easy to overlook the fact that "trusted source"
doesn't mean "safe to run uncontained".</p>
<p>I suggest that you try using an editor from Flatpak so you can see and
experience running an editor in a sandbox. It felt weird to me because I had
gotten used to being able to see all my files with Yazi or do insecure
customizations to my editor unfettered. With Flatseal, you can see which
permissions the app ships with and adjust them accordingly.</p>
<p><strong>nixpkgs-unstable Security Overview</strong></p>
<ul>
<li>
<p><code>nixpkgs-unstable</code> tracks the master branch of the Nixpkgs repo and is
constantly updated.</p>
</li>
<li>
<p>This branch gets security updates faster, patching vulnerabilities faster.</p>
</li>
<li>
<p>Since it's a rolling-release, packages are less thoroughly tested. This
increases the risk of new, undiscovered bugs or regressions. Some of which
could have security implications.</p>
</li>
<li>
<p>The packages are generally the most recent upstream versions, which is
important for security-sensitive software like browsers and kernels, as old
versions may have publicly known, unpatched vulnerabilities.</p>
</li>
<li>
<p>As the name states, <code>nixpkgs-unstable</code> is less stable and an update is more
likely to cause your system to fail to build due to breaking changes in Nix
expressions.</p>
</li>
</ul>
<hr />
<p><strong>Stable (e.g., <code>nixos-24.05</code>) Security Overview</strong></p>
<p>Stable Nixpkgs channels correspond to point release (e.g., released every 6
months) and are supported for a limited period (typically one month past the
next release).</p>
<ul>
<li>
<p>Stable channels generally only receive conservative bug and security fixes.
Major version bumps for features are typically avoided to maintain "stability
against deliberate changes", which means you won't get the latest upstream
features or general bug fixes.</p>
</li>
<li>
<p>While critical security updates are backported quickly, updates for less
critical packages may be slower or not happen at all if they require a
significant refactoring or version bump.</p>
</li>
<li>
<p>Stable channels are generally more stable, meaning updates are less likely to
introduce breaking changes to your configuration or system environment.</p>
</li>
<li>
<p>Many packages will be older versions. If a critical security vulnerability
requires a major upstream version update (which is often avoided in a stable
channel), the maintainers must backport the patch, a process which can
introduce its own set of risks and delays.</p>
</li>
</ul>
<p><strong>What should you use?</strong></p>
<p>The primary security trade-off is between <strong>patching speed for known
vulnerabilities</strong> and <strong>stability/exposure to new bugs</strong>:</p>
<ul>
<li>
<p>Choose <code>unstable</code> if you prioritize getting the latest security fixes
(especially for end-user apps like browsers) as soon as they are available
upstream, accepting a higher risk of non-security-related system breakage or
new, undiscovered bugs.</p>
</li>
<li>
<p>Choose <code>stable</code> if you prioritize system predictability and stability, relying
on dedicated backports for critical vulnerabilities, while accepting that
non-critical security and bug fixes will be delayed or absent until the next
major release.</p>
</li>
</ul>
<p>A common hybrid approach is to use the <code>stable</code> channel as the base for the OS
and selectively pin specific packages from <code>unstable</code> to ensure they receive
rapid security updates.</p>
<p>With flakes it's easy to add both <code>stable</code> and <code>unstable</code> as flake inputs and
access each with some simple logic.</p>
<h2 id="users-and-suid-binaries"><a class="header" href="#users-and-suid-binaries">Users and SUID Binaries</a></h2>
<blockquote>
<p>NOTE: The point here is to avoid using a setuid binary (<code>sudo</code>), <code>run0</code> is a
wrapper over <code>systemd-run</code> which speaks over IPC to PID1 which is considered
safer than a setuid binary as they have a long history of vulnerabilities. We
separate our daily user from administration tasks and authenticate through our
admin account. This reduces the attack surface by removing sudo but is still
bigger than <code>doas</code>. The problem with <code>doas</code> is that it's unmaintained within
nixpkgs and it's still a SUID binary.</p>
</blockquote>
<details>
<summary> Click to Expand SUID and run0 resources </summary>
<ul>
<li>
<p><a href="https://mastodon.social/@pid_eins/112353324518585654">run0 explained by Lennart</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Setuid">setuid Wikipedia</a></p>
</li>
<li>
<p>Using <code>run0</code> removes of these classes of
<a href="https://ruderich.org/simon/notes/su-sudo-from-root-tty-hijacking">attacks</a></p>
</li>
<li>
<p>The following lists some of the downsides
<a href="https://www.kicksecure.com/wiki/Dev/secureblue">kicksecure vs secureblue</a></p>
</li>
</ul>
</details>
<p><code>run0</code> is not a SUID, it asks the service manager to invoke a command or shell
under the target user's UID. The target command is invoked in an isolated exec
context, freshly forked off PID1 without inheriting any context from the client</p>
<p>I rebuild way too often to completely separate the accounts and allow no admin
tasks for my daily user. That may be a better option for servers, etc.</p>
<p>Create an admin user for administrative tasks and remove your daily user from
the <code>wheel</code> group, and disable the <code>sudo</code>, <code>su</code>, and <code>pkexec</code> SUIDs:</p>
<pre><code class="language-users.nix">{ config, pkgs, lib }:
{
users.users.admin = {
    isNormalUser = true;
    description  = "System administrator";
    extraGroups  = [ "wheel" ];   # wheel = sudo
    # run `mkpasswd --method=yescrypt` and replace "changeme" w/ the result
    initialHashedPassword = "changeme";           # change with `passwd admin` later
    openssh.authorizedKeys.keys = [
      # (optional) paste your SSH public key here
      # "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAI..."
    ];
  };

  # --------------------------------------------------------------------
  # 2. Existing daily user – remove from wheel, keep everything else
  # --------------------------------------------------------------------
  users.users.daily = {
    isNormalUser = true;
    description  = "Daily driver account";
    extraGroups  = lib.mkForce [ "networkmanager" "audio" "video" ]; # keep useful groups
    initialHashedPassword = "changeme";
    # Remove `wheel` by *not* listing it (mkForce overrides any default)
  };

security = {
polkit.enable = true;
# Disable sudo
sudo.enable = false;
wrappers = {
    su.setuid = lib.mkForce = false;
    sudo.setuid = lib.mkForce = false;
    sudoedit.setuid = lib.mkForce = false;
    sg.setuid = lib.mkForce = false;
    fusermount.setuid = lib.mkForce = false;
    fusermount3.setuid = lib.mkForce = false;
    mount.setuid = lib.mkForce = false;
    pkexec.setuid = lib.mkForce = false;
    newgrp.setuid = lib.mkForce = false;
    newgidmap.setuid = lib.mkForce = false;
    newuidmap.setuid= lib.mkForce = false;
};
# Or hyprlock, required for swaylock to accept your password
pam.services.swaylock = {
  text = ''
    auth include login
    account include login
    password include login
    session include login
  '';
  };
};
</code></pre>
<p>The <code>security.wrappers...</code> removes the setuid bit making the commands unusable
removing the SUID vulnerabilities for <code>su</code> and <code>pkexec</code>. You can find the other
SUID wrappers in <code>/run/wrappers/bin/</code>, such as <code>fusermount</code> and more.</p>
<p>SUID's that can be disabled:</p>
<ul>
<li>
<p><code>umount</code>: Allows unprivileged users to unmount devices listed in your fstab.</p>
</li>
<li>
<p><code>mount</code>: Same as above but for mounting.</p>
</li>
<li>
<p><code>sg</code>: Executes a command as a different group.</p>
</li>
<li>
<p><code>mtr-packet</code>: Used by mtr to create network sockets.</p>
</li>
<li>
<p><code>fusermount</code>, <code>fusermount3</code>: Allows unprivileged users to mount FUSE
filesystems. Can be disabled if you don't use FUSE (e.g., Appimages, etc.)</p>
</li>
<li>
<p><code>newuidmap</code>, <code>newgidmap</code>: Used for user namespace creation (Often used for
unprivileged containers). (Disable if you don't use unprivileged
containers/namespaces)</p>
</li>
</ul>
<hr />
<p>Never Disable:</p>
<ul>
<li><code>unix_chkpwd</code>: This is a core PAM helper to securely check user passwords
against the root-readable <code>/etc/shadow</code>.</li>
</ul>
<hr />
<h3 id="capabilities"><a class="header" href="#capabilities">Capabilities</a></h3>
<details>
<summary> ✔️ Click to expand capabilities examples </summary>
<p>One way to help get rid of setuid binaries is to replace them with capabilities.
I personally only remove the SUID bit and don't try to replace with capabilities
as of now. You can still use the commands from <code>security.wrappers</code> such as
<code>run0 su -</code>.</p>
<p>Capabilities provide a subset of what is available to root to a process. This
breaks up root privileges into smaller units that can independently grant access
to processes. This reduces the full set of privileges, decreasing the risk of
exploitation.</p>
<p>(This is just an example):</p>
<pre><code class="language-nix">{
  # a setuid root program
  doas =
    { setuid = true;
      owner = "root";
      group = "root";
      source = "${pkgs.doas}/bin/doas";
    };

  # a setgid program
  locate =
    { setgid = true;
      owner = "root";
      group = "mlocate";
      source = "${pkgs.locate}/bin/locate";
    };

  # a program with the CAP_NET_RAW capability
  ping =
    { owner = "root";
      group = "root";
      capabilities = "cap_net_raw+ep";
      source = "${pkgs.iputils.out}/bin/ping";
    };
}
</code></pre>
<p>List the highest capability number for your kernel with:</p>
<pre><code class="language-bash">cat /proc/sys/kernel/cap_last_cap
# Output:
40
</code></pre>
<p>List available Linux capabilities:</p>
<pre><code class="language-bash">capsh --print
</code></pre>
<p>List processes:</p>
<pre><code class="language-bash">ps
# Example Output
PID    TTY     TIME   CMD
8063   pts/1    02     zsh
</code></pre>
<pre><code class="language-bash">cat /proc/8063/status | grep Cap
# Output
CapInh: 0000000800000000
CapPrm: 0000000000000000
CapEff: 0000000000000000
CapBnd: 000001ffffffffff
CapAmb: 0000000000000000
</code></pre>
<pre><code class="language-bash">capsh --decode=000001ffffffffff
# Output
0x000001ffffffffff=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read,cap_perfmon,cap_bpf,cap_checkpoint_restore
</code></pre>
<p><code>cap_net_raw</code>: Allows the program to use raw and unbuffered network sockets,
which is what <code>ping</code> and <code>mtr-packet</code> need to send ICMP packets.</p>
<p><code>cap_sys_admin</code>: Grants a variety of system administration operations, including
the ability to perform FUSE mounts. This is a powerful capability, but it's
still more restrictive than full root SUID.</p>
<ul>
<li><code>+ep</code>: This is crucial. It stands for:
<ul>
<li>
<p><code>e</code> (Effective): The set of capabilities actually used by the process when
running.</p>
</li>
<li>
<p><code>p</code> (Permitted): The set of capabilities that can be enabled by the process.</p>
</li>
</ul>
</li>
</ul>
<p>By using this approach, you are following the security principle of least
privilege, significantly reducing the attack surface compared to traditional
SUID binaries.</p>
<ul>
<li>
<p><a href="https://search.nixos.org/options?channel=unstable&amp;show=security.wrappers&amp;query=security.wrappers">security.wrappers</a></p>
</li>
<li>
<p><a href="https://linux-audit.com/kernel/capabilities/linux-capabilities-101/">Linux Audit capabilities 101</a></p>
</li>
<li>
<p><a href="https://www.kicksecure.com/wiki/Dev/secureblue#capabilities">Kicksecure's take on capabilities</a></p>
</li>
</ul>
</details>
<hr />
<p>You will have to use <code>run0</code> to authenticate your daily user, for example:</p>
<pre><code class="language-bash">run0 nixos-rebuild switch --flake .
</code></pre>
<p>Since <code>run0</code> doesn't cache results and <code>nixos-rebuild</code> calls on Polkit 3 times
so on every rebuild, you will be asked for your password 3 times which isn't
ideal. I found the following workaround that will only ask for your password
once.</p>
<p>Add the following to your <code>configuration.nix</code>, replacing <code>user-name</code> with your
username:</p>
<pre><code class="language-nix"> security.polkit.extraConfig = ''
     polkit.addRule(function(action, subject) {
       if (subject.user == "user-name") {
         if (action.id.indexOf("org.nixos") == 0) {
           polkit.log("Caching admin authentication for single NixOS operation");
           return polkit.Result.AUTH_ADMIN_KEEP;
         }
       }
     });
   '';

</code></pre>
<p>Create a zsh function for easy access:</p>
<pre><code class="language-nix"># zsh.nix
#...snip...
initContent = ''
  fr() {
    run0 nixos-rebuild switch --flake "/home/$USER/flake#"$(hostname)
  }
'';
</code></pre>
<p>Needless to say, this is less secure but much more convenient than entering your
password 3 times on every single rebuild.</p>
<p>Without the <code>pam</code> settings for swaylock, it won't accept your password to log
back in.</p>
<p><strong>run0 Usage Example</strong></p>
<p>When you are in a privileged shell, <code>run0</code> changes the color of the background
to red to remind you of this.</p>
<p>Example creating a user:</p>
<ol>
<li>
<p><code>run0</code></p>
</li>
<li>
<p><code>adduser admin</code></p>
</li>
<li>
<p><code>usermod -aG wheel admin</code></p>
</li>
<li>
<p><code>passwd admin</code></p>
</li>
<li>
<p><code>exit</code></p>
</li>
<li>
<p><code>reboot</code></p>
</li>
</ol>
<p>This is just an example, since we manage our users declaratively the user
created would be discarded on the next rebuild because of the
<code>users.mutableUsers = false;</code> setting. You could of course change this to <code>true</code>
to manage your users imperatively but I don't recommend it.</p>
<hr />
<h2 id="impermanence"><a class="header" href="#impermanence">Impermanence</a></h2>
<p>Impermanence, especially when using a <code>tmpfs</code> as the root filesystem, provides
several significant security benefits. The core principle is that impermanence
defeats persistence, a fundamental goal for any attacker.</p>
<p>When you use a root-as-tmpfs setup on NixOS, the boot process loads the entire
operating system from the read-only Nix store into a <code>tmpfs</code> in RAM. The mutable
directories, such as <code>/etc</code> and <code>/var</code>, are then created on this RAM disk. When
the system is shut down, the <code>tmpfs</code> is wiped, leaving the on-disk storage
untouched and secure.</p>
<p>This means you get a fresh, secure boot every time, making it much harder for an
attacker to maintain a presence on your system.</p>
<ul>
<li>
<p><a href="https://grahamc.com/blog/erase-your-darlings/">Erase your Darlings (ZFS)</a></p>
</li>
<li>
<p><a href="https://saylesss88.github.io/installation/enc/encrypted_impermanence.html">Encrypted BTRFS Impermanence Guide</a>
Only follow this guide if you also followed the encrypted disko install,
impermanence is designed to be destructive and needs to match your config
exactly.</p>
</li>
</ul>
<h2 id="replace-timesyncd-with-a-chron-job-that-enables-network-time-security-nts"><a class="header" href="#replace-timesyncd-with-a-chron-job-that-enables-network-time-security-nts">Replace timesyncd with a chron job that enables Network Time Security (NTS)</a></h2>
<p>This is implementing the GrapheneOS/secureblue NTS chrony settings to NixOS:</p>
<pre><code class="language-nix">{ config
, ...
}:
{
  services.chrony = {
    enable = true;
    enableNTS = true;
    servers = [
        "server time.cloudflare.com iburst nts"
        "server ntppool1.time.nl iburst nts"
        "server nts.netnod.se iburst nts"
        "server ptbtime1.ptb.de iburst nts"
        "server time.dfm.dk iburst nts"
        "server time.cifelli.xyz iburst nts"
     ];
    # havent worked out the kinks yet
  #  extraConfig = ''
  #      minsources 3
  #      authselectmode require

  #      # EF
  #      dscp 46

  #      driftfile /var/lib/chrony/drift
  #      dumpdir /var/lib/chrony
  #      ntsdumpdir /var/lib/chrony

  #      leapseclist /usr/share/zoneinfo/leap-seconds.list
  #      makestep 1.0 3

  #      rtconutc

  #      cmdport 0

  #      noclientlog
  #  '';
  };
}
</code></pre>
<p>Ensure NTS is being used with:</p>
<pre><code class="language-bash">sudo chronyc -N authdata
</code></pre>
<hr />
<h2 id="secure-boot"><a class="header" href="#secure-boot">Secure Boot</a></h2>
<!-- ![Virus](../images/virus1.png) -->
<p>Enable a UEFI password or Administrator password where it requires
authentication in order to access the UEFI/BIOS.</p>
<p>Secure Boot helps ensure only signed, trusted kernels and bootloaders are
executed at startup.</p>
<p>Useful Resources:</p>
<details>
<summary> ✔️ Click to Expand Secure Boot Resources </summary>
<ul>
<li>
<p><a href="https://0pointer.net/blog/authenticated-boot-and-disk-encryption-on-linux.html">The Strange State of Authenticated Boot and Encryption</a></p>
</li>
<li>
<p><a href="https://wiki.nixos.org/wiki/Secure_Boot">NixOS Wiki Secure Boot</a></p>
</li>
<li>
<p><a href="https://github.com/nix-community/lanzaboote">lanzaboote repo</a></p>
</li>
</ul>
</details>
<p>Practical Lanzaboote Secure Boot setup for NixOS:
<a href="https://saylesss88.github.io/installation/enc/lanzaboote.html">Guide:Secure Boot on NixOS with Lanzaboote</a></p>
<h3 id="the-kernel"><a class="header" href="#the-kernel">The Kernel</a></h3>
<p>Given the kernel's central role, it's a frequent target for malicious actors,
making robust hardening essential.</p>
<p>NixOS provides a <code>hardened</code> profile that applies a set of security-focused
kernel and system configurations.</p>
<p>For flakes, you could do something like the following in your
<code>configuration.nix</code> or equivalent to import <code>hardened.nix</code> and enable
<code>profiles.hardened</code>:</p>
<pre><code class="language-nix"># configuration.nix
{ pkgs, inputs, ... }: let
   modulesPath = "${inputs.nixpkgs}/nixos/modules";

in {
  imports = [ "${modulesPath}/profiles/hardened.nix" ];

}
</code></pre>
<ul>
<li>
<p>There is a proposal to remove it completely that has gained ground, the
following thread discusses why:
<a href="https://discourse.nixos.org/t/proposal-to-deprecate-the-hardened-profile/63081">Discourse Thread</a></p>
</li>
<li>
<p><a href="https://github.com/NixOS/nixpkgs/pull/383438">PR #383438</a> Proposed removal
PR.</p>
</li>
<li>
<p>Check
<a href="https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/profiles/hardened.nix">hardened.nix</a>
to see exactly what adding it enables to avoid duplicates and conflicts moving
on. I included this for completeness, the choice is yours if you want to use
it or not.</p>
</li>
</ul>
<h2 id="choosing-your-kernel"><a class="header" href="#choosing-your-kernel">Choosing your Kernel</a></h2>
<p>See which kernel you're currently using with:</p>
<pre><code class="language-bash"># show the kernel release
uname -r
# show kernel version, hostname, and architecture
uname -a
</code></pre>
<p>Show the configuration of your current kernel:</p>
<pre><code class="language-bash">zcat /proc/config.gz
# ...snip...
#
# Compression
#
CONFIG_CRYPTO_DEFLATE=m
CONFIG_CRYPTO_LZO=y
CONFIG_CRYPTO_842=m
CONFIG_CRYPTO_LZ4=m
CONFIG_CRYPTO_LZ4HC=m
CONFIG_CRYPTO_ZSTD=y
# end of Compression
# ...snip...
</code></pre>
<p>The <a href="https://nixos.org/manual/nixos/stable/#sec-kernel-config">NixOS Manual</a>
states that the default Linux kernel configuration should be fine for most
users.</p>
<p>The Linux kernel is typically released under two forms: stable and long-term
support (LTS). Choosing either has consequences, do your research.
<a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html#stable-vs-lts">Stable vs. LTS kernels</a></p>
<ul>
<li><a href="https://www.kernel.org/category/releases.html">The Linux Kernel Archives Active kernel releases</a></li>
</ul>
<p><strong>OR</strong>, you can choose the hardened kernel for a kernel that prioritizes
security over everything else.</p>
<h3 id="the-hardened-kernel"><a class="header" href="#the-hardened-kernel">The Hardened Kernel</a></h3>
<blockquote>
<p>NOTE: Expect breakage when using the hardened kernel. <code>linux-hardened</code>
completely disables
<a href="https://secureblue.dev/articles/userns">unprivileged user namespaces</a>, which
are required for Flatpak, chromium-based browsers, and more.</p>
</blockquote>
<p>The <code>linuxPackages_latest_hardened</code> attribute has been deprecated. If you want
to use a hardened kernel, it is now recommended to use <code>linux_hardened</code>, which
is aliased to <code>linux_default.kernel</code>.</p>
<p>You can find the latest available hardened kernel packages by searching
<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/top-level/linux-kernels.nix">pkgs/top-level/linux-kernels.nix</a>.
It is recommended to use <code>linux_hardened</code> without specifying a version, such as:</p>
<pre><code class="language-nix">boot.kernelPackages = pkgs.linuxPackages_hardened;
</code></pre>
<p><code>linux_hardened</code> is aliased to the <code>linux_default.kernel</code>.</p>
<p>Note that this not only replaces the kernel, but also packages that are specific
to the kernel version, such as NVIDIA video drivers. This also removes your
ability to use the <code>.extend</code> kernel attribute, they are only available to
<em>kernel package sets</em> (e.g., <code>linuxPackages_hardened</code>)</p>
<ul>
<li>If you decide to use this, read further before rebuilding.</li>
</ul>
<p>You can inspect
<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/os-specific/linux/kernel/hardened/patches.json">nixpkgs/pkgs/os-specific/linux/kernel/hardened/patches.json</a>
to see the metadata of the patches that are applied. You can then follow the
links in the <code>.json</code> file to see the patch diffs.</p>
<h3 id="sysctl"><a class="header" href="#sysctl">sysctl</a></h3>
<p>A tool for checking the security hardening options of the Linux kernel:</p>
<pre><code class="language-nix">environment.systemPackages = [ pkgs.kernel-hardening-checker ];
</code></pre>
<p><code>sysctl</code> is a tool that allows you to view or modify kernel settings and
enable/disable different features.</p>
<p>Check all <code>sysctl</code> parameters against the <code>kernel-hardening-checker</code>
recommendations:</p>
<pre><code class="language-bash">sudo sysctl -a &gt; params.txt
kernel-hardening-checker -l /proc/cmdline -c /proc/config.gz -s ./params.txt
</code></pre>
<p>Check the value of a specific parameter:</p>
<pre><code class="language-bash">sudo sysctl -a | grep "kernel.kptr_restrict"
# Output:
kernel.kptr_restrict = 2
</code></pre>
<p>Check Active Linux Security Modules:</p>
<pre><code class="language-bash">cat /sys/kernel/security/lsm
# Output:
File: /sys/kernel/security/lsm
capability,landlock,yama,bpf,apparmor
</code></pre>
<p>Check Kernel Configuration Options:</p>
<pre><code class="language-bash">zcat /proc/config.gz | grep CONFIG_SECURITY_SELINUX
zcat /proc/config.gz | grep CONFIG_HARDENED_USERCOPY
zcat /proc/config.gz | grep CONFIG_STACKPROTECTOR
</code></pre>
<p>Since it is difficult to see exactly what enabling the hardened_kernel does.
Before rebuilding, you could do something like this to see exactly what is
added:</p>
<pre><code class="language-bash">sudo sysctl -a &gt; before.txt
</code></pre>
<p>And after the rebuild:</p>
<pre><code class="language-bash">sudo sysctl -a &gt; after.txt
</code></pre>
<p>And finally run a <code>diff</code> on them:</p>
<pre><code class="language-bash">diff before.txt after.txt
</code></pre>
<p>You can also diff against <code>after.txt</code> for future changes to avoid duplicates,
this seems easier to me than trying to parse through the patches.</p>
<h2 id="kernel-security-settings"><a class="header" href="#kernel-security-settings">Kernel Security Settings</a></h2>
<pre><code class="language-nix">security = {
      protectKernelImage = true;
      lockKernelModules = false; # this breaks iptables, wireguard, and virtd

      # force-enable the Page Table Isolation (PTI) Linux kernel feature
      forcePageTableIsolation = true;

      # User namespaces are required for sandboxing.
      # this means you cannot set `"user.max_user_namespaces" = 0;` in sysctl
      allowUserNamespaces = true;

      # Disable unprivileged user namespaces, unless containers are enabled
      unprivilegedUsernsClone = config.virtualisation.containers.enable;
      allowSimultaneousMultithreading = true;
}
</code></pre>
<h2 id="further-hardening-with-sysctl"><a class="header" href="#further-hardening-with-sysctl">Further Hardening with sysctl</a></h2>
<p><code>sysctl</code> hardening settings further reinforce kernel-level protections. The
hardened kernel includes security patches and stricter defaults, but it doesn't
cover all runtime tunables. Refer to the above commands to get a diff of the
changes.</p>
<p><a href="https://nixos.org/manual/nixos/stable/options#opt-boot.kernel.sysctl">boot.kernel.sysctl</a>:
Runtime parameters of the Linux kernel, as set by sysctl(8). Note that the
sysctl parameters names must be enclosed in quotes. Values may be a string,
integer, boolean, or null.</p>
<p>Check what each setting does <a href="https://sysctl-explorer.net/">sysctl-explorer</a></p>
<p>Refer to
<a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html#sysctl-kernel">madadaidans-insecurities#sysctl-kernel</a>
for the following settings and their explainations.</p>
<p>Also see the
<a href="https://kspp.github.io/Recommended_Settings#sysctls">Kernel Self Protection Projects sysctls</a></p>
<pre><code class="language-nix">  boot.kernel.sysctl = {
    "fs.suid_dumpable" = 0;
    # prevent pointer leaks
    "kernel.kptr_restrict" = 2;
    # restrict kernel log to CAP_SYSLOG capability
    "kernel.dmesg_restrict" = 1;
    # Note: certian container runtimes or browser sandboxes might rely on the following
    # restrict eBPF to the CAP_BPF capability
    "kernel.unprivileged_bpf_disabled" = 1;
    # should be enabled along with bpf above
    # "net.core.bpf_jit_harden" = 2;
    # restrict loading TTY line disciplines to the CAP_SYS_MODULE
    "dev.tty.ldisk_autoload" = 0;
    # prevent exploit of use-after-free flaws
    "vm.unprivileged_userfaultfd" = 0;
    # kexec is used to boot another kernel during runtime and can be abused
    "kernel.kexec_load_disabled" = 1;
    # Kernel self-protection
    # SysRq exposes a lot of potentially dangerous debugging functionality to unprivileged users
    # 4 makes it so a user can only use the secure attention key. A value of 0 would disable completely
    "kernel.sysrq" = 4;
    # disable unprivileged user namespaces, Note: Docker, NH, and other apps may need this
    # "kernel.unprivileged_userns_clone" = 0; # Set to 1 because it makes NH and other programs fail
    # This should be set to 0 if you don't rely on flatpak, NH, Docker, etc.
    "kernel.unprivileged_userns_clone" = 1;
    # restrict all usage of performance events to the CAP_PERFMON capability
    "kernel.perf_event_paranoid" = 3;

    # Network
    # protect against SYN flood attacks (denial of service attack)
    "net.ipv4.tcp_syncookies" = 1;
    # protection against TIME-WAIT assassination
    "net.ipv4.tcp_rfc1337" = 1;
    # enable source validation of packets received (prevents IP spoofing)
    "net.ipv4.conf.default.rp_filter" = 1;
    "net.ipv4.conf.all.rp_filter" = 1;

    "net.ipv4.conf.all.accept_redirects" = 0;
    "net.ipv4.conf.default.accept_redirects" = 0;
    "net.ipv4.conf.all.secure_redirects" = 0;
    "net.ipv4.conf.default.secure_redirects" = 0;
    # Protect against IP spoofing
    "net.ipv6.conf.all.accept_redirects" = 0;
    "net.ipv6.conf.default.accept_redirects" = 0;
    "net.ipv4.conf.all.send_redirects" = 0;
    "net.ipv4.conf.default.send_redirects" = 0;

    # prevent man-in-the-middle attacks
    "net.ipv4.icmp_echo_ignore_all" = 1;

    # ignore ICMP request, helps avoid Smurf attacks
    "net.ipv4.conf.all.forwarding" = 0;
    "net.ipv4.conf.default.accept_source_route" = 0;
    "net.ipv4.conf.all.accept_source_route" = 0;
    "net.ipv6.conf.all.accept_source_route" = 0;
    "net.ipv6.conf.default.accept_source_route" = 0;
    # Reverse path filtering causes the kernel to do source validation of
    "net.ipv6.conf.all.forwarding" = 0;
    "net.ipv6.conf.all.accept_ra" = 0;
    "net.ipv6.conf.default.accept_ra" = 0;

    ## TCP hardening
    # Prevent bogus ICMP errors from filling up logs.
    "net.ipv4.icmp_ignore_bogus_error_responses" = 1;

    # Userspace
    # restrict usage of ptrace
    "kernel.yama.ptrace_scope" = 2;

    # ASLR memory protection (64-bit systems)
    "vm.mmap_rnd_bits" = 32;
    "vm.mmap_rnd_compat_bits" = 16;

    # only permit symlinks to be followed when outside of a world-writable sticky directory
    "fs.protected_symlinks" = 1;
    "fs.protected_hardlinks" = 1;
    # Prevent creating files in potentially attacker-controlled environments
    "fs.protected_fifos" = 2;
    "fs.protected_regular" = 2;

    # Randomize memory
    "kernel.randomize_va_space" = 2;
    # Exec Shield (Stack protection)
    "kernel.exec-shield" = 1;

    ## TCP optimization
    # TCP Fast Open is a TCP extension that reduces network latency by packing
    # data in the sender’s initial TCP SYN. Setting 3 = enable TCP Fast Open for
    # both incoming and outgoing connections:
    "net.ipv4.tcp_fastopen" = 3;
    # Bufferbloat mitigations + slight improvement in throughput &amp; latency
    "net.ipv4.tcp_congestion_control" = "bbr";
    "net.core.default_qdisc" = "cake";
  };
</code></pre>
<blockquote>
<p>❗ Note: The above settings are fairly aggressive and can break common
programs, read the comment warnings.</p>
</blockquote>
<h2 id="hardening-boot-parameters"><a class="header" href="#hardening-boot-parameters">Hardening Boot Parameters</a></h2>
<p><code>boot.kernelParams</code> can be used to set additional kernel command line arguments
at boot time. It can only be used for built-in modules.</p>
<p>You can find the following settings in the above guide in the
<a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html#boot-parameters">Boot parameters section</a></p>
<pre><code class="language-nix"># boot.nix
      boot.kernelParams = [
        # make it harder to influence slab cache layout
        "slab_nomerge"
        # enables zeroing of memory during allocation and free time
        # helps mitigate use-after-free vulnerabilaties
        "init_on_alloc=1"
        "init_on_free=1"
        # randomizes page allocator freelist, improving security by
        # making page allocations less predictable
        "page_alloc.shuffel=1"
        # enables Kernel Page Table Isolation, which mitigates Meltdown and
        # prevents some KASLR bypasses
        "pti=on"
        # randomizes the kernel stack offset on each syscall
        # making attacks that rely on a deterministic stack layout difficult
        "randomize_kstack_offset=on"
        # disables vsyscalls, they've been replaced with vDSO
        "vsyscall=none"
        # disables debugfs, which exposes sensitive info about the kernel
        "debugfs=off"
        # certain exploits cause an "oops", this makes the kernel panic if an "oops" occurs
        "oops=panic"
        # only alows kernel modules that have been signed with a valid key to be loaded
        # making it harder to load malicious kernel modules
        # can make VirtualBox or Nvidia drivers unusable
        "module.sig_enforce=1"
        # prevents user space code excalation
        "lockdown=confidentiality"
        # "rd.udev.log_level=3"
        # "udev.log_priority=3"
      ];
</code></pre>
<p>This is a thoughtful start to hardening boot parameters, there are more
recommendations in the guide.</p>
<p>Kernel modules for hardware devices are generally loaded automatically by
<code>udev</code>. You can force a module to be loaded via <code>boot.kernelModules</code>.</p>
<hr />
<p><strong>Hardening Modprobe</strong></p>
<p>You can use both <code>extraModprobeConfig</code> &amp; <code>blacklistedKernelModules</code> to disable
different features. If you prefer, you can place these in the next section as
well.</p>
<pre><code class="language-nix">boot.extraModprobeConfig = ''
     # firewire and thunderbolt
    install firewire-core /bin/false
    install firewire_core /bin/false
    install firewire-ohci /bin/false
    install firewire_ohci /bin/false
    install firewire_sbp2 /bin/false
    install firewire-sbp2 /bin/false
    install firewire-net /bin/false
    install thunderbolt /bin/false
    install ohci1394 /bin/false
    install sbp2 /bin/false
    install dv1394 /bin/false
    install raw1394 /bin/false
    install video1394 /bin/false
'';
# OR
#boot.blacklistedKernelModules = [
#  "firewire-core"
#  # ... snip ...
#];
</code></pre>
<hr />
<p><strong>Blacklisting Kernel Parameters</strong></p>
<p>Blacklisting unused kernel modules reduces the attack surface.</p>
<p><a href="https://nixos.org/manual/nixos/stable/options#opt-boot.blacklistedKernelModules">boot.blacklistedKernelModules</a>:
List of names of kernel modules that should not be loaded automatically by the
hardware probing code.</p>
<p>You can find the following settings in the
<a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html#kasr-kernel-modules">Blacklisting Kernel Modules Section</a></p>
<pre><code class="language-nix">      boot.blacklistedKernelModules = [
        # Obscure networking protocols
        "dccp"   # Datagram Congestion Control Protocol
        "sctp"  # Stream Control Transmission Protocol
        "rds"  # Reliable Datagram Sockets
        "tipc"  # Transparent Inter-Process Communication
        "n-hdlc" # High-level Data Link Control
        "ax25"  # Amateur X.25
        "netrom"  # NetRom
        "x25"     # X.25
        "rose"
        "decnet"
        "econet"
        "af_802154"  # IEEE 802.15.4
        "ipx"  # Internetwork Packet Exchange
        "appletalk"
        "psnap"  # SubnetworkAccess Protocol
        "p8023"  # Novell raw IEE 802.3
        "p8022"  # IEE 802.3
        "can"   # Controller Area Network
        "atm"
        # Various rare filesystems
        "cramfs"
        "freevxfs"
        "jffs2"
        "hfs"
        "hfsplus"
        "udf"

        # "squashfs"  # compressed read-only file system used for Live CDs
        # "cifs"  # cmb (Common Internet File System)
        # "nfs"  # Network File System
        # "nfsv3"
        # "nfsv4"
        # "ksmbd"  # SMB3 Kernel Server
        # "gfs2"  # Global File System 2
        # vivid driver is only useful for testing purposes and has been the
        # cause of privilege escalation vulnerabilities
        # "vivid"
      ];
</code></pre>
<p>As with the <code>kernelParameters</code> above, there are more suggestions in the guide, I
have used the above parameters along with the commented out ones and had no
issues.</p>
<p>Also see
<a href="https://github.com/secureblue/secureblue/blob/live/files/system/etc/modprobe.d/blacklist.conf">SecureBlue's blacklist.conf</a>
for more ideas.</p>
<hr />
<h2 id="hardened-memory-allocator"><a class="header" href="#hardened-memory-allocator">Hardened Memory Allocator</a></h2>
<blockquote>
<p>NOTE: There is a performance cost to enabling a hardened memory allocator, and
some apps will not work without a workaround such as Firefox, Thunderbird,
Torbrowser, LibreWolf, and ZenBrowser to name a few.</p>
</blockquote>
<p>The grapheneOS <code>hardened_malloc</code> is available for NixOS in two variants, add
either to your <code>configuration.nix</code> or equivalent to apply them:</p>
<ol>
<li>
<p><code>environment.memoryAllocator.provider = "graphene-hardened";</code>: This is the
default configuration template that has all normal optional security features
enabled. It's aggressive, you can expect app breakage and a performance cost.</p>
</li>
<li>
<p><code>environment.memoryAllocator.provider = "graphene-hardened-light";</code>: The
light template disables the slap quarantines, write after free check, slot
randomization and raises the guard slab interval from 1 to 8 but leaves
zero-on-free and slab canaries enabled. This version has solid performance
and is still far more secure than the standard allocator.</p>
</li>
</ol>
<p><code>libhardened_malloc.so</code> is typically installed to
<code>/usr/local/lib/libhardened_malloc.so</code> and referenced from <code>/etc/ld.so.preload</code>.</p>
<ul>
<li>
<p><a href="https://nixos.org/manual/nixos/stable/options#opt-environment.memoryAllocator.provider">NixOS Manual memoryAllocator</a></p>
</li>
<li>
<p><a href="https://github.com/GrapheneOS/hardened_malloc?tab=readme-ov-file#traditional-linux-based-operating-systems">GrapheneOS hardened_malloc</a></p>
</li>
<li>
<p><a href="https://github.com/secureblue/secureblue/issues/193#issuecomment-1953323680">GrapheneOS/secureblue discussion on hardened_malloc issues</a></p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">ld.so man page</a></p>
</li>
</ul>
<h2 id="hardening-systemd"><a class="header" href="#hardening-systemd">Hardening Systemd</a></h2>
<!-- ![Hacker](../images/hacker.png) -->
<p><code>systemd</code> is the core "init system" and service manager that controls how
services, daemons, and basic system processes are started, stopped and
supervised on modern Linux distributions, including NixOS. It provides a suite
of basic building blocks for a Linux system as well as a system and service
manager that runs as <code>PID 1</code> and starts the rest of the system.</p>
<p>Because it launches and supervises almost all system services, hardening systemd
means raising the baseline security of your entire system.</p>
<p>Disable coredumps:</p>
<pre><code class="language-nix">systemd.coredump.enable = false;
# ➡️ Sets the kernel's resource limit (ulimit -c 0)
  security.pam.loginLimits = [
    {
      domain = "*"; # Applies to all users/sessions
      type = "-"; # Set both soft and hard limits
      item = "core"; # The soft/hard limit item
      value = "0";   # Core dumps size is limited to 0 (effectively disabled)
    }
  ];
</code></pre>
<p>Disabling coredumps helps save space and improves security/privacy because when
a program fails, a coredump contains an exact copy of a programs running memory
at the time of the crash. This can inadvertently expose sensitive data.</p>
<p>If a program is handling private information when it crashes, the core dump file
could contain:</p>
<ul>
<li>
<p>Passwords: Stored in memory before being sent or hashed.</p>
</li>
<li>
<p>Encryption Keys: Used for securing network connections.</p>
</li>
<li>
<p>Personal Info: Chat messages, website forms, etc.</p>
</li>
</ul>
<p>It can give a minor performance upgrade and does reduce the attack surface. If a
malicious program were to gain access to your system, one of the first things it
might look for are core dump files to extract sensitive data. By disabling them,
you eliminate this potential source of information leakage.</p>
<p><code>dbus-broker</code> is generally considered more secure and robust but isn't the
default as of yet. To set <code>dbus-broker</code> as the default:</p>
<pre><code class="language-nix">  users.groups.netdev = {};
  services = {
    dbus.implementation = "broker";
    logrotate.enable = true;
    journald = {
      storage = "volatile"; # Store logs in memory
      upload.enable = false; # Disable remote log upload (the default)
      extraConfig = ''
        SystemMaxUse=500M
        SystemMaxFileSize=50M
      '';
    };
  };
</code></pre>
<ul>
<li>
<p><code>dbus-broker</code> is more resilient to resource exhaustion attacks and integrates
better with Linux security features.</p>
</li>
<li>
<p><a href="https://dvdhrm.github.io/rethinking-the-dbus-message-bus/">Rethinking-the-dbus-message-bus</a></p>
</li>
<li>
<p>Setting <code>storage = "volatile"</code> tells journald to keep log data only in memory.
There is a tradeoff though, If you need long-term auditing or troubleshooting
after a reboot, this will not preserve system logs.</p>
</li>
<li>
<p><code>upload.enable</code> is for forwarding log messages to remote servers, setting this
to false prevents accidental leaks of potentially sensitive or internal system
information.</p>
</li>
<li>
<p>Enabling <code>logrotate</code> prevents your disk from filling with excessive
<strong>legacy/service</strong> log files. These are the classic plain-text logs.</p>
</li>
<li>
<p>Systemd uses <code>journald</code> which stores logs in a binary format</p>
</li>
</ul>
<p>You can check the security status with:</p>
<pre><code class="language-bash">systemd-analyze security
# or for a detailed view of individual services security posture
systemd-analyze security NetworkManager
</code></pre>
<p>Optionally disable vulnerable services to reduce the attack surface, obviously
don't disable what you need or change your habits:</p>
<pre><code class="language-nix">services = {
    # mDNS/DNS-SD
    avahi.enable = false;
    # Geoclue (location services)
    geoclue2.enable = false;
    udisks2.enable = false;
    accounts-daemon.enable = false;
  };
  # Only needed for WWAN/3G/4G modems, otherwise it runs `mmcli` unnecessarily
  networking.modemmanager.enable = false;
  # Bluetooth has a long history of vulnerabilities
  hardware.bluetooth.enable = false;
  # Prefer manual upgrades on a hardened system
  system.autoUpgrade.enable = false;
</code></pre>
<p>Further reading on systemd:</p>
<details>
<summary> ✔️ Click to Expand Systemd Resources </summary>
<ul>
<li>
<p><a href="https://systemd.io/">systemd.io</a></p>
</li>
<li>
<p><a href="https://0pointer.de/blog/projects/systemd.html">Rethinking PID 1</a></p>
</li>
<li>
<p><a href="https://0pointer.de/blog/projects/the-biggest-myths.html">Biggest Myths about Systemd</a></p>
</li>
</ul>
</details>
<p>The following is a repo containing many of the Systemd hardening settings in
NixOS format:</p>
<p><a href="https://github.com/wallago/nix-system-services-hardened">nix-system-services-hardened</a></p>
<p>For example, to harden bluetooth you could add the following to your
<code>configuration.nix</code> or equivalent:</p>
<pre><code class="language-nix">systemd.services = {
      bluetooth.serviceConfig = {
      ProtectKernelTunables = lib.mkDefault true;
      ProtectKernelModules = lib.mkDefault true;
      ProtectKernelLogs = lib.mkDefault true;
      ProtectHostname = true;
      ProtectControlGroups = true;
      ProtectProc = "invisible";
      SystemCallFilter = [
        "~@obsolete"
        "~@cpu-emulation"
        "~@swap"
        "~@reboot"
        "~@mount"
      ];
      SystemCallArchitectures = "native";
    };
}
</code></pre>
<details>
<summary> Click to expand `systemd.nix` example implementing many of the recommendations </summary>
<pre><code class="language-nix">{lib, ...}: {
  systemd.services = {
    # "home-manager-jr".after = ["network-online.target"];
    # "home-manager-jr".wantedBy = ["multi-user.target"];
    "user@".serviceConfig = {
      ProtectSystem = "strict";
      ProtectClock = true;
      ProtectHostname = true;
      ProtectKernelTunables = true;
      ProtectKernelModules = true;
      ProtectKernelLogs = true;
      ProtectProc = "invisible";
      PrivateTmp = true;
      PrivateNetwork = true;
      MemoryDenyWriteExecute = false;
      RestrictAddressFamilies = [
        "AF_UNIX"
        "AF_NETLINK"
        "AF_BLUETOOTH"
      ];
      RestrictNamespaces = true;
      RestrictRealtime = true;
      RestrictSUIDSGID = true;
      SystemCallFilter = [
        "~@keyring"
        "~@swap"
        "~@debug"
        "~@module"
        "~@obsolete"
        "~@cpu-emulation"
      ];
      SystemCallArchitectures = "native";
    };
    acpid.serviceConfig = {
      ProtectSystem = "full";
      ProtectHome = true;
      RestrictAddressFamilies = ["AF_INET" "AF_INET6"];
      SystemCallFilter = "~@clock @cpu-emulation @debug @module @mount @raw-io @reboot @swap";
      ProtectKernelTunables = true;
      ProtectKernelModules = true;
    };

    auditd.serviceConfig = {
      NoNewPrivileges = true;
      ProtectSystem = "full";
      ProtectHome = true;
      ProtectHostname = true;
      ProtectKernelTunables = true;
      ProtectKernelModules = true;
      ProtectControlGroups = true;
      ProtectProc = "invisible";
      ProtectClock = true;
      PrivateTmp = true;
      PrivateNetwork = true;
      PrivateMounts = true;
      PrivateDevices = true;
      RestrictNamespaces = true;
      RestrictRealtime = true;
      RestrictSUIDSGID = true;
      RestrictAddressFamilies = [
        "~AF_INET6"
        "~AF_INET"
        "~AF_PACKET"
      ];
      MemoryDenyWriteExecute = true;
      LockPersonality = true;
      SystemCallFilter = [
        "~@clock"
        "~@module"
        "~@mount"
        "~@swap"
        "~@obsolete"
        "~@cpu-emulation"
      ];
      SystemCallArchitectures = "native";
      CapabilityBoundingSet = [
        "~CAP_CHOWN"
        "~CAP_FSETID"
        "~CAP_SETFCAP"
      ];
    };

    cups.serviceConfig = {
      NoNewPrivileges = true;
      ProtectSystem = "full";
      ProtectHome = true;
      ProtectKernelModules = true;
      ProtectKernelTunables = true;
      ProtectKernelLogs = true;
      ProtectControlGroups = true;
      ProtectHostname = true;
      ProtectClock = true;
      ProtectProc = "invisible";
      RestrictRealtime = true;
      RestrictNamespaces = true;
      RestrictSUIDSGID = true;
      RestrictAddressFamilies = [
        "AF_UNIX"
        "AF_NETLINK"
        "AF_INET"
        "AF_INET6"
        "AF_PACKET"
      ];

      MemoryDenyWriteExecute = true;
      SystemCallFilter = [
        "~@clock"
        "~@reboot"
        "~@debug"
        "~@module"
        "~@swap"
        "~@obsolete"
        "~@cpu-emulation"
      ];
      SystemCallArchitectures = "native";
      LockPersonality = true;
    };

    NetworkManager.serviceConfig = {
      NoNewPrivileges = true;
      ProtectHome = true;
      ProtectKernelModules = true;
      ProtectKernelLogs = true;
      ProtectControlGroups = true;
      ProtectClock = true;
      ProtectHostname = true;
      ProtectProc = "invisible";
      PrivateTmp = true;
      RestrictRealtime = true;
      RestrictAddressFamilies = [
        "AF_UNIX"
        "AF_NETLINK"
        "AF_INET"
        "AF_INET6"
        "AF_PACKET"
      ];
      RestrictNamespaces = true;
      RestrictSUIDSGID = true;
      MemoryDenyWriteExecute = true;
      SystemCallFilter = [
        "~@mount"
        "~@module"
        "~@swap"
        "~@obsolete"
        "~@cpu-emulation"
        "ptrace"
      ];
      SystemCallArchitectures = "native";
      LockPersonality = true;
    };

    wpa_supplicant.serviceConfig = {
      NoNewPrivileges = true;
      ProtectSystem = "strict";
      ProtectHome = true;
      ProtectKernelModules = true;
      ProtectKernelLogs = true;
      ProtectControlGroups = true;
      ProtectClock = true;
      ProtectHostname = true;
      ProtectProc = "invisible";
      PrivateTmp = true;
      PrivateMounts = true;
      RestrictRealtime = true;
      RestrictAddressFamilies = [
        "AF_UNIX"
        "AF_NETLINK"
        "AF_INET"
        "AF_INET6"
        "AF_PACKET"
      ];
      RestrictNamespaces = true;
      RestrictSUIDSGID = true;
      MemoryDenyWriteExecute = true;
      SystemCallFilter = [
        "~@mount"
        "~@raw-io"
        "~@privileged"
        "~@keyring"
        "~@reboot"
        "~@module"
        "~@swap"
        "~@resources"
        "~@obsolete"
        "~@cpu-emulation"
        "ptrace"
      ];
      SystemCallArchitectures = "native";
      LockPersonality = true;
      CapabilityBoundingSet = "CAP_NET_ADMIN CAP_NET_RAW";
    };

    dbus.serviceConfig = {
      NoNewPrivileges = true;
      ProtectSystem = "stric";
      ProtectControlGroups = true;
      ProtectHome = true;
      ProtectHostname = true;
      ProtectKernelTunables = true;
      ProtectKernelModules = true;
      ProtectKernelLogs = true;
      PrivateMounts = true;
      PrivateDevices = true;
      PrivateTmp = true;
      RestrictSUIDSGID = true;
      RestrictRealtime = true;
      RestrictAddressFamilies = [
        "AF_UNIX"
      ];
      RestrictNamespaces = true;
      SystemCallErrorNumber = "EPERM";
      SystemCallArchitectures = "native";
      SystemCallFilter = [
        "~@obsolete"
        "~@resources"
        "~@debug"
        "~@mount"
        "~@reboot"
        "~@swap"
        "~@cpu-emulation"
      ];
      LockPersonality = true;
      IPAddressDeny = ["0.0.0.0/0" "::/0"];
      MemoryDenyWriteExecute = true;
      DevicePolicy = "closed";
      UMask = 0077;
    };

    nscd.serviceConfig = {
      ProtectClock = true;
      ProtectHostname = true;
      ProtectKernelTunables = true;
      ProtectKernelModules = true;
      ProtectKernelLogs = true;
      ProtectControlGroups = true;
      ProtectProc = "invisible";
      RestrictNamespaces = true;
      RestrictRealtime = true;
      MemoryDenyWriteExecute = true;
      LockPersonality = true;
      SystemCallFilter = [
        "~@mount"
        "~@swap"
        "~@clock"
        "~@obsolete"
        "~@cpu-emulation"
      ];
      SystemCallArchitectures = "native";
      CapabilityBoundingSet = [
        "~CAP_CHOWN"
        "~CAP_FSETID"
        "~CAP_SETFCAP"
      ];
    };
    bluetooth.serviceConfig = {
      ProtectKernelTunables = lib.mkDefault true;
      ProtectKernelModules = lib.mkDefault true;
      ProtectKernelLogs = lib.mkDefault true;
      ProtectHostname = true;
      ProtectControlGroups = true;
      ProtectProc = "invisible";
      SystemCallFilter = [
        "~@obsolete"
        "~@cpu-emulation"
        "~@swap"
        "~@reboot"
        "~@mount"
      ];
      SystemCallArchitectures = "native";
    };
    systemd-rfkill.serviceConfig = {
      ProtectSystem = "strict";
      ProtectHome = true;
      ProtectKernelTunables = true;
      ProtectKernelModules = true;
      ProtectControlGroups = true;
      ProtectClock = true;
      ProtectProc = "invisible";
      ProcSubset = "pid";
      PrivateTmp = true;
      MemoryDenyWriteExecute = true;
      NoNewPrivileges = true;
      LockPersonality = true;
      RestrictRealtime = true;
      SystemCallArchitectures = "native";
      UMask = "0077";
      IPAddressDeny = "any";
    };
    systemd-machined.serviceConfig = {
      NoNewPrivileges = true;
      ProtectSystem = "strict";
      ProtectHome = true;
      ProtectClock = true;
      ProtectHostname = true;
      ProtectKernelTunables = true;
      ProtectKernelModules = true;
      ProtectKernelLogs = true;
      ProtectProc = "invisible";
      PrivateTmp = true;
      PrivateMounts = true;
      PrivateUsers = true;
      PrivateNetwork = true;
      RestrictNamespaces = true;
      RestrictRealtime = true;
      RestrictSUIDSGID = true;
      RestrictAddressFamilies = ["AF_UNIX"];
      MemoryDenyWriteExecute = true;
      SystemCallArchitectures = "native";
    };
    systemd-udevd.serviceConfig = {
      NoNewPrivileges = true;
      ProtectSystem = "strict";
      ProtectHome = true;
      ProtectKernelLogs = true;
      ProtectControlGroups = true;
      ProtectClock = true;
      ProtectProc = "invisible";
      RestrictNamespaces = true;
      CapabilityBoundingSet = "~CAP_SYS_PTRACE ~CAP_SYS_PACCT";
    };
    nix-daemon.serviceConfig = {
      NoNewPrivileges = true;
      ProtectControlGroups = true;
      ProtectKernelModules = true;
      PrivateMounts = true;
      PrivateTmp = true;
      PrivateDevices = true;
      RestrictSUIDSGID = true;
      RestrictRealtime = true;
      RestrictNamespaces = ["~cgroup"];
      RestrictAddressFamilies = [
        "AF_UNIX"
        "AF_NETLINK"
        "AF_INET6"
        "AF_INET"
      ];
      CapabilityBoundingSet = [
        "~CAP_SYS_CHROOT"
        "~CAP_BPF"
        "~CAP_AUDIT_WRITE"
        "~CAP_AUDIT_CONTROL"
        "~CAP_AUDIT_READ"
        "~CAP_SYS_PTRACE"
        "~CAP_SYS_NICE"
        "~CAP_SYS_RESOURCE"
        "~CAP_SYS_RAWIO"
        "~CAP_SYS_TIME"
        "~CAP_SYS_PACCT"
        "~CAP_LINUX_IMMUTABLE"
        "~CAP_IPC_LOCK"
        "~CAP_WAKE_ALARM"
        "~CAP_SYS_TTY_CONFIG"
        "~CAP_SYS_BOOT"
        "~CAP_LEASE"
        "~CAP_BLOCK_SUSPEND"
        "~CAP_MAC_ADMIN"
        "~CAP_MAC_OVERRIDE"
      ];
      SystemCallErrorNumber = "EPERM";
      SystemCallArchitectures = "native";
      SystemCallFilter = [
        "~@resources"
        "~@module"
        "~@obsolete"
        "~@debug"
        "~@reboot"
        "~@swap"
        "~@cpu-emulation"
        "~@clock"
        "~@raw-io"
      ];
      LockPersonality = true;
      MemoryDenyWriteExecute = false;
      DevicePolicy = "closed";
      UMask = 0077;
    };
    systemd-journald.serviceConfig = {
      NoNewPrivileges = true;
      ProtectProc = "invisible";
      ProtectHostname = true;
      PrivateMounts = true;
    };
  };
}
</code></pre>
</details>
<p>As you can see from above, you typically use the <code>serviceConfig</code> attribute to
harden settings for systemd services.</p>
<pre><code class="language-bash">systemd-analyze security bluetooth
→ Overall exposure level for bluetooth.service: 3.3 OK 🙂
</code></pre>
<h2 id="lynis-and-other-tools"><a class="header" href="#lynis-and-other-tools">Lynis and other tools</a></h2>
<p>Lynis is a security auditing tool for systems based on UNIX like Linux, macOS,
BSD, and others.--<a href="https://github.com/CISOfy/lynis">lynis repo</a></p>
<p><code>chkrootkit</code> was removed as it is unmaintained and archived upstream.</p>
<p>Installation:</p>
<pre><code class="language-nix">environment.systemPackages = [
pkgs.lynis
pkgs.clamav
pkgs.aide
 ];
</code></pre>
<details>
<summary> ✔️ Click to Expand AIDE Example </summary>
<p>AIDE is an intrusion detection system (IDS) that will notify us whenever it
detects that a potential intrusion has occurred. When a system is compromised,
attackers typically will try to change file permissions and escalate to the root
user account and start to modify system files, AIDE can detect this.</p>
<p>To set up AIDE on your system follow these steps:</p>
<ol>
<li>Create the <code>aide.conf</code>:</li>
</ol>
<pre><code class="language-bash">sudo mkdir -p /var/lib/aide &amp;&amp; cd /var/lib/aide/
sudo hx aide.conf
</code></pre>
<p>Add the following content to <code>/var/lib/aide/aide.conf</code>:</p>
<pre><code class="language-conf"># aide.conf
# Example configuration file for AIDE.

@@define DBDIR /var/lib/aide

# The location of the database to be read.
database_in=file:@@{DBDIR}/aide.db.gz

# The location of the database to be written.
#database_out=sql:host:port:database:login_name:passwd:table
#database_out=file:aide.db.new
database_out=file:@@{DBDIR}/aide.db.new.gz

# Whether to gzip the output to database
gzip_dbout=yes

log_level=info

report_url=file:/var/log/aide/aide.log
report_url=stdout
#report_url=stderr
#NOT IMPLEMENTED report_url=mailto:root@foo.com
#NOT IMPLEMENTED report_url=syslog:LOG_AUTH

# These are the default rules.
#
#p:      permissions
#i:      inode:
#n:      number of links
#u:      user
#g:      group
#s:      size
#b:      block count
#m:      mtime
#a:      atime
#c:      ctime
#S:      check for growing size
#md5:    md5 checksum
#sha1:   sha1 checksum
#rmd160: rmd160 checksum
#tiger:  tiger checksum
#haval:  haval checksum
#gost:   gost checksum
#crc32:  crc32 checksum
#R:      p+i+n+u+g+s+m+c+md5
#L:      p+i+n+u+g
#E:      Empty group
#&gt;:      Growing logfile p+u+g+i+n+S

# You can create custom rules like this.

NORMAL = R+b+sha512

DIR = p+i+n+u+g

# Next decide what directories/files you want in the database.

/boot   NORMAL
/bin    NORMAL
/sbin   NORMAL
/lib    NORMAL
/opt    NORMAL
/usr    NORMAL
/root   NORMAL

# Check only permissions, inode, user and group for /etc, but
# cover some important files closely.
/etc    p+i+u+g
!/etc/mtab
/etc/exports  NORMAL
/etc/fstab    NORMAL
/etc/passwd   NORMAL
/etc/group    NORMAL
/etc/gshadow  NORMAL
/etc/shadow   NORMAL

/var/log   p+n+u+g

# With AIDE's default verbosity level of 5, these would give lots of
# warnings upon tree traversal. It might change with future version.
#
#=/lost\+found    DIR
#=/home           DIR
</code></pre>
<p>Create the logfile:</p>
<pre><code class="language-bash">sudo mkdir -p /var/log/aide
sudo touch /var/log/aide/aide.log
</code></pre>
<ol start="2">
<li>Generate the initial database, this will store the checksums of all files
that it's configured to monitor. Take note of the location of the new
database, mine was <code>/etc/aide.db.new</code></li>
</ol>
<pre><code class="language-bash">sudo aide --config /var/lib/aide/aide.conf --init
</code></pre>
<ol start="3">
<li>Move the new database and remove the <code>.new</code>:</li>
</ol>
<pre><code class="language-bash">sudo mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz
</code></pre>
<pre><code class="language-bash">ls /var/lib/aide/
aide.conf   aide.db.gz
</code></pre>
<ol start="4">
<li>Check with AIDE:</li>
</ol>
<pre><code class="language-bash">sudo aide --check --config /var/lib/aide/aide.conf
Start timestamp: 2025-09-05 09:50:07 -0400 (AIDE 0.19.2)
AIDE found NO differences between database and filesystem. Looks okay!!
</code></pre>
<ol start="5">
<li>Whenever you make changes to system files, or especially after running a
system update or installing new tools, you have to rescan all files to update
their checksums in the AIDE database:</li>
</ol>
<pre><code class="language-bash">sudo aide --update --config /var/lib/aide/aide.conf
</code></pre>
<p>Unfortunately, AIDE doesn't automatically replace the old database so you have
to rename the new one again:</p>
<pre><code class="language-bash">sudo mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz
</code></pre>
<p>And finally check again:</p>
<pre><code class="language-bash">sudo aide --check --config /var/lib/aide/aide.conf
</code></pre>
<ul>
<li><a href="https://linux.die.net/man/1/aide">aide(1) man page</a></li>
</ul>
</details>
<details>
<summary> ✔️ Click to Expand clamav.nix Example </summary>
<pre><code class="language-nix">{pkgs, ...}: {
  environment.systemPackages = with pkgs; [
    clamav
  ];
  services.clamav = {
    # Enable clamd daemon
    daemon.enable = true;
    updater.enable = true;
    updater.frequency = 12; # Number of database checks per day
    scanner = {
      enable = true;
      # 4:00 AM
      interval = "*-*-* 04:00:00";
      scanDirectories = [
        "/home"
        "/var/lib"
        "/tmp"
        "/etc"
        "/var/tmp"
      ];
    };
  };
}
</code></pre>
</details>
<p>Lynis Usage:</p>
<pre><code class="language-bash">sudo lynis show commands
# Output:
Commands:
lynis audit
lynis configure
lynis generate
lynis show
lynis update
lynis upload-only

sudo lynis audit system
# Output:
  Lynis security scan details:

  Hardening index : 79 [###############     ]
  Tests performed : 234
  Plugins enabled : 0

  Components:
  - Firewall               [V]
  - Malware scanner        [V]

  Scan mode:
  Normal [V]  Forensics [ ]  Integration [ ]  Pentest [ ]

  Lynis modules:
  - Compliance status      [?]
  - Security audit         [V]
  - Vulnerability scan     [V]
</code></pre>
<ul>
<li>
<p>The "Lynis hardening index" is an overall impression on how well a system is
hardened. However, this is just an indicator on measures taken - not a
percentage of how safe a system might be. A score over 75 typically indicates
a system with more than average safety measures implemented.</p>
</li>
<li>
<p>Lynis will give you more recommendations for securing your system as well.</p>
</li>
</ul>
<p>If you use <code>clamscan</code>, create the following log file:</p>
<pre><code class="language-bash">sudo touch /var/log/clamscan.log
</code></pre>
<p>Example cron job for <code>clamav</code> &amp; <code>aide</code>:</p>
<pre><code class="language-nix">{pkgs, ...}: {
  services.cron = {
    enable = true;
    # messages.enable = true;
    systemCronJobs = [
      # Every day at 2:00 AM, run clamscan as root and append output to a log file
      "0 2 * * * root ${pkgs.clamav}/bin/clamscan -r /home &gt;&gt; /var/log/clamscan.log"
      "0 11 * * * ${pkgs.aide}/bin/aide --check --config /var/lib/aide/aide.conf"
    ];
  };
}
</code></pre>
<p>ClamAV usage:</p>
<p>You can run <code>clamav</code> manually with:</p>
<pre><code class="language-bash"># Recursive Scan:
sudo clamscan -r ~/home
</code></pre>
<blockquote>
<p>❗ NOTE: You only need either the individual <code>pkgs.clamav</code> with the cron job
<strong>OR</strong> the <code>clamd-daemon</code> module. <code>clamdscan</code> is for software integration and
uses a different user that doesn't have permission to scan your files. You can
use <code>clamdscan --fdpass /path/to/scan</code> to pass the necessary file permissions.
NOTE: <code>clamdscan</code> runs in the background, you can watch it with <code>top</code>.</p>
</blockquote>
<h2 id="securing-ssh"><a class="header" href="#securing-ssh">Securing SSH</a></h2>
<blockquote>
<p><strong>Security information</strong>: Changing SSH configuration settings can
significantly impact the security of your system(s). It is crucial to have a
solid understanding of what you are doing before making any adjustments. Avoid
blindly copying and pasting examples, including those from this Wiki page,
without conducting a thorough analysis. Failure to do so may compromise the
security of your system(s) and lead to potential vulnerabilities. Take the
time to comprehend the implications of your actions and ensure that any
changes made are done thoughtfully and with care. --NixOS Wiki</p>
</blockquote>
<blockquote>
<p>❗ NOTE: Choose one, either <code>ssh-agent</code> or <code>gpg-agent</code></p>
</blockquote>
<ol>
<li>Use normal SSH keys generated with <code>ssh-keygen</code>, this is recommended unless
you have a good reason for not using it.</li>
</ol>
<p><strong>OR</strong></p>
<ol start="2">
<li>Use a GPG key with <code>gpg-agent</code> (which acts as your SSH agent). Complex, and
harder to understand in my opinion.</li>
</ol>
<p>My setup caused conflicts when enabling <code>programs.ssh.startAgent</code> so I chose
<code>gpg-agent</code> personally.</p>
<p>There are situations where you are required to use one or the other like for
headless CI/CD environments, <code>ssh-keygen</code> is required.</p>
<ul>
<li><a href="https://saylesss88.github.io/nix/gpg-agent.html">Click Here for GnuPG and gpg-agent chapter</a></li>
</ul>
<p>Further reading:</p>
<details>
<summary> ✔️ Click to Expand Resourses on OpenSSH </summary>
<ul>
<li>
<p><a href="https://wiki.archlinux.org/title/OpenSSH">Arch Wiki OpenSSH</a></p>
</li>
<li>
<p><a href="https://wiki.gentoo.org/wiki/GnuPG">Gentoo GnuPG</a></p>
</li>
<li>
<p><a href="https://rgoulter.com/blog/posts/programming/2022-06-10-a-visual-explanation-of-gpg-subkeys.html">A Visual Explanation of GPG Subkeys</a></p>
</li>
<li>
<p><a href="https://blog.stribik.technology/2015/01/04/secure-secure-shell.html">Secure Secure Shell</a></p>
</li>
</ul>
</details>
<h2 id="key-generation"><a class="header" href="#key-generation">Key generation</a></h2>
<h3 id="ssh-keygen"><a class="header" href="#ssh-keygen">ssh-keygen</a></h3>
<p>The <code>ed25519</code> algorithm is significantly faster and more secure when compared to
<code>RSA</code>. You can also specify the key derivation function (KDF) rounds to
strengthen protection even more.</p>
<p>For example, to generate a strong key for MdBook:</p>
<pre><code class="language-bash">ssh-keygen -t ed25519 -a 32 -f ~/.ssh/id_ed25519_github_$(date +%Y-%m-%d) -C "SSH Key for MdBook"
</code></pre>
<ul>
<li>
<p><code>-t</code> is for type</p>
</li>
<li>
<p><code>-a 32</code> sets the number of KDF rounds. The standard is usually good enough,
adding extra rounds can make it harder to brute-force.</p>
</li>
<li>
<p><code>-f</code> is for filename</p>
</li>
</ul>
<h3 id="openssh-server"><a class="header" href="#openssh-server">OpenSSH Server</a></h3>
<p>First of all, if you don't use SSH don't enable it in the first place. If you do
use SSH, it's important to understand what that opens you up to.</p>
<p>The following are some recommendations from Mozilla on OpenSSH:</p>
<ul>
<li><a href="https://infosec.mozilla.org/guidelines/openssh.html">Mozilla OpenSSH guidelines</a></li>
</ul>
<p>The following OpenSSH setup is based on the above guidelines with strong
algorithms, and best practices:</p>
<pre><code class="language-nix">{config, ...}: {
  config = {
    services = {
      fail2ban = {
        enable = true;
        maxretry = 5;
        bantime = "1h";
        # ignoreIP = [
        # "172.16.0.0/12"
        # "192.168.0.0/16"
        # "2601:881:8100:8de0:31e6:ac52:b5be:462a"
        # "matrix.org"
        # "app.element.io" # don't ratelimit matrix users
        # ];

        bantime-increment = {
          enable = true; # Enable increment of bantime after each violation
          multipliers = "1 2 4 8 16 32 64 128 256";
          maxtime = "168h"; # Do not ban for more than 1 week
          overalljails = true; # Calculate the bantime based on all the violations
        };
      };
      openssh = {
        enable = true;
        settings = {
          PasswordAuthentication = false;
          PermitEmptyPasswords = false;
          PermitTunnel = false;
          UseDns = false;
          KbdInteractiveAuthentication = false;
          X11Forwarding = config.services.xserver.enable;
          MaxAuthTries = 3;
          MaxSessions = 2;
          ClientAliveInterval = 300;
          ClientAliveCountMax = 0;
          AllowUsers = ["your-user"];
          TCPKeepAlive = false;
          AllowTcpForwarding = false;
          AllowAgentForwarding = false;
          LogLevel = "VERBOSE";
          PermitRootLogin = "no";
          KexAlgorithms = [
            # Key Exchange Algorithms in priority order
            "curve25519-sha256@libssh.org"
            "ecdh-sha2-nistp521"
            "ecdh-sha2-nistp384"
            "ecdh-sha2-nistp256"
            "diffie-hellman-group-exchange-sha256"
          ];
          Ciphers = [
            # stream cipher alternative to aes256, proven to be resilient
            # Very fast on basically anything
            "chacha20-poly1305@openssh.com"
            # industry standard, fast if you have AES-NI hardware
            "aes256-gcm@openssh.com"
            "aes128-gcm@openssh.com"
            "aes256-ctr"
            "aes192-ctr"
            "aes128-ctr"
          ];
          Macs = [
            # Combines the SHA-512 hash func with a secret key to create a MAC
            "hmac-sha2-512-etm@openssh.com"
            "hmac-sha2-256-etm@openssh.com"
            "umac-128-etm@openssh.com"
            "hmac-sha2-512"
            "hmac-sha2-256"
            "umac-128@openssh.com"
          ];
        };
        # These keys will be generated for you
        hostKeys = [
          {
            path = "/etc/ssh/ssh_host_ed25519_key";
            type = "ed25519";
          }
        ];
      };
    };
  };
}
</code></pre>
<p>TCP port 22 (ssh) is opened automatically if the SSH daemon is enabled
(<code>services.openssh.enable = true;</code>)</p>
<p>Much of the SSH hardening settings came from
<a href="https://ryanseipp.com/post/nixos-secure-ssh/">ryanseipp's secure-ssh Guide</a>
with some additions of my own.</p>
<p>Fail2Ban is an intrusion prevention software framework. It's designed to prevent
brute-force attacks by scanning log files for suspicious activity, such as
repeated failed login attempts.</p>
<p>OpenSSH is the primary tool for secure remote access for NixOS. Enabling it
activates the OpenSSH server on the system, allowing incoming SSH connections.</p>
<p>The above configuration is a robust setup for securing an SSH server by:</p>
<ul>
<li>
<p>Preventing brute-force attacks with Fail2Ban</p>
</li>
<li>
<p>Eliminating password authentication in favor of more secure SSH keys</p>
</li>
<li>
<p>Restricting user access and preventing root login</p>
</li>
<li>
<p>Disabling potentially risky forwarding features (tunnel, TCP, agent)</p>
</li>
<li>
<p>Enforce the use of strong, modern cryptographic algorithms for all SSH
communications.</p>
</li>
<li>
<p>Enhanced logging for better auditing.</p>
</li>
</ul>
<p>Further Reading:</p>
<ul>
<li>
<p><a href="https://www.openssh.com/">OpenSSH</a></p>
</li>
<li>
<p><a href="https://www.digitalocean.com/community/tutorials/how-fail2ban-works-to-protect-services-on-a-linux-server">DigitalOcean how fail2ban works</a></p>
</li>
</ul>
<h2 id="encrypted-secrets"><a class="header" href="#encrypted-secrets">Encrypted Secrets</a></h2>
<p>Never store secrets in plain text in repositories. Use something like
<a href="https://github.com/Mic92/sops-nix">sops-nix</a>, which lets you keep encrypted
secrets under version control declaratively.</p>
<p>Another option is <a href="https://github.com/ryantm/agenix">agenix</a></p>
<ul>
<li><a href="https://wiki.nixos.org/wiki/Agenix">NixOS Wiki Agenix</a></li>
</ul>
<h3 id="sops-nix-guide"><a class="header" href="#sops-nix-guide">Sops-nix Guide</a></h3>
<p>Protect your secrets, the following guide is on setting up Sops on NixOS:
<a href="https://saylesss88.github.io/installation/enc/sops-nix.html">Sops Encrypted Secrets</a></p>
<h2 id="auditd"><a class="header" href="#auditd">Auditd</a></h2>
<p>To enable the Linux Audit Daemon (<code>auditd</code>) and define a very basic rule set,
you can use the following NixOS configuration. This example demonstrates how to
log every program execution (<code>execve</code>) on a 64-bit architecture.</p>
<pre><code class="language-nix"># modules/security/auditd-minimal.nix (or directly in configuration.nix)
{
  # start as early in the boot process as possible
  boot.kernelParams = ["audit=1"];
  security.auditd.enable = true;
  security.audit.enable = true;
  security.audit.rules = [
    # Log all program executions on 64-bit architecture
    "-a exit,always -F arch=b64 -S execve"
  ];
}
</code></pre>
<ul>
<li>
<p><code>audit=1</code> Enables auditing at the kernel level very early in the boot process.
Without this, some events could be missed.</p>
</li>
<li>
<p><code>security.auditd.enable = true;</code> Ensures the <code>auditd</code> userspace daemon is
started.</p>
</li>
<li>
<p>While often enabled together, <code>security.audit.enable</code> specifically refers to
enabling the NixOS module for audit rules generation.</p>
</li>
<li>
<p><code>execve</code> (program executions)</p>
</li>
<li>
<p>This is just a basic configuration, there is much more that can be tracked.</p>
</li>
</ul>
<h2 id="usb-port-protection"><a class="header" href="#usb-port-protection">USB Port Protection</a></h2>
<p>It's important to protect your USB ports to prevent BadUSB attacks, data
exfiltration, unauthorized device access, malware injection, etc.</p>
<p>To get a list of your connected USB devices you can use <code>lsusb</code> from the
<code>usbutils</code> package.</p>
<pre><code class="language-bash">lsusb
</code></pre>
<p>To list the devices recognized by USBGuard, run:</p>
<pre><code class="language-bash">sudo usbguard list-devices
</code></pre>
<ul>
<li><a href="https://mynixos.com/options/services.usbguard">MyNixOS services.usbguard</a></li>
</ul>
<p>Change <code>your-user</code> to your username:</p>
<pre><code class="language-nix"># usbguard.nix
{
  config,
  pkgs,
  lib,
  ...
}: let
  inherit (lib) mkIf;
  cfg = config.custom.security.usbguard;
in {
  options.custom.security.usbguard = {
    enable = lib.mkEnableOption "usbguard";
  };

  config = mkIf cfg.enable {
    services.usbguard = {
      enable = true;
      IPCAllowedUsers = ["root" "your-user"];
    # presentDevicePolicy refers to how to treat USB devices that are already connected when the daemon starts
      presentDevicePolicy = "allow";
      rules = ''
        # allow `only` devices with mass storage interfaces (USB Mass Storage)
        allow with-interface equals { 08:*:* }
        # allow mice and keyboards
        # allow with-interface equals { 03:*:* }

        # Reject devices with suspicious combination of interfaces
        reject with-interface all-of { 08:*:* 03:00:* }
        reject with-interface all-of { 08:*:* 03:01:* }
        reject with-interface all-of { 08:*:* e0:*:* }
        reject with-interface all-of { 08:*:* 02:*:* }
      '';
    };

    environment.systemPackages = [pkgs.usbguard];
  };
}
</code></pre>
<p>The above settings can be found in
<a href="https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/7/html/security_guide/sec-using-usbguard">RedHat UsbGuard</a></p>
<p>The only <code>allow</code> rule is for devices with <strong>only</strong> mass storage interfaces
(<code>08:*:*</code>) i.e., USB Mass storage devices, devices like keyboards and mice
(which use interface class <code>03:*:*</code>) implicitly <strong>not allowed</strong>.</p>
<p>The <code>reject</code> rules reject devices with a suspicious combination of interfaces. A
USB drive that implements a keyboard or a network interface is very suspicious,
these <code>reject</code> rules prevent that.</p>
<p>The <code>presentDevicePolicy = "allow";</code> allows any device that is present at daemon
start up even if they're not explicitly allowed. However, newly plugged in
devices must match an <code>allow</code> rule or get denied implicitly.</p>
<p>The <code>presentDevicePolicy</code> should be one of: # one of <code>"apply-policy"</code>(default,
evaluate the rule set for every present device), <code>"block"</code>, <code>"reject"</code>, <code>"keep"</code>
(keep whatever state the device is currently in), or <code>"allow"</code>, which is used in
the example.</p>
<p>There is also the
<a href="https://github.com/Cropi/usbguard-notifier">usbguard-notifier</a></p>
<p>And enable it with the following in your <code>configuration.nix</code> or equivalent:</p>
<pre><code class="language-nix"># configuration.nix
imports = [
    ./usbguard.nix
];
custom.security.usbguard.enable = true;
</code></pre>
<blockquote>
<p>❗ If you are ever unsure about a setting that you want to harden and think
that it could possibly break your system you can always use a specialisation
reversing the action and choose it's generation at boot up. For example, to
force-reverse the above settings you could:</p>
<pre><code class="language-nix"># configuration.nix
specialisation.no-usbguard.configuration = {
    services.usbguard.enable = lib.mkForce false;
};
</code></pre>
<ul>
<li>This is a situation where I recommend this, it's easy to lock yourself out
of your keyboard, mouse, etc. when trying to configure this.</li>
</ul>
</blockquote>
<p>Further Reading:</p>
<ul>
<li>
<p><a href="https://www.ninjaone.com/it-hub/endpoint-security/what-is-badusb/">NinjaOne BadUSB</a></p>
</li>
<li>
<p><a href="https://usbguard.github.io/">USBGuard</a></p>
</li>
<li>
<p><a href="https://www.cyberciti.biz/security/how-to-protect-linux-against-rogue-usb-devices-using-usbguard/">NixCraft USBGuard</a></p>
</li>
</ul>
<h2 id="doas-over-sudo"><a class="header" href="#doas-over-sudo">Doas over sudo</a></h2>
<blockquote>
<p>NOTE: I have moved to <code>run0</code> for authentication which is included by default
with systemd. It's actually a symlink to the existing <code>systemd-run</code> tool. It
behaves like a secure <code>sudo</code> alternative: it spawns a transient service under
PID 1 for privilege escalation, without relying on SUID (set user ID)
binaries. Also note that the Nixpkgs version of <code>doas</code> is unmaintained and
hasn't been updated in 4 years.</p>
</blockquote>
<ul>
<li>
<p><a href="https://mastodon.social/@pid_eins/112353324518585654">Why run0</a></p>
</li>
<li>
<p>SUID = "Set User ID": When a binary has the SUID bit set, it runs with the
privileges of the file's owner (often root). There is a long history of
vulnerabilities with SUID binaries.</p>
</li>
<li>
<p><code>run0</code> configuration is explained in the
<a href="https://saylesss88.github.io/nix/index.html">Hardening README</a></p>
</li>
</ul>
<p>For a more minimalist version of <code>sudo</code> with a smaller codebase and attack
surface, consider <code>doas</code>. Replace <code>userName</code> with your username:</p>
<pre><code class="language-nix"># doas.nix
{
  lib,
  config,
  pkgs, # Add pkgs if you need to access user information
  ...
}: let
  cfg = config.custom.security.doas;
in {
  options.custom.security.doas = {
    enable = lib.mkEnableOption "doas";
  };

  config = lib.mkIf cfg.enable {
    # Disable sudo
    security.sudo.enable = false;

    # Enable and configure `doas`.
    security.doas = {
      enable = true;
      extraRules = [
        {
          # Grant doas access specifically to your user
          users = ["userName"]; # &lt;--- Only give access to your user
          # persist = true; # Convenient but less secure
          # noPass = true;    # Convenient but even less secure
          keepEnv = true; # Often necessary
          # Optional: You can also specify which commands they can run, e.g.:
          # cmd = "ALL"; # Allows running all commands (default if not specified)
          # cmd = "/run/current-system/sw/bin/nixos-rebuild"; # Only allow specific command
        }
      ];
    };

    # Add an alias to the shell for backward-compat and convenience.
    environment.shellAliases = {
      sudo = "doas";
    };
  };
}
</code></pre>
<p>You would then import this into your <code>configuration.nix</code> and enable/disable it
with the following:</p>
<pre><code class="language-nix"># configuration.nix

imports = [
    ./doas.nix
];

custom.security.doas.enable = true;
</code></pre>
<blockquote>
<p>❗ NOTE: Many people opt for the less secure <code>groups = ["wheel"];</code> in the
above configuration instead of <code>users = ["userName"];</code> to give wider access,
the choice is yours.</p>
</blockquote>
<h2 id="firejail"><a class="header" href="#firejail">Firejail</a></h2>
<blockquote>
<p>❗️ Critics such as madaidan say that Firejail worsens security by acting as a
privilege escalation hole. Firejail requires the executable to be setuid,
meaning it runs with root privileges.This is risky because any vulnerability
in Firejail can lead to privilege escalation. This combined with many
convenience features and complicated command line flags leads to a large
attack surface.</p>
</blockquote>
<ul>
<li>
<p>I haven't personally tried
<a href="https://github.com/Naxdy/nix-bwrapper">nix-bwrapper</a> myself yet, but it's
another sandboxing option that looks interesting. Bubblewrap is known for
having a more minimal design and smaller attack surface.</p>
<ul>
<li>Also see: <a href="#flatpak">Flatpak section</a> for another option for sandboxing.</li>
</ul>
</li>
<li>
<p><a href="https://sr.ht/~fgaz/nix-bubblewrap/">nix-bubblewrap</a> is another option.</p>
</li>
<li>
<p><a href="https://wiki.nixos.org/wiki/Firejail">NixOS Wiki Firejail</a></p>
</li>
<li>
<p><a href="https://wiki.archlinux.org/title/Firejail">Arch Wiki Firejail</a></p>
</li>
</ul>
<blockquote>
<p>❗ WARNING: Running untrusted code is never safe, sandboxing cannot change
this. --Arch Wiki</p>
</blockquote>
<pre><code class="language-nix"># firejail.nix
{
  pkgs,
  lib,
  ...
}: {
  programs.firejail = {
    enable = true;
    wrappedBinaries = {
      # Sandbox a web browser
      librewolf = {
        executable = "${lib.getBin pkgs.librewolf}/bin/librewolf";
        profile = "${pkgs.firejail}/etc/firejail/librewolf.profile";
      };
      # Sandbox a file manager
      thunar = {
        executable = "${lib.getBin pkgs.xfce.thunar}/bin/thunar";
        profile = "${pkgs.firejail}/etc/firejail/thunar.profile";
      };
      # Sandbox a document viewer
      zathura = {
        executable = "${lib.getBin pkgs.zathura}/bin/zathura";
        profile = "${pkgs.firejail}/etc/firejail/zathura.profile";
      };
    };
  };
}
</code></pre>
<p><code>wrappedBinaries</code> is a list of applications you want to run inside a sandbox.
Only the apps in the <code>wrappedBinaries</code> attribute set will be automatically
firejailed when launched the usual way.</p>
<p>Other apps may be started manually using <code>firejail &lt;app&gt;</code>, or added to
<code>wrappedBinaries</code> if you want automatic sandboxing, just make sure the profile
exists.</p>
<p>To inspect which profiles are available, after rebuilding go to <code>/nix/store/</code>, I
used Yazi to search for <code>/firejail</code> and followed it to <code>firejail/etc</code>, where the
profiles are.</p>
<p>There are many flags and options available with firejail, I suggest checking out
<code>man firejail</code>.</p>
<p>There are comments explaining what's going on in:
<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/by-name/fi/firejail/package.nix">firejail/package.nix</a></p>
<p>Firejail is a SUID program that reduces the risk of security breaches by
restricting the running environment of untrusted applications using
<a href="https://lwn.net/Articles/531114/">Linux namespaces</a> and
<a href="https://l3net.wordpress.com/2015/04/13/firejail-seccomp-guide/">seccomp-bpf</a>--<a href="https://firejail.wordpress.com/">Firejail Security Sandbox</a></p>
<p>It provides sandboxing and access restriction per application, much like what
AppArmor/SELinux does at a kernel level. However, it's not as secure or
comprehensive as kernel-enforced MAC systems (AppArmor/SELinux), since it's a
userspace tool and can potentially be bypassed by privilege escalation exploits.</p>
<hr />
<h2 id="flatpak"><a class="header" href="#flatpak">Flatpak</a></h2>
<blockquote>
<p>❗️NOTE: You cannot effectively use Firejail with Flatpak apps because of how
their sandboxing technologies operate.</p>
</blockquote>
<p>Apps that don't have a flatpak equivalent can be further hardened with
bubblewrap independently but bubblewrap is not needed on Flatpak apps.</p>
<p>Because of this limited native MAC (Mandatory Access Control) support on NixOS,
using Flatpak is often a good approach to get sandboxing and isolation for many
GUI apps.</p>
<ul>
<li>
<p>Flatpak bundles runtimes and sandbox mechanisms that provide app isolation
independently of the host system's AppArmor or SELinux infrastructure. This
can improve security and containment for GUI applications running on NixOS
despite the system lacking full native MAC coverage.</p>
</li>
<li>
<p>Flatpak apps benefit from sandboxing through bubblewrap, which isolate apps
and restrict access to user/home and system resources.</p>
</li>
</ul>
<p>Add Flatpak with the FlatHub repository for all users:</p>
<pre><code class="language-nix">services.flatpak.enable = true;
  systemd.services.flatpak-repo = {
    wantedBy = [ "multi-user.target" ];
    path = [ pkgs.flatpak ];
    script = ''
      flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
      # Only apps that are verified
      # flatpak remote-add --if-not-exists --subset=verified flathub-verified https://flathub.org/repo/flathub.flatpakrepo
    '';
  };
xdg = {
  portal = {
    enable = true;
    extraPortals = [ pkgs.xdg-desktop-portal-gtk ];
    config.common.default = [ "gtk" ];
  };
};
# Disables screencopy
systemd.user.services."xdg-desktop-portal-wlr" = {
  enable = false;
};
</code></pre>
<ul>
<li>
<p><a href="https://docs.flathub.org/docs/for-users/verification">Flathub Verified Apps</a></p>
</li>
<li>
<p><a href="https://secureblue.dev/articles/flatpak">Flatpak the good the bad the ugly</a></p>
</li>
</ul>
<p>Then you can either find apps through <a href="https://flathub.org/en">FlatHub</a> or on
the cmdline with <code>flatpak search &lt;app&gt;</code>. Flatpak is best used for GUI apps, some
CLI apps can be installed through it but not all.</p>
<ul>
<li>
<p>There is also <a href="https://github.com/gmodena/nix-flatpak">nix-flatpak</a>, which
enables you to manage your flatpaks declaratively.</p>
</li>
<li>
<p><a href="https://flathub.org/en/apps/com.github.tchx84.Flatseal">Flatseal</a> is GUI
utility that enables you to review and modify permissions from your Flatpak
apps. Many apps by default come with smart-card support, X11 &amp; Wayland
support, and more, disabling unnecessary permissions is recommended.</p>
</li>
<li>
<p><a href="https://flathub.org/en/apps/io.github.flattool.Warehouse">Warehouse</a> provides
a simple UI to control complex Flatpak options, no cmdline required.</p>
</li>
</ul>
<p>I have heard that it is not recommended to use Flatpak browsers because in order
for flatpak to work it has to disable some of the built-in browser sandboxing
which can reduce security. I haven't found any examples of Flatpak browsers
being exposed but it's something to keep in mind.</p>
<hr />
<h2 id="selinuxapparmor-mac-mandatory-access-control"><a class="header" href="#selinuxapparmor-mac-mandatory-access-control">SeLinux/AppArmor MAC (Mandatory Access Control)</a></h2>
<p><strong>AppArmor</strong> is available on NixOS, but is still in a somewhat experimental and
evolving state. There are only a few profiles that have been adapted to NixOS,
see here
<a href="https://discourse.nixos.org/t/apparmor-default-profiles/16780">Discourse on default-profiles</a>
Which guides you here
<a href="https://github.com/NixOS/nixpkgs/blob/2acaef7a85356329f750819a0e7c3bb4a98c13fe/nixos/modules/security/apparmor/includes.nix">apparmor/includes.nix</a>
where you can see some of the abstractions and tunables to follow progress.</p>
<p><strong>SELinux</strong>: Experimental, not fully integrated, recent progress for
advanced/curious users; expect rough edges and manual intervention if you want
to try it. Most find SELinux more complex to configure and maintain than
AppArmor.</p>
<p>This isn't meant to be a comprehensive guide, more to get people thinking about
security on NixOS.</p>
<p>See the following guide on hardening networking:</p>
<ul>
<li><a href="https://saylesss88.github.io/nix/hardening_networking.html">Hardening Networking</a></li>
</ul>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<h3 id="advanced-hardening-with-nix-mineral-community-project"><a class="header" href="#advanced-hardening-with-nix-mineral-community-project">Advanced Hardening with <code>nix-mineral</code> (Community Project)</a></h3>
<details>
<summary> ✔️ Click to Expand section on `nix-mineral` </summary>
<p>For users seeking a more comprehensive and opinionated approach to system
hardening beyond the built-in <code>hardened</code> profile, the community project
<a href="https://github.com/cynicsketch/nix-mineral"><code>nix-mineral</code></a> offers a declarative
NixOS module.</p>
<p><code>nix-mineral</code> aims to apply a wide array of security configurations, focusing on
tweaking kernel parameters, system settings, and file permissions to reduce the
attack surface.</p>
<ul>
<li><strong>Community Project Status:</strong> <code>nix-mineral</code> is a community-maintained project
and is not officially part of the Nixpkgs repository or NixOS documentation.
Its development status is explicitly stated as "Alpha software," meaning it
may introduce stability issues or unexpected behavior.</li>
</ul>
<p>For detailed information on <code>nix-mineral</code>'s capabilities and current status,
refer directly to its
<a href="https://github.com/cynicsketch/nix-mineral">GitHub repository</a>.</p>
</details>
<ul>
<li>
<p><a href="https://hedgedoc.grimmauld.de/s/hWcvJEniW#">AppArmor and apparmor.d on NixOS</a></p>
</li>
<li>
<p><a href="https://tristanxr.com/post/selinux-on-nixos/">SELinux on NixOS</a></p>
</li>
<li>
<p><a href="https://xeiaso.net/blog/paranoid-nixos-2021-07-18/">Paranoid NixOS</a></p>
</li>
<li>
<p><a href="https://wiki.nixos.org/wiki/Security">NixOS Wiki Security</a></p>
</li>
<li>
<p><a href="https://nixos.org/manual/nixos/unstable/index.html#sec-luks-file-systems">Luks Encrypted File Systems</a></p>
</li>
<li>
<p><a href="https://discourse.nixos.org/t/a-modern-and-secure-desktop-setup/41154">Discourse A Modern and Secure Desktop</a></p>
</li>
<li>
<p><a href="https://notashelf.dev/posts/insecurities-remedies-i">notashelf NixOS Security 1 Systemd</a></p>
</li>
<li>
<p><a href="https://ryanseipp.com/post/hardening-nixos/">ryanseipp hardening-nixos</a></p>
</li>
<li>
<p><a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html">madaidans Linux Hardening Guide</a></p>
</li>
<li>
<p><a href="https://cybersecuritynews.com/hardening-linux-servers">Hardening-Linux-Servers</a></p>
</li>
<li>
<p><a href="https://linux-audit.com/linux-server-hardening-most-important-steps-to-secure-systems/">linux-audit Linux Server hardening best practices</a></p>
</li>
<li>
<p><a href="https://linux-audit.com/linux-security-guide-extended-version/">linux-audit Linux security guide extended</a></p>
</li>
<li>
<p><a href="https://wiki.archlinux.org/title/Security">Arch Wiki Security</a></p>
</li>
<li>
<p><a href="https://wiki.gentoo.org/wiki/Security_Handbook/Concepts">Gentoo Security_Handbook Concepts</a></p>
</li>
<li>
<p>STIGs are configuration standards developed by the Defense Information Systems
Agency (DISA) to secure systems and software for the U.S. Department of
Defense (DoD). They are considered a highly authoritative source for system
hardening.There are recommendations for hardening all kinds of software in the
<a href="https://stigviewer.com/stigs">Stig Viewer</a></p>
</li>
<li>
<p><a href="https://www.cisecurity.org/cis-benchmarks">CIS Benchmarks</a></p>
</li>
<li>
<p><a href="https://github.com/nsacyber">NSA Cybersecurity Directorate</a></p>
</li>
<li>
<p><a href="https://secureblue.dev/faq">secureblue FAQ</a></p>
</li>
<li>
<p><a href="https://www.kicksecure.com/wiki/Documentation">Excellent Kicksecure Docs</a></p>
</li>
<li>
<p><a href="https://factorable.net/faq.html">factorable.net (study of RSA and DSA crypto keys) FAQ</a></p>
</li>
<li>
<p><a href="https://blog.cr.yp.to/20140205-entropy.html">The cr.yp.to blog Entropy</a></p>
</li>
<li>
<p><a href="https://delroth.net/posts/nixos-security-wishlist/">NixOS Security wishlist</a></p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../nix/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../nix/gpg-agent.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../nix/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../nix/gpg-agent.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
