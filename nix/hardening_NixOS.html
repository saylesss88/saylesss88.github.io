<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hardening NixOS - nix-book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <a href="#" class="top-link" id="back-to-top">↑</a>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">nix-book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hardening-nixos"><a class="header" href="#hardening-nixos">Hardening NixOS</a></h1>
<details>
<summary> Click to Expand Table of Contents</summary>
<ul>
<li><a href="#minimal-installation-with-luks">Minimal Installation with LUKS</a></li>
<li><a href="#manual-encrypted-install-following-the-manual">Manual Encrypted Install Following the Manual</a></li>
<li><a href="#guided-encrypted-btrfs-subvol-install-using-disko">Guided Encrypted BTRFS Subvol install using disko</a></li>
<li><a href="#installing-software">Installing Software</a></li>
<li><a href="#impermanence">Impermanence</a></li>
<li><a href="#replace-timesyncd-with-a-chron-job-that-enables-network-time-security-nts">Replace timesyncd with a chron job that enables Network Time Security (NTS)</a></li>
<li><a href="#secure-boot">Secure Boot</a>
<ul>
<li><a href="#the-kernel">The Kernel</a></li>
</ul>
</li>
<li><a href="#choosing-your-kernel">Choosing your Kernel</a>
<ul>
<li><a href="#the-hardened-kernel">The Hardened Kernel</a></li>
<li><a href="#sysctl">sysctl</a></li>
</ul>
</li>
<li><a href="#kernel-security-settings">Kernel Security Settings</a></li>
<li><a href="#further-hardening-with-sysctl">Further Hardening with sysctl</a></li>
<li><a href="#hardening-boot-parameters">Hardening Boot Parameters</a></li>
<li><a href="#hardened-memory-allocator">Hardened Memory Allocator</a></li>
<li><a href="#hardening-systemd">Hardening Systemd</a></li>
<li><a href="#lynis-and-other-tools">Lynis and other tools</a></li>
<li><a href="#securing-ssh">Securing SSH</a></li>
<li><a href="#key-generation">Key generation</a>
<ul>
<li><a href="#ssh-keygen">ssh-keygen</a></li>
<li><a href="#openssh-server">OpenSSH Server</a></li>
</ul>
</li>
<li><a href="#encrypted-secrets">Encrypted Secrets</a>
<ul>
<li><a href="#sops-nix-guide">Sops-nix Guide</a></li>
</ul>
</li>
<li><a href="#auditd">Auditd</a></li>
<li><a href="#usb-port-protection">USB Port Protection</a></li>
<li><a href="#doas-over-sudo">Doas over sudo</a></li>
<li><a href="#firejail">Firejail</a></li>
<li><a href="#flatpak">Flatpak</a></li>
<li><a href="#selinuxapparmor-mac-mandatory-access-control">SeLinux/AppArmor MAC (Mandatory Access Control)</a></li>
<li><a href="#resources">Resources</a>
<ul>
<li><a href="#advanced-hardening-with-nix-mineral-community-project">Advanced Hardening with <code>nix-mineral</code> (Community Project)</a></li>
</ul>
</li>
</ul>
</details>
<!-- ![guy fawks hacker](../images/guy_fawks.png) -->
<p>Securing your NixOS system begins with a philosophy of minimalism, explicit
configuration, and proactive control.</p>
<blockquote>
<p>⚠️ Warning: I am not a security expert. This guide presents various options
for hardening NixOS, but it is your responsibility to evaluate whether each
adjustment suits your specific needs and environment. Security hardening and
process isolation can introduce stability challenges, compatibility issues, or
unexpected behavior. Additionally, these protections often come with
performance tradeoffs. Always conduct thorough research, there are no plug and
play one size fits all security solutions.</p>
</blockquote>
<blockquote>
<p>That said, I typically write about what I'm implementing myself to deepen
understanding and share what works for me. <code>--Source</code> means the proceeding
paragraph came from <code>--Source</code>, you can often click to check for yourself. If
you use some common sense with a bit of caution you could end up with a more
secure NixOS system that fits your needs.</p>
</blockquote>
<blockquote>
<p>Much of this guide draws inspiration or recommendations from the well-known
<a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html">Linux Hardening Guide</a>
by Madaidan's Insecurities. Madaidan’s work is widely regarded in technical
and security circles as one of the most comprehensive and rigorously
researched sources on practical Linux security, frequently cited for its depth
and actionable advice. For example, much of the original basis for hardening
for <a href="https://github.com/cynicsketch/nix-mineral">nix-mineral</a> came from this
guide as well. This can be a starting point but shouldn't be blindly followed
either, always do your own research, things change frequently.</p>
</blockquote>
<p>For an article with apposing perspectives, see
<a href="https://chyrp.cgps.ch/en/debunking-madaidans-insecurities/">debunking-madaidans-insecurities</a>.
We can learn from both and hopefully find something in between that is closer to
the truth.</p>
<blockquote>
<p>❗ <strong>Note on SELinux and AppArmor</strong>: While NixOS can provide a high degree of
security through its immutable and declarative nature, it's important to
understand the limitations regarding Mandatory Access Control (MAC)
frameworks. Neither SELinux nor AppArmor are fully supported or widely used in
the NixOS ecosystem. You can do a lot to secure NixOS but if anonymity and
isolation are paramount, I recommend booting into a
<a href="https://tails.net/">Tails USB stick</a>. Or using
<a href="https://www.whonix.org/">Whonix</a>.</p>
</blockquote>
<p>☝️ The unique file structure of NixOS, particularly the immutable <code>/nix/store</code>,
makes it difficult to implement and manage the file-labeling mechanisms that
these frameworks rely on. There are ongoing community efforts to improve
support, but as of now, they are considered experimental and not a standard part
of a typical NixOS configuration. For an immutable distro that implements
SELinux by default at a system level as well as many other hardening techniques,
see <a href="https://secureblue.dev/">Fedora secureblue</a>.</p>
<p>Containers and VMs are beyond the scope of this chapter but can also enhance
security and sandboxing if configured correctly. See
<a href="https://saylesss88.github.io/nix/kvm.html">Running NixOS in a VM</a> for more
details on running NixOS in a Secureblue VM for additional security.</p>
<p>It's crucial to <strong>document every change</strong> you make. By creating smaller,
feature-complete commits, each with a descriptive message, you're building a
clear history. This approach makes it far simpler to revert a breaking change
and quickly identify what went wrong. Over time, this discipline allows you to
create security-focused checklists and ensure all angles are covered, building a
more robust and secure system.</p>
<p>Check out the
<a href="https://saylesss88.github.io/nix/index.html">Hardening NixOS Baseline Hardening README</a>
for baseline hardening recommendations and best practices.</p>
<p>There is something to be said about the window manager you use. GNOME, KDE
Plasma, and Sway secure privileged Wayland protocols like screencopy. This means
that on environments outside of GNOME, KDE, and Sway, applications can access
screen content of the entire desktop. This implicitly includes the content of
other applications. It's primarily for this reason that Silverblue, Kinoite, and
Sericea images are recommended. COSMIC has plans to fix this.
--<a href="https://secureblue.dev/images">secureblue Images</a></p>
<p>For example, to disable Xwayland for sway on home-manager you would add:</p>
<pre><code class="language-nix">wayland.windowManager.sway = {
  enable = true;
  extraConfig = ''
    xwayland disable
  '';
}
</code></pre>
<ul>
<li>You may get an error saying you're only able to disable xwayland at boot,
restart your system and you'll be all set.</li>
</ul>
<p>You can explicitly disable <code>xdg-desktop-portal-wlr</code> with systemd in your
<code>configuration.nix</code> like this:</p>
<pre><code class="language-nix"># configuration.nix
systemd.user.services."xdg-desktop-portal-wlr" = {
  enable = false;  # Masks/stops the wlr service
};
</code></pre>
<h2 id="minimal-installation-with-luks"><a class="header" href="#minimal-installation-with-luks">Minimal Installation with LUKS</a></h2>
<p>Begin with NixOS’s minimal installation image. This gives you a base system with
only essential tools and no extras that could introduce vulnerabilities.</p>
<h2 id="manual-encrypted-install-following-the-manual"><a class="header" href="#manual-encrypted-install-following-the-manual">Manual Encrypted Install Following the Manual</a></h2>
<p>Encryption is the process of using an algorithm to scramble plaintext data into
ciphertext, making it unreadable except to a person who has the key to decrypt
it.</p>
<p><strong>Data at rest</strong> is data in storage, such as a computer's or a servers hard
disk.</p>
<p><strong>Data at rest encryption</strong> (typically hard disk encryption), secures the
documents, directories, and files behind an encryption key. Encrypting your data
at rest prevents data leakage, physical theft, unauthorized access, and more as
long as the key management scheme isn't compromised.</p>
<ul>
<li>
<p><a href="https://channels.nixos.org/nixos-25.05/latest-nixos-minimal-x86_64-linux.iso">Minimal ISO Download (64-bit Intel/AMD)</a></p>
</li>
<li>
<p><a href="https://nixos.org/manual/nixos/stable/#sec-installation">NixOS Manual Installation</a></p>
</li>
<li>
<p><a href="https://wiki.nixos.org/wiki/Full_Disk_Encryption">NixOS Wiki Full Disk Encryption</a></p>
</li>
<li>
<p>The
<a href="https://www.nsa.gov/Press-Room/Press-Releases-Statements/Press-Release-View/Article/3498776/post-quantum-cryptography-cisa-nist-and-nsa-recommend-how-to-prepare-now/">NSA, CISA, and NIST warn</a>
that nation-state actors are likely stockpiling encrypted data now, preparing
for a future when quantum computers could break today’s most widely used
encryption algorithms. Sensitive data with long-term secrecy needs is
especially at risk.</p>
</li>
<li>
<p>This is a wake-up call to use the strongest encryption available today and to
plan early for post-quantum security.</p>
</li>
<li>
<p><a href="https://www.nist.gov/news-events/news/2024/08/nist-releases-first-3-finalized-post-quantum-encryption-standards">NIST First 3 Post-Quantum Encryption Standards</a>
Organizations and individuals should prepare to migrate cryptographic systems
to these new standards as soon as practical.</p>
</li>
<li>
<p>They chose
<a href="https://www.nist.gov/news-events/news/2022/07/nist-announces-first-four-quantum-resistant-cryptographic-algorithms">Four Quantum-Resistant Cryptographic Algorithms</a>
warning that public-key cryptography is especially vulnerable and widely used
to protect digital information.</p>
</li>
</ul>
<h2 id="guided-encrypted-btrfs-subvol-install-using-disko"><a class="header" href="#guided-encrypted-btrfs-subvol-install-using-disko">Guided Encrypted BTRFS Subvol install using disko</a></h2>
<p>Use LUKS encryption to protect your data at rest, the following guide is a
minimal disko encrypted installation:
<a href="https://saylesss88.github.io/installation/enc/enc_install.html">Encrypted Install</a></p>
<h2 id="installing-software"><a class="header" href="#installing-software">Installing Software</a></h2>
<p>Most users don't fully understand that running any software without sandboxing
gives it unrestricted access to their user data and system resources. There is a
widespread lack of awareness that Linux apps generally run with the full
permissions of the user. It's easy to overlook the fact that "trusted source"
doesn't mean "safe to run uncontained".</p>
<p>I suggest that you try using an editor from Flatpak so you can see and
experience running an editor in a sandbox. It felt weird to me because I had
gotten used to being able to see all my files with Yazi or do insecure
customizations to my editor unfettered. With Flatseal, you can see which
permissions the app ships with and adjust them accordingly.</p>
<p><strong>nixpkgs-unstable Security Overview</strong></p>
<ul>
<li>
<p><code>nixpkgs-unstable</code> tracks the master branch of the Nixpkgs repo and is
constantly updated.</p>
</li>
<li>
<p>This branch gets security updates faster, patching vulnerabilities faster.</p>
</li>
<li>
<p>Since it's a rolling-release, packages are less thoroughly tested. This
increases the risk of new, undiscovered bugs or regressions. Some of which
could have security implications.</p>
</li>
<li>
<p>The packages are generally the most recent upstream versions, which is
important for security-sensitive software like browsers and kernels, as old
versions may have publicly known, unpatched vulnerabilities.</p>
</li>
<li>
<p>As the name states, <code>nixpkgs-unstable</code> is less stable and an update is more
likely to cause your system to fail to build due to breaking changes in Nix
expressions.</p>
</li>
</ul>
<hr />
<p><strong>Stable (e.g., <code>nixos-24.05</code>) Security Overview</strong></p>
<p>Stable Nixpkgs channels correspond to point release (e.g., released every 6
months) and are supported for a limited period (typically one month past the
next release).</p>
<ul>
<li>
<p>Stable channels generally only receive conservative bug and security fixes.
Major version bumps for features are typically avoided to maintain "stability
against deliberate changes", which means you won't get the latest upstream
features or general bug fixes.</p>
</li>
<li>
<p>While critical security updates are backported quickly, updates for less
critical packages may be slower or not happen at all if they require a
significant refactoring or version bump.</p>
</li>
<li>
<p>Stable channels are generally more stable, meaning updates are less likely to
introduce breaking changes to your configuration or system environment.</p>
</li>
<li>
<p>Many packages will be older versions. If a critical security vulnerability
requires a major upstream version update (which is often avoided in a stable
channel), the maintainers must backport the patch, a process which can
introduce its own set of risks and delays.</p>
</li>
</ul>
<p><strong>What should you use?</strong></p>
<p>The primary security trade-off is between <strong>patching speed for known
vulnerabilities</strong> and <strong>stability/exposure to new bugs</strong>:</p>
<ul>
<li>
<p>Choose <code>unstable</code> if you prioritize getting the latest security fixes
(especially for end-user apps like browsers) as soon as they are available
upstream, accepting a higher risk of non-security-related system breakage or
new, undiscovered bugs.</p>
</li>
<li>
<p>Choose <code>stable</code> if you prioritize system predictability and stability, relying
on dedicated backports for critical vulnerabilities, while accepting that
non-critical security and bug fixes will be delayed or absent until the next
major release.</p>
</li>
</ul>
<p>A common hybrid approach is to use the <code>stable</code> channel as the base for the OS
and selectively pin specific packages from <code>unstable</code> to ensure they receive
rapid security updates.</p>
<p>With flakes it's easy to add both <code>stable</code> and <code>unstable</code> as flake inputs and
access each with some simple logic.</p>
<p>For example:</p>
<details>
<summary> Click to expand
<h2 id="impermanence"><a class="header" href="#impermanence">Impermanence</a></h2>
<p>Impermanence, especially when using a <code>tmpfs</code> as the root filesystem, provides
several significant security benefits. The core principle is that impermanence
defeats persistence, a fundamental goal for any attacker.</p>
<p>When you use a root-as-tmpfs setup on NixOS, the boot process loads the entire
operating system from the read-only Nix store into a <code>tmpfs</code> in RAM. The mutable
directories, such as <code>/etc</code> and <code>/var</code>, are then created on this RAM disk. When
the system is shut down, the <code>tmpfs</code> is wiped, leaving the on-disk storage
untouched and secure.</p>
<p>This means you get a fresh, secure boot every time, making it much harder for an
attacker to maintain a presence on your system.</p>
<ul>
<li>
<p><a href="https://grahamc.com/blog/erase-your-darlings/">Erase your Darlings (ZFS)</a></p>
</li>
<li>
<p><a href="https://saylesss88.github.io/installation/enc/encrypted_impermanence.html">Encrypted BTRFS Impermanence Guide</a>
Only follow this guide if you also followed the encrypted disko install,
impermanence is designed to be destructive and needs to match your config
exactly.</p>
</li>
</ul>
<h2 id="replace-timesyncd-with-a-chron-job-that-enables-network-time-security-nts"><a class="header" href="#replace-timesyncd-with-a-chron-job-that-enables-network-time-security-nts">Replace timesyncd with a chron job that enables Network Time Security (NTS)</a></h2>
<p>This is implementing the GrapheneOS/secureblue NTS chrony settings to NixOS:</p>
<pre><code class="language-nix"># configuration.nix  (or any module you import)
{ config, pkgs, ... }:

let
  # ----------------------------------------------------------------------
  # How often the timer should run (change to "hourly", "*:0/30", etc.)
  # ----------------------------------------------------------------------
  chronyNtsTimer = "daily";

  # ----------------------------------------------------------------------
  # The hardened Chrony configuration (the secureblue one)
  # ----------------------------------------------------------------------
  chronyConf = pkgs.writeText "chrony.conf" ''
    # Copyright © 2014-2025 GrapheneOS
    # (full license text omitted for brevity – it will be preserved)

    server time.cloudflare.com iburst nts
    server ntppool1.time.nl iburst nts
    server nts.netnod.se iburst nts
    server ptbtime1.ptb.de iburst nts
    server time.dfm.dk iburst nts
    server time.cifelli.xyz iburst nts
    minsources 3
    authselectmode require
    # EF
    dscp 46
    driftfile /var/lib/chrony/drift
    dumpdir /var/lib/chrony
    ntsdumpdir /var/lib/chrony
    leapsectz /usr/share/zoneinfo/leap-seconds.list
    makestep 1.0 3
    rtconutc
    rtcsync
    cmdport 0
    noclientlog
  '';

  # ----------------------------------------------------------------------
  # Service that writes the config and reloads Chrony
  # ----------------------------------------------------------------------
  chronyNtsService = {
    description = "Write hardened Chrony config with NTS and reload";
    serviceConfig = {
      Type = "oneshot";
      ExecStartPre = pkgs.writeShellScript "write-chrony-nts.sh" ''
        set -euo pipefail

        # Ensure directories exist
        mkdir -p /var/lib/chrony /etc

        # Atomically write the config
        ${pkgs.coreutils}/bin/install -m 0644 ${chronyConf} /etc/chrony.conf

        # Reload (or restart if reload fails)
        ${pkgs.systemd}/bin/systemctl try-reload-or-restart chronyd
      '';
    };
    wantedBy = [ "multi-user.target" ];
  };

  # ----------------------------------------------------------------------
  # Timer that triggers the service
  # ----------------------------------------------------------------------
  chronyNtsTimerConfig = {
    description = "Timer to keep hardened Chrony+NTS config applied";
    wantedBy = [ "timers.target" ];
    timerConfig = {
      OnCalendar = chronyNtsTimer;
      Persistent = true;          # run missed jobs after reboot
      RandomizedDelaySec = "5m";  # jitter
    };
  };
in
{
  # ----------------------------------------------------------------------
  # 1. Enable Chrony (disable systemd-timesyncd)
  # ----------------------------------------------------------------------
  services.chrony.enable = true;
  services.timesyncd.enable = false;   # we’re using Chrony

  # ----------------------------------------------------------------------
  # 2. Install timer + service
  # ----------------------------------------------------------------------
  systemd.timers."chrony-nts" = chronyNtsTimerConfig;
  systemd.services."chrony-nts" = chronyNtsService;

  # ----------------------------------------------------------------------
  # 3. Run once at boot (before the timer)
  # ----------------------------------------------------------------------
  systemd.services."chrony-nts-at-boot" = chronyNtsService // {
    description = "Apply hardened Chrony+NTS config at boot";
    after = [ "chronyd.service" ];
    wantedBy = [ "multi-user.target" ];
  };
}
</code></pre>
<h2 id="secure-boot"><a class="header" href="#secure-boot">Secure Boot</a></h2>
<!-- ![Virus](../images/virus1.png) -->
<p>Enable a UEFI password or Administrator password where it requires
authentication in order to access the UEFI/BIOS.</p>
<p>Secure Boot helps ensure only signed, trusted kernels and bootloaders are
executed at startup.</p>
<p>Useful Resources:</p>
<details>
<summary> ✔️ Click to Expand Secure Boot Resources </summary>
<ul>
<li>
<p><a href="https://0pointer.net/blog/authenticated-boot-and-disk-encryption-on-linux.html">The Strange State of Authenticated Boot and Encryption</a></p>
</li>
<li>
<p><a href="https://wiki.nixos.org/wiki/Secure_Boot">NixOS Wiki Secure Boot</a></p>
</li>
<li>
<p><a href="https://github.com/nix-community/lanzaboote">lanzaboote repo</a></p>
</li>
</ul>
</details>
<p>Practical Lanzaboote Secure Boot setup for NixOS:
<a href="https://saylesss88.github.io/installation/enc/lanzaboote.html">Guide:Secure Boot on NixOS with Lanzaboote</a></p>
<h3 id="the-kernel"><a class="header" href="#the-kernel">The Kernel</a></h3>
<p>Given the kernel's central role, it's a frequent target for malicious actors,
making robust hardening essential.</p>
<p>NixOS provides a <code>hardened</code> profile that applies a set of security-focused
kernel and system configurations.</p>
<p>For flakes, you could do something like the following in your
<code>configuration.nix</code> or equivalent to import <code>hardened.nix</code> and enable
<code>profiles.hardened</code>:</p>
<pre><code class="language-nix"># configuration.nix
{ pkgs, inputs, ... }: let
   modulesPath = "${inputs.nixpkgs}/nixos/modules";

in {
  imports = [ "${modulesPath}/profiles/hardened.nix" ];

}
</code></pre>
<ul>
<li>
<p>There is a proposal to remove it completely that has gained ground, the
following thread discusses why:
<a href="https://discourse.nixos.org/t/proposal-to-deprecate-the-hardened-profile/63081">Discourse Thread</a></p>
</li>
<li>
<p><a href="https://github.com/NixOS/nixpkgs/pull/383438">PR #383438</a> Proposed removal
PR.</p>
</li>
<li>
<p>Check
<a href="https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/profiles/hardened.nix">hardened.nix</a>
to see exactly what adding it enables to avoid duplicates and conflicts moving
on. I included this for completeness, the choice is yours if you want to use
it or not.</p>
</li>
</ul>
<h2 id="choosing-your-kernel"><a class="header" href="#choosing-your-kernel">Choosing your Kernel</a></h2>
<p>See which kernel you're currently using with:</p>
<pre><code class="language-bash"># show the kernel release
uname -r
# show kernel version, hostname, and architecture
uname -a
</code></pre>
<p>Show the configuration of your current kernel:</p>
<pre><code class="language-bash">zcat /proc/config.gz
# ...snip...
#
# Compression
#
CONFIG_CRYPTO_DEFLATE=m
CONFIG_CRYPTO_LZO=y
CONFIG_CRYPTO_842=m
CONFIG_CRYPTO_LZ4=m
CONFIG_CRYPTO_LZ4HC=m
CONFIG_CRYPTO_ZSTD=y
# end of Compression
# ...snip...
</code></pre>
<p>The <a href="https://nixos.org/manual/nixos/stable/#sec-kernel-config">NixOS Manual</a>
states that the default Linux kernel configuration should be fine for most
users.</p>
<p>The Linux kernel is typically released under two forms: stable and long-term
support (LTS). Choosing either has consequences, do your research.
<a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html#stable-vs-lts">Stable vs. LTS kernels</a></p>
<ul>
<li><a href="https://www.kernel.org/category/releases.html">The Linux Kernel Archives Active kernel releases</a></li>
</ul>
<p><strong>OR</strong>, you can choose the hardened kernel for a kernel that prioritizes
security over everything else.</p>
<h3 id="the-hardened-kernel"><a class="header" href="#the-hardened-kernel">The Hardened Kernel</a></h3>
<blockquote>
<p>NOTE: Expect breakage when using the hardened kernel. <code>linux-hardened</code>
completely disables
<a href="https://secureblue.dev/articles/userns">unprivileged user namespaces</a>, which
are required for Flatpak, chromium-based browsers, and more.</p>
</blockquote>
<p>The <code>linuxPackages_latest_hardened</code> attribute has been deprecated. If you want
to use a hardened kernel, it is now recommended to use <code>linux_hardened</code>, which
is aliased to <code>linux_default.kernel</code>.</p>
<p>You can find the latest available hardened kernel packages by searching
<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/top-level/linux-kernels.nix">pkgs/top-level/linux-kernels.nix</a>.
It is recommended to use <code>linux_hardened</code> without specifying a version, such as:</p>
<pre><code class="language-nix">boot.kernelPackages = pkgs.linuxPackages_hardened;
</code></pre>
<p><code>linux_hardened</code> is aliased to the <code>linux_default.kernel</code>.</p>
<p>Note that this not only replaces the kernel, but also packages that are specific
to the kernel version, such as NVIDIA video drivers. This also removes your
ability to use the <code>.extend</code> kernel attribute, they are only available to
<em>kernel package sets</em> (e.g., <code>linuxPackages_hardened</code>)</p>
<ul>
<li>If you decide to use this, read further before rebuilding.</li>
</ul>
<p>You can inspect
<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/os-specific/linux/kernel/hardened/patches.json">nixpkgs/pkgs/os-specific/linux/kernel/hardened/patches.json</a>
to see the metadata of the patches that are applied. You can then follow the
links in the <code>.json</code> file to see the patch diffs.</p>
<h3 id="sysctl"><a class="header" href="#sysctl">sysctl</a></h3>
<p>A tool for checking the security hardening options of the Linux kernel:</p>
<pre><code class="language-nix">environment.systemPackages = [ pkgs.kernel-hardening-checker ];
</code></pre>
<p><code>sysctl</code> is a tool that allows you to view or modify kernel settings and
enable/disable different features.</p>
<p>Check all <code>sysctl</code> parameters against the <code>kernel-hardening-checker</code>
recommendations:</p>
<pre><code class="language-bash">sudo sysctl -a &gt; params.txt
kernel-hardening-checker -l /proc/cmdline -c /proc/config.gz -s ./params.txt
</code></pre>
<p>Check the value of a specific parameter:</p>
<pre><code class="language-bash">sudo sysctl -a | grep "kernel.kptr_restrict"
# Output:
kernel.kptr_restrict = 2
</code></pre>
<p>Check Active Linux Security Modules:</p>
<pre><code class="language-bash">cat /sys/kernel/security/lsm
# Output:
File: /sys/kernel/security/lsm
capability,landlock,yama,bpf,apparmor
</code></pre>
<p>Check Kernel Configuration Options:</p>
<pre><code class="language-bash">zcat /proc/config.gz | grep CONFIG_SECURITY_SELINUX
zcat /proc/config.gz | grep CONFIG_HARDENED_USERCOPY
zcat /proc/config.gz | grep CONFIG_STACKPROTECTOR
</code></pre>
<p>Since it is difficult to see exactly what enabling the hardened_kernel does.
Before rebuilding, you could do something like this to see exactly what is
added:</p>
<pre><code class="language-bash">sudo sysctl -a &gt; before.txt
</code></pre>
<p>And after the rebuild:</p>
<pre><code class="language-bash">sudo sysctl -a &gt; after.txt
</code></pre>
<p>And finally run a <code>diff</code> on them:</p>
<pre><code class="language-bash">diff before.txt after.txt
</code></pre>
<p>You can also diff against <code>after.txt</code> for future changes to avoid duplicates,
this seems easier to me than trying to parse through the patches.</p>
<h2 id="kernel-security-settings"><a class="header" href="#kernel-security-settings">Kernel Security Settings</a></h2>
<pre><code class="language-nix">security = {
      protectKernelImage = true;
      lockKernelModules = false; # this breaks iptables, wireguard, and virtd

      # force-enable the Page Table Isolation (PTI) Linux kernel feature
      forcePageTableIsolation = true;

      # User namespaces are required for sandboxing.
      # this means you cannot set `"user.max_user_namespaces" = 0;` in sysctl
      allowUserNamespaces = true;

      # Disable unprivileged user namespaces, unless containers are enabled
      unprivilegedUsernsClone = config.virtualisation.containers.enable;
      allowSimultaneousMultithreading = true;
}
</code></pre>
<h2 id="further-hardening-with-sysctl"><a class="header" href="#further-hardening-with-sysctl">Further Hardening with sysctl</a></h2>
<p><code>sysctl</code> hardening settings further reinforce kernel-level protections. The
hardened kernel includes security patches and stricter defaults, but it doesn't
cover all runtime tunables. Refer to the above commands to get a diff of the
changes.</p>
<p><a href="https://nixos.org/manual/nixos/stable/options#opt-boot.kernel.sysctl">boot.kernel.sysctl</a>:
Runtime parameters of the Linux kernel, as set by sysctl(8). Note that the
sysctl parameters names must be enclosed in quotes. Values may be a string,
integer, boolean, or null.</p>
<p>Check what each setting does <a href="https://sysctl-explorer.net/">sysctl-explorer</a></p>
<p>Refer to
<a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html#sysctl-kernel">madadaidans-insecurities#sysctl-kernel</a>
for the following settings and their explainations.</p>
<p>Also see the
<a href="https://kspp.github.io/Recommended_Settings#sysctls">Kernel Self Protection Projects sysctls</a></p>
<pre><code class="language-nix">  boot.kernel.sysctl = {
    "fs.suid_dumpable" = 0;
    # prevent pointer leaks
    "kernel.kptr_restrict" = 2;
    # restrict kernel log to CAP_SYSLOG capability
    "kernel.dmesg_restrict" = 1;
    # Note: certian container runtimes or browser sandboxes might rely on the following
    # restrict eBPF to the CAP_BPF capability
    "kernel.unprivileged_bpf_disabled" = 1;
    # should be enabled along with bpf above
    # "net.core.bpf_jit_harden" = 2;
    # restrict loading TTY line disciplines to the CAP_SYS_MODULE
    "dev.tty.ldisk_autoload" = 0;
    # prevent exploit of use-after-free flaws
    "vm.unprivileged_userfaultfd" = 0;
    # kexec is used to boot another kernel during runtime and can be abused
    "kernel.kexec_load_disabled" = 1;
    # Kernel self-protection
    # SysRq exposes a lot of potentially dangerous debugging functionality to unprivileged users
    # 4 makes it so a user can only use the secure attention key. A value of 0 would disable completely
    "kernel.sysrq" = 4;
    # disable unprivileged user namespaces, Note: Docker, NH, and other apps may need this
    # "kernel.unprivileged_userns_clone" = 0; # commented out because it makes NH and other programs fail
    # restrict all usage of performance events to the CAP_PERFMON capability
    "kernel.perf_event_paranoid" = 3;

    # Network
    # protect against SYN flood attacks (denial of service attack)
    "net.ipv4.tcp_syncookies" = 1;
    # protection against TIME-WAIT assassination
    "net.ipv4.tcp_rfc1337" = 1;
    # enable source validation of packets received (prevents IP spoofing)
    "net.ipv4.conf.default.rp_filter" = 1;
    "net.ipv4.conf.all.rp_filter" = 1;

    "net.ipv4.conf.all.accept_redirects" = 0;
    "net.ipv4.conf.default.accept_redirects" = 0;
    "net.ipv4.conf.all.secure_redirects" = 0;
    "net.ipv4.conf.default.secure_redirects" = 0;
    # Protect against IP spoofing
    "net.ipv6.conf.all.accept_redirects" = 0;
    "net.ipv6.conf.default.accept_redirects" = 0;
    "net.ipv4.conf.all.send_redirects" = 0;
    "net.ipv4.conf.default.send_redirects" = 0;

    # prevent man-in-the-middle attacks
    "net.ipv4.icmp_echo_ignore_all" = 1;

    # ignore ICMP request, helps avoid Smurf attacks
    "net.ipv4.conf.all.forwarding" = 0;
    "net.ipv4.conf.default.accept_source_route" = 0;
    "net.ipv4.conf.all.accept_source_route" = 0;
    "net.ipv6.conf.all.accept_source_route" = 0;
    "net.ipv6.conf.default.accept_source_route" = 0;
    # Reverse path filtering causes the kernel to do source validation of
    "net.ipv6.conf.all.forwarding" = 0;
    "net.ipv6.conf.all.accept_ra" = 0;
    "net.ipv6.conf.default.accept_ra" = 0;

    ## TCP hardening
    # Prevent bogus ICMP errors from filling up logs.
    "net.ipv4.icmp_ignore_bogus_error_responses" = 1;

    # Disable TCP SACK
    "net.ipv4.tcp_sack" = 0;
    "net.ipv4.tcp_dsack" = 0;
    "net.ipv4.tcp_fack" = 0;

    # Userspace
    # restrict usage of ptrace
    "kernel.yama.ptrace_scope" = 2;

    # ASLR memory protection (64-bit systems)
    "vm.mmap_rnd_bits" = 32;
    "vm.mmap_rnd_compat_bits" = 16;

    # only permit symlinks to be followed when outside of a world-writable sticky directory
    "fs.protected_symlinks" = 1;
    "fs.protected_hardlinks" = 1;
    # Prevent creating files in potentially attacker-controlled environments
    "fs.protected_fifos" = 2;
    "fs.protected_regular" = 2;

    # Randomize memory
    "kernel.randomize_va_space" = 2;
    # Exec Shield (Stack protection)
    "kernel.exec-shield" = 1;

    ## TCP optimization
    # TCP Fast Open is a TCP extension that reduces network latency by packing
    # data in the sender’s initial TCP SYN. Setting 3 = enable TCP Fast Open for
    # both incoming and outgoing connections:
    "net.ipv4.tcp_fastopen" = 3;
    # Bufferbloat mitigations + slight improvement in throughput &amp; latency
    "net.ipv4.tcp_congestion_control" = "bbr";
    "net.core.default_qdisc" = "cake";
  };
</code></pre>
<blockquote>
<p>❗ Note: The above settings are fairly aggressive and can break common
programs, read the comment warnings.</p>
</blockquote>
<h2 id="hardening-boot-parameters"><a class="header" href="#hardening-boot-parameters">Hardening Boot Parameters</a></h2>
<p><code>boot.kernelParams</code> can be used to set additional kernel command line arguments
at boot time. It can only be used for built-in modules.</p>
<p>You can find the following settings in the above guide in the
<a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html#boot-parameters">Boot parameters section</a></p>
<pre><code class="language-nix"># boot.nix
      boot.kernelParams = [
        # make it harder to influence slab cache layout
        "slab_nomerge"
        # enables zeroing of memory during allocation and free time
        # helps mitigate use-after-free vulnerabilaties
        "init_on_alloc=1"
        "init_on_free=1"
        # randomizes page allocator freelist, improving security by
        # making page allocations less predictable
        "page_alloc.shuffel=1"
        # enables Kernel Page Table Isolation, which mitigates Meltdown and
        # prevents some KASLR bypasses
        "pti=on"
        # randomizes the kernel stack offset on each syscall
        # making attacks that rely on a deterministic stack layout difficult
        "randomize_kstack_offset=on"
        # disables vsyscalls, they've been replaced with vDSO
        "vsyscall=none"
        # disables debugfs, which exposes sensitive info about the kernel
        "debugfs=off"
        # certain exploits cause an "oops", this makes the kernel panic if an "oops" occurs
        "oops=panic"
        # only alows kernel modules that have been signed with a valid key to be loaded
        # making it harder to load malicious kernel modules
        # can make VirtualBox or Nvidia drivers unusable
        "module.sig_enforce=1"
        # prevents user space code excalation
        "lockdown=confidentiality"
        # "rd.udev.log_level=3"
        # "udev.log_priority=3"
      ];
</code></pre>
<p>This is a thoughtful start to hardening boot parameters, there are more
recommendations in the guide.</p>
<p>Kernel modules for hardware devices are generally loaded automatically by
<code>udev</code>. You can force a module to be loaded via <code>boot.kernelModules</code>.</p>
<hr />
<p><strong>Blacklisting Kernel Parameters</strong></p>
<p>Blacklisting unused kernel modules reduces the attack surface.</p>
<p><a href="https://nixos.org/manual/nixos/stable/options#opt-boot.blacklistedKernelModules">boot.blacklistedKernelModules</a>:
List of names of kernel modules that should not be loaded automatically by the
hardware probing code.</p>
<p>You can find the following settings in the
<a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html#kasr-kernel-modules">Blacklisting Kernel Modules Section</a></p>
<pre><code class="language-nix">      boot.blacklistedKernelModules = [
        # Obscure networking protocols
        "dccp"   # Datagram Congestion Control Protocol
        "sctp"  # Stream Control Transmission Protocol
        "rds"  # Reliable Datagram Sockets
        "tipc"  # Transparent Inter-Process Communication
        "n-hdlc" # High-level Data Link Control
        "ax25"  # Amateur X.25
        "netrom"  # NetRom
        "x25"     # X.25
        "rose"
        "decnet"
        "econet"
        "af_802154"  # IEEE 802.15.4
        "ipx"  # Internetwork Packet Exchange
        "appletalk"
        "psnap"  # SubnetworkAccess Protocol
        "p8023"  # Novell raw IEE 802.3
        "p8022"  # IEE 802.3
        "can"   # Controller Area Network
        "atm"
        # Various rare filesystems
        "cramfs"
        "freevxfs"
        "jffs2"
        "hfs"
        "hfsplus"
        "udf"

        # "squashfs"  # compressed read-only file system used for Live CDs
        # "cifs"  # cmb (Common Internet File System)
        # "nfs"  # Network File System
        # "nfsv3"
        # "nfsv4"
        # "ksmbd"  # SMB3 Kernel Server
        # "gfs2"  # Global File System 2
        # vivid driver is only useful for testing purposes and has been the
        # cause of privilege escalation vulnerabilities
        # "vivid"
      ];
</code></pre>
<p>As with the <code>kernelParameters</code> above, there are more suggestions in the guide, I
have used the above parameters along with the commented out ones and had no
issues.</p>
<p>Also see
<a href="https://github.com/secureblue/secureblue/blob/live/files/system/etc/modprobe.d/blacklist.conf">SecureBlue's blacklist.conf</a>
for more ideas.</p>
<hr />
<h2 id="hardened-memory-allocator"><a class="header" href="#hardened-memory-allocator">Hardened Memory Allocator</a></h2>
<blockquote>
<p>NOTE: There is a performance cost to enabling a hardened memory allocator, and
some apps will not work without a workaround such as Firefox, Thunderbird,
Torbrowser, LibreWolf, and ZenBrowser to name a few.</p>
</blockquote>
<p>The grapheneOS <code>hardened_malloc</code> is available for NixOS in two variants, add
either to your <code>configuration.nix</code> or equivalent to apply them:</p>
<ol>
<li>
<p><code>environment.memoryAllocator.provider = "graphene-hardened";</code>: This is the
default configuration template that has all normal optional security features
enabled. It's aggressive, you can expect app breakage and a performance cost.</p>
</li>
<li>
<p><code>environment.memoryAllocator.provider = "graphene-hardened-light";</code>: The
light template disables the slap quarantines, write after free check, slot
randomization and raises the guard slab interval from 1 to 8 but leaves
zero-on-free and slab canaries enabled. This version has solid performance
and is still far more secure than the standard allocator.</p>
</li>
</ol>
<p><code>libhardened_malloc.so</code> is typically installed to
<code>/usr/local/lib/libhardened_malloc.so</code> and referenced from <code>/etc/ld.so.preload</code>.</p>
<ul>
<li>
<p><a href="https://nixos.org/manual/nixos/stable/options#opt-environment.memoryAllocator.provider">NixOS Manual memoryAllocator</a></p>
</li>
<li>
<p><a href="https://github.com/GrapheneOS/hardened_malloc?tab=readme-ov-file#traditional-linux-based-operating-systems">GrapheneOS hardened_malloc</a></p>
</li>
<li>
<p><a href="https://github.com/secureblue/secureblue/issues/193#issuecomment-1953323680">GrapheneOS/secureblue discussion on hardened_malloc issues</a></p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">ld.so man page</a></p>
</li>
</ul>
<h2 id="hardening-systemd"><a class="header" href="#hardening-systemd">Hardening Systemd</a></h2>
<!-- ![Hacker](../images/hacker.png) -->
<p><code>systemd</code> is the core "init system" and service manager that controls how
services, daemons, and basic system processes are started, stopped and
supervised on modern Linux distributions, including NixOS. It provides a suite
of basic building blocks for a Linux system as well as a system and service
manager that runs as <code>PID 1</code> and starts the rest of the system.</p>
<p>Because it launches and supervises almost all system services, hardening systemd
means raising the baseline security of your entire system.</p>
<p><code>dbus-broker</code> is generally considered more secure and robust but isn't the
default as of yet. To set <code>dbus-broker</code> as the default:</p>
<pre><code class="language-nix">  users.groups.netdev = {};
  services = {
    dbus.implementation = "broker";
    logrotate.enable = true;
    journald = {
      storage = "volatile"; # Store logs in memory
      upload.enable = false; # Disable remote log upload (the default)
      extraConfig = ''
        SystemMaxUse=500M
        SystemMaxFileSize=50M
      '';
    };
  };
</code></pre>
<ul>
<li>
<p><code>dbus-broker</code> is more resilient to resource exhaustion attacks and integrates
better with Linux security features.</p>
</li>
<li>
<p><a href="https://dvdhrm.github.io/rethinking-the-dbus-message-bus/">Rethinking-the-dbus-message-bus</a></p>
</li>
<li>
<p>Setting <code>storage = "volatile"</code> tells journald to keep log data only in memory.
There is a tradeoff though, If you need long-term auditing or troubleshooting
after a reboot, this will not preserve system logs.</p>
</li>
<li>
<p><code>upload.enable</code> is for forwarding log messages to remote servers, setting this
to false prevents accidental leaks of potentially sensitive or internal system
information.</p>
</li>
<li>
<p>Enabling <code>logrotate</code> prevents your disk from filling with excessive
<strong>legacy/service</strong> log files. These are the classic plain-text logs.</p>
</li>
<li>
<p>Systemd uses <code>journald</code> which stores logs in a binary format</p>
</li>
</ul>
<p>You can check the security status with:</p>
<pre><code class="language-bash">systemd-analyze security
# or for a detailed view of individual services security posture
systemd-analyze security NetworkManager
</code></pre>
<p>It is also recommended to disable and mask unused or vulnerable services such as
cups, geoclue, etc.</p>
<pre><code class="language-bash">sudo systemctl disable cups
sudo systemctl mask cups
# To unmask use unmask:
# sudo systemctl unmask cups
</code></pre>
<p>Further reading on systemd:</p>
<details>
<summary> ✔️ Click to Expand Systemd Resources </summary>
<ul>
<li>
<p><a href="https://systemd.io/">systemd.io</a></p>
</li>
<li>
<p><a href="https://0pointer.de/blog/projects/systemd.html">Rethinking PID 1</a></p>
</li>
<li>
<p><a href="https://0pointer.de/blog/projects/the-biggest-myths.html">Biggest Myths about Systemd</a></p>
</li>
</ul>
</details>
<p>The following is a repo containing many of the Systemd hardening settings in
NixOS format:</p>
<p><a href="https://github.com/wallago/nix-system-services-hardened">nix-system-services-hardened</a></p>
<p>For example, to harden bluetooth you could add the following to your
<code>configuration.nix</code> or equivalent:</p>
<pre><code class="language-nix">systemd.services = {
      bluetooth.serviceConfig = {
      ProtectKernelTunables = lib.mkDefault true;
      ProtectKernelModules = lib.mkDefault true;
      ProtectKernelLogs = lib.mkDefault true;
      ProtectHostname = true;
      ProtectControlGroups = true;
      ProtectProc = "invisible";
      SystemCallFilter = [
        "~@obsolete"
        "~@cpu-emulation"
        "~@swap"
        "~@reboot"
        "~@mount"
      ];
      SystemCallArchitectures = "native";
    };
}
</code></pre>
<p>As you can see from above, you typically use the <code>serviceConfig</code> attribute to
harden settings for systemd services.</p>
<pre><code class="language-bash">systemd-analyze security bluetooth
→ Overall exposure level for bluetooth.service: 3.3 OK 🙂
</code></pre>
<h2 id="lynis-and-other-tools"><a class="header" href="#lynis-and-other-tools">Lynis and other tools</a></h2>
<p>Lynis is a security auditing tool for systems based on UNIX like Linux, macOS,
BSD, and others.--<a href="https://github.com/CISOfy/lynis">lynis repo</a></p>
<p><code>chkrootkit</code> was removed as it is unmaintained and archived upstream.</p>
<p>Installation:</p>
<pre><code class="language-nix">environment.systemPackages = [
pkgs.lynis
pkgs.clamav
pkgs.aide
 ];
</code></pre>
<details>
<summary> ✔️ Click to Expand AIDE Example </summary>
<p>AIDE is an intrusion detection system (IDS) that will notify us whenever it
detects that a potential intrusion has occurred. When a system is compromised,
attackers typically will try to change file permissions and escalate to the root
user account and start to modify system files, AIDE can detect this.</p>
<p>To set up AIDE on your system follow these steps:</p>
<ol>
<li>Create the <code>aide.conf</code>:</li>
</ol>
<pre><code class="language-bash">sudo mkdir -p /var/lib/aide &amp;&amp; cd /var/lib/aide/
sudo hx aide.conf
</code></pre>
<p>Add the following content to <code>/var/lib/aide/aide.conf</code>:</p>
<pre><code class="language-conf"># aide.conf
# Example configuration file for AIDE.

@@define DBDIR /var/lib/aide

# The location of the database to be read.
database_in=file:@@{DBDIR}/aide.db.gz

# The location of the database to be written.
#database_out=sql:host:port:database:login_name:passwd:table
#database_out=file:aide.db.new
database_out=file:@@{DBDIR}/aide.db.new.gz

# Whether to gzip the output to database
gzip_dbout=yes

log_level=info

report_url=file:/var/log/aide/aide.log
report_url=stdout
#report_url=stderr
#NOT IMPLEMENTED report_url=mailto:root@foo.com
#NOT IMPLEMENTED report_url=syslog:LOG_AUTH

# These are the default rules.
#
#p:      permissions
#i:      inode:
#n:      number of links
#u:      user
#g:      group
#s:      size
#b:      block count
#m:      mtime
#a:      atime
#c:      ctime
#S:      check for growing size
#md5:    md5 checksum
#sha1:   sha1 checksum
#rmd160: rmd160 checksum
#tiger:  tiger checksum
#haval:  haval checksum
#gost:   gost checksum
#crc32:  crc32 checksum
#R:      p+i+n+u+g+s+m+c+md5
#L:      p+i+n+u+g
#E:      Empty group
#&gt;:      Growing logfile p+u+g+i+n+S

# You can create custom rules like this.

NORMAL = R+b+sha512

DIR = p+i+n+u+g

# Next decide what directories/files you want in the database.

/boot   NORMAL
/bin    NORMAL
/sbin   NORMAL
/lib    NORMAL
/opt    NORMAL
/usr    NORMAL
/root   NORMAL

# Check only permissions, inode, user and group for /etc, but
# cover some important files closely.
/etc    p+i+u+g
!/etc/mtab
/etc/exports  NORMAL
/etc/fstab    NORMAL
/etc/passwd   NORMAL
/etc/group    NORMAL
/etc/gshadow  NORMAL
/etc/shadow   NORMAL

/var/log   p+n+u+g

# With AIDE's default verbosity level of 5, these would give lots of
# warnings upon tree traversal. It might change with future version.
#
#=/lost\+found    DIR
#=/home           DIR
</code></pre>
<p>Create the logfile:</p>
<pre><code class="language-bash">sudo mkdir -p /var/log/aide
sudo touch /var/log/aide/aide.log
</code></pre>
<ol start="2">
<li>Generate the initial database, this will store the checksums of all files
that it's configured to monitor. Take note of the location of the new
database, mine was <code>/etc/aide.db.new</code></li>
</ol>
<pre><code class="language-bash">sudo aide --config /var/lib/aide/aide.conf --init
</code></pre>
<ol start="3">
<li>Move the new database and remove the <code>.new</code>:</li>
</ol>
<pre><code class="language-bash">sudo mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz
</code></pre>
<pre><code class="language-bash">ls /var/lib/aide/
aide.conf   aide.db.gz
</code></pre>
<ol start="4">
<li>Check with AIDE:</li>
</ol>
<pre><code class="language-bash">sudo aide --check --config /var/lib/aide/aide.conf
Start timestamp: 2025-09-05 09:50:07 -0400 (AIDE 0.19.2)
AIDE found NO differences between database and filesystem. Looks okay!!
</code></pre>
<ol start="5">
<li>Whenever you make changes to system files, or especially after running a
system update or installing new tools, you have to rescan all files to update
their checksums in the AIDE database:</li>
</ol>
<pre><code class="language-bash">sudo aide --update --config /var/lib/aide/aide.conf
</code></pre>
<p>Unfortunately, AIDE doesn't automatically replace the old database so you have
to rename the new one again:</p>
<pre><code class="language-bash">sudo mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz
</code></pre>
<p>And finally check again:</p>
<pre><code class="language-bash">sudo aide --check --config /var/lib/aide/aide.conf
</code></pre>
<ul>
<li><a href="https://linux.die.net/man/1/aide">aide(1) man page</a></li>
</ul>
</details>
<details>
<summary> ✔️ Click to Expand clamav.nix Example </summary>
<pre><code class="language-nix">{pkgs, ...}: {
  environment.systemPackages = with pkgs; [
    clamav
  ];
  services.clamav = {
    # Enable clamd daemon
    daemon.enable = true;
    updater.enable = true;
    updater.frequency = 12; # Number of database checks per day
    scanner = {
      enable = true;
      # 4:00 AM
      interval = "*-*-* 04:00:00";
      scanDirectories = [
        "/home"
        "/var/lib"
        "/tmp"
        "/etc"
        "/var/tmp"
      ];
    };
  };
}
</code></pre>
</details>
<p>Lynis Usage:</p>
<pre><code class="language-bash">sudo lynis show commands
# Output:
Commands:
lynis audit
lynis configure
lynis generate
lynis show
lynis update
lynis upload-only

sudo lynis audit system
# Output:
  Lynis security scan details:

  Hardening index : 79 [###############     ]
  Tests performed : 234
  Plugins enabled : 0

  Components:
  - Firewall               [V]
  - Malware scanner        [V]

  Scan mode:
  Normal [V]  Forensics [ ]  Integration [ ]  Pentest [ ]

  Lynis modules:
  - Compliance status      [?]
  - Security audit         [V]
  - Vulnerability scan     [V]
</code></pre>
<ul>
<li>
<p>The "Lynis hardening index" is an overall impression on how well a system is
hardened. However, this is just an indicator on measures taken - not a
percentage of how safe a system might be. A score over 75 typically indicates
a system with more than average safety measures implemented.</p>
</li>
<li>
<p>Lynis will give you more recommendations for securing your system as well.</p>
</li>
</ul>
<p>If you use <code>clamscan</code>, create the following log file:</p>
<pre><code class="language-bash">sudo touch /var/log/clamscan.log
</code></pre>
<p>Example cron job for <code>clamav</code> &amp; <code>aide</code>:</p>
<pre><code class="language-nix">{pkgs, ...}: {
  services.cron = {
    enable = true;
    # messages.enable = true;
    systemCronJobs = [
      # Every day at 2:00 AM, run clamscan as root and append output to a log file
      "0 2 * * * root ${pkgs.clamav}/bin/clamscan -r /home &gt;&gt; /var/log/clamscan.log"
      "0 11 * * * ${pkgs.aide}/bin/aide --check --config /var/lib/aide/aide.conf"
    ];
  };
}
</code></pre>
<p>ClamAV usage:</p>
<p>You can run <code>clamav</code> manually with:</p>
<pre><code class="language-bash"># Recursive Scan:
sudo clamscan -r ~/home
</code></pre>
<blockquote>
<p>❗ NOTE: You only need either the individual <code>pkgs.clamav</code> with the cron job
<strong>OR</strong> the <code>clamd-daemon</code> module. <code>clamdscan</code> is for software integration and
uses a different user that doesn't have permission to scan your files. You can
use <code>clamdscan --fdpass /path/to/scan</code> to pass the necessary file permissions.
NOTE: <code>clamdscan</code> runs in the background, you can watch it with <code>top</code>.</p>
</blockquote>
<h2 id="securing-ssh"><a class="header" href="#securing-ssh">Securing SSH</a></h2>
<blockquote>
<p><strong>Security information</strong>: Changing SSH configuration settings can
significantly impact the security of your system(s). It is crucial to have a
solid understanding of what you are doing before making any adjustments. Avoid
blindly copying and pasting examples, including those from this Wiki page,
without conducting a thorough analysis. Failure to do so may compromise the
security of your system(s) and lead to potential vulnerabilities. Take the
time to comprehend the implications of your actions and ensure that any
changes made are done thoughtfully and with care. --NixOS Wiki</p>
</blockquote>
<blockquote>
<p>❗ NOTE: Choose one, either <code>ssh-agent</code> or <code>gpg-agent</code></p>
</blockquote>
<ol>
<li>Use normal SSH keys generated with <code>ssh-keygen</code>, this is recommended unless
you have a good reason for not using it.</li>
</ol>
<p><strong>OR</strong></p>
<ol start="2">
<li>Use a GPG key with <code>gpg-agent</code> (which acts as your SSH agent). Complex, and
harder to understand in my opinion.</li>
</ol>
<p>My setup caused conflicts when enabling <code>programs.ssh.startAgent</code> so I chose
<code>gpg-agent</code> personally.</p>
<p>There are situations where you are required to use one or the other like for
headless CI/CD environments, <code>ssh-keygen</code> is required.</p>
<ul>
<li><a href="https://saylesss88.github.io/nix/gpg-agent.html">Click Here for GnuPG and gpg-agent chapter</a></li>
</ul>
<p>Further reading:</p>
<details>
<summary> ✔️ Click to Expand Resourses on OpenSSH </summary>
<ul>
<li>
<p><a href="https://wiki.archlinux.org/title/OpenSSH">Arch Wiki OpenSSH</a></p>
</li>
<li>
<p><a href="https://wiki.gentoo.org/wiki/GnuPG">Gentoo GnuPG</a></p>
</li>
<li>
<p><a href="https://rgoulter.com/blog/posts/programming/2022-06-10-a-visual-explanation-of-gpg-subkeys.html">A Visual Explanation of GPG Subkeys</a></p>
</li>
<li>
<p><a href="https://blog.stribik.technology/2015/01/04/secure-secure-shell.html">Secure Secure Shell</a></p>
</li>
</ul>
</details>
<h2 id="key-generation"><a class="header" href="#key-generation">Key generation</a></h2>
<h3 id="ssh-keygen"><a class="header" href="#ssh-keygen">ssh-keygen</a></h3>
<p>The <code>ed25519</code> algorithm is significantly faster and more secure when compared to
<code>RSA</code>. You can also specify the key derivation function (KDF) rounds to
strengthen protection even more.</p>
<p>For example, to generate a strong key for MdBook:</p>
<pre><code class="language-bash">ssh-keygen -t ed25519 -a 32 -f ~/.ssh/id_ed25519_github_$(date +%Y-%m-%d) -C "SSH Key for MdBook"
</code></pre>
<ul>
<li>
<p><code>-t</code> is for type</p>
</li>
<li>
<p><code>-a 32</code> sets the number of KDF rounds. The standard is usually good enough,
adding extra rounds can make it harder to brute-force.</p>
</li>
<li>
<p><code>-f</code> is for filename</p>
</li>
</ul>
<h3 id="openssh-server"><a class="header" href="#openssh-server">OpenSSH Server</a></h3>
<p>First of all, if you don't use SSH don't enable it in the first place. If you do
use SSH, it's important to understand what that opens you up to.</p>
<p>The following are some recommendations from Mozilla on OpenSSH:</p>
<ul>
<li><a href="https://infosec.mozilla.org/guidelines/openssh.html">Mozilla OpenSSH guidelines</a></li>
</ul>
<p>The following OpenSSH setup is based on the above guidelines with strong
algorithms, and best practices:</p>
<pre><code class="language-nix">{config, ...}: {
  config = {
    services = {
      fail2ban = {
        enable = true;
        maxretry = 5;
        bantime = "1h";
        # ignoreIP = [
        # "172.16.0.0/12"
        # "192.168.0.0/16"
        # "2601:881:8100:8de0:31e6:ac52:b5be:462a"
        # "matrix.org"
        # "app.element.io" # don't ratelimit matrix users
        # ];

        bantime-increment = {
          enable = true; # Enable increment of bantime after each violation
          multipliers = "1 2 4 8 16 32 64 128 256";
          maxtime = "168h"; # Do not ban for more than 1 week
          overalljails = true; # Calculate the bantime based on all the violations
        };
      };
      openssh = {
        enable = true;
        settings = {
          PasswordAuthentication = false;
          PermitEmptyPasswords = false;
          PermitTunnel = false;
          UseDns = false;
          KbdInteractiveAuthentication = false;
          X11Forwarding = config.services.xserver.enable;
          MaxAuthTries = 3;
          MaxSessions = 2;
          ClientAliveInterval = 300;
          ClientAliveCountMax = 0;
          AllowUsers = ["your-user"];
          TCPKeepAlive = false;
          AllowTcpForwarding = false;
          AllowAgentForwarding = false;
          LogLevel = "VERBOSE";
          PermitRootLogin = "no";
          KexAlgorithms = [
            # Key Exchange Algorithms in priority order
            "curve25519-sha256@libssh.org"
            "ecdh-sha2-nistp521"
            "ecdh-sha2-nistp384"
            "ecdh-sha2-nistp256"
            "diffie-hellman-group-exchange-sha256"
          ];
          Ciphers = [
            # stream cipher alternative to aes256, proven to be resilient
            # Very fast on basically anything
            "chacha20-poly1305@openssh.com"
            # industry standard, fast if you have AES-NI hardware
            "aes256-gcm@openssh.com"
            "aes128-gcm@openssh.com"
            "aes256-ctr"
            "aes192-ctr"
            "aes128-ctr"
          ];
          Macs = [
            # Combines the SHA-512 hash func with a secret key to create a MAC
            "hmac-sha2-512-etm@openssh.com"
            "hmac-sha2-256-etm@openssh.com"
            "umac-128-etm@openssh.com"
            "hmac-sha2-512"
            "hmac-sha2-256"
            "umac-128@openssh.com"
          ];
        };
        # These keys will be generated for you
        hostKeys = [
          {
            path = "/etc/ssh/ssh_host_ed25519_key";
            type = "ed25519";
          }
        ];
      };
    };
  };
}
</code></pre>
<p>TCP port 22 (ssh) is opened automatically if the SSH daemon is enabled
(<code>services.openssh.enable = true;</code>)</p>
<p>Much of the SSH hardening settings came from
<a href="https://ryanseipp.com/post/nixos-secure-ssh/">ryanseipp's secure-ssh Guide</a>
with some additions of my own.</p>
<p>Fail2Ban is an intrusion prevention software framework. It's designed to prevent
brute-force attacks by scanning log files for suspicious activity, such as
repeated failed login attempts.</p>
<p>OpenSSH is the primary tool for secure remote access for NixOS. Enabling it
activates the OpenSSH server on the system, allowing incoming SSH connections.</p>
<p>The above configuration is a robust setup for securing an SSH server by:</p>
<ul>
<li>
<p>Preventing brute-force attacks with Fail2Ban</p>
</li>
<li>
<p>Eliminating password authentication in favor of more secure SSH keys</p>
</li>
<li>
<p>Restricting user access and preventing root login</p>
</li>
<li>
<p>Disabling potentially risky forwarding features (tunnel, TCP, agent)</p>
</li>
<li>
<p>Enforce the use of strong, modern cryptographic algorithms for all SSH
communications.</p>
</li>
<li>
<p>Enhanced logging for better auditing.</p>
</li>
</ul>
<p>Further Reading:</p>
<ul>
<li>
<p><a href="https://www.openssh.com/">OpenSSH</a></p>
</li>
<li>
<p><a href="https://www.digitalocean.com/community/tutorials/how-fail2ban-works-to-protect-services-on-a-linux-server">DigitalOcean how fail2ban works</a></p>
</li>
</ul>
<h2 id="encrypted-secrets"><a class="header" href="#encrypted-secrets">Encrypted Secrets</a></h2>
<p>Never store secrets in plain text in repositories. Use something like
<a href="https://github.com/Mic92/sops-nix">sops-nix</a>, which lets you keep encrypted
secrets under version control declaratively.</p>
<p>Another option is <a href="https://github.com/ryantm/agenix">agenix</a></p>
<ul>
<li><a href="https://wiki.nixos.org/wiki/Agenix">NixOS Wiki Agenix</a></li>
</ul>
<h3 id="sops-nix-guide"><a class="header" href="#sops-nix-guide">Sops-nix Guide</a></h3>
<p>Protect your secrets, the following guide is on setting up Sops on NixOS:
<a href="https://saylesss88.github.io/installation/enc/sops-nix.html">Sops Encrypted Secrets</a></p>
<h2 id="auditd"><a class="header" href="#auditd">Auditd</a></h2>
<p>To enable the Linux Audit Daemon (<code>auditd</code>) and define a very basic rule set,
you can use the following NixOS configuration. This example demonstrates how to
log every program execution (<code>execve</code>) on a 64-bit architecture.</p>
<pre><code class="language-nix"># modules/security/auditd-minimal.nix (or directly in configuration.nix)
{
  # start as early in the boot process as possible
  boot.kernelParams = ["audit=1"];
  security.auditd.enable = true;
  security.audit.enable = true;
  security.audit.rules = [
    # Log all program executions on 64-bit architecture
    "-a exit,always -F arch=b64 -S execve"
  ];
}
</code></pre>
<ul>
<li>
<p><code>audit=1</code> Enables auditing at the kernel level very early in the boot process.
Without this, some events could be missed.</p>
</li>
<li>
<p><code>security.auditd.enable = true;</code> Ensures the <code>auditd</code> userspace daemon is
started.</p>
</li>
<li>
<p>While often enabled together, <code>security.audit.enable</code> specifically refers to
enabling the NixOS module for audit rules generation.</p>
</li>
<li>
<p><code>execve</code> (program executions)</p>
</li>
<li>
<p>This is just a basic configuration, there is much more that can be tracked.</p>
</li>
</ul>
<h2 id="usb-port-protection"><a class="header" href="#usb-port-protection">USB Port Protection</a></h2>
<p>It's important to protect your USB ports to prevent BadUSB attacks, data
exfiltration, unauthorized device access, malware injection, etc.</p>
<p>To get a list of your connected USB devices you can use <code>lsusb</code> from the
<code>usbutils</code> package.</p>
<pre><code class="language-bash">lsusb
</code></pre>
<p>To list the devices recognized by USBGuard, run:</p>
<pre><code class="language-bash">sudo usbguard list-devices
</code></pre>
<ul>
<li><a href="https://mynixos.com/options/services.usbguard">MyNixOS services.usbguard</a></li>
</ul>
<p>Change <code>your-user</code> to your username:</p>
<pre><code class="language-nix"># usbguard.nix
{
  config,
  pkgs,
  lib,
  ...
}: let
  inherit (lib) mkIf;
  cfg = config.custom.security.usbguard;
in {
  options.custom.security.usbguard = {
    enable = lib.mkEnableOption "usbguard";
  };

  config = mkIf cfg.enable {
    services.usbguard = {
      enable = true;
      IPCAllowedUsers = ["root" "your-user"];
    # presentDevicePolicy refers to how to treat USB devices that are already connected when the daemon starts
      presentDevicePolicy = "allow";
      rules = ''
        # allow `only` devices with mass storage interfaces (USB Mass Storage)
        allow with-interface equals { 08:*:* }
        # allow mice and keyboards
        # allow with-interface equals { 03:*:* }

        # Reject devices with suspicious combination of interfaces
        reject with-interface all-of { 08:*:* 03:00:* }
        reject with-interface all-of { 08:*:* 03:01:* }
        reject with-interface all-of { 08:*:* e0:*:* }
        reject with-interface all-of { 08:*:* 02:*:* }
      '';
    };

    environment.systemPackages = [pkgs.usbguard];
  };
}
</code></pre>
<p>The above settings can be found in
<a href="https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/7/html/security_guide/sec-using-usbguard">RedHat UsbGuard</a></p>
<p>The only <code>allow</code> rule is for devices with <strong>only</strong> mass storage interfaces
(<code>08:*:*</code>) i.e., USB Mass storage devices, devices like keyboards and mice
(which use interface class <code>03:*:*</code>) implicitly <strong>not allowed</strong>.</p>
<p>The <code>reject</code> rules reject devices with a suspicious combination of interfaces. A
USB drive that implements a keyboard or a network interface is very suspicious,
these <code>reject</code> rules prevent that.</p>
<p>The <code>presentDevicePolicy = "allow";</code> allows any device that is present at daemon
start up even if they're not explicitly allowed. However, newly plugged in
devices must match an <code>allow</code> rule or get denied implicitly.</p>
<p>The <code>presentDevicePolicy</code> should be one of: # one of <code>"apply-policy"</code>(default,
evaluate the rule set for every present device), <code>"block"</code>, <code>"reject"</code>, <code>"keep"</code>
(keep whatever state the device is currently in), or <code>"allow"</code>, which is used in
the example.</p>
<p>There is also the
<a href="https://github.com/Cropi/usbguard-notifier">usbguard-notifier</a></p>
<p>And enable it with the following in your <code>configuration.nix</code> or equivalent:</p>
<pre><code class="language-nix"># configuration.nix
imports = [
    ./usbguard.nix
];
custom.security.usbguard.enable = true;
</code></pre>
<blockquote>
<p>❗ If you are ever unsure about a setting that you want to harden and think
that it could possibly break your system you can always use a specialisation
reversing the action and choose it's generation at boot up. For example, to
force-reverse the above settings you could:</p>
<pre><code class="language-nix"># configuration.nix
specialisation.no-usbguard.configuration = {
    services.usbguard.enable = lib.mkForce false;
};
</code></pre>
<ul>
<li>This is a situation where I recommend this, it's easy to lock yourself out
of your keyboard, mouse, etc. when trying to configure this.</li>
</ul>
</blockquote>
<p>Further Reading:</p>
<ul>
<li>
<p><a href="https://www.ninjaone.com/it-hub/endpoint-security/what-is-badusb/">NinjaOne BadUSB</a></p>
</li>
<li>
<p><a href="https://usbguard.github.io/">USBGuard</a></p>
</li>
<li>
<p><a href="https://www.cyberciti.biz/security/how-to-protect-linux-against-rogue-usb-devices-using-usbguard/">NixCraft USBGuard</a></p>
</li>
</ul>
<h2 id="doas-over-sudo"><a class="header" href="#doas-over-sudo">Doas over sudo</a></h2>
<blockquote>
<p>NOTE: I have moved to <code>run0</code> for authentication which is included by default
with systemd. It's actually a symlink to the existing <code>systemd-run</code> tool. It
behaves like a secure <code>sudo</code> alternative: it spawns a transient service under
PID 1 for privilege escalation, without relying on SUID (set user ID)
binaries.</p>
</blockquote>
<ul>
<li>
<p>SUID = "Set User ID": When a binary has the SUID bit set, it runs with the
privileges of the file's owner (often root). There is a long history of
vulnerabilities with SUID binaries.</p>
</li>
<li>
<p><code>run0</code> configuration is explained in the
<a href="https://saylesss88.github.io/nix/index.html">Hardening README</a></p>
</li>
</ul>
<p>For a more minimalist version of <code>sudo</code> with a smaller codebase and attack
surface, consider <code>doas</code>. Replace <code>userName</code> with your username:</p>
<pre><code class="language-nix"># doas.nix
{
  lib,
  config,
  pkgs, # Add pkgs if you need to access user information
  ...
}: let
  cfg = config.custom.security.doas;
in {
  options.custom.security.doas = {
    enable = lib.mkEnableOption "doas";
  };

  config = lib.mkIf cfg.enable {
    # Disable sudo
    security.sudo.enable = false;

    # Enable and configure `doas`.
    security.doas = {
      enable = true;
      extraRules = [
        {
          # Grant doas access specifically to your user
          users = ["userName"]; # &lt;--- Only give access to your user
          # persist = true; # Convenient but less secure
          # noPass = true;    # Convenient but even less secure
          keepEnv = true; # Often necessary
          # Optional: You can also specify which commands they can run, e.g.:
          # cmd = "ALL"; # Allows running all commands (default if not specified)
          # cmd = "/run/current-system/sw/bin/nixos-rebuild"; # Only allow specific command
        }
      ];
    };

    # Add an alias to the shell for backward-compat and convenience.
    environment.shellAliases = {
      sudo = "doas";
    };
  };
}
</code></pre>
<p>You would then import this into your <code>configuration.nix</code> and enable/disable it
with the following:</p>
<pre><code class="language-nix"># configuration.nix

imports = [
    ./doas.nix
];

custom.security.doas.enable = true;
</code></pre>
<blockquote>
<p>❗ NOTE: Many people opt for the less secure <code>groups = ["wheel"];</code> in the
above configuration instead of <code>users = ["userName"];</code> to give wider access,
the choice is yours.</p>
</blockquote>
<h2 id="firejail"><a class="header" href="#firejail">Firejail</a></h2>
<blockquote>
<p>❗️ Critics such as madaidan say that Firejail worsens security by acting as a
privilege escalation hole. Firejail requires the executable to be setuid,
meaning it runs with root privileges.This is risky because any vulnerability
in Firejail can lead to privilege escalation. This combined with many
convenience features and complicated command line flags leads to a large
attack surface.</p>
</blockquote>
<ul>
<li>
<p>I haven't personally tried
<a href="https://github.com/Naxdy/nix-bwrapper">nix-bwrapper</a> myself yet, but it's
another sandboxing option that looks interesting. Bubblewrap is known for
having a more minimal design and smaller attack surface.</p>
<ul>
<li>Also see: <a href="#flatpak">Flatpak section</a> for another option for sandboxing.</li>
</ul>
</li>
<li>
<p><a href="https://sr.ht/~fgaz/nix-bubblewrap/">nix-bubblewrap</a> is another option.</p>
</li>
<li>
<p><a href="https://wiki.nixos.org/wiki/Firejail">NixOS Wiki Firejail</a></p>
</li>
<li>
<p><a href="https://wiki.archlinux.org/title/Firejail">Arch Wiki Firejail</a></p>
</li>
</ul>
<blockquote>
<p>❗ WARNING: Running untrusted code is never safe, sandboxing cannot change
this. --Arch Wiki</p>
</blockquote>
<pre><code class="language-nix"># firejail.nix
{
  pkgs,
  lib,
  ...
}: {
  programs.firejail = {
    enable = true;
    wrappedBinaries = {
      # Sandbox a web browser
      librewolf = {
        executable = "${lib.getBin pkgs.librewolf}/bin/librewolf";
        profile = "${pkgs.firejail}/etc/firejail/librewolf.profile";
      };
      # Sandbox a file manager
      thunar = {
        executable = "${lib.getBin pkgs.xfce.thunar}/bin/thunar";
        profile = "${pkgs.firejail}/etc/firejail/thunar.profile";
      };
      # Sandbox a document viewer
      zathura = {
        executable = "${lib.getBin pkgs.zathura}/bin/zathura";
        profile = "${pkgs.firejail}/etc/firejail/zathura.profile";
      };
    };
  };
}
</code></pre>
<p><code>wrappedBinaries</code> is a list of applications you want to run inside a sandbox.
Only the apps in the <code>wrappedBinaries</code> attribute set will be automatically
firejailed when launched the usual way.</p>
<p>Other apps may be started manually using <code>firejail &lt;app&gt;</code>, or added to
<code>wrappedBinaries</code> if you want automatic sandboxing, just make sure the profile
exists.</p>
<p>To inspect which profiles are available, after rebuilding go to <code>/nix/store/</code>, I
used Yazi to search for <code>/firejail</code> and followed it to <code>firejail/etc</code>, where the
profiles are.</p>
<p>There are many flags and options available with firejail, I suggest checking out
<code>man firejail</code>.</p>
<p>There are comments explaining what's going on in:
<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/by-name/fi/firejail/package.nix">firejail/package.nix</a></p>
<p>Firejail is a SUID program that reduces the risk of security breaches by
restricting the running environment of untrusted applications using
<a href="https://lwn.net/Articles/531114/">Linux namespaces</a> and
<a href="https://l3net.wordpress.com/2015/04/13/firejail-seccomp-guide/">seccomp-bpf</a>--<a href="https://firejail.wordpress.com/">Firejail Security Sandbox</a></p>
<p>It provides sandboxing and access restriction per application, much like what
AppArmor/SELinux does at a kernel level. However, it's not as secure or
comprehensive as kernel-enforced MAC systems (AppArmor/SELinux), since it's a
userspace tool and can potentially be bypassed by privilege escalation exploits.</p>
<hr />
<h2 id="flatpak"><a class="header" href="#flatpak">Flatpak</a></h2>
<blockquote>
<p>❗️NOTE: You cannot effectively use Firejail with Flatpak apps because of how
their sandboxing technologies operate.</p>
</blockquote>
<p>Apps that don't have a flatpak equivalent can be further hardened with
bubblewrap independently but bubblewrap is not needed on Flatpak apps.</p>
<p>Because of this limited native MAC (Mandatory Access Control) support on NixOS,
using Flatpak is often a good approach to get sandboxing and isolation for many
GUI apps.</p>
<ul>
<li>
<p>Flatpak bundles runtimes and sandbox mechanisms that provide app isolation
independently of the host system's AppArmor or SELinux infrastructure. This
can improve security and containment for GUI applications running on NixOS
despite the system lacking full native MAC coverage.</p>
</li>
<li>
<p>Flatpak apps benefit from sandboxing through bubblewrap, which isolate apps
and restrict access to user/home and system resources.</p>
</li>
</ul>
<p>Add Flatpak with the FlatHub repository for all users:</p>
<pre><code class="language-nix">services.flatpak.enable = true;
  systemd.services.flatpak-repo = {
    wantedBy = [ "multi-user.target" ];
    path = [ pkgs.flatpak ];
    script = ''
      flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
      # Only apps that are verified
      # flatpak remote-add --if-not-exists --subset=verified flathub-verified https://flathub.org/repo/flathub.flatpakrepo
    '';
  };
</code></pre>
<ul>
<li>
<p><a href="https://docs.flathub.org/docs/for-users/verification">Flathub Verified Apps</a></p>
</li>
<li>
<p><a href="https://secureblue.dev/articles/flatpak">Flatpak the good the bad the ugly</a></p>
</li>
</ul>
<p>Then you can either find apps through <a href="https://flathub.org/en">FlatHub</a> or on
the cmdline with <code>flatpak search &lt;app&gt;</code>. Flatpak is best used for GUI apps, some
CLI apps can be installed through it but not all.</p>
<ul>
<li>
<p>There is also <a href="https://github.com/gmodena/nix-flatpak">nix-flatpak</a>, which
enables you to manage your flatpaks declaratively.</p>
</li>
<li>
<p><a href="https://flathub.org/en/apps/com.github.tchx84.Flatseal">Flatseal</a> is GUI
utility that enables you to review and modify permissions from your Flatpak
apps. Many apps by default come with smart-card support, X11 &amp; Wayland
support, and more, disabling unnecessary permissions is recommended.</p>
</li>
<li>
<p><a href="https://flathub.org/en/apps/io.github.flattool.Warehouse">Warehouse</a> provides
a simple UI to control complex Flatpak options, no cmdline required.</p>
</li>
</ul>
<p>I have heard that it is not recommended to use Flatpak browsers because in order
for flatpak to work it has to disable some of the built-in browser sandboxing
which can reduce security. I haven't found any examples of Flatpak browsers
being exposed but it's something to keep in mind.</p>
<hr />
<h2 id="selinuxapparmor-mac-mandatory-access-control"><a class="header" href="#selinuxapparmor-mac-mandatory-access-control">SeLinux/AppArmor MAC (Mandatory Access Control)</a></h2>
<p><strong>AppArmor</strong> is available on NixOS, but is still in a somewhat experimental and
evolving state. There are only a few profiles that have been adapted to NixOS,
see here
<a href="https://discourse.nixos.org/t/apparmor-default-profiles/16780">Discourse on default-profiles</a>
Which guides you here
<a href="https://github.com/NixOS/nixpkgs/blob/2acaef7a85356329f750819a0e7c3bb4a98c13fe/nixos/modules/security/apparmor/includes.nix">apparmor/includes.nix</a>
where you can see some of the abstractions and tunables to follow progress.</p>
<p><strong>SELinux</strong>: Experimental, not fully integrated, recent progress for
advanced/curious users; expect rough edges and manual intervention if you want
to try it. Most find SELinux more complex to configure and maintain than
AppArmor.</p>
<p>This isn't meant to be a comprehensive guide, more to get people thinking about
security on NixOS.</p>
<p>See the following guide on hardening networking:</p>
<ul>
<li><a href="https://saylesss88.github.io/nix/hardening_networking.html">Hardening Networking</a></li>
</ul>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<h3 id="advanced-hardening-with-nix-mineral-community-project"><a class="header" href="#advanced-hardening-with-nix-mineral-community-project">Advanced Hardening with <code>nix-mineral</code> (Community Project)</a></h3>
<details>
<summary> ✔️ Click to Expand section on `nix-mineral` </summary>
<p>For users seeking a more comprehensive and opinionated approach to system
hardening beyond the built-in <code>hardened</code> profile, the community project
<a href="https://github.com/cynicsketch/nix-mineral"><code>nix-mineral</code></a> offers a declarative
NixOS module.</p>
<p><code>nix-mineral</code> aims to apply a wide array of security configurations, focusing on
tweaking kernel parameters, system settings, and file permissions to reduce the
attack surface.</p>
<ul>
<li><strong>Community Project Status:</strong> <code>nix-mineral</code> is a community-maintained project
and is not officially part of the Nixpkgs repository or NixOS documentation.
Its development status is explicitly stated as "Alpha software," meaning it
may introduce stability issues or unexpected behavior.</li>
</ul>
<p>For detailed information on <code>nix-mineral</code>'s capabilities and current status,
refer directly to its
<a href="https://github.com/cynicsketch/nix-mineral">GitHub repository</a>.</p>
</details>
<ul>
<li>
<p><a href="https://hedgedoc.grimmauld.de/s/hWcvJEniW#">AppArmor and apparmor.d on NixOS</a></p>
</li>
<li>
<p><a href="https://tristanxr.com/post/selinux-on-nixos/">SELinux on NixOS</a></p>
</li>
<li>
<p><a href="https://xeiaso.net/blog/paranoid-nixos-2021-07-18/">Paranoid NixOS</a></p>
</li>
<li>
<p><a href="https://wiki.nixos.org/wiki/Security">NixOS Wiki Security</a></p>
</li>
<li>
<p><a href="https://nixos.org/manual/nixos/unstable/index.html#sec-luks-file-systems">Luks Encrypted File Systems</a></p>
</li>
<li>
<p><a href="https://discourse.nixos.org/t/a-modern-and-secure-desktop-setup/41154">Discourse A Modern and Secure Desktop</a></p>
</li>
<li>
<p><a href="https://notashelf.dev/posts/insecurities-remedies-i">notashelf NixOS Security 1 Systemd</a></p>
</li>
<li>
<p><a href="https://ryanseipp.com/post/hardening-nixos/">ryanseipp hardening-nixos</a></p>
</li>
<li>
<p><a href="https://madaidans-insecurities.github.io/guides/linux-hardening.html">madaidans Linux Hardening Guide</a></p>
</li>
<li>
<p><a href="https://cybersecuritynews.com/hardening-linux-servers">Hardening-Linux-Servers</a></p>
</li>
<li>
<p><a href="https://linux-audit.com/linux-server-hardening-most-important-steps-to-secure-systems/">linux-audit Linux Server hardening best practices</a></p>
</li>
<li>
<p><a href="https://linux-audit.com/linux-security-guide-extended-version/">linux-audit Linux security guide extended</a></p>
</li>
<li>
<p><a href="https://wiki.archlinux.org/title/Security">Arch Wiki Security</a></p>
</li>
<li>
<p><a href="https://wiki.gentoo.org/wiki/Security_Handbook/Concepts">Gentoo Security_Handbook Concepts</a></p>
</li>
<li>
<p>STIGs are configuration standards developed by the Defense Information Systems
Agency (DISA) to secure systems and software for the U.S. Department of
Defense (DoD). They are considered a highly authoritative source for system
hardening.There are recommendations for hardening all kinds of software in the
<a href="https://stigviewer.com/stigs">Stig Viewer</a></p>
</li>
<li>
<p><a href="https://www.cisecurity.org/cis-benchmarks">CIS Benchmarks</a></p>
</li>
<li>
<p><a href="https://github.com/nsacyber">NSA Cybersecurity Directorate</a></p>
</li>
<li>
<p><a href="https://secureblue.dev/faq">secureblue FAQ</a></p>
</li>
<li>
<p><a href="https://www.kicksecure.com/wiki/Documentation">Excellent Kicksecure Docs</a></p>
</li>
<li>
<p><a href="https://factorable.net/faq.html">factorable.net (study of RSA and DSA crypto keys) FAQ</a></p>
</li>
<li>
<p><a href="https://blog.cr.yp.to/20140205-entropy.html">The cr.yp.to blog Entropy</a></p>
</li>
<li>
<p><a href="https://delroth.net/posts/nixos-security-wishlist/">NixOS Security wishlist</a></p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../nix/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../nix/gpg-agent.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../nix/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../nix/gpg-agent.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
