<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>NixOS Modules Explained - nix-book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="nix-book">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">nix-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-3"><a class="header" href="#chapter-3">Chapter 3</a></h1>
<h2 id="nixos-modules-explained"><a class="header" href="#nixos-modules-explained">NixOS Modules Explained</a></h2>
<p><img src="images/gruv3.png" alt="gruv3" /></p>
<p>TL;DR: In this post I break down the NixOS module system and explain how to
define options. As well as how to test modules with the repl.</p>
<ul>
<li>Most modules are functions that take an attribute set and return an attribute
set.</li>
</ul>
<details>
<summary>
**Refresher**(Click to Expand):
</summary>
<ul>
<li>
<p>An <strong>attribute set</strong> is a collection of name-value pairs called <em>attributes</em>:</p>
</li>
<li>
<p>Attribute sets are written enclosed in curly braces <code>{}</code>. Attribute names and
attribute values are separated by an equal sign <code>=</code>. Each value can be an
arbitrary expression, terminated by a semicolon <code>;</code>.</p>
</li>
</ul>
<blockquote>
<p><strong>Example</strong>:<a href="https://nix.dev/manual/nix/2.24/language/syntax#attrs-literal">nix.dev reference</a>
This defines an attribute set with attributes named:</p>
<ul>
<li><code>x</code> with the value <code>123</code>, an integer</li>
<li><code>text</code> with the value <code>"Hello"</code>, a string</li>
<li><code>y</code> where the value is the result of applying the function <code>f</code> to the
attribute set <code>{bla = 456; }</code></li>
</ul>
<pre><code class="language-nix">{
 x = 123;
 text = "Hello";
 y = f { bla = 456; };
}
</code></pre>
<pre><code class="language-nix">{ a = "Foo"; b = "Bar"}.a   # Output: `"Foo"`
</code></pre>
</blockquote>
<ul>
<li>Attributes can appear in any order. An attribute name may only occur once in
each attribute set.</li>
</ul>
<blockquote>
<p>❗ Remember <code>{}</code> is a valid attribute set in Nix.</p>
</blockquote>
<ul>
<li>The following is a <strong>function</strong> with an attribute set argument, remember that
anytime you see a <code>:</code> in Nix code it means this is a function. To the left is
the <strong>function arguments</strong> and to the right is the <strong>function body</strong>:</li>
</ul>
<pre><code class="language-nix">{ a, b }: a + b
</code></pre>
<ul>
<li>The simplest possible <strong>NixOS Module</strong>:</li>
</ul>
<pre><code class="language-nix">{ ... }:
{
}
</code></pre>
</details>
<p>NixOS produces a full system configuration by combining smaller, more isolated
and reusable components: <strong>Modules</strong>. If you want to understand Nix and NixOS
make sure you grasp modules!</p>
<ul>
<li>
<p>A NixOS module defines configuration options and behaviors for system
components, allowing users to extend, customize, and compose configurations
declaratively.</p>
</li>
<li>
<p>A <strong>module</strong> is a file containing a Nix expression with a specific structure.
It <em>declares</em> options for other modules to define (give a value). Modules were
introduced to allow extending NixOS without modifying its source code.</p>
</li>
<li>
<p>To define any values, the module system first has to know which ones are
allowed. This is done by declaring options that specify which attributes can
be set and used elsewhere.</p>
</li>
<li>
<p>If you want to write your own modules, I recommend setting up
<a href="https://github.com/nix-community/nixd?tab=readme-ov-file">nixd</a>
or <a href="https://github.com/oxalica/nil">nil</a> with your editor of choice.
This will allow your editor to warn you about missing arguments and
dependencies as well as syntax errors.</p>
</li>
</ul>
<h2 id="declaring-options"><a class="header" href="#declaring-options">Declaring Options</a></h2>
<p>The following is <code>nixpkgs/nixos/modules/programs/vim.nix</code>:</p>
<pre><code class="language-nix">{
  config,
  lib,
  pkgs,
  ...
}:

let
  cfg = config.programs.vim;
in
{
  options.programs.vim = {
    enable = lib.mkEnableOption "Vi IMproved, an advanced text";

    defaultEditor = lib.mkEnableOption "vim as the default editor";

    package = lib.mkPackageOption pkgs "vim" { example = "vim-full"; };
  };

  # TODO: convert it into assert after 24.11 release
  config = lib.mkIf (cfg.enable || cfg.defaultEditor) {
    warnings = lib.mkIf (cfg.defaultEditor &amp;&amp; !cfg.enable) [
      "programs.vim.defaultEditor will only work if programs.vim.enable is
       enabled, which will be enforced after the 24.11 release"
    ];
    environment = {
      systemPackages = [ cfg.package ];
      variables.EDITOR = lib.mkIf cfg.defaultEditor (lib.mkOverride 900 "vim");
      pathsToLink = [ "/share/vim-plugins" ];
    };
  };
}
</code></pre>
<ul>
<li>It provides options to enable Vim, set it as the default editor, and specify
the Vim package to use.</li>
</ul>
<details>
<summary>Breakdown of the `vim` module.(Click to Expand)</summary>
1. Module Inputs and Structure:
<pre><code class="language-nix">{
  config,
  lib,
  pkgs,
  ...
}
</code></pre>
<ul>
<li>
<p>Inputs: The module takes the above inputs and <code>...</code> (catch-all for other args)</p>
<ul>
<li>
<p><code>config</code>: Allows the module to read option values (e.g.
<code>config.programs.vim.enable</code>). It provides access to the evaluated
configuration.</p>
</li>
<li>
<p><code>lib</code>: The Nixpkgs library, giving us helper functions like <code>mkEnableOption</code>
, <code>mkIf</code>, and <code>mkOverride</code>.</p>
</li>
<li>
<p><code>pkgs</code>: The Nixpkgs package set, used to access packages like <code>pkgs.vim</code></p>
</li>
<li>
<p><code>...</code>: Allows the module to accept additional arguments, making it flexible
for extension in the future.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Key Takeaways: A NixOS module is typically a function that can include
<code>config</code>, <code>lib</code>, and <code>pkgs</code>, but it doesn’t require them. The <code>...</code>
argument ensures flexibility, allowing a module to accept extra inputs
without breaking future compatibility. Using <code>lib</code> simplifies handling
options (mkEnableOption, mkIf, mkOverride) and helps follow best practices.
Modules define options, which users can set in their configuration, and
<code>config</code>, which applies changes based on those options.</p>
</blockquote>
<ol start="2">
<li>Local Configuration Reference:</li>
</ol>
<pre><code class="language-nix">let
  cfg = config.programs.vim;
in
</code></pre>
<ul>
<li>This is a local alias. Instead of typing <code>config.programs.vim</code> over and over,
the module uses <code>cfg</code>.</li>
</ul>
<ol start="3">
<li>Option Declaration</li>
</ol>
<pre><code class="language-nix">options.programs.vim = {
  enable = lib.mkEnableOption "Vi IMproved, an advanced text";
  defaultEditor = lib.mkEnableOption "vim as the default editor";
  package = lib.mkPackageOption pkgs "vim" { example = "vim-full"; };
};
</code></pre>
<p>This defines three user-configurable options:</p>
<ul>
<li>
<p><code>enable</code>: Turns on Vim support system-wide.</p>
</li>
<li>
<p><code>defaultEditor</code>: Sets Vim as the system's default <code>$EDITOR</code>.</p>
</li>
<li>
<p><code>package</code>: lets the user override which Vim package is used.</p>
</li>
</ul>
<blockquote>
<p><code>mkPackageOption</code> is a helper that defines a package-typed option with a
default (<code>pkgs.vim</code>) and provides docs + example.</p>
</blockquote>
<ol start="4">
<li>Conditional Configuration</li>
</ol>
<pre><code class="language-nix">config = lib.mkIf (cfg.enable || cfg.defaultEditor) {
</code></pre>
<ul>
<li>This block is only activated if <em>either</em> <code>programs.vim.enable</code> or
<code>defaultEditor</code> is set.</li>
</ul>
<ol start="5">
<li>Warnings</li>
</ol>
<pre><code class="language-nix">warnings = lib.mkIf (cfg.defaultEditor &amp;&amp; !cfg.enable) [
  "programs.vim.defaultEditor will only work if programs.vim.enable is enabled,
   which will be enforced after the 24.11 release"
];
</code></pre>
<ul>
<li>Gives you a soft warning if you try to set <code>defaultEditor = true</code> without
also enabling Vim.</li>
</ul>
<ol start="6">
<li>Actual System Config Changes</li>
</ol>
<pre><code class="language-nix">environment = {
  systemPackages = [ cfg.package ];
  variables.EDITOR = lib.mkIf cfg.defaultEditor (lib.mkOverride 900 "vim");
  pathsToLink = [ "/share/vim-plugins" ];
};
</code></pre>
<ul>
<li>It adds Vim to your <code>systemPackages</code>, sets <code>$EDITOR</code> if <code>defaultEditor</code> is
true, and makes <code>/share/vim-plugins</code> available in the environment.</li>
</ul>
</details>
<p>The following is a bat home-manager module that I wrote:</p>
<pre><code class="language-nix"># bat.nix
{
  pkgs,
  config,
  lib,
  ...
}: let
  cfg = config.custom.batModule;
in {
  options.custom.batModule.enable = lib.mkOption {
    type = lib.types.bool;
    default = false;
    description = "Enable bat module";
  };

  config = lib.mkIf cfg.enable {
    programs.bat = {
      enable = true;
      themes = {
        dracula = {
          src = pkgs.fetchFromGitHub {
            owner = "dracula";
            repo = "sublime"; # Bat uses sublime syntax for its themes
            rev = "26c57ec282abcaa76e57e055f38432bd827ac34e";
            sha256 = "019hfl4zbn4vm4154hh3bwk6hm7bdxbr1hdww83nabxwjn99ndhv";
          };
          file = "Dracula.tmTheme";
        };
      };
      extraPackages = with pkgs.bat-extras; [
        batdiff
        batman
        prettybat
        batgrep
      ];
    };
  };
}
</code></pre>
<p>Now I could add this to my <code>home.nix</code> to enable it:</p>
<pre><code class="language-nix"># home.nix
custom = {
  batModule.enable = true;
}
</code></pre>
<ul>
<li>
<p>If I set this option to true the bat configuration is dropped in place. If
it's not set to true, it won't put the bat configuration in the system. Same
as with options defined in modules within the Nixpkgs repository.</p>
</li>
<li>
<p>If I had set the default to <code>true</code>, it would automatically enable the module
without requiring an explicit <code>custom.batModule.enable = true;</code> call in my
<code>home.nix</code>.</p>
</li>
</ul>
<h3 id="module-composition"><a class="header" href="#module-composition">Module Composition</a></h3>
<ul>
<li>
<p>NixOS achieves its full system configuration by combining the configurations
defined in various modules. This composition is primarily handled through the
<code>imports</code> mechanism.</p>
</li>
<li>
<p><code>imports</code>: This is a standard option within a NixOS or Home Manager
configuration (often found in your configuration.nix or home.nix). It takes
a list of paths to other Nix modules. When you include a module in the imports
list, the options and configurations defined in that module become part of
your overall system configuration.</p>
</li>
<li>
<p>You declaratively state the desired state of your system by setting options
across various modules. The NixOS build system then evaluates and merges these
option settings. The culmination of this process, which includes building the
entire system closure, is represented by the derivation built by
<code>config.system.build.toplevel</code>.</p>
</li>
</ul>
<h3 id="nixos-modules-and-dependency-locking-with-npins"><a class="header" href="#nixos-modules-and-dependency-locking-with-npins">NixOS Modules and Dependency Locking with npins</a></h3>
<details>
<summary>`npins` example (Click to Expand)</summary>
As our NixOS configurations grow in complexity, so too does the challenge of
managing the dependencies they rely on. Ensuring consistency and reproducibility
not only applies to individual packages but also to the versions of Nixpkgs and
other external resources our configurations depend upon.
<p>Traditionally, NixOS configurations often implicitly rely on the version of
Nixpkgs available when <code>nixos-rebuild</code> is run. However, for more robust and
reproducible setups, especially in collaborative environments or when rolling
back to specific configurations, explicitly locking these dependencies to
specific versions becomes crucial.</p>
<p>In the following example, we'll explore how to use a tool called <code>npins</code> to
manage and lock the dependencies of a NixOS configuration, ensuring a more
predictable and reproducible system. This will involve setting up a project
structure and using npins to pin the specific version of Nixpkgs our
configuration relies on.</p>
<p>This is the file structure:</p>
<pre><code class="language-bash">❯ tree
.
├── configuration.nix
├── default.nix
├── desktop.nix
└── npins
    ├── default.nix
    └── sources.json
</code></pre>
<p>This uses <code>npins</code> for dependency locking. Install it and run this in the project</p>
<p>directory:</p>
<pre><code class="language-bash">npins init
</code></pre>
<p>Create a <code>default.nix</code> with the following:</p>
<pre><code class="language-nix"># default.nix
{ system ? builtins.currentSystem, sources ? import ./npins, }:
let
  pkgs = import sources.nixpkgs {
    config = { };
    overlays = [ ];
  };
  inherit (pkgs) lib;
in lib.makeScope pkgs.newScope (self: {

  shell = pkgs.mkShell { packages = [ pkgs.npins self.myPackage ]; };

    # inherit lib;

  nixosSystem = import (sources.nixpkgs + "/nixos") {
    configuration = ./configuration.nix;
  };

  moduleEvale = lib.evalModules {
    modules = [
      # ...
    ];
  };
})
</code></pre>
<p>A <code>configuration.nix</code> with the following:</p>
<pre><code class="language-nix"># configuration.nix
{
  boot.loader.grub.device = "nodev";
  fileSystems."/".device = "/devst";
  system.stateVersion = "25.05";

  # declaring options means to declare a new option
  # defining options means to define a value of an option
  imports = [
    # ./main.nix
     ./desktop.nix # Files
    # ./minimal.nix
  ];

  # mine.desktop.enable = true;
}
</code></pre>
<p>And a <code>desktop.nix</code> with the following:</p>
<pre><code class="language-nix"># desktop.nix
{ pkgs, lib, config, ... }:

{
  imports = [];

  # Define an option to enable or disable desktop configuration
  options.mine.desktop.enable = lib.mkEnableOption "desktop settings";

  # Configuration that applies when the option is enabled
  config = lib.mkIf config.mine.desktop.enable {
    environment.systemPackages = [ pkgs.git ];
  };
}
</code></pre>
<p><code>mkEnableOption</code> defaults to false. Now in your <code>configuration.nix</code> you can
uncomment <code>mine.desktop.enable = true;</code> to enable the desktop config and
vice-versa.</p>
<p>You can test that this works by running:</p>
<pre><code class="language-bash">nix-instantiate -A nixosSystem.system
</code></pre>
<ul>
<li><code>nix-instantiate</code> performs only the evaluation phase of Nix expressions.
During this phase, Nix interprets the Nix code, resolves all dependencies, and
constructs derivations but does not execute any build actions. Useful for
testing.</li>
</ul>
<p>To check if this worked and <code>git</code> is installed in systemPackages you can
load it into <code>nix repl</code> but first you'll want <code>lib</code> to be available so uncomment
this in your <code>default.nix</code>:</p>
<pre><code class="language-nix"># default.nix
inherit lib;
</code></pre>
<p>Rerun <code>nix-instantiate -A nixosSystem.system</code></p>
<p>Then load the repl and check that <code>git</code> is in <code>systemPackages</code>:</p>
<pre><code class="language-bash">nix repl -f .
nix-repl&gt; builtins.filter (pkg: lib.hasPrefix "git" pkg.name) nixosSystem.config.environment.systemPackages
</code></pre>
<p>This shows the path to the derivation</p>
<p>Check that mine.desktop.enable is true</p>
<pre><code class="language-nix">nix-repl&gt; nixosSystem.config.mine.desktop.enable
true
</code></pre>
<p>As demonstrated with npins, explicitly managing the dependencies of your NixOS
modules is a powerful technique for ensuring the long-term stability and
reproducibility of your system configurations. By pinning specific versions
of Nixpkgs and other resources, you gain greater control over your environment
and reduce the risk of unexpected changes due to upstream updates.</p>
</details>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<p>You'll see the following all throughout Nix code and is convenient although it
doesn't follow best practices. One reason is static analysis can't reason about
the code, because it would have to actually evaluate the files to see which names
are in scope:</p>
<pre><code class="language-nix"># utils.nix
{ pkgs, ... }: {
  environment.systemPackages = with pkgs; [
    rustup
    evcxr
    nix-prefetch-git
  ];
}
</code></pre>
<p>The following follows best practices:</p>
<pre><code class="language-nix">{pkgs, ... }: {
  environment.systemPackages = builtins.attrValues {
    inherit (pkgs)
      rustup
      evcxr
      nix-prefetch-git;
  };
}
</code></pre>
<ul>
<li>
<p><code>builtins.attrValues</code> essentially converts an attribute set into a list.</p>
</li>
<li>
<p>The above approach avoids scope pollution, <code>with pkgs; [...]</code> brings all
attributes of <code>pkgs</code> into scope, which can make it harder to track where
specific values come from.</p>
</li>
<li>
<p>It can lead to unintended name clashes or confusion when debugging.</p>
</li>
</ul>
<p>Upon looking into this a bit further, most people use the following format to
avoid the "anti-pattern" from using <code>with pkgs;</code>:</p>
<pre><code class="language-nix"># utils.nix
{ pkgs, ... }: {
  environment.systemPackages = [
    pkgs.rustup
    pkgs.evcxr
    pkgs.nix-prefetch-git
  ];
}
</code></pre>
<ul>
<li>While the performance differences might be negligible on modern computers,
adopting this best practice from the start is highly recommended.</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>As we have seen throughout this chapter, modules are the building blocks of your
NixOS system and are themselves often functions. There are a few different ways
to use these modules to build your system. In the next chapter, <a href="https://saylesss88.github.io/Nix_Flakes_Explained_4.html">Nix Flakes
Explained</a> we will learn about Nix
Flakes as a more modern and comprehensive entrypoint for managing your entire
system and its dependencies.</p>
<p>To further deepen your understanding of NixOS Modules and the broader ecosystem
of tools and best practices surrounding them, the following resources offer
valuable insights and information.</p>
<h3 id="resources-on-modules"><a class="header" href="#resources-on-modules">Resources on Modules</a></h3>
<ul>
<li>
<p><a href="https://nixos.org/manual/nixos/stable/#sec-writing-modules">WritingNixOsModules</a></p>
</li>
<li>
<p><a href="https://nixos.wiki/wiki/NixOS_modules">NixWikiNixOSModules</a></p>
</li>
<li>
<p><a href="https://nix.dev/tutorials/module-system/a-basic-module/index.html">nix.dev A basic module</a></p>
</li>
<li>
<p><a href="https://nix.dev/tutorials/module-system/deep-dive#module-system-deep-dive">ModuleSystemDeepDive</a></p>
</li>
<li>
<p><a href="https://xeiaso.net/talks/asg-2023-nixos/">xeiaso Nixos Modules for fun &amp; profit</a></p>
</li>
<li>
<p><a href="https://nixos-and-flakes.thiscute.world/other-usage-of-flakes/module-system">NixOS Flakes Book Module System</a></p>
</li>
</ul>
<h1 id="videos"><a class="header" href="#videos">Videos</a></h1>
<p><a href="https://www.youtube.com/watch?v=N7hFP_40DJo&amp;t=17s">NixHour Writing NixOS modules</a> -- This example is from this video
<a href="https://infinisil.com/modules.mp4">infinisilModules</a></p>
<p><a href="https://www.youtube.com/watch?v=cZjOzOHb2ow">tweagModuleSystemRecursion</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Understanding_Nix_Functions_2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="Nix_Flakes_Explained_4.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Understanding_Nix_Functions_2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="Nix_Flakes_Explained_4.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
