{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "nix-book",
  "home_page_url": "https://saylesss88.github.io/",
  "feed_url": "https://saylesss88.github.io/feed3.json",
  "description": "An mdBook-generated site",
  "items": [
    {
      "id": "https://saylesss88.github.io/flakes/specialisations_4.6.html",
      "url": "https://saylesss88.github.io/flakes/specialisations_4.6.html",
      "title": "Specialisations",
      "content_html": "<h1>NixOS Specialisations For Multiple Profiles</h1>\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><strong>NixOS specialisations</strong> are a powerful feature that allow you to define\nalternative system configurations variations within a single NixOS setup. Each\nspecialisation can modify or extend the base configuration, and NixOS will\ngenerate separate boot entries for each, letting you choose at boot time (or\nswitch at runtime) which environment to use. This is ideal for testing,\nhardware-specific tweaks, or separating work and personal environments without\nmaintaining multiple configuration files</p>\n<h2>How Specialisations Work</h2>\n<p>Specialisations are defined as attributes under the <code>specialisation</code> option in\nyour configuration. Each key (e.g., <code>niri-test</code>) represents a named\nspecialisation, and its configuration attribute contains the NixOS options to\napply on top of the base system</p>\n<p>By default, a specialisation inherits the parent configuration and applies its\nchanges on top. You can also set <code>inheritParentConfig = false;</code> to create a\ncompletely separate configuration.</p>\n<p>After running <code>nixos-rebuild boot</code>, your bootloader will present extra entries\nfor each specialisation. Selecting one boots into the system with that\nspecialisation’s settings applied</p>\n<p>Runtime Switching: You can switch to a specialisation at runtime using\nactivation scripts, e.g.:</p>\n<pre><code class=\"language-bash\">nixos-rebuild switch --specialisation niri-test\n</code></pre>\n<p>or</p>\n<pre><code class=\"language-bash\">/run/current-system/specialisation/niri-test/bin/switch-to-configuration switch\n</code></pre>\n<blockquote>\n<p>Note: Some changes (like kernel switches) require a reboot to take effect</p>\n</blockquote>\n<p>Example: Let’s create a basic specialisation to try out the Niri Window Manager:</p>\n<p>First we have to add the <code>niri-flake</code> as an input to our <code>flake.nix</code> and add the\nmodule to install it:</p>\n<pre><code class=\"language-nix\"># flake.nix\ninputs = {\n     niri.url = \"github:sodiboo/niri-flake\";\n};\n</code></pre>\n<pre><code class=\"language-nix\"># configuration.nix\n{ pkgs, inputs, ... }: {\n# ... snip ...\nimports = [\n    inputs.niri.nixosModules.niri\n];\n\n# This is the top-level overlay\n  nixpkgs.overlays = [inputs.niri.overlays.niri];\n\n# ... snip ...\n\n  specialisation = {\n    niri-test.configuration = {\n      system.nixos.tags = [\"niri\"];\n\n      # Add the Niri overlay for this specialisation\n      nixpkgs.overlays = [inputs.niri.overlays.niri];\n\n      # Enable Niri session\n      programs.niri = {\n        enable = true;\n        package = pkgs.niri-unstable;\n      };\n\n      # Optionally, add a test user and greetd for login\n      users.users.niri = {\n        isNormalUser = true;\n        extraGroups = [\"networkmanager\" \"video\" \"wheel\"];\n        initialPassword = \"test\"; # for testing only!\n        createHome = true;\n      };\n\n      services.greetd = {\n        enable = true;\n        settings = rec {\n          initial_session = {\n            command = lib.mkForce \"${pkgs.niri}/bin/niri\";\n            user = lib.mkForce \"niri\";\n          };\n          default_session = initial_session;\n        };\n      };\n\n      environment.etc.\"niri/config.kdl\".text = ''\n        binds {\n          Mod+T { spawn \"alacritty\"; }\n          Mod+D { spawn \"fuzzel\"; }\n          Mod+Q { close-window; }\n          Mod+Shift+Q { exit; }\n        }\n      '';\n      environment.systemPackages = with pkgs; [\n        alacritty\n        waybar\n        fuzzel\n        mako\n        firefox\n      ];\n\n      programs.firefox.enable = true;\n\n      services.pipewire = {\n        enable = true;\n        alsa.enable = true;\n        pulse.enable = true;\n        # Optionally:\n        jack.enable = true;\n      };\n\n      hardware.alsa.enablePersistence = true;\n\n      networking.networkmanager.enable = true;\n    };\n  };\n}\n</code></pre>\n<p>I chose to use the nightly version so it was required to add the overlay at the\ntop-level as well as inside the <code>specialisation</code> block.</p>\n<p>On my system it sped up build times to first run:</p>\n<pre><code class=\"language-bash\">sudo nixos-rebuild switch --flake .\n# And Then Run\nsudo nixos-rebuild boot --flake .\n</code></pre>\n<p><strong>What this does</strong>:</p>\n<ul>\n<li>\n<p>Creates a boot entry called <code>niri-test</code> with the Niri Wayland compositor, a\ntest user, and a <code>greetd</code> login manager.</p>\n</li>\n<li>\n<p>Installs a set of packages and enables PipeWire with ALSA, PulseAudio, and\nJACK support.</p>\n</li>\n<li>\n<p>Provides a custom Niri configuration file for a few keybinds and enables\nNetworkManager.</p>\n</li>\n</ul>\n<h2>Using Your Specialisation After Boot</h2>\n<p>Once you have rebooted and selected your specialisation from the boot menu, you\ncan use your system as usual. If you want to add or remove programs, change\nsettings, or update your environment within a specialisation, simply:</p>\n<ol>\n<li>\n<p>Edit your configuration: Add or remove packages (e.g., add <code>ghostty</code> to\n<code>environment.systemPackages</code>) or change any other options inside the\nrelevant <code>specialisation</code> block in your NixOS configuration.</p>\n</li>\n<li>\n<p>Apply changes with a rebuild: Run the standard NixOS rebuild command. If you\nare currently running the specialisation you want to update, use:</p>\n</li>\n</ol>\n<pre><code class=\"language-bash\">sudo nixos-rebuild switch\n</code></pre>\n<p>This will apply your changes to the current specialisation</p>\n<p>If you want to build and activate a different specialisation from your current\nsession, use:</p>\n<pre><code class=\"language-bash\">sudo nixos-rebuild switch --specialisation name\n</code></pre>\n<p>Or, you can activate a specialisation directly with:</p>\n<pre><code class=\"language-bash\">sudo /run/current-system/specialisation/&lt;name&gt;/bin/switch-to-configuration switch\n</code></pre>\n<p>Replace <code>&lt;name&gt;</code> with your specialisation’s name.</p>\n<p>Reboot if needed: Most changes apply immediately, but some (like kernel or\n<code>initrd</code> changes) require a reboot for the specialisation to fully take effect</p>\n<p><strong>Tip</strong>:</p>\n<p>Each specialisation can have its own set of installed programs. Only those\nlisted in the <code>environment.systemPackages</code> (or enabled via modules) inside the\n<code>specialisation</code> block will be available when you boot into that context.</p>\n<p>You manage and update your specialisation just like your main NixOS system no\nspecial commands or workflow are required beyond specifying the specialisation\nwhen rebuilding or switching.</p>\n<h2>Use Cases for Specialisations</h2>\n<ul>\n<li>\n<p><strong>Hardware Profiles</strong>: Enable/disable drivers or services for specific\nhardware (e.g., eGPU, WiFi, or SR-IOV setups)</p>\n</li>\n<li>\n<p><strong>Desktop Environments</strong>: Quickly switch between different desktop\nenvironments or compositors (e.g., GNOME, Plasma, Niri)</p>\n</li>\n<li>\n<p><strong>Testing</strong>: Safely try out unstable packages, new kernels, or experimental\nfeatures without risking your main environment</p>\n</li>\n<li>\n<p><strong>User Separation</strong>: Create profiles for different users, each with their own\nsettings, packages, and auto-login</p>\n</li>\n<li>\n<p><strong>Secure Environments</strong>: Combine with encrypted partitions for more secure,\nisolated setups</p>\n</li>\n</ul>\n<h2>Securely Separated Contexts with NixOS Specialisations</h2>\n<p>I will just explain the concept here for completeness, if you want to implement\nthis I recommend following:</p>\n<p><a href=\"https://www.tweag.io/blog/2022-11-01-hard-user-separation-with-nixos/\">Tweag Hard User Separation with NixOS</a></p>\n<details>\n<summary> ✔️ Click To Expand Section on Separate Contexts </summary>\n<p>If you use the same computer in different contexts such as for work and for your\nprivate life you may worry about the risks of mixing sensitive environments. For\nexample, a cryptolocker received through a compromised work email could\npotentially encrypt your personal files, including irreplaceable family photos.</p>\n<p>A common solution is to install two different operating systems and dual-boot\nbetween them, keeping work and personal data isolated. However, this approach\nmeans you have two systems to maintain, update, and configure, which can be a\nsignificant hassle.</p>\n<p>NixOS offers a third alternative: With NixOS specialisations, you can manage two\n(or more) securely separated contexts within a single operating system. At boot\ntime, you select which context you want to use work or personal. Each context\ncan have its own encrypted root partition, user accounts, and configuration, but\nboth share the same Nix store for packages. This means:</p>\n<ul>\n<li>\n<p>No duplicated packages: Both contexts use the same system-wide package store,\nsaving space and simplifying updates.</p>\n</li>\n<li>\n<p>Single system to maintain: You update and manage only one NixOS installation,\nnot two.</p>\n</li>\n<li>\n<p>Strong security boundaries: Each context can have its own encrypted root, so a\ncompromise in one context (such as malware in your work environment) cannot\naccess the data in the other context.</p>\n</li>\n<li>\n<p>Flexible management: You can configure both contexts from either environment,\nmaking administration easier.</p>\n</li>\n</ul>\n<p>This approach combines the security of dual-booting with the convenience and\nefficiency of a single, unified system.</p>\n<p><strong>How It Works</strong>:</p>\n<ul>\n<li>\n<p>Encrypted Partitions: Each context (work and personal) has its own encrypted\nroot partition. The shared /nix/store partition is also encrypted, but can be\nunlocked by either context.</p>\n</li>\n<li>\n<p>Specialisations at Boot: NixOS generates multiple boot entries, one for each\ncontext. You simply choose your desired environment at boot time.</p>\n</li>\n<li>\n<p>Separation of Data: Your work and personal home directories, settings, and\ndocuments remain isolated from each other, while still benefiting from shared\nsystem packages.</p>\n</li>\n</ul>\n<p>Benefits Over Traditional Dual-Boot</p>\n<ul>\n<li>\n<p>Only one system to update and configure.</p>\n</li>\n<li>\n<p>No wasted disk space on duplicate packages.</p>\n</li>\n<li>\n<p>Seamless switching between contexts with a reboot.</p>\n</li>\n<li>\n<p>Consistent NixOS tooling and workflows in both environments.</p>\n</li>\n</ul>\n<p>What You Need</p>\n<ul>\n<li>\n<p>A physical or virtual machine supported by NixOS.</p>\n</li>\n<li>\n<p>Willingness to erase the system disk during setup.</p>\n</li>\n<li>\n<p>LVM (Logical Volume Manager) support: This setup requires using LVM for disk\npartitioning and management. LVM allows you to create multiple logical volumes\non a single physical disk, making it possible to securely separate your work\nand personal environments while sharing a common Nix store. You will use LVM\ncommands such as <code>pvcreate</code>, <code>vgcreate</code>, and <code>lvcreate</code> to prepare your disk\nlayout</p>\n</li>\n</ul>\n<p>In summary: With NixOS specialisations and careful disk partitioning, you can\nachieve secure, convenient, and efficient context separation—no need to\ncompromise between security and manageability.</p>\n</details>\n<h3>Tips and Best Practices</h3>\n<ul>\n<li>\n<p>Overriding Values: Use <code>lib.mkDefault</code> or <code>lib.mkForce</code> to make options\noverridable or forced in specialisations. I had to do it above because I have\ngreetd setup for my main configuration as well.</p>\n</li>\n<li>\n<p>Selective Configuration: If you want certain options only in the default\n(non-specialised) system, use:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">config = lib.mkIf (config.specialisation != {}) { ... }\n</code></pre>\n<ul>\n<li>\n<p>This condition checks if you’re in a specialisation.</p>\n</li>\n<li>\n<p>Any settings inside this block will <strong>not</strong> be inherited by specialisations,\nkeeping them exclusive to the main system.</p>\n</li>\n<li>\n<p>Runtime Limitations: Not all changes (e.g., kernel or <code>initrd</code>) can be fully\napplied at runtime; a reboot is required for those.</p>\n</li>\n<li>\n<p>Modularity: Specialisations work well with modular NixOS configs keep\nhardware, user, and service configs in separate files for easier management</p>\n</li>\n</ul>\n<p>References to Official Documentation and Community Resources</p>\n<ul>\n<li>\n<p><a href=\"https://www.tweag.io/blog/2022-08-18-nixos-specialisations/\">Tweag: Introduction to NixOS specialisations</a></p>\n</li>\n<li>\n<p><a href=\"https://wiki.nixos.org/wiki/Specialisation\">NixOS Wiki: Specialisation</a></p>\n</li>\n<li>\n<p><a href=\"https://www.tweag.io/blog/2022-11-01-hard-user-separation-with-nixos/\">Tweag Hard User Separation with NixOS</a></p>\n</li>\n</ul>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/flakes/overlays_4.5.html",
      "url": "https://saylesss88.github.io/flakes/overlays_4.5.html",
      "title": "Overlays",
      "content_html": "<h1>Extending Flakes with Custom Packages using Overlays</h1>\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><img src=\"../images/pokego.png\" alt=\"Pokego Logo\" />–<a href=\"https://github.com/rubiin/pokego\">pokego repo</a></p>\n<p>Overlays are Nix functions that accept two arguments, <code>final</code> and <code>prev</code> and\nreturn a set of packages. Overlays are similar to <code>packageOverrides</code> as a way to\ncustomize Nixpkgs, <code>packageOverrides</code> acts as an overlay with only the <code>prev</code>\nargument. Therefore, <code>packageOverrides</code> is appropriate for basic use, but\noverlays are more powerful and easier to distribute.</p>\n<p>Example:</p>\n<pre><code class=\"language-nix\">final: prev: {\n  firefox = prev.firefox.overrideAttrs (old: {\n    buildInputs = (old.buildInputs or []) ++ [ prev.vlc ];\n    env.FIREFOX_DISABLE_GMP_UPDATER = \"1\";\n  });\n}\n</code></pre>\n<p>To see the original derivation, run <code>nix edit -f \"&lt;nixpkgs&gt;\" firefox</code>.</p>\n<p>This modifies Firefox by:</p>\n<ul>\n<li>\n<p>Adding <code>vlc</code> to <code>buildInputs</code>, useful if a package requires additional\ndependencies.</p>\n</li>\n<li>\n<p>Setting an environment variable (<code>FIREFOX_DISABLE_GMP_UPDATER=1</code>) to disable\nautomatic updates of the Gecko Media Plugin.</p>\n</li>\n</ul>\n<p>It is very common to use overlays in Nix to install packages that aren’t\navailable in the standard Nixpkgs repository.</p>\n<p><strong>Overlays</strong> are one of the primary and recommended ways to extend and customize\nyour Nix environment. It’s important to remember that Nix overlays are made to\nallow you to modify or extend the package set provided by Nixpkgs (or other Nix\nsources) without directly altering the original package definitions. This is\ncrucial for maintaining reproducibility and avoiding conflicts. Overlays are\nessentially functions that take the previous package set and allow you to add,\nmodify, or remove packages.</p>\n<ul>\n<li>To better understand the structure of my <code>flake.nix</code> it may be helpful to\nfirst read <a href=\"https://tsawyer87.github.io/posts/nix_flakes_tips/\">This</a> blog\npost first.</li>\n</ul>\n<h2>Adding the overlays output to your Flake</h2>\n<p>I’ll show the process of adding the <code>pokego</code> package that is not in Nixpkgs:</p>\n<ol>\n<li>In my <code>flake.nix</code> I have a custom inputs variable within my let block of my\nflake like so just showing the necessary parts for brevity:</li>\n</ol>\n<pre><code class=\"language-nix\"># flake.nix\n  outputs = my-inputs @ {\n    self,\n    nixpkgs,\n    treefmt-nix,\n    ...\n  }: let\n    system = \"x86_64-linux\";\n    host = \"magic\";\n    userVars = {\n      username = \"jr\";\n      gitUsername = \"saylesss88\";\n      editor = \"hx\";\n      term = \"ghostty\";\n      keys = \"us\";\n      browser = \"firefox\";\n      flake = builtins.getEnv \"HOME\" + \"/flake\";\n    };\n\n    inputs =\n      my-inputs\n      // {\n        pkgs = import inputs.nixpkgs {\n          inherit system;\n        };\n        lib = {\n          overlays = import ./lib/overlay.nix;\n          nixOsModules = import ./nixos;\n          homeModules = import ./home;\n          inherit system;\n        };\n      };\n      # ... snip ...\n</code></pre>\n<ul>\n<li>Why I Created <code>inputs.lib</code> in My <code>flake.nix</code>. In the above example, you’ll\nnotice a <code>lib</code> attribute defined within the main <code>let</code> block.\n<ul>\n<li>\n<p>This might seem a bit unusual at first, as inputs are typically defined at\nthe top level of a flake. However, this structure provides a powerful way to\norganize and reuse common Nix functions and configurations across my flake.</p>\n</li>\n<li>\n<p>By bundling my custom logic and modules into <code>inputs.lib</code>, I can pass\n<code>inputs</code> (which now includes my custom <code>lib</code>) as a <code>specialArgs</code> to other\nmodules. This provides a clean way for all modules to access these shared\nresources. For example, in <code>configuration.nix</code>, <code>inputs.lib.overlays</code>\ndirectly references my custom overlay set.</p>\n</li>\n<li>\n<p>My <code>inputs.lib</code> is my own project-specific library, designed to hold\nfunctions and attribute sets relevant to my flake’s custom configurations.\nWhile <code>nixpkgs.lib</code> is globally available, my custom <code>lib</code> contains my\nunique additions.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>While defining <code>inputs</code> within the <code>let</code> block to achieve this structure is a\npersonal preference and works well for my setup, the core benefit is the\ncreation of a dedicated, centralized <code>lib</code> attribute that encapsulates my\nflake’s reusable Nix code, leading to a more organized and maintainable\nconfiguration.</p>\n<h2>The Actual Overlay</h2>\n<ol start=\"2\">\n<li>In the <code>overlay.nix</code> I have this helper function and the defined package:</li>\n</ol>\n<pre><code class=\"language-nix\"># overlay.nix\n_final: prev: let\n  # Helper function to import a package\n  callPackage = prev.lib.callPackageWith (prev // packages);\n\n  # Define all packages\n  packages = {\n    # Additional packages\n    pokego = callPackage ./pac_defs/pokego.nix {};\n  };\nin\n  packages\n</code></pre>\n<ol>\n<li><code>_final: prev:</code>: This is the function definition of the overlay.</li>\n</ol>\n<ul>\n<li>\n<p><code>_final</code>: This argument represents the final, merged package set after all\noverlays have been applied. It’s often unused within a single overlay, hence\nthe <code>_</code> prefix (a Nix convention for unused variables).</p>\n</li>\n<li>\n<p><code>prev</code>: This is the crucial argument. It represents the package set before\nthis overlay is applied. This allows you to refer to existing packages and\nfunctions from Nixpkgs.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p><code>let ... in packages</code>: This introduces a <code>let</code> expression, which defines\nlocal variables within the scope of this overlay function. The <code>in packages</code>\npart means that the overlay function will ultimately return the <code>packages</code>\nattribute set defined within the <code>let</code> block.</p>\n</li>\n<li>\n<p><code>callPackage = prev.lib.callPackageWith (prev // packages)</code>: This line\ndefines a helper function called <code>callPackage</code>.</p>\n</li>\n</ol>\n<ul>\n<li>\n<p><code>prev.lib.callPackageWith</code> Is a function provided by Nixpkgs’ <code>lib</code>.\n<code>callPackageWith</code> is like <code>prev.lib.callPackage</code>, but allows the passing of\nadditional arguments that will then be passed to the package definition.</p>\n</li>\n<li>\n<p><code>(prev // packages)</code>: This is an attribute set merge operation. It takes the\n<code>prev</code> package set (Nixpkgs before this overlay) and merges it with the\n<code>packages</code> attribute set defined later in this overlay.</p>\n</li>\n<li>\n<p>By using <code>callPackageWith</code> with this merged attribute set, the <code>callPackage</code>\nfunction defined here is set up to correctly import package definitions,\nensuring they have access to both the original Nixpkgs and any other packages\ndefined within this overlay.</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>\n<p><code>packages = { ... };</code>: This defines an attribute set named <code>packages</code>. This\nset will contain all the new or modified packages introduced by this overlay.</p>\n</li>\n<li>\n<p><code>pokego = callPackages ./pac_defs/pokego.nix { };</code>: This is the core of how\nthe <code>pokego</code> package is added.</p>\n</li>\n</ol>\n<ul>\n<li>\n<p><code>pokego =</code>: This defines a new attribute named <code>pokego</code> within the packages\nattribute set. This name will be used to refer to the pokego package later.</p>\n</li>\n<li>\n<p><code>callPackage ./pac_defs/pokego.nix {}</code>: This calls the callPackage helper\nfunction defined earlier.</p>\n</li>\n<li>\n<p><code>./pac_defs/pokego.nix</code>: This is the path to another Nix file(<code>pokego.nix</code>)\nthat contains the actual package definition for pokego. This file would define\nhow to fetch, build, and install the pokego software</p>\n</li>\n<li>\n<p><code>{}</code>: This is an empty attribute set passed as additional arguments to the\n<code>pokego.nix</code> package definition. If <code>pokego.nix</code> expected any specific\nparameters (like versions or dependencies), you would provide them here. Since\nit’s empty, it implies pokego.nix either has no required arguments or uses\ndefault values.</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><code>in packages</code>: As mentioned earlier, the overlay function returns the\npackages attribute set. When this overlay is applied, the packages defined\nwithin this packages set (including pokego) will be added to the overall Nix\npackage set.</li>\n</ol>\n<h2>The pokego Package definition</h2>\n<p>The following is the <code>./pac_defs/pokego.nix</code>:</p>\n<pre><code class=\"language-nix\"># pokego.nix\n{\n  lib,\n  buildGoModule,\n  fetchFromGitHub,\n}:\nbuildGoModule rec {\n  pname = \"pokego\";\n  version = \"0.3.0\";\n\n  src = fetchFromGitHub {\n    owner = \"rubiin\";\n    repo = \"pokego\";\n    rev = \"v${version}\";\n    hash = \"sha256-cFpEi8wBdCzAl9dputoCwy8LeGyK3UF2vyylft7/1wY=\";\n  };\n\n  vendorHash = \"sha256-7SoKHH+tDJKhUQDoVwAzVZXoPuKNJEHDEyQ77BPEDQ0=\";\n\n  # Install shell completions\n  postInstall = ''\n    install -Dm644 completions/pokego.bash \"$out/share/bash-completion/completions/pokego\"\n    install -Dm644 completions/pokego.fish \"$out/share/fish/vendor_completions.d/pokego.fish\"\n    install -Dm644 completions/pokego.zsh \"$out/share/zsh/site-functions/_pokego\"\n  '';\n\n  meta = with lib; {\n    description = \"Command-line tool that lets you display Pokémon sprites in color directly in your terminal\";\n    homepage = \"https://github.com/rubiin/pokego\";\n    license = licenses.gpl3Only;\n    maintainers = with maintainers; [\n      rubiin\n      jameskim0987\n      vinibispo\n    ];\n    mainProgram = \"pokego\";\n    platforms = platforms.all;\n  };\n}\n</code></pre>\n<h2>Adding the overlay to your configuration</h2>\n<p>There are a few places you could choose to put the following, I choose to use my\n<code>configuration.nix</code> because of my setup:</p>\n<pre><code class=\"language-nix\"># configuration.nix\nnixpkgs.overlays = [inputs.lib.overlays]\n</code></pre>\n<h2>Installing Pokego</h2>\n<ul>\n<li>If you are managing your entire system configuration with NixOS, you would\ntypically add <code>pokego</code> to your <code>environment.systemPackages</code>.</li>\n</ul>\n<pre><code class=\"language-nix\"># configuration.nix\nenvironment.systemPackages = with pkgs; [\n  pokego\n]\n</code></pre>\n<ul>\n<li>If you prefer home-manager you can install <code>pokego</code> with home-manager also:</li>\n</ul>\n<pre><code class=\"language-nix\"># home.nix\nhome.packages = [\n  pkgs.pokego\n]\n</code></pre>\n<h3>Another Overlay Example</h3>\n<pre><code class=\"language-nix\">{\n  inputs = {\n    nixpkgs.url = \"https://flakehub.com/NixOS/nixpkgs/*.tar.gz\";\n\n    nix.url = \"https://flakehub.com/f/NixOS/nix/2.17.0.tar.gz\";\n  };\n\n  outputs = { self, nixpkgs, nix }:\n\n    let\n      system = \"aarch64-darwin\";\n      pkgs = import nixpkgs {\n        inherit system;\n        overlays = [\n          nix.overlays.default\n        ];\n      };\n    in\n    {\n     # `pkgs` is nixpkgs for the system, with nix's overlay applied\n    };\n}\n</code></pre>\n<ul>\n<li>\n<p>Normally,\n<code>pkgs = import nixpkgs { }`` imports Nixpkgs with default settings.  However, the example above customizes this import by passing arguments:  </code>pkgs\n= import nixpkgs { inherit system; overlays = [\nnix.overlays.default];}<code>.  This makes the pkgs variable represent nixpkgs specifically for the </code>aarch64-darwin`\nsystem, with the overlay from the nix flake applied.</p>\n</li>\n<li>\n<p>Consequently, any packages built using this customized <code>pkgs</code> will now depend\non or use the specific nix version (<code>2.17.0</code>) provided by the nix flake,\ninstead of the version that comes with the fetched <code>nixpkgs</code>. This technique\ncan be useful for ensuring a consistent environment or testing specific\npackage versions.</p>\n</li>\n</ul>\n<h2>Customizing Nixpkgs Imports and Overlays</h2>\n<p>While overlays are typically used to add or modify packages within a single\n<code>nixpkgs</code> instance, Nix’s lazy evaluation and flake inputs allow for even more\npowerful scenarios. You can have multiple versions of nixpkgs in a single flake,\nand they will only be evaluated when a package from that specific version is\nactually referenced. This complements overlays by giving you fine-grained\ncontrol over which nixpkgs instance an overlay applies to, or which <code>nixpkgs</code>\nversion a specific part of your project depends on.</p>\n<p>Consider this example where we import nixpkgs with a specific overlay applied\ndirectly at the import site:</p>\n<pre><code class=\"language-nix\">{\n  inputs = {\n    nixpkgs.url = \"[https://flakehub.com/NixOS/nixpkgs/*.tar.gz](https://flakehub.com/NixOS/nixpkgs/*.tar.gz)\"; # This will be the base nixpkgs\n\n    nix.url = \"[https://flakehub.com/f/NixOS/nix/2.17.0.tar.gz](https://flakehub.com/f/NixOS/nix/2.17.0.tar.gz)\"; # This flake provides an overlay for a specific Nix version\n  };\n\n  outputs = { self, nixpkgs, nix }:\n\n    let\n      system = \"aarch64-darwin\";\n      # Here, we import nixpkgs and apply the 'nix' flake's overlay.\n      # This 'pkgs' variable now holds a customized Nix package set.\n      # In this 'pkgs' set, the 'nix' package (and anything that depends on it)\n      # will be version 2.17.0 as defined by the 'nix' flake's overlay.\n      pkgs_with_custom_nix = import nixpkgs {\n        inherit system;\n        overlays = [\n          nix.overlays.default # Apply the overlay from the 'nix' flake here\n        ];\n      };\n    in\n    {\n      # We can then expose packages or devShells that use this customized `pkgs` set.\n      devShells.${system}.default = pkgs_with_custom_nix.mkShell {\n        packages = [\n          pkgs_with_custom_nix.nix # This 'nix' package is now version 2.17.0 due to the overlay!\n        ];\n        shellHook = ''\n          echo \"Using Nix version: &lt;span class=\"math-inline\"&gt;\\(nix \\-\\-version\\)\"\n'';\n};\n# You can also make this customized package set available as a top-level overlay\n# if other parts of your flake or configuration want to use it.\n# overlays.custom-nix-version = final: prev: {\n#   inherit (pkgs_with_custom_nix) nix; # Expose the specific nix package from our overlayed pkgs\n# };\n# You can also import multiple versions of nixpkgs and select packages from them:\n# pkgs-2505 = import (inputs.nixpkgs-2505 or nixpkgs) { inherit system; }; # Example, assuming 2505 is an input\n# packages.&lt;/span&gt;{system}.my-tool-2505 = pkgs-2505.myTool; # Using a package from a specific stable version\n    };\n}\n</code></pre>\n<p>Normally, <code>pkgs = import nixpkgs { }</code> imports Nixpkgs with default settings.\nHowever, the example above customizes this import by passing arguments:\n<code>pkgs = import nixpkgs { inherit system; overlays = [ nix.overlays.default];}</code>.\nThis makes the <code>pkgs_with_custom_nix</code> variable represent Nixpkgs specifically\nfor the <code>aarch64-darwin</code> system, with the overlay from the nix flake applied at\nthe time of import.</p>\n<p>Consequently, any packages built using this customized <code>pkgs_with_custom_nix</code>\nwill now depend on or use the specific Nix version (<code>2.17.0</code>) provided by the\nnix flake’s overlay, instead of the version that comes with the base <code>nixpkgs</code>\ninput. This technique is highly useful for ensuring a consistent environment or\ntesting specific package versions without affecting the entire system’s\n<code>nixpkgs</code> set.</p>\n",
      "date_published": "2025-11-22T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/Package_Definitions_Explained_6.html",
      "url": "https://saylesss88.github.io/Package_Definitions_Explained_6.html",
      "title": "Package Definitions Explained",
      "content_html": "<h1>Chapter 8</h1>\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><img src=\"images/coding2.png\" alt=\"coding2\" /></p>\n<!-- ![gruv1](images/gruv1.png) -->\n<h2>Package Definitions Explained</h2>\n<p>In Nix, the concept of a <strong>package</strong> can refer to two things:</p>\n<ul>\n<li>\n<p>A collection of files and data that constitute a piece of software or an\nartifact.</p>\n</li>\n<li>\n<p>A Nix <strong>expression</strong> that describes how to create such a collection. This\nexpression acts as a blueprint before the package exists in a tangible form.</p>\n</li>\n</ul>\n<p>The process begins with writing a <strong>package definition</strong> using the Nix language.\nThis definition contains the necessary instructions and metadata about the\nsoftware you intend to “package.”</p>\n<h2>The Journey from Definition to Package</h2>\n<details>\n<summary> ✔️ Click to Expand</summary>\n<ol>\n<li>\n<p><strong>Package Definition:</strong></p>\n<ul>\n<li>\n<p>This is essentially a function written in the Nix language.</p>\n</li>\n<li>\n<p>Nix language shares similarities with JSON but includes the crucial\naddition of functions.</p>\n</li>\n<li>\n<p>It acts as the blueprint for creating a package.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Derivation:</strong></p>\n<ul>\n<li>\n<p>When the package definition is evaluated by Nix, it results in a\n<strong>derivation</strong>.</p>\n</li>\n<li>\n<p>A derivation is a concrete and detailed build plan.</p>\n</li>\n<li>\n<p>It outlines the exact steps Nix needs to take: fetching source code,\nbuilding dependencies, compiling code, and ultimately producing the\ndesired output (the package).</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Realization (Building the Package):</strong></p>\n<ul>\n<li>\n<p>You don’t get a pre-built “package” directly from the definition or the\nderivation.</p>\n</li>\n<li>\n<p>The package comes into being when Nix <strong>executes</strong> the derivation. This\nprocess is often referred to as “realizing” the derivation.</p>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>Analogy:</strong> Think of a package definition as an architectural blueprint, the\nderivation as the detailed construction plan, and the realized package as the\nfinished building.</p>\n</details>\n## Skeleton of a Derivation\n<p>The most basic derivation structure in Nix looks like this:</p>\n<pre><code class=\"language-nix\">{ stdenv }:\n\nstdenv.mkDerivation { }\n</code></pre>\n<ul>\n<li>\n<p>This is a function that expects an attribute set containing <code>stdenv</code> as its\nargument.</p>\n</li>\n<li>\n<p>It then calls <code>stdenv.mkDerivation</code> (a function provided by <code>stdenv</code>) to\nproduce a derivation.</p>\n</li>\n<li>\n<p>Currently, this derivation doesn’t specify any build steps or outputs.</p>\n</li>\n<li>\n<p>Further Reading:</p>\n</li>\n<li>\n<p><a href=\"https://ryantm.github.io/nixpkgs/stdenv/stdenv/\">The Standard Environment</a></p>\n</li>\n<li>\n<p><a href=\"https://nixos.org/guides/nix-pills/19-fundamentals-of-stdenv.html\">Fundamentals of Stdenv</a></p>\n</li>\n</ul>\n<h2>Example: A Simple “Hello” Package Definition</h2>\n<p>Here’s a package definition for the classic “hello” program:</p>\n<pre><code class=\"language-nix\"># hello.nix\n{\n  stdenv,\n  fetchzip,\n}:\n\nstdenv.mkDerivation {\n  pname = \"hello\";\n  version = \"2.12.1\";\n\n  src = fetchzip {\n    url = \"[https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz](https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz)\";\n    sha256 = \"\";\n  };\n}\n</code></pre>\n<ul>\n<li>\n<p>This is a Nix function that takes stdenv and fetchzip as arguments.</p>\n</li>\n<li>\n<p>It uses <code>stdenv.mkDerivation</code> to define the build process for the “hello”\npackage.</p>\n<ul>\n<li>\n<p><code>pname</code>: The package name.</p>\n</li>\n<li>\n<p><code>version</code>: The package version.</p>\n</li>\n<li>\n<p><code>src</code>: Specifies how to fetch the source code using <code>fetchzip</code>.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Handling Dependencies: Importing Nixpkgs</strong></p>\n<ul>\n<li>\n<p>If you try to build <code>hello.nix</code> directly with <code>nix-build hello.nix</code>, it will\nfail because <code>stdenv</code> and <code>fetchzip</code> are part of Nixpkgs, which isn’t included\nin this isolated file.</p>\n</li>\n<li>\n<p>To make this package definition work, you need to pass the correct arguments\n(<code>stdenv</code>, <code>fetchzip</code>) to the function.</p>\n</li>\n</ul>\n<p>The recommended approach is to create a <code>default.nix</code> file in the same\ndirectory:</p>\n<pre><code class=\"language-nix\"># default.nix\n\nlet\n  nixpkgs = fetchTarball \"[https://github.com/NixOS/nixpkgs/tarball/nixos-24.05](https://github.com/NixOS/nixpkgs/tarball/nixos-24.05)\";\n  pkgs = import nixpkgs { config = {}; overlays = []; };\nin\n{\n  hello = pkgs.callPackage ./hello.nix { };\n}\n</code></pre>\n<ul>\n<li>\n<p>This <code>default.nix</code> imports Nixpkgs.</p>\n</li>\n<li>\n<p>It then uses <code>pkgs.callPackage</code> to call the function in <code>hello.nix</code>, passing\nthe necessary dependencies from Nixpkgs.</p>\n</li>\n<li>\n<p>You can now build the “hello” package using: <code>nix-build -A hello</code>. The <code>-A</code>\nflag tells Nix to build the attribute named hello from the top-level\nexpression in default.nix.</p>\n</li>\n</ul>\n<p><strong>Realizing the Derivation and Handling sha256</strong></p>\n<ul>\n<li>\n<p><strong>Evaluation vs. Realization</strong>: While “evaluate” refers to Nix processing an\nexpression, “realize” often specifically means building a derivation and\nproducing its output in the Nix store.</p>\n</li>\n<li>\n<p>When you first run <code>nix-build -A hello</code>, it will likely fail due to a missing\nsha256 hash for the source file. Nix needs this hash for security and\nreproducibility. The error message will provide the correct sha256 value.</p>\n</li>\n<li>\n<p><strong>Example Error</strong>:</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">  nix-build -A hello\n  error: hash mismatch in fixed-output derivation '/nix/store/pd2kiyfa0c06giparlhd1k31bvllypbb-source.drv':\n  specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\n  got: sha256-1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=\n  error: 1 dependencies of derivation '/nix/store/b4mjwlv73nmiqgkdabsdjc4zq9gnma1l-hello-2.12.1.drv' failed to build\n</code></pre>\n<ul>\n<li>Replace the empty <code>sha256 = \"\";</code> in <code>hello.nix</code> with the provided correct\nvalue: <code>sha256 = \"1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=\";</code>.</li>\n</ul>\n<p><strong>Building and Running the Result</strong></p>\n<p>After updating the <code>sha256</code>, you can successfully build the package:</p>\n<pre><code class=\"language-bash\">nix-build -A hello\n</code></pre>\n<p>The output will be a result symlink pointing to the built package in the Nix\nstore. You can then run the “hello” program:</p>\n<pre><code class=\"language-bash\">./result/bin/hello\nHello, world!\n</code></pre>\n<h3>Swaytools Package Definition</h3>\n<p><strong>Example: The swaytools Package Definition</strong></p>\n<p>Let’s examine a more complex, real-world package definition from Nixpkgs:\n<code>nixpkgs/pkgs/tools/wayland/swaytools/default.nix</code>.</p>\n<pre><code class=\"language-nix\"># default.nix\n{\n  lib,\n  setuptools,\n  buildPythonApplication,\n  fetchFromGitHub,\n  slurp,\n}:\n\nbuildPythonApplication rec {\n  pname = \"swaytools\";\n  version = \"0.1.2\";\n\n  format = \"pyproject\";\n\n  src = fetchFromGitHub {\n    owner = \"tmccombs\";\n    repo = \"swaytools\";\n    rev = version;\n    sha256 = \"sha256-UoWK53B1DNmKwNLFwJW1ZEm9dwMOvQeO03+RoMl6M0Q=\";\n  };\n\n  nativeBuildInputs = [ setuptools ];\n\n  propagatedBuildInputs = [ slurp ];\n\n  meta = with lib; {\n    homepage = \"https://github.com/tmccombs/swaytools\";\n    description = \"Collection of simple tools for sway (and i3)\";\n    license = licenses.gpl3Only;\n    maintainers = with maintainers; [ atila ];\n    platforms = platforms.linux;\n  };\n}\n</code></pre>\n<h3>Breakdown of the Above default.nix</h3>\n<details>\n<summary>Click to Expand</summary>\n<p>1 <strong>Function Structure</strong>:</p>\n<ul>\n<li>\n<dl>\n<dt>The file starts with a function taking an attribute set of dependencies from\nNixpkgs: <code>{ lib, setuptools, buildPythonApplication, fetchFromGitHub, slurp }</code></dt>\n<dd>.</dd>\n</dl>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>Derivation Creation</strong>:</li>\n</ol>\n<ul>\n<li>It calls <code>buildPythonApplication</code>, a specialized helper for Python packages\n(similar to <code>stdenv.mkDerivation</code> but pre-configured for Python). The <code>rec</code>\nkeyword allows attributes within the derivation to refer to each other.</li>\n</ul>\n<ol start=\"3\">\n<li><strong>Package Metadata</strong>:</li>\n</ol>\n<ul>\n<li>\n<p><code>pname</code> and <code>version</code> define the package’s name and version.</p>\n</li>\n<li>\n<p>The <code>meta</code> attribute provides standard package information like the homepage,\ndescription, license, maintainers, and supported platforms.</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li><strong>Source Specification</strong>:</li>\n</ol>\n<ul>\n<li>The <code>src</code> attribute uses <code>fetchFromGitHub</code> to download the source code from\nthe specified repository and revision, along with its <code>sha256</code> hash for\nverification.</li>\n</ul>\n<ol start=\"5\">\n<li><strong>Build and Runtime Dependencies</strong>:</li>\n</ol>\n<ul>\n<li>\n<p><code>nativeBuildInputs</code>: Lists tools required during the build process (e.g.,\n<code>setuptools</code> for Python).</p>\n</li>\n<li>\n<p><code>propagatedBuildInputs</code>: Lists dependencies needed at runtime (e.g., <code>slurp</code>).</p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><strong>Build Format</strong>:</li>\n</ol>\n<ul>\n<li><code>format = \"pyproject\";</code> indicates that the package uses a <code>pyproject.toml</code>\nfile for its Python build configuration.</li>\n</ul>\n<p><strong>Integration within Nixpkgs</strong></p>\n<ul>\n<li>\n<p><strong>Location</strong>: The swaytools definition resides in\n<code>pkgs/tools/wayland/swaytools/default.nix</code>.</p>\n</li>\n<li>\n<p><strong>Top-Level Inclusion</strong>: It’s made available as a top-level package in\n<code>pkgs/top-level/all-packages.nix</code> like this:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\"># all-packages.nix\nswaytools = python3Packages.callPackage ../tools/wayland/swaytools { };\n</code></pre>\n<ul>\n<li><code>python3Packages.callPackage</code> is used here because <code>swaytools</code> is a Python\npackage, and it ensures the necessary Python-related dependencies are correctly\npassed to the <code>swaytools</code> definition.</li>\n</ul>\n</details>\n<h2>Conclusion</h2>\n<p>In this chapter, we’ve journeyed through the fundamental concept of package\ndefinitions in Nix. We’ve seen how these Nix expressions act as blueprints,\nleading to the creation of derivations – the detailed plans for building\nsoftware. Finally, we touched upon the realization process where Nix executes\nthese derivations to produce tangible packages in the Nix store. Examining the\nsimple “hello” package and the more complex “swaytools” definition provided\npractical insights into the structure and key attributes involved in defining\nsoftware within the Nix ecosystem.</p>\n<p>The crucial step in this process, the transformation from a package definition\nto a concrete build plan, is embodied by the <strong>derivation</strong>. This detailed\nspecification outlines every step Nix needs to take to fetch sources, build\ndependencies, compile code, and produce the final package output. Understanding\nthe anatomy and lifecycle of a derivation is key to unlocking the full power and\nflexibility of Nix.</p>\n<p>In the <strong>next chapter</strong>,\n<a href=\"https://saylesss88.github.io/Intro_to_Nix_Derivations_7.html\">Introduction to Nix Derivations</a>,\nwe will delve deeper into the structure and components of these derivations. We\nwill explore the attributes that define a build process, how dependencies are\nmanaged within a derivation, and how Nix ensures the reproducibility and\nisolation of your software builds through this fundamental concept.</p>\n<h2>Resources</h2>\n<ul>\n<li><a href=\"https://nix.dev/tutorials/packaging-existing-software.html\">Packaging Existing Software</a></li>\n</ul>\n",
      "date_published": "2025-11-21T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/Understanding_Top-Level_Attributes_5.html",
      "url": "https://saylesss88.github.io/Understanding_Top-Level_Attributes_5.html",
      "title": "Top-Level Attributes",
      "content_html": "<h1>Chapter 5</h1>\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<!-- ![coding1](images/coding1.png) -->\n<img src=\"images/gruv9.png\" width=\"800\" height=\"600\">\n<h2>Understanding Top-Level Attributes in NixOS Modules</h2>\n<p>This explanation is based on insights from Infinisil, a prominent figure in the\nNix community, to help clarify the concept of top-level attributes within NixOS\nmodules.</p>\n<h3>The Core of a NixOS System: <code>system.build.toplevel</code></h3>\n<details>\n<summary> ✔️ `system.build.toplevel` Explained (Click to Expand) </summary>\n<p>In a NixOS system, everything is built from a single “system derivation.” The\ncommand <code>nix-build '&lt;nixpkgs/nixos&gt;' -A system</code> initiates this build process.</p>\n<p>The <code>-A system</code> part tells Nix to focus on the <code>system</code> attribute defined in the\n<code>'&lt;nixpkgs/nixos&gt;'</code> file (which is essentially <code>./default.nix</code> within the\nNixpkgs repository).</p>\n<p>This <code>system</code> attribute is specifically the NixOS option <code>system.build.toplevel</code>\n. Think of <code>system.build.toplevel</code> as the <strong>very top of the configuration\nhierarchy</strong> for your entire NixOS system. Almost every setting you configure\neventually influences this top-level derivation, often through a series of\nintermediate steps.</p>\n<p><strong>Key Takeaway:</strong> <code>system.build.toplevel</code> is the ultimate output that defines\nyour entire NixOS system.</p>\n</details>\n<h3>How Options Relate: A Chain of Influence</h3>\n<p>Options in NixOS are not isolated; they often build upon each other.</p>\n<details>\n<summary>Example: Nginx Option Chain (Click to Expand)</summary>\n<p>Here’s an example of how a high-level option can lead down to a low-level system\nconfiguration:</p>\n<ul>\n<li>You enable Nginx with <code>services.nginx.enable = true;</code>.</li>\n<li>This setting influences the lower-level option <code>systemd.services.nginx</code>.</li>\n<li>Which, in turn, affects the even lower-level option\n<code>systemd.units.\"nginx.service\"</code>.</li>\n<li>Ultimately, this leads to the creation of a systemd unit file within\n<code>environment.etc.\"systemd/system\"</code>.</li>\n<li>Finally, this unit file ends up as <code>result/etc/systemd/system/nginx.service</code>\nwithin the final <code>system.build.toplevel</code> derivation.</li>\n</ul>\n</details>\n<p><strong>Key Takeaway:</strong> Higher-level, user-friendly options are translated into\nlower-level system configurations that are part of the final system build.</p>\n<h3>The NixOS Module System: Evaluating Options</h3>\n<p>So, how do these options get processed and turned into the final system\nconfiguration? That’s the job of the <strong>NixOS module system</strong>, located in the\n<code>./lib</code> directory of Nixpkgs (specifically in <code>modules.nix</code>, <code>options.nix</code>, and\n<code>types.nix</code>).</p>\n<p>Interestingly, the module system isn’t exclusive to NixOS; you can use it to\nmanage option sets in your own Nix projects.</p>\n<p>Here’s a simplified example of using the module system outside of NixOS:</p>\n<pre><code class=\"language-nix\">let\n  systemModule = { lib, config, ... }: {\n    options.toplevel = lib.mkOption {\n      type = lib.types.str;\n    };\n\n    options.enableFoo = lib.mkOption {\n      type = lib.types.bool;\n      default = false;\n    };\n\n    config.toplevel = ''\n      Is foo enabled? ${lib.boolToString config.enableFoo}\n    '';\n  };\n\n  userModule = {\n    enableFoo = true;\n  };\n\nin (import &lt;nixpkgs/lib&gt;).evalModules {\n  modules = [ systemModule userModule ];\n}\n</code></pre>\n<p><strong>You can evaluate the <code>config.toplevel</code> option from this example using:</strong></p>\n<pre><code class=\"language-bash\">nix-instantiate --eval file.nix -A config.toplevel\n</code></pre>\n<p><strong>Key Takeaway</strong>: The NixOS module system is responsible for evaluating and\nmerging option configurations from different modules.</p>\n<h3>How the Module System Works: A Simplified Overview</h3>\n<p>The module system processes a set of “modules” through these general steps:</p>\n<details>\n<summary> ✔️ Detailed Steps (Click to Expand)</summary>\n<ol>\n<li>\n<p><strong>Importing Modules</strong>: It recursively finds and includes all modules\nspecified in <code>imports = [ ... ];</code> statements.</p>\n</li>\n<li>\n<p><strong>Declaring Options</strong>: It collects all option declarations defined using\n<code>options = { ... };</code> from all the modules and merges them. If the same option\nis declared in multiple modules, the module system handles this (details\nomitted for simplicity).</p>\n</li>\n<li>\n<p><strong>Defining Option Values</strong>: For each declared option, it gathers all the\nvalue assignments (defined using <code>config = { ... };</code> or directly at the top\nlevel if no <code>options</code> or <code>config</code> are present) from all modules and merges\nthem according to the option’s defined type.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Important Note</strong>: Option evaluation is lazy, meaning an option’s value is\nonly computed when it’s actually needed. It can also depend on the values of\nother options.</p>\n</blockquote>\n</details>\n<p><strong>Key Takeaway</strong>: The module system imports, declares, and then evaluates option\nvalues from various modules to build the final configuration.</p>\n<p><strong>Top-Level Attributes in a Module: <code>imports</code>, <code>options</code>, and <code>config</code></strong></p>\n<p>Within a NixOS module (the files that define parts of your system configuration)\n, the attributes defined directly at the top level of the module’s function have\nspecific meanings:</p>\n<ul>\n<li>\n<p><code>imports</code>: This attribute is a list of other module files to include. Their\noptions and configurations will also be part of the evaluation.</p>\n</li>\n<li>\n<p><code>options</code>: This attribute is where you declare new configuration options. You\ndefine their type, default value, description, etc., using functions like\n<code>lib.mkOption</code> or <code>lib.mkEnableOption</code>.</p>\n</li>\n<li>\n<p><code>config</code>: This attribute is where you assign values to the options that have\nbeen declared (either in the current module or in imported modules).</p>\n</li>\n</ul>\n<p><strong>Key Takeaway</strong>: The top-level attributes <code>imports</code>, <code>options</code>, and <code>config</code>\nare the primary ways to structure a NixOS module.</p>\n<p><strong>The Rule: Move Non-Option Attributes Under <code>config</code></strong></p>\n<p>If you define either an <code>options</code> or a <code>config</code> attribute at the top level of\nyour module, any other attributes that are not option declarations must be moved\ninside the config attribute.</p>\n<details>\n<summary> ✔️ Examples of Correct and Incorrect Usage (Click to Expand)</summary>\n<p>Let’s look at an example of what not to do:</p>\n<pre><code class=\"language-nix\">{ pkgs, lib, config, ... }:\n{\nimports = [];\n\n# Defining an option at the top level\n\noptions.mine.desktop.enable = lib.mkEnableOption \"desktop settings\";\n\n# This will cause an error because 'environment' and 'appstream'\n\n# are not 'options' and 'config' is also present at the top level.jjjj\n\nenvironment.systemPackages =\nlib.mkIf config.appstream.enable [ pkgs.git ];\n\nappstream.enable = true;\n}\n</code></pre>\n<p>This will result in the error:\n<code>error: Module has an unsupported attribute 'appstream' This is caused by introducing a top-level 'config' or 'options' attribute. Add configuration attributes immediately on the top level instead, or move all of them into the explicit 'config' attribute</code>.</p>\n<p><strong>Key Takeaway</strong>: When you have <code>options</code> or <code>config</code> at the top level, all\nvalue assignments need to go inside the config block.</p>\n<p><strong>The Correct Way</strong>): Using the <code>config</code> Attribute</p>\n<p>To fix the previous example, you need to move the value assignments for\n<code>environment.systemPackages</code> and <code>appstream.enable</code> inside the config attribute:</p>\n<pre><code class=\"language-nix\">{ pkgs, lib, config, ... }:\n{\nimports = [];\n\n# Defining an option at the top level\n\noptions.mine.desktop.enable = lib.mkEnableOption \"desktop settings\";\n\nconfig = {\nenvironment.systemPackages =\nlib.mkIf config.appstream.enable [ pkgs.git ];\n\n    appstream.enable = true;\n\n};\n}\n</code></pre>\n<p>Now, Nix knows that you are declaring an option (<code>options.mine.desktop.enable</code>)\nand then setting values for other options (<code>environment.systemPackages</code>,\n<code>appstream.enable</code>) within the <code>config</code> block.</p>\n<p><strong>Key Takeaway</strong>: The <code>config</code> attribute is used to define the values of\noptions.</p>\n<p><strong>Implicit <code>config</code>: When <code>options</code> is Absent</strong></p>\n<p>If your module does not define either <code>options</code> or <code>config</code> at the top level,\nthen any attributes you define directly at the top level are implicitly treated\nas being part of the config.</p>\n<p>For example, this is valid:</p>\n<pre><code class=\"language-nix\">{ pkgs, lib, config, ... }:\n{\nenvironment.systemPackages =\nlib.mkIf config.appstream.enable [ pkgs.git ];\n\nappstream.enable = true;\n}\n</code></pre>\n<p>Nix will implicitly understand that <code>environment.systemPackages</code> and\n<code>appstream.enable</code> are configuration settings.</p>\n<p><strong>Key Takeaway</strong>: If no explicit options or config are present, top-level\nattributes are automatically considered part of the configuration.</p>\n<p><strong>Removing an Option: What Happens to <code>config</code></strong></p>\n<p>Even if you remove the <code>options</code> declaration from a module that has a <code>config</code>\nsection, the <code>config = { environment.systemPackages = ... };</code> part will still\nfunction correctly, assuming the option it’s referencing (<code>appstream.enable</code> in\nthis case) is defined elsewhere (e.g., in an imported module).</p>\n</details>\n<p><strong>Key Takeaway</strong>: The <code>config</code> section defines values for options, regardless of\nwhether those options are declared in the same module.</p>\n<h4>Conclusion</h4>\n<p>Understanding the nuances of top-level attributes within NixOS modules,\nparticularly <code>imports</code>, <code>options</code>, and <code>config</code>, is fundamental to structuring\nand managing your system’s configuration effectively. As we’ve seen, the module\nsystem provides a powerful and declarative way to define and evaluate system\nsettings, ultimately contributing to the construction of the\n<code>system.build.toplevel</code> derivation that represents your entire NixOS\nenvironment.</p>\n<p>The concepts of option declaration and value assignment, along with the crucial\nrule of organizing non-option attributes under the <code>config</code> attribute when\n<code>options</code> is present, provide a clear framework for building modular and\nmaintainable configurations.</p>\n<p>Now that we have a solid grasp of how NixOS modules are structured and how they\ncontribute to the final system derivation, it’s a natural next step to explore\nthe tangible results of these configurations: the software and system components\nthemselves. These are built and managed by a core concept in Nix, known as\n<strong>derivations</strong>.</p>\n<p>In the next chapter,\n<a href=\"https://saylesss88.github.io/Package_Definitions_Explained_6.html\">Package Definitions Explained</a>\nwe will shift our focus from the abstract configuration to the concrete software\npackages. We will learn how Nix uses <em>package definitions</em> to create\n<em>derivations</em>, which are the actual build plans that produce the software we use\non our NixOS systems. This will bridge the gap between configuring your system\nand understanding how the software within it is managed.</p>\n",
      "date_published": "2025-11-21T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/Nix_Flakes_Explained_4.html",
      "url": "https://saylesss88.github.io/Nix_Flakes_Explained_4.html",
      "title": "Nix Flakes Explained",
      "content_html": "<h1>Chapter 4</h1>\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<p><img src=\"images/trees3.cleaned.png\" alt=\"trees3\" /></p>\n<!-- <img src=\"images/gruv15.png\" width=\"800\" height=\"600\"> -->\n<h2>Nix Flakes Explained</h2>\n<p>If you’re completely new, take a look at\n<a href=\"https://nixos.wiki/wiki/flakes#Installing_flakes\">this</a> to get flakes on your\nsystem.</p>\n<p>For the Nix Flake man page type <code>man nix3 flake</code> and for a specific feature,\ntype something like <code>man nix3 flake-lock</code>.</p>\n<p>Flakes replace stateful channels (which cause much confusion among novices) and\nintroduce a more intuitive and consistent CLI, making them a perfect opportunity\nto start using Nix. – Alexander Bantyev\n<a href=\"https://serokell.io/blog/practical-nix-flakes\">Practical Nix Flakes</a></p>\n<p>The “state” being remembered and updated by channels is the specific revision of\nthe Nixpkgs repository that your local Nix installation considers “current” for\na given channel. When this state changes on your machine, your builds diverge\nfrom others whose machines have a different, independently updated channel\nstate.</p>\n<p>Channels are also constantly updated on the remote servers. So, “nixos-unstable”\ntoday refers to a different set of packages and versions than “nixos-unstable”\ndid yesterday or will tomorrow.</p>\n<p>Flakes solve this by making the exact revision of <code>nixpkgs</code> (and other\ndependencies) an explicit input within your <code>flake.nix</code> file, pinned in the\n<code>flake.lock</code>. This means the state is explicitly defined in the configuration\nitself, not implicitly managed by a global system setting.</p>\n<p>Evaluation time is notoriously slow on NixOS, the problem was that in the past\nNix evaluation wasn’t hermetic preventing effective evaluation caching. A <code>.nix</code>\nfile can import other Nix files or by looking them up in the Nix search path\n(<code>$NIX_PATH</code>). This causes a cached result to be inconsistent unless every file\nis perfectly kept track of. Flakes solve this problem by ensuring fully hermetic\nevaluation.</p>\n<p>“Hermetic” means that the output of an evaluation (the derivation itself)\ndepends <em>only</em> on the explicit inputs provided, not on anything external like\nenvironment variables or pulling in files only on your system. This is the\nproblem that Nix solves and the problem that flakes are built around.</p>\n<h2>What is a Nix Flake?</h2>\n<p><strong>Nix flakes</strong> are independent components in the Nix ecosystem. They define\ntheir own <strong>dependencies</strong> (inputs) and what they produce (outputs), which can\ninclude <strong>packages</strong>, <strong>deployment configurations</strong>, or <strong>Nix functions</strong> for\nother flakes to use.</p>\n<p>Flakes provide a standardized framework for building and managing software,\nmaking all project inputs explicit for greater reproducibility and\nself-containment.</p>\n<p>At its core, a flake is a source tree (like a Git repository) that contains a\n<code>flake.nix</code> file in its root directory. This file provides a standardized way to\naccess Nix artifacts such as packages and modules.</p>\n<p>Flakes provide a standard way to write Nix expressions (and therefore packages)\nwhose dependencies are version-pinned in a lock file, improving reproducibility\nof Nix installations. – NixOS Wiki</p>\n<p>Think of <code>flake.nix</code> as the central entry point of a flake. It not only defines\nwhat the flake produces but also declares its dependencies.</p>\n<h3>Key Concepts</h3>\n<p><code>flake.nix</code>: <strong>The Heart of a Flake</strong></p>\n<p>The <code>flake.nix</code> file is mandatory for any flake. It must contain an attribute\nset with at least one required attribute: <code>outputs</code>. It can also optionally\ninclude <code>description</code> and <code>inputs</code>.</p>\n<p><strong>Basic Structure:</strong></p>\n<pre><code class=\"language-nix\">{\n  description = \"Package description\";\n  inputs = { /* Dependencies go here */ };\n  outputs = { /* What the flake produces */ };\n  nixConfig = { /* Advanced configuration options */ };\n}\n</code></pre>\n<p>I typically see <code>nixConfig</code> used for extra-substituters for cachix. This is a\ngeneral-purpose way to define Nix configuration options that apply when this\nflake is evaluated or built. It ties into your <code>/etc/nix/nix.conf</code> or\n<code>~/.config/nix/nix.conf</code>.</p>\n<p>For example, create a directory and add a <code>flake.nix</code> with the following\ncontents, yes this is a complete <code>flake.nix</code> demonstrating <em>outputs</em> being the\nonly required attribute:</p>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  outputs = _: { multiply = 2 * 2; };\n}\n</code></pre>\n<p>Now evaluate it with:</p>\n<pre><code class=\"language-bash\">nix eval .#multiply\n4\n</code></pre>\n<p>In the <code>outputs = _: { ... };</code> line, the <code>_</code> (underscore) is a placeholder\nargument. It represents the inputs that the outputs function could receive (like\n<code>inputs</code>, <code>self</code>, <code>pkgs</code>, etc.), but in this specific case, we’re not using any\nof them to define the multiply attribute. It’s a common convention in Nix to use\n<code>_</code> when an argument is required by a function but intentionally ignored.</p>\n<p>In the command <code>nix eval .#multiply</code>:</p>\n<ul>\n<li>\n<p>the <code>.</code> signifies the current directory, indicating that Nix should look for a\n<code>flake.nix</code> file in the directory where you’re running the command.</p>\n</li>\n<li>\n<p>The <code>#</code> is used to select a specific attribute from the <code>outputs</code> of the\nflake. In this case, it’s telling Nix to evaluate the <code>multiply</code> attribute.</p>\n</li>\n</ul>\n<p>In the next example we will create a <code>devShells</code> output as well as a <code>packages</code>\noutput.</p>\n<p><strong><code>flake.lock</code> auto-generated lock file</strong></p>\n<p>All flake inputs are pinned to specific revisions in a lockfile called\n<code>flake.lock</code> This file stores the revision info as JSON.</p>\n<p>The <code>flake.lock</code> file ensures that Nix flakes have purely deterministic outputs.\nA <code>flake.nix</code> file without an accompanying <code>flake.lock</code> should be considered\nincomplete and a kind of proto-flake. Any Nix CLI command that is run against\nthe flake—like <code>nix build</code>, <code>nix develop</code>, or even <code>nix flake show</code>—generates a\n<code>flake.lock</code> for you.</p>\n<p>Here’s an example section of a <code>flake.lock</code> file that pins Nixpkgs to a specific\nrevision:</p>\n<pre><code class=\"language-bash\">$ cat flake.lock\n{\n  \"nodes\": {\n    \"nixpkgs\": {\n      \"info\": {\n        \"lastModified\": 1587398327,\n        \"narHash\": \"sha256-mEKkeLgUrzAsdEaJ/1wdvYn0YZBAKEG3AN21koD2AgU=\"\n      },\n      \"locked\": {\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"5272327b81ed355bbed5659b8d303cf2979b6953\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"ref\": \"nixos-20.03\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"root\": {\n      \"inputs\": {\n        \"nixpkgs\": \"nixpkgs\"\n      }\n    }\n  },\n  \"root\": \"root\",\n  \"version\": 5\n}\n</code></pre>\n<p>Any future build of this flake will use the version of <code>nixpkgs</code> recorded in the\nlock file. If you add new inputs, they will be automatically added when you run\na nix flake command like <code>nix flake show</code>. But it won’t replace existing locks.</p>\n<p>If you need to update a locked input to the latest version:</p>\n<pre><code class=\"language-bash\">nix flake lock --update-input nixpkgs\nnix build\n</code></pre>\n<p>The above command allows you to update individual inputs, and <code>nix flake update</code>\nwill update the whole lock file.</p>\n<h3>Helper functions that are good to know for working with Flakes</h3>\n<p><code>lib.genAttrs</code>: A function, given the name of the attribute, returns the\nattribute’s value</p>\n<p>Example:</p>\n<pre><code class=\"language-nix\">nix repl\nnix-repl&gt; :l &lt;nixpkgs&gt;\nnix-repl&gt; lib.genAttrs [ \"boom\" \"bash\" ] (name: \"sonic\" + name)\n</code></pre>\n<p><strong>Output</strong>:</p>\n<pre><code class=\"language-nix\">{\n  bash = \"sonicbash\";\n  boom = \"sonicboom\";\n}\n</code></pre>\n<p>You will often see the following:</p>\n<p>A common use for this with flakes is to have a list of different systems:</p>\n<pre><code class=\"language-nix\">     systems = [\n       \"x86_64-linux\"\n       \"aarch64-linux\"\n       \"x86_64-darwin\"\n       \"aarch64-darwin\"\n     ];\n</code></pre>\n<p>And use it to generate an attribute set for each listed system:</p>\n<pre><code class=\"language-nix\">eachSystem = lib.genAttrs systems;\n</code></pre>\n<p>The above command creates an attribute set by mapping over a list of system\nstrings. If you notice, you provide it a list (i.e. [ 1 2 3 ]) and the function\nreturns a set (i.e. <code>{ ... }</code>)</p>\n<p>Why <code>genAttrs</code> is useful:</p>\n<ul>\n<li>\n<p>It lets you define attributes (like <code>packages</code>, <code>checks</code>, <code>devShells</code>) per\nsupported system in a DRY(don’t repeat yourself), structured way.</p>\n</li>\n<li>\n<p><code>lib.mapAttrs</code>: A function, given an attribute’s name and value, returns a new\n<code>nameValuePair</code>.</p>\n</li>\n</ul>\n<p>Example:</p>\n<pre><code class=\"language-nix\">nix-repl&gt; builtins.mapAttrs (name: value: name + \"-\" + value) { x = \"foo\"; y = \"bar\"; }\n</code></pre>\n<p><strong>Output</strong>:</p>\n<pre><code class=\"language-nix\">{\n  x = \"x-foo\";\n  y = \"y-bar\";\n}\n</code></pre>\n<p><code>pkgs.mkShell</code>: is a specialized <code>stdenv.mkDerivation</code> that removes some\nrepetition when using it with <code>nix-shell</code> (or <code>nix develop</code>)</p>\n<p>Example:</p>\n<pre><code class=\"language-nix\">{ pkgs ? import &lt;nixpkgs&gt; {} }:\npkgs.mkShell {\n  packages = [ pkgs.gnumake ];\n\n  inputsFrom = [ pkgs.hello pkgs.gnutar ];\n\n  shellHook = ''\n    export DEBUG=1\n  '';\n}\n</code></pre>\n<h4>A Simple flake that outputs a devshell and a package</h4>\n<p>In a new directory create a <code>flake.nix</code></p>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  outputs = {\n    self,\n    nixpkgs,\n  }: let\n    pkgs = nixpkgs.legacyPackages.x86_64-linux;\n  in {\n\n    packages.x86_64-linux.default = pkgs.kakoune; # You could define a meta-package here\n\n    devShells.x86_64-linux.default = pkgs.mkShell {\n      packages = [\n        pkgs.kakoune\n        pkgs.git\n        pkgs.ripgrep\n        pkgs.fzf\n      ];\n    };\n  };\n}\n</code></pre>\n<p><code>mkShell</code> is a wrapper around <code>mkDerivation</code></p>\n<p>This flake offers two main outputs for <code>x86_64-linux</code> systems:</p>\n<ol>\n<li>\n<p>A <strong>standard package</strong> (<code>packages.x86_64-linux.default</code>): This simple example\njust re-exports <code>kakoune</code> from <code>nixpkgs</code>. You could build your own apps here.</p>\n</li>\n<li>\n<p>A <strong>development shell</strong> (<code>devShells.x86_64-linux.default</code>): This provides a\nconvenient environment where you have specific tools available without\ninstalling them globally on your system.</p>\n</li>\n</ol>\n<p>To use this flake you have a few options:</p>\n<ul>\n<li>\n<p><code>nix run</code> will launch kakoune</p>\n</li>\n<li>\n<p><code>nix develop</code> will activate the development environment providing all of the\npkgs listed under <code>mkShell</code>.</p>\n</li>\n<li>\n<p>Or more explicitly <code>nix develop .#devShells.x86_64-linux.default</code>, does the\nsame thing as the command above.</p>\n</li>\n</ul>\n<h4>Flake References</h4>\n<details>\n<summary> ✔️ Flake References (Click to Expand) </summary>\n<p><strong>Flake references</strong> (flakerefs) are a way to specify the location of a flake.\nThey have two different formats:</p>\n<blockquote>\n<p><strong>Attribute set representation</strong>:</p>\n<pre><code class=\"language-nix\">{\n  type = \"github\";\n  owner = \"NixOS\";\n  repo = \"nixpkgs\";\n}\n</code></pre>\n<p>or <strong>URL-like syntax</strong>:</p>\n<pre><code class=\"language-nix\">github:NixOS/nixpkgs\n</code></pre>\n<p>These are used on the command line as a more convenient alternative to the\nattribute set representation. For instance, in the command</p>\n<pre><code class=\"language-nix\">nix build github:NixOS/nixpkgs#hello\n</code></pre>\n<p><code>github:NixOS/nixpkgs</code> is a flake reference (while <code>hello</code> is an output\nattribute). They are also allowed in the <code>inputs</code> attribute of a flake, e.g.</p>\n<pre><code class=\"language-nix\">inputs.nixpkgs.url = \"github:NixOS/nixpkgs\";\n</code></pre>\n<p>is equivalent to</p>\n<pre><code class=\"language-nix\">inputs.nixpkgs = {\n  type = \"github\";\n  owner = \"NixOS\";\n  repo = \"nixpkgs\";\n};\n</code></pre>\n<p>–\n<a href=\"https://nix.dev/manual/nix/2.24/command-ref/new-cli/nix3-flake#flake-references\">nix.dev flake-references</a></p>\n</blockquote>\n</details>\n<h4>Nix Flake Commands</h4>\n<details>\n<summary> ✔️ Flake Commands (Click to Expand) </summary>\n<blockquote>\n<p><code>nix flake</code> provides subcommands for creating, modifying and querying <em>Nix\nFlakes</em>. Flakes are the unit for packaging Nix code in a reproducible and\ndiscoverable way. They can have dependencies on other flakes, making it\npossible to have multi-repository Nix projects.</p>\n</blockquote>\n<p>— From\n<a href=\"https://nix.dev/manual/nix/2.28/command-ref/new-cli/nix3-flake\">nix.dev Reference Manual</a></p>\n<ul>\n<li>\n<p>The main thing to note here is that <code>nix flake</code> is used to manage Nix flakes\nand that Flake commands are whitespace separated rather than hyphen <code>-</code>\nseparated.</p>\n</li>\n<li>\n<p>Flakes do provide some advantages when it comes to discoverability of outputs.</p>\n</li>\n<li>\n<p>For Example, two helpful commands to inspect a flake are:</p>\n<ul>\n<li>\n<p><a href=\"https://nix.dev/manual/nix/2.28/command-ref/new-cli/nix3-flake-show\">nix flake show</a>\ncommand: Show the outputs provided by a flake.</p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/manual/nix/2.28/command-ref/new-cli/nix3-flake-check\">nix flake check</a>\ncommand: check whether the flake evaluates and run its tests.</p>\n</li>\n<li>\n<p>Any Nix CLI command that is run against a flake – like <code>nix build</code>,\n<code>nix develop</code>, <code>nix flake show</code> – generate a <code>flake.lock</code> file for you.</p>\n<ul>\n<li>The <code>flake.lock</code> file ensures that all flake inputs are pinned to specific\nrevisions and that Flakes have purely deterministic outputs.</li>\n</ul>\n</li>\n</ul>\n<p>Example:</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">nix shell nixpkgs#ponysay --command ponysay \"Flakes Rock!\"\n</code></pre>\n<p>This works because of the [flake registry] that maps symbolic identifiers like\n<code>nixpkgs</code> to actual locations such as <code>https://github.com/NixOS/nixpkgs</code>. So the\nfollowing are equivalent:</p>\n<pre><code class=\"language-bash\">nix shell nixpkgs#ponysay --command ponysay Flakes Rock!\nnix shell github:NixOS/nixpkgs#ponysay --command ponysay Flakes Rock!\n</code></pre>\n<p>To override the <code>nixpkgs</code> registry with your own local copy you could:</p>\n<pre><code class=\"language-bash\">nix registry add nixpkgs ~/src/local-nixpkgs\n</code></pre>\n</details>\n<h3>Attribute Sets: The Building Blocks</h3>\n<details>\n<summary> ✔️ Attribute set Refresher (Click to Expand) </summary>\n<p><strong>Attribute sets</strong> are fundamental in Nix. They are simply collections of\nname-value pairs wrapped in curly braces <code>{}</code>.</p>\n<ul>\n<li>Example, (click to see Output):</li>\n</ul>\n<pre><code class=\"language-nix\">let\n  my_attrset = { foo = \"bar\"; };\nin\nmy_attrset.foo\n~ \"bar\"\n</code></pre>\n<p><strong>Top-Level Attributes of a Flake</strong>:</p>\n<p>Flakes have specific <strong>top-level attributes</strong> that can be accessed directly\n(without dot notation). The most common ones are <code>inputs</code>, <code>outputs</code>, and\n<code>nixConfig</code>.</p>\n  </details>\n<h3>Deeper Dive into the Structure of <code>flake.nix</code></h3>\n<!-- ![Flakes](images/Flakes.png) -->\n<p><code>inputs</code>: <strong>Declaring Dependencies</strong></p>\n<p>The <code>inputs</code> attribute set specifies the other flakes that your current flake\ndepends on.</p>\n<p>Each key in the <code>inputs</code> set is a name you choose for the dependency, and the\nvalue is a reference to that flake (usually a URL or a Git Repo).</p>\n<p>To access something from a dependency, you generally go through the <code>inputs</code>\nattribute (e.g., <code>inputs.helix.packages</code>).</p>\n<p>See\n<a href=\"https://saylesss88.github.io/flakes/flake_inputs_4.1.html\">Nix Flake inputs</a>\nfor a flake inputs deep dive.</p>\n<p><strong>Example:</strong> This declares dependencies on the <code>nixpkgs</code> and <code>import-cargo</code>\nflakes:</p>\n<pre><code class=\"language-nix\">inputs = {\n  import-cargo.url = \"github:edolstra/import-cargo\";\n  nixpkgs.url = \"nixpkgs\";\n};\n</code></pre>\n<p>When Nix evaluates your flake, it fetches and evaluates each input. These\nevaluated inputs are then passed as an attribute set to the outputs function,\nwith the keys matching the names you gave them in the inputs set.</p>\n<p>The special input <code>self</code> is a reference to the <code>outputs</code> and the source tree of\nthe current flake itself.</p>\n<p><strong><code>outputs</code>: Defining What Your Flake Provides</strong></p>\n<p>The <strong><code>outputs</code></strong> attribute defines what your flake makes available. This can\ninclude packages, NixOS modules, development environments (<code>devShells</code>) and\nother Nix derivations.</p>\n<p>Flakes can output arbitrary Nix values. However, certain outputs have specific\nmeanings for Nix commands and must adhere to particular types (often\nderivations, as described in the\n<a href=\"https://nixos.wiki/wiki/Flakes\">output schema</a>).</p>\n<p>You can inspect the outputs of a flake using the command:</p>\n<pre><code class=\"language-nix\">nix flake show\n</code></pre>\n<blockquote>\n<p>This command takes a flake URI and displays its outputs in a tree structure,\nshowing the attribute paths and their corresponding types.</p>\n</blockquote>\n<p><strong>Understanding the <code>outputs</code> Function</strong></p>\n<p>Beginners often mistakenly think that self and nixpkgs within\n<code>outputs = { self, nixpkgs, ... }: { ... }</code> are the outputs themselves. Instead,\nthey are the <em>input arguments</em> (often called <em>output arguments</em>) to the outputs\nfunction.</p>\n<p>The outputs function in <code>flake.nix</code> always takes a single argument, which is an\nattribute set. The syntax <code>{ self, nixpkgs, ... }</code> is Nix’s way of destructuring\nthis single input attribute set to extract the values associated with the keys\n<code>self</code> and <code>nixpkgs</code>.</p>\n<p>Flakes output your whole system configuration, packages, as well as Nix\nfunctions for use elsewhere.</p>\n<ul>\n<li>\n<p>For example, the <code>nixpkgs</code> repository has its own <code>flake.nix</code> file that\noutputs many helper functions via the <code>lib</code> attribute.</p>\n</li>\n<li>\n<p>For a deep dive into flake outputs, see\n<a href=\"https://saylesss88.github.io/flakes/flake_outputs_4.2.html\">Nix Flake Outputs</a></p>\n</li>\n</ul>\n<blockquote>\n<p>The <code>lib</code> convention The convention of using <code>lib</code> to output functions is\nobserved not just by Nixpkgs but by many other Nix projects. You’re free,\nhowever, to output functions via whichever attribute you prefer. –\n<a href=\"https://zero-to-nix.com/concepts/flakes/#inputs\">Zero to Nix Flakes</a></p>\n</blockquote>\n<p>Some flake outputs are required to be system specific (i.e. “x86_64-linux” for\n(64-bit AMD/Intel Linux) including packages, development environments, and NixOS\nconfigurations)</p>\n<p><strong>Variadic Attributes (…) and @-patterns</strong></p>\n<p>The <code>...</code> syntax in the input arguments of the outputs function indicates\nvariadic attributes, meaning the input attribute set can contain more attributes\nthan just those explicitly listed (like <code>lib</code> and <code>nixpkgs</code>).</p>\n<p><strong>Example:</strong></p>\n<pre><code class=\"language-nix\">mul = { a, b, ... }: a * b;\nmul { a = 3; b = 4; c = 2; } # 'c' is an extra attribute\n</code></pre>\n<p>However, you cannot directly access these extra attributes within the function\nbody unless you use the @-pattern:</p>\n<ul>\n<li>(Click for Output)</li>\n</ul>\n<pre><code class=\"language-nix\">mul = s@{ a, b, ... }: a  b  s.c; # 's' now refers to the entire input set\nmul { a = 3; b = 4; c = 2; } # Output: 24\n~ 24\n</code></pre>\n<p>When used in the outputs function argument list (e.g.,\n<code>outputs = { pkgs, ... } @ inputs)</code>, the @-pattern binds the entire input\nattribute set to a name (in this case, <code>inputs</code>) while also allowing you to\ndestructure specific attributes like pkgs.</p>\n<p><strong>What <code>outputs = { pkgs, ... } @ inputs: { ... };</code> does:</strong></p>\n<ol>\n<li>\n<p><strong>Destructuring:</strong> It tries to extract the value associated with the key\n<code>pkgs</code> from the input attribute set and binds it to the variable <code>pkgs</code>. The\n<code>...</code> allows for other keys in the input attribute set to be ignored during\nthis direct destructuring.</p>\n</li>\n<li>\n<p><strong>Binding the Entire Set:</strong> It binds the entire input attribute set to the\nvariable inputs.</p>\n<ul>\n<li>Example <code>flake.nix</code>:</li>\n</ul>\n</li>\n</ol>\n<pre><code class=\"language-nix\">{\ninputs.nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\ninputs.home-manager.url = \"github:nix-community/home-manager\";\n\noutputs = { self, nixpkgs, ... } @ attrs: { # A `packages` output for the x86_64-linux platform\npackages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello;\n\n    # A `nixosConfigurations` output (for a NixOS system named \"fnord\")\n    nixosConfigurations.fnord = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      specialArgs = attrs;\n      modules = [ ./configuration.nix ];\n    };\n\n};\n}\n</code></pre>\n<p><strong>Platform Specificity in Outputs</strong></p>\n<p>Flakes ensure that their outputs are consistent across different evaluation\nenvironments. Therefore, any package-related output must explicitly specify the\ntarget platform (a combination of architecture and OS, <code>x86_64-linux</code>).</p>\n<p><strong>legacyPackages Explained</strong></p>\n<p><code>legacyPackages</code> is a way for flakes to interact with the traditional, less\nstructured package organization of nixpkgs. Instead of packages being directly\nat the top level (e.g., <code>pkgs.hello</code>), <code>legacyPackages</code> provides a\nplatform-aware way to access them within the flake’s structured output format\n(e.g., <code>nixpkgs.legacyPackages.x86_64-linux.hello</code>). It acts as a bridge between\nthe flake’s expected output structure and nixpkgs’s historical organization.</p>\n<p><strong>The Sole Argument of outputs</strong></p>\n<p>It’s crucial to remember that the outputs function accepts only one argument,\nwhich is an attribute set. The <code>{ self, nixpkgs, ... }</code> syntax is simply\ndestructuring that single input attribute set.</p>\n<p><strong>Outputs of the Flake (Return Value)</strong></p>\n<p>The outputs of the flake refer to the attribute set that is returned by the\n<code>outputs</code> function. This attribute set can contain various named outputs like\n<code>packages</code>, <code>nixosConfigurations</code>, <code>devShells</code>, etc.</p>\n<p><strong>Imports: Including Other Nix Expressions</strong></p>\n<p>The <code>import</code> function in Nix is used to evaluate the Nix expression found at a\nspecified path (usually a file or directory) and return its value.</p>\n<p>Basic Usage: import <code>./path/to/file.nix</code></p>\n<p><strong>Passing Arguments During Import</strong></p>\n<p><code>import &lt;nixpkgs&gt; {}</code> is calling two functions, not one.</p>\n<ol>\n<li><code>import &lt;nixpkgs&gt;</code>: The first function call</li>\n</ol>\n<ul>\n<li>\n<p><code>import</code> is a built-in Nix function. Its job is to load and evaluate a Nix\nexpression from a specified path.</p>\n</li>\n<li>\n<p><code>&lt;nixpkgs&gt;</code> is a flake reference. When you use <code>import &lt;nixpkgs&gt;</code>, Nix\nevaluates the <code>default.nix</code> file (or sometimes <code>lib/default.nix</code>) found at\nthat location.</p>\n</li>\n<li>\n<p>The <code>default.nix</code> in <code>nixpkgs</code> evaluates to a function. This function is\ndesigned to be configurable, allowing you to pass arguments like <code>system</code>,\n<code>config</code>, etc. to customize how <code>nixpkgs</code> behaves and what packages it\nprovides.</p>\n</li>\n<li>\n<p>So, <code>import &lt;nixpkgs&gt;</code> doesn’t give you the <code>nixpkgs</code> package set directly; it\ngives you the function that generates the <code>nixpkgs</code> package set derivation.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><code>{}</code>: The second function call (and its argument)</li>\n</ol>\n<ul>\n<li>\n<p><code>{}</code> denotes an empty attribute set</p>\n</li>\n<li>\n<p>When an attribute set immediately follows a function, it means you are calling\nthat function and passing the attribute set as its single argument.</p>\n</li>\n</ul>\n<p>So, the <code>{}</code> after <code>import &lt;nixpkgs&gt;</code> is not part of the <code>import</code> function\niteself. It’s the argument being passed to the function that <code>import &lt;nixpkgs&gt;</code>\njust returned.</p>\n<p>You can also pass an attribute set as an argument to the Nix expression being\nimported:</p>\n<pre><code class=\"language-nix\">let\nmyHelpers = import ./lib/my-helpers.nix { pkgs = nixpkgs; };\nin\n# ... use myHelpers\n</code></pre>\n<p>In this case, the Nix expression in <code>./lib/my-helpers.nix</code> is likely a function\nthat expects an argument (often named <code>pkgs</code> by convention):</p>\n<pre><code class=\"language-nix\"># ./lib/my-helpers.nix\n\n{ pkgs }:\nlet\nmyPackage = pkgs.stdenv.mkDerivation {\nname = \"my-package\"; # ...\n};\nin\nmyPackage\n</code></pre>\n<p>By passing <code>{ pkgs = nixpkgs; }</code> during the import, you are providing the\nnixpkgs value from your current <code>flake.nix</code> scope to the pkgs parameter expected\nby the code in <code>./lib/my-helpers.nix</code>.</p>\n<p><strong>Importing Directories (<code>default.nix</code>)</strong></p>\n<p>When you use import with a path that points to a directory, Nix automatically\nlooks for a file named <code>default.nix</code> within that directory. If found, Nix\nevaluates the expressions within <code>default.nix</code> as if you had specified its path\ndirectly in the import statement.</p>\n<ul>\n<li>For more advanced examples see\n<a href=\"https://saylesss88.github.io/flakes/flake_examples_4.3.html\">Nix Flake Examples</a></li>\n</ul>\n<h5>Conclusion: Unifying Your Nix Experience with Flakes</h5>\n<p>For some examples of more advanced outputs like <code>devShells</code> and <code>checks</code>, check\nout this blog post that I wrote:\n<a href=\"https://tsawyer87.github.io/posts/nix_flakes_tips/\">Nix Flakes Tips and Tricks</a></p>\n<p>In this chapter, we’ve explored Nix Flakes as a powerful and modern approach to\nmanaging Nix projects, from development environments to entire system\nconfigurations. We’ve seen how they provide structure, dependency management,\nand reproducibility through well-defined inputs and outputs. Flakes offer a\ncohesive way to organize your Nix code and share it with others.</p>\n<p>As we’ve worked with the flake.nix file, you’ve likely noticed its structure – a\ntop-level attribute set defining various outputs like devShells, packages,\nnixosConfigurations, and more. These top-level attributes are not arbitrary;\nthey follow certain conventions and play specific roles within the Flake\necosystem.</p>\n<p>In the next chapter,\n<a href=\"https://saylesss88.github.io/Understanding_Top-Level_Attributes_5.html\">Understanding Top-Level Attributes</a>\nwe will delve deeper into the meaning and purpose of these common top-level\nattributes. We’ll explore how they are structured, what kind of expressions they\ntypically contain, and how they contribute to the overall functionality and\norganization of your Nix Flakes. Understanding these attributes is key to\neffectively leveraging the full potential of Nix Flakes.</p>\n<h5>Further Resources</h5>\n<details>\n<summary> ✔️ Resources (Click to Expand)</summary>\n<ul>\n<li>\n<p><a href=\"https://serokell.io/blog/practical-nix-flakes\">practical-nix-flakes</a></p>\n</li>\n<li>\n<p><a href=\"https://xeiaso.net/blog/nix-flakes-1-2022-02-21/\">Nix Flakes an Introduction</a></p>\n</li>\n<li>\n<p><a href=\"https://www.tweag.io/blog/2020-07-31-nixos-flakes/\">tweag nix-flakes</a></p>\n</li>\n<li>\n<p><a href=\"https://nixos.wiki/wiki/Flakes\">NixOS-wiki Flakes</a></p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/concepts/flakes.html\">nix.dev flakes</a></p>\n</li>\n<li>\n<p><a href=\"https://vtimofeenko.com/posts/practical-nix-flake-anatomy-a-guided-tour-of-flake.nix/\">anatomy-of-a-flake</a></p>\n</li>\n<li>\n<p><a href=\"https://jade.fyi/blog/flakes-arent-real/\">flakes-arent-real</a></p>\n</li>\n<li>\n<p><a href=\"https://mhwombat.codeberg.page/nix-book/#_attribute_set_operations\">wombats-book-of-nix</a></p>\n</li>\n<li>\n<p><a href=\"https://zero-to-nix.com/concepts/flakes/\">zero-to-nix flakes</a></p>\n</li>\n<li>\n<p><a href=\"https://nixos-and-flakes.thiscute.world/\">nixos-and-flakes-book</a></p>\n</li>\n<li>\n<p><a href=\"https://flakehub.com/\">FlakeHub</a></p>\n</li>\n</ul>\n<p><img src=\"images/nixosnix.png\" alt=\"FlakeHub\" /></p>\n</details>\n",
      "date_published": "2025-11-21T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/NixOS_Modules_Explained_3.html",
      "url": "https://saylesss88.github.io/NixOS_Modules_Explained_3.html",
      "title": "Nix Module System Explained",
      "content_html": "<h1>Chapter 3</h1>\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<h2>Nix Module System Explained</h2>\n<!-- ![gruv3](images/gruv3.png) -->\n<p><img src=\"images/buildings1.png\" alt=\"buildings\" /></p>\n<p><strong>TL;DR</strong>: In this chapter, we will break down the Nix module system used by\nboth NixOS and Home-Manager. We will discuss using home-manager as a module and\nthe flexibility that modules give us. We will touch on options and break down\nthe <code>vim</code> module from the Nixpkgs collection. Finally we will display how to\ntest modules with the repl.</p>\n<p>Your <code>configuration.nix</code> is a module. For the Nixpkgs collection most modules\nare in <code>nixos/modules</code>.</p>\n<p>The suggested way of using <code>home-manager</code> according to their manual is as a\n<a href=\"https://nix-community.github.io/home-manager/index.xhtml#sec-install-nixos-module\">NixOS module</a>.\nBoth home-manager and NixOS use the same module system.</p>\n<h2>Module Structure</h2>\n<pre><code class=\"language-nix\">{\n  imports = [\n    # Paths to other modules.\n    # Compose this module out of smaller ones.\n  ];\n\n  options = {\n    # Option declarations.\n    # Declare what settings a user of this module can set.\n    # Usually this includes a global \"enable\" option which defaults to false.\n  };\n\n  config = {\n    # Option definitions.\n    # Define what other settings, services and resources should be active.\n    # Usually these depend on whether a user of this module chose to \"enable\" it\n    # using the \"option\" above.\n    # Options for modules imported in \"imports\" can be set here.\n  };\n}\n</code></pre>\n<p><code>imports</code>, <code>options</code>, and <code>config</code> are the top-level attributes of a Nix module.\nThey are the primary, reserved keys that the Nix module system recognizes and\nprocesses to combine different configurations into a single, cohesive system or\nuser environment. <code>config</code> is the same <code>config</code> you receive as a module argument\n(e.g. <code>{ pkgs, config, ... }:</code> at the top of your module function)</p>\n<p>Understanding <code>config</code>:</p>\n<p><code>config</code> is the big constantly updated blueprint of your entire system.</p>\n<p>Every time you bring in a new module, it adds its own settings and options to\nthis blueprint. So, when a module receives the <code>config</code> argument, it’s getting\nthe complete picture of everything you’ve asked NixOS to set up so far.</p>\n<p>This allows the module to:</p>\n<ul>\n<li>\n<p>See what other parts of your system are doing.</p>\n</li>\n<li>\n<p>Make smart decisions based on those settings.</p>\n</li>\n<li>\n<p>Add its own pieces to the overall plan, building on what’s already there.</p>\n</li>\n<li>\n<p>Most modules are functions that take an attribute set and return an attribute\nset.</p>\n</li>\n</ul>\n<p>To turn the above module into a function accepting an attribute set just add the\nfunction arguments to the top, click the eye to see the whole module:</p>\n<pre><code class=\"language-nix\">{ config, pkgs, ... }:\n~ {\n~   imports = [\n~     # Paths to other modules.\n~     # Compose this module out of smaller ones.\n~   ];\n~\n~   options = {\n~     # Option declarations.\n~     # Declare what settings a user of this module can set.\n~     # Usually this includes a global \"enable\" option which defaults to false.\n~   };\n~\n~   config = {\n~     # Option definitions.\n~     # Define what other settings, services and resources should be active.\n~     # Usually these depend on whether a user of this module chose to \"enable\" it\n~     # using the \"option\" above.\n~     # Options for modules imported in \"imports\" can be set here.\n~   };\n~ }\n</code></pre>\n<p>It may require the attribute set to contain:</p>\n<ul>\n<li>\n<p><code>config</code>: The configuration of the entire system.</p>\n</li>\n<li>\n<p><code>options</code>: All option declarations refined with all definition and declaration\nreferences.</p>\n</li>\n<li>\n<p><code>pkgs</code>: The attribute set extracted from the Nix package collection and\nenhanced with the <code>nixpkgs.config</code> option.</p>\n</li>\n<li>\n<p><code>modulesPath</code>: The location of the module directory of NixOS.</p>\n</li>\n</ul>\n<h2>Modularize your configuration.nix</h2>\n<p>Many people start of using a single <code>configuration.nix</code> and eventually their\nsingle file configuration gets too large to search through and maintain\nconveniently.</p>\n<p>This is where <strong>modules</strong> come in allowing you to break up your configuration\ninto logical parts. Your <code>boot.nix</code> will contain settings and options related to\nthe actual boot process. You’re <code>services.nix</code> will only have services and so\non…</p>\n<ul>\n<li>These modules are placed in a logical path relative to either your\n<code>configuration.nix</code> or equivalent or if you’re using flakes relative to your\n<code>flake.nix</code> or equivalent.\n<ul>\n<li>The <code>imports</code> mechanism takes paths to other modules as its argument and\ncombines them to be included in the evaluation of the system configuration.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<pre><code class=\"language-nix\">{ ... }:\n{\n  imports = [\n     # Paths to other modules\n\n     # They can be relative paths\n     ./otherModule.nix\n\n     # Or absolute\n     /path/to/otherModule.nix\n\n     # Or to a directory\n     ../modules/home/shells/nushell\n  ];\n}\n</code></pre>\n</blockquote>\n<blockquote>\n<p>❗: The <strong>imports</strong> mechanism includes and evaluates the Nix expression found\nat the given path <em>as a module</em>. If that path is a directory, it will\nautomatically look for and evaluate a <code>default.nix</code> file within that directory\n<em>as a module</em>. It is common to have that <code>default.nix</code> be a function that only\nimports and combines all the modules in said directory. Like the above\nexample, in the nushell directory would be a <code>default.nix</code> that is\nautomatically imported and evaluated.</p>\n</blockquote>\n<p><strong>Crucial Distinction: <code>imports</code> vs. <code>import</code></strong>:</p>\n<p>Beginners often confuse the modules attribute <code>imports = [./module.nix]</code> here\nwith the Nix builtins function <code>import module.nix</code>. The first expects a path to\na file containing a NixOS module (having the same specific structure we’re\ndescribing here), while the second loads whatever Nix expression is in that file\n(no expected structure). –NixOS Wiki.</p>\n<p>Considering <code>configuration.nix</code> is a module, it can be imported like any other\nmodule and this is exactly what you do when getting started with flakes.</p>\n<pre><code class=\"language-nix\"># flake.nix\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = inputs@{ nixpkgs, home-manager, ... }: {\n    nixosConfigurations = {\n      hostname = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n          home-manager.nixosModules.home-manager\n          {\n            home-manager.useGlobalPkgs = true;\n            home-manager.useUserPackages = true;\n            home-manager.users.jdoe = ./home.nix;\n\n            # Optionally, use home-manager.extraSpecialArgs to pass\n            # arguments to home.nix\n          }\n        ];\n      };\n    };\n  };\n}\n</code></pre>\n<p><code>modules = [...]</code> in <code>flake.nix</code>: This is effectively the initial <code>imports</code> list\nfor your entire NixOS system or Home Manager user configuration. It tells the\nNix module system: “Start by collecting and merging the configurations defined\nin these specific modules.”</p>\n<p>The above example is what you get from running:\n<code>nix flake new /etc/nixos -t github:nix-community/home-manager#nixos</code></p>\n<p>If you notice the <code>home-manager.nixosModules.home-manager</code>, that is what imports\nhome-manager as a module.</p>\n<p>You could also make the actual home-manager module and import it like this:</p>\n<pre><code class=\"language-nix\"># home-manager.nix\n{ inputs, outputs, ... }: {\n  imports = [\n    # Import home-manager's NixOS module\n    inputs.home-manager.nixosModules.home-manager\n  ];\n\n  home-manager = {\n    extraSpecialArgs = { inherit inputs outputs; };\n    users = {\n      # Import your home-manager configuration\n      your-username = import ../home-manager/home.nix;\n    };\n  };\n}\n</code></pre>\n<p>This “module” isn’t much different from the one included in the <code>flake.nix</code>\nabove, it is just shown here to show the flexibility of modules. They can be as\nbig and complex or as small and simple as you want. You can break up every\nsingle program or component of your configuration into individual modules or\nhave modules that bundle similar programs the choice is yours.</p>\n<p>Then in your <code>configuration.nix</code> or equivalent you would add <code>home-manager.nix</code>\nto your imports list and you would have home-manager as a NixOS module.</p>\n<details>\n<summary>\n✔️ Refresher (Click to Expand):\n</summary>\n<p>An <strong>attribute set</strong> is a collection of name-value pairs called <em>attributes</em>:</p>\n<p>Attribute sets are written enclosed in curly braces <code>{}</code>. Attribute names and\nattribute values are separated by an equal sign <code>=</code>. Each value can be an\narbitrary expression, terminated by a semicolon <code>;</code>.</p>\n<blockquote>\n<p><strong>Example</strong>:<a href=\"https://nix.dev/manual/nix/2.24/language/syntax#attrs-literal\">nix.dev reference</a>\nThis defines an attribute set with attributes named:</p>\n<ul>\n<li><code>x</code> with the value <code>123</code>, an integer</li>\n<li><code>text</code> with the value <code>\"Hello\"</code>, a string</li>\n<li><code>y</code> where the value is the result of applying the function <code>f</code> to the\nattribute set <code>{bla = 456; }</code></li>\n</ul>\n<pre><code class=\"language-nix\">{\n x = 123;\n text = \"Hello\";\n y = f { bla = 456; };\n}\n</code></pre>\n<pre><code class=\"language-nix\">{ a = \"Foo\"; b = \"Bar\"}.a\n~ \"Foo\"\n</code></pre>\n</blockquote>\n<p>Attributes can appear in any order. An attribute name may only occur once in\neach attribute set.</p>\n<blockquote>\n<p>❗ Remember <code>{}</code> is a valid attribute set in Nix.</p>\n</blockquote>\n<p>The following is a <strong>function</strong> with an attribute set argument, remember that\nanytime you see a <code>:</code> in Nix code it means this is a function. To the left is\nthe <strong>function arguments</strong> and to the right is the <strong>function body</strong>:</p>\n<pre><code class=\"language-nix\">{ a, b }: a + b\n</code></pre>\n<p>The simplest possible <strong>NixOS Module</strong>:</p>\n<pre><code class=\"language-nix\">{ ... }:\n{\n}\n</code></pre>\n</details>\n<p>NixOS produces a full system configuration by combining smaller, more isolated\nand reusable components: <strong>Modules</strong>. If you want to understand Nix and NixOS\nmake sure you grasp modules!</p>\n<p>A NixOS module defines configuration options and behaviors for system\ncomponents, allowing users to extend, customize, and compose configurations\ndeclaratively.</p>\n<p>A <strong>module</strong> is a file containing a Nix expression with a specific structure. It\n<em>declares</em> options for other modules to define (give a value). Modules were\nintroduced to allow extending NixOS without modifying its source code.</p>\n<p>To define any values, the module system first has to know which ones are\nallowed. This is done by declaring options that specify which attributes can be\nset and used elsewhere.</p>\n<p>If you want to write your own modules, I recommend setting up\n<a href=\"https://github.com/nix-community/nixd?tab=readme-ov-file\">nixd</a> or\n<a href=\"https://github.com/oxalica/nil\">nil</a> with your editor of choice. This will\nallow your editor to warn you about missing arguments and dependencies as well\nas syntax errors.</p>\n<h3>Declaring Options</h3>\n<p>Options are declared under the top-level <code>options</code> attribute with\n<code>lib.mkOption</code>.</p>\n<p><a href=\"https://nixos.org/manual/nixpkgs/stable/#function-library-lib.options.mkOption\">mkOption</a>\nCreates an Option attribute set. It accepts an attribute set with certain keys\nsuch as, <code>default</code>, <code>package</code>, and <code>example</code>.</p>\n<pre><code class=\"language-nix\"># options.nix\n{ lib, ... }:\n{\n  options = {\n    name = lib.mkOption { type = lib.types.str; };\n  };\n}\n</code></pre>\n<blockquote>\n<p><code>lib</code> provides helper functions from <code>nixpkgs.lib</code> and the ellipsis (<code>...</code>) is\nfor arbitrary arguments which means that this function is prepared to accept\n<strong>any additional arguments</strong> that the caller might provide, even if those\narguments are not explicitly named or used within the module’s body. They make\nthe modules more flexible, without the <code>...</code> each module would have to\nexplicitly list every possible argument it might receive, which would be\ncumbersome and error-prone. So <code>{lib, ... }:</code> means that “I need the <code>lib</code>\nargument” <strong>and</strong> I acknowledge that the module system might pass other\narguments automatically (like <code>config</code>, <code>pkgs</code>, etc.) and I’m fine with them\nbeing there, even if I don’t use them directly in this specific module file.</p>\n</blockquote>\n<h3>Defining Values</h3>\n<p>Options are <strong>set</strong> or <strong>defined</strong> under the top-level <code>config</code> attribute:</p>\n<pre><code class=\"language-nix\"># config.nix\n{ ... }:\n{\n  config = {\n    name = \"Slick Jones\";\n  };\n}\n</code></pre>\n<p>In this <strong>option declaration</strong>, we created an option <code>name</code> of type <em>string</em> and\nset that same option to a string.</p>\n<p><strong>Option Definitions</strong> can be in a separate file than <strong>Option Declarations</strong></p>\n<h3>Evaluating Modules</h3>\n<p>Modules are <strong>evaluated</strong> with\n<a href=\"https://nixos.org/manual/nixpkgs/stable/#module-system-lib-evalModules\">lib.evalModules</a>\n<code>lib.evalModules</code> evaluates a set of modules, typically once per application\n(e.g. once for NixOS and once for Home-Manager).</p>\n<h2>Checking out the Vim module provided by Nixpkgs</h2>\n<p>The following is <code>nixpkgs/nixos/modules/programs/vim.nix</code>, a module that is\nincluded in the Nixpkgs collection:</p>\n<pre><code class=\"language-nix\">{\n  config,\n  lib,\n  pkgs,\n  ...\n}:\n\nlet\n  cfg = config.programs.vim;\nin\n{\n  options.programs.vim = {\n    enable = lib.mkEnableOption \"Vi IMproved, an advanced text\";\n\n    defaultEditor = lib.mkEnableOption \"vim as the default editor\";\n\n    package = lib.mkPackageOption pkgs \"vim\" { example = \"vim-full\"; };\n  };\n\n  # TODO: convert it into assert after 24.11 release\n  config = lib.mkIf (cfg.enable || cfg.defaultEditor) {\n    warnings = lib.mkIf (cfg.defaultEditor &amp;&amp; !cfg.enable) [\n      \"programs.vim.defaultEditor will only work if programs.vim.enable is\n       enabled, which will be enforced after the 24.11 release\"\n    ];\n    environment = {\n      systemPackages = [ cfg.package ];\n      variables.EDITOR = lib.mkIf cfg.defaultEditor (lib.mkOverride 900 \"vim\");\n      pathsToLink = [ \"/share/vim-plugins\" ];\n    };\n  };\n}\n</code></pre>\n<p>It provides options to enable Vim, set it as the default editor, and specify the\nVim package to use.</p>\n<details>\n<summary> ✔️ Breakdown of the vim module.(Click to Expand)</summary>\n1. Module Inputs and Structure:\n<pre><code class=\"language-nix\">{\n  config,\n  lib,\n  pkgs,\n  ...\n}\n</code></pre>\n<p><strong>Inputs</strong>: The module takes the above inputs and <code>...</code> (catch-all for other\nargs)</p>\n<ul>\n<li>\n<p><code>config</code>: Allows the module to read option values (e.g.\n<code>config.programs.vim.enable</code>). It provides access to the evaluated\nconfiguration.</p>\n</li>\n<li>\n<p><code>lib</code>: The Nixpkgs library, giving us helper functions like <code>mkEnableOption</code> ,\n<code>mkIf</code>, and <code>mkOverride</code>.</p>\n</li>\n<li>\n<p><code>pkgs</code>: The Nixpkgs package set, used to access packages like <code>pkgs.vim</code></p>\n</li>\n<li>\n<p><code>...</code>: Allows the module to accept additional arguments, making it flexible\nfor extension in the future.</p>\n</li>\n</ul>\n<blockquote>\n<p>Key Takeaways: A NixOS module is typically a function that can include\n<code>config</code>, <code>lib</code>, and <code>pkgs</code>, but it doesn’t require them. The <code>...</code> argument\nensures flexibility, allowing a module to accept extra inputs without breaking\nfuture compatibility. Using <code>lib</code> simplifies handling options (mkEnableOption,\nmkIf, mkOverride) and helps follow best practices. Modules define options,\nwhich users can set in their configuration, and <code>config</code>, which applies\nchanges based on those options.</p>\n</blockquote>\n<ol start=\"2\">\n<li>Local Configuration Reference:</li>\n</ol>\n<pre><code class=\"language-nix\">let\n  cfg = config.programs.vim;\nin\n</code></pre>\n<p>This is a local alias. Instead of typing <code>config.programs.vim</code> over and over,\nthe module uses <code>cfg</code>.</p>\n<ol start=\"3\">\n<li>Option Declaration</li>\n</ol>\n<pre><code class=\"language-nix\">options.programs.vim = {\n  enable = lib.mkEnableOption \"Vi IMproved, an advanced text\";\n  defaultEditor = lib.mkEnableOption \"vim as the default editor\";\n  package = lib.mkPackageOption pkgs \"vim\" { example = \"vim-full\"; };\n};\n</code></pre>\n<p>This defines three user-configurable options:</p>\n<ul>\n<li>\n<p><code>enable</code>: Turns on Vim support system-wide.</p>\n</li>\n<li>\n<p><code>defaultEditor</code>: Sets Vim as the system’s default <code>$EDITOR</code>.</p>\n</li>\n<li>\n<p><code>package</code>: lets the user override which Vim package is used.</p>\n</li>\n</ul>\n<blockquote>\n<p><code>mkPackageOption</code> is a helper that defines a package-typed option with a\ndefault (<code>pkgs.vim</code>) and provides docs + example. Using <code>lib.mkEnableOption</code>\nmakes it clear exactly where this function is coming from. Same with\n<code>lib.mkIf</code> and as you can see they can be further down the configuration,\nfurther from where you defined <code>with lib;</code> making it less clear where they\ncome from. Explicitness is your friend when it comes to reproducability and\nclarity.</p>\n</blockquote>\n<ol start=\"4\">\n<li>Conditional Configuration</li>\n</ol>\n<pre><code class=\"language-nix\">config = lib.mkIf (cfg.enable || cfg.defaultEditor) {\n</code></pre>\n<ul>\n<li>This block is only activated if <em>either</em> <code>programs.vim.enable</code> or\n<code>defaultEditor</code> is set.</li>\n</ul>\n<ol start=\"5\">\n<li>Warnings</li>\n</ol>\n<pre><code class=\"language-nix\">warnings = lib.mkIf (cfg.defaultEditor &amp;&amp; !cfg.enable) [\n  \"programs.vim.defaultEditor will only work if programs.vim.enable is enabled,\n   which will be enforced after the 24.11 release\"\n];\n</code></pre>\n<p>Gives you a soft warning if you try to set <code>defaultEditor = true</code> without also\nenabling Vim.</p>\n<ol start=\"6\">\n<li>Actual System Config Changes</li>\n</ol>\n<pre><code class=\"language-nix\">environment = {\n  systemPackages = [ cfg.package ];\n  variables.EDITOR = lib.mkIf cfg.defaultEditor (lib.mkOverride 900 \"vim\");\n  pathsToLink = [ \"/share/vim-plugins\" ];\n};\n</code></pre>\n<p>It adds Vim to your <code>systemPackages</code>, sets <code>$EDITOR</code> if <code>defaultEditor</code> is true,\nand makes <code>/share/vim-plugins</code> available in the environment.</p>\n</details>\n<p>The following is a bat home-manager module that I wrote:</p>\n<pre><code class=\"language-nix\"># bat.nix\n{\n  pkgs,\n  config,\n  lib,\n  ...\n}: let\n  cfg = config.custom.batModule;\nin {\n  options.custom.batModule.enable = lib.mkOption {\n    type = lib.types.bool;\n    default = false;\n    description = \"Enable bat module\";\n  };\n\n  config = lib.mkIf cfg.enable {\n    programs.bat = {\n      enable = true;\n      themes = {\n        dracula = {\n          src = pkgs.fetchFromGitHub {\n            owner = \"dracula\";\n            repo = \"sublime\"; # Bat uses sublime syntax for its themes\n            rev = \"26c57ec282abcaa76e57e055f38432bd827ac34e\";\n            sha256 = \"019hfl4zbn4vm4154hh3bwk6hm7bdxbr1hdww83nabxwjn99ndhv\";\n          };\n          file = \"Dracula.tmTheme\";\n        };\n      };\n      extraPackages = with pkgs.bat-extras; [\n        batdiff\n        batman\n        prettybat\n        batgrep\n      ];\n    };\n  };\n}\n</code></pre>\n<p>Now I could add this to my <code>home.nix</code> to enable it:</p>\n<pre><code class=\"language-nix\"># home.nix\ncustom = {\n  batModule.enable = true;\n}\n</code></pre>\n<p>If I set this option to true the bat configuration is dropped in place. If it’s\nnot set to true, it won’t put the bat configuration in the system. Same as with\noptions defined in modules within the Nixpkgs repository.</p>\n<p>If I had set the default to <code>true</code>, it would automatically enable the module\nwithout requiring an explicit <code>custom.batModule.enable = true;</code> call in my\n<code>home.nix</code>.</p>\n<h3>Module Composition</h3>\n<p>NixOS achieves its full system configuration by combining the configurations\ndefined in various modules. This composition is primarily handled through the\n<code>imports</code> mechanism.</p>\n<p><code>imports</code>: This is a standard option within a NixOS or Home Manager\nconfiguration (often found in your configuration.nix or home.nix). It takes a\nlist of paths to other Nix modules. When you include a module in the imports\nlist, the options and configurations defined in that module become part of your\noverall system configuration.</p>\n<p>You declaratively state the desired state of your system by setting options\nacross various modules. The NixOS build system then evaluates and merges these\noption settings. The culmination of this process, which includes building the\nentire system closure, is represented by the derivation built by\n<code>config.system.build.toplevel</code>.</p>\n<h3>NixOS Modules and Dependency Locking with npins</h3>\n<details>\n<summary> ✔️ npins example (Click to Expand)</summary>\nAs our NixOS configurations grow in complexity, so too does the challenge of\nmanaging the dependencies they rely on. Ensuring consistency and reproducibility\nnot only applies to individual packages but also to the versions of Nixpkgs and\nother external resources our configurations depend upon.\n<p>Traditionally, NixOS configurations often implicitly rely on the version of\nNixpkgs available when <code>nixos-rebuild</code> is run. However, for more robust and\nreproducible setups, especially in collaborative environments or when rolling\nback to specific configurations, explicitly locking these dependencies to\nspecific versions becomes crucial.</p>\n<p>In the following example, we’ll explore how to use a tool called <code>npins</code> to\nmanage and lock the dependencies of a NixOS configuration, ensuring a more\npredictable and reproducible system. This will involve setting up a project\nstructure and using npins to pin the specific version of Nixpkgs our\nconfiguration relies on.</p>\n<p>This is the file structure:</p>\n<pre><code class=\"language-bash\">❯ tree\n.\n├── configuration.nix\n├── default.nix\n├── desktop.nix\n└── npins\n    ├── default.nix\n    └── sources.json\n</code></pre>\n<p>This uses <code>npins</code> for dependency locking. Install it and run this in the project</p>\n<p>directory:</p>\n<pre><code class=\"language-bash\">npins init\n</code></pre>\n<p>Create a <code>default.nix</code> with the following:</p>\n<pre><code class=\"language-nix\"># default.nix\n{ system ? builtins.currentSystem, sources ? import ./npins, }:\nlet\n  pkgs = import sources.nixpkgs {\n    config = { };\n    overlays = [ ];\n  };\n  inherit (pkgs) lib;\nin lib.makeScope pkgs.newScope (self: {\n\n  shell = pkgs.mkShell { packages = [ pkgs.npins self.myPackage ]; };\n\n    # inherit lib;\n\n  nixosSystem = import (sources.nixpkgs + \"/nixos\") {\n    configuration = ./configuration.nix;\n  };\n\n  moduleEvale = lib.evalModules {\n    modules = [\n      # ...\n    ];\n  };\n})\n</code></pre>\n<p>A <code>configuration.nix</code> with the following:</p>\n<pre><code class=\"language-nix\"># configuration.nix\n{\n  boot.loader.grub.device = \"nodev\";\n  fileSystems.\"/\".device = \"/devst\";\n  system.stateVersion = \"25.05\";\n\n  # declaring options means to declare a new option\n  # defining options means to define a value of an option\n  imports = [\n    # ./main.nix\n     ./desktop.nix # Files\n    # ./minimal.nix\n  ];\n\n  # mine.desktop.enable = true;\n}\n</code></pre>\n<p>And a <code>desktop.nix</code> with the following:</p>\n<pre><code class=\"language-nix\"># desktop.nix\n{ pkgs, lib, config, ... }:\n\n{\n  imports = [];\n\n  # Define an option to enable or disable desktop configuration\n  options.mine.desktop.enable = lib.mkEnableOption \"desktop settings\";\n\n  # Configuration that applies when the option is enabled\n  config = lib.mkIf config.mine.desktop.enable {\n    environment.systemPackages = [ pkgs.git ];\n  };\n}\n</code></pre>\n<p><code>mkEnableOption</code> defaults to false. Now in your <code>configuration.nix</code> you can\nuncomment <code>mine.desktop.enable = true;</code> to enable the desktop config and\nvice-versa.</p>\n<p>You can test that this works by running:</p>\n<pre><code class=\"language-bash\">nix-instantiate -A nixosSystem.system\n</code></pre>\n<p><code>nix-instantiate</code> performs only the evaluation phase of Nix expressions. During\nthis phase, Nix interprets the Nix code, resolves all dependencies, and\nconstructs derivations but does not execute any build actions. Useful for\ntesting.</p>\n<p>To check if this worked and <code>git</code> is installed in systemPackages you can load it\ninto <code>nix repl</code> but first you’ll want <code>lib</code> to be available so uncomment this in\nyour <code>default.nix</code>:</p>\n<pre><code class=\"language-nix\"># default.nix\ninherit lib;\n</code></pre>\n<p>Rerun <code>nix-instantiate -A nixosSystem.system</code></p>\n<p>Then load the repl and check that <code>git</code> is in <code>systemPackages</code>:</p>\n<pre><code class=\"language-bash\">nix repl -f .\nnix-repl&gt; builtins.filter (pkg: lib.hasPrefix \"git\" pkg.name) nixosSystem.config.environment.systemPackages\n</code></pre>\n<p>This shows the path to the derivation</p>\n<p>Check that mine.desktop.enable is true</p>\n<pre><code class=\"language-nix\">nix-repl&gt; nixosSystem.config.mine.desktop.enable\ntrue\n</code></pre>\n<p>As demonstrated with npins, explicitly managing the dependencies of your NixOS\nmodules is a powerful technique for ensuring the long-term stability and\nreproducibility of your system configurations. By pinning specific versions of\nNixpkgs and other resources, you gain greater control over your environment and\nreduce the risk of unexpected changes due to upstream updates.</p>\n</details>\n<h3>Best Practices</h3>\n<p>You’ll see the following all throughout Nix code and is convenient although it\ndoesn’t follow best practices. One reason is static analysis can’t reason about\nthe code (e.g. Because it implicitly brings all attributes into scope, tools\ncan’t verify which ones are actually being used), because it would have to\nactually evaluate the files to see which names are in scope:</p>\n<pre><code class=\"language-nix\"># utils.nix\n{ pkgs, ... }: {\n  environment.systemPackages = with pkgs; [\n    rustup\n    evcxr\n    nix-prefetch-git\n  ];\n}\n</code></pre>\n<p>Another reason the above expression is considered an “anti-pattern” is when more\nthen one <code>with</code> is used, it’s no longer clear where the names are coming from.</p>\n<p>Scoping rules for <code>with</code> are not intuitive, see\n<a href=\"https://github.com/NixOS/nix/issues/490\">issue</a> –nix.dev This can make\ndebugging harder, as searching for variable origins becomes ambiguous (i.e. open\nto more than one interpretation).</p>\n<p>The following follows best practices:</p>\n<pre><code class=\"language-nix\">{pkgs, ... }: {\n  environment.systemPackages = builtins.attrValues {\n    inherit (pkgs)\n      rustup\n      evcxr\n      nix-prefetch-git;\n  };\n}\n</code></pre>\n<ul>\n<li><a href=\"https://noogle.dev/f/builtins/attrValues\">Noogle builtins.attrValues</a></li>\n</ul>\n<details>\n<summary> ✔️ Above Command Summary (Click to Expand) </summary>\n<pre><code class=\"language-nix\">{\n  inherit (pkgs) rustup evcxr nix-prefetch-git;\n}\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code class=\"language-nix\">{\n  rustup = pkgs.rustup;\n  evcxr = pkgs.evcxr;\n  nix-prefetch-git = pkgs.nix-prefetch-git;\n}\n</code></pre>\n<p>Applying <code>builtins.attrValues</code> produces:</p>\n<pre><code class=\"language-nix\">[ pkgs.evcxr pkgs.nix-prefetch-git pkgs.rustup ]\n</code></pre>\n<p>As you can see only the values are included in the list, not the keys. This is\nmore explicit and declarative but can be more complicated, especially for a\nbeginner.</p>\n<p><code>builtins.attrValues</code> returns the values of all attributes in the given set,\nsorted by attribute name. The above expression turns into something like the\nfollowing avoiding bringing every attribute name from <code>nixpkgs</code> into scope.</p>\n<p>A more straightforward example:</p>\n<pre><code class=\"language-nix\">attrValues {c = 3; a = 1; b = 2;}\n=&gt; [1 2 3]\n</code></pre>\n</details>\n<p>This approach avoids unintended name clashes or confusion when debugging.</p>\n<p>Upon looking into this a bit further, most people use the following format to\navoid the “anti-pattern” from using <code>with pkgs;</code>:</p>\n<pre><code class=\"language-nix\"># utils.nix\n{ pkgs, ... }: {\n  environment.systemPackages = [\n    pkgs.rustup\n    pkgs.evcxr\n    pkgs.nix-prefetch-git\n  ];\n}\n</code></pre>\n<p>While the performance differences might be negligible on modern computers,\nadopting this best practice from the start is highly recommended. The above\napproach is more explicit, it’s clear exactly where each package is coming from.</p>\n<p>If maintaining strict scope control matters, use <code>builtins.attrValues</code>.</p>\n<p>If readability and simplicity are more your priority, explicitly referencing\n<code>pkgs.&lt;packageName&gt;</code> might be better. Now you can choose for yourself.</p>\n<h4>Conclusion</h4>\n<p>As we have seen throughout this chapter, modules are the building blocks of your\nNixOS system and are themselves often functions. There are a few different ways\nto use these modules to build your system. In the next chapter,\n<a href=\"https://saylesss88.github.io/Nix_Flakes_Explained_4.html\">Nix Flakes Explained</a>\nwe will learn about Nix Flakes as a more modern and comprehensive entrypoint for\nmanaging your entire system and its dependencies.</p>\n<p>To further deepen your understanding of NixOS Modules and the broader ecosystem\nof tools and best practices surrounding them, the following resources offer\nvaluable insights and information.</p>\n<h4>Resources on Modules</h4>\n<details>\n<summary> ✔️ Resources (Click to Expand) </summary>\n<ul>\n<li>\n<p><a href=\"https://nixos.org/manual/nixos/stable/#sec-writing-modules\">WritingNixOsModules</a></p>\n</li>\n<li>\n<p><a href=\"https://nixos.wiki/wiki/NixOS_modules\">NixWikiNixOSModules</a></p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/tutorials/module-system/a-basic-module/index.html\">nix.dev A basic module</a></p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/tutorials/module-system/deep-dive#module-system-deep-dive\">ModuleSystemDeepDive</a></p>\n</li>\n<li>\n<p><a href=\"https://xeiaso.net/talks/asg-2023-nixos/\">xeiaso Nixos Modules for fun &amp; profit</a></p>\n</li>\n<li>\n<p><a href=\"https://nixos-and-flakes.thiscute.world/other-usage-of-flakes/module-system\">NixOS Flakes Book Module System</a></p>\n</li>\n</ul>\n<h1>Videos</h1>\n<p><a href=\"https://www.youtube.com/watch?v=N7hFP_40DJo&amp;t=17s\">NixHour Writing NixOS modules</a>\n– This example is from this video\n<a href=\"https://infinisil.com/modules.mp4\">infinisilModules</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=cZjOzOHb2ow\">tweagModuleSystemRecursion</a></p>\n</details>\n",
      "date_published": "2025-11-21T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/Understanding_Nix_Functions_2.html",
      "url": "https://saylesss88.github.io/Understanding_Nix_Functions_2.html",
      "title": "Understanding Nix Functions",
      "content_html": "<h1>Chapter 2</h1>\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<!-- <img src=\"images/nixLogo.png\" width=\"400\" height=\"300\"> -->\n<p><img src=\"images/trees2.cleaned.png\" alt=\"trees2\" /></p>\n<h2>Understanding Nix Functions</h2>\n<p><strong>Functions</strong> are the building blocks of Nix, appearing everywhere in Nix\nexpressions and configurations. Mastering them is essential for writing\neffective Nix code and understanding tools like NixOS and Home Manager. This\nchapter explores how Nix functions work, focusing on their <strong>single-argument\nnature</strong>, <strong>currying</strong>, <strong>partial application</strong>, and their role in <strong>modules</strong>.</p>\n<h2>What are Nix Functions?</h2>\n<p>A <strong>Nix Function</strong> is a rule that takes an input (called an <strong>argument</strong>) and\nproduces an <strong>output</strong> based on that input. Unlike many programming languages,\nNix functions are designed to take exactly one argument at a time. This unique\napproach, combined with a technique called currying, allows Nix to simulate\nmulti-argument functions in a flexible and reusable way.</p>\n<h2>Builtins</h2>\n<details>\n<summary> ✔️ Nix Builtin Functions (Click to Expand)</summary>\n<p>The Nix expression evaluator has a bunch of functions and constants built in:</p>\n<ul>\n<li>\n<p><code>toString e</code>: (Convert the expression <code>e</code> to a string)</p>\n</li>\n<li>\n<p><code>import path</code>: (Load, parse and return the Nix expression in the file <code>path</code>)</p>\n</li>\n<li>\n<p><code>throw x</code>: (Throw an error message <code>x</code>. Usually stops evaluation)</p>\n</li>\n<li>\n<p><code>map f list</code>: (Apply the function <code>f</code> to each element in the <code>list</code>)</p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/manual/nix/2.18/language/builtins\">Built-in Functions</a></p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/manual/nix/2.26/language/operators\">Nix Operators</a></p>\n</li>\n</ul>\n</details>\n<h2>Lambdas</h2>\n<p>Nix functions are anonymous (lambdas) (e.g., <code>x: x + 2</code>), and technically take a\nsingle parameter. However, that single parameter is very often an attribute set,\nallowing you to effectively pass multiple named inputs by destructuring (e.g.,\n<code>{ arg1, arg2 }: arg1 + arg2</code>).</p>\n<p>Type the parameter name, followed by a colon, and finally the body of the\nfunction.</p>\n<pre><code class=\"language-nix\">nix-repl&gt; param: param * 2\n&lt;&lt;lambda @ &lt;&lt;string&gt;&gt;:1:1&gt;&gt;\n\nnix-repl&gt; (param: param * 2) 2\n4\n</code></pre>\n<p>The above example shows that everything in Nix returns a value. When you call a\nfunction directly (without first assigning the function itself to a variable),\nthe result of that call is immediately evaluated and displayed/used.</p>\n<p>In order to make our function reusable and be able to pass different values at\ndifferent times we have to assign our function to a variable:</p>\n<pre><code class=\"language-nix\">nix-repl&gt; twoTimes = param: param * 2\n</code></pre>\n<p>Now, we can reference our function by it’s name and pass our required parameter:</p>\n<pre><code class=\"language-nix\">nix-repl&gt; twoTimes\n«lambda @ «string»:1:2»\nnix-repl&gt; twoTimes 2\n4\nnix-repl&gt; twoTimes 4\n8\n</code></pre>\n<p>We defined a function <code>param: param * 2</code> takes one parameter <code>param</code>, and\nreturns <code>param * 2</code>. We then assigned this function to the variable <code>twoTimes</code>.\nLastly, we called the function with a few different arguments showing it’s\nreusability.</p>\n<h2>Understanding Function Structure: The Role of the Colon</h2>\n<p>The colon (<code>:</code>) acts as a clear separator within a function definition:</p>\n<ul>\n<li>\n<p><strong>Left of the Colon:</strong> This is the function’s <strong>argument</strong>. It’s a placeholder\nname for a value that will be provided when the function is called.</p>\n</li>\n<li>\n<p><strong>Right of the Colon:</strong> This is the <strong>function body</strong>. It’s the expression\nthat will be evaluated when the function is invoked.</p>\n</li>\n</ul>\n<p><strong>Think of function arguments as naming values that aren’t known in advance.</strong>\nThese names are placeholders that get filled with specific values when the\nfunction is used.</p>\n<p><strong>Example:</strong></p>\n<pre><code class=\"language-nix\">greet = personName: \"Hello, ${personName}!\";\n</code></pre>\n<ul>\n<li>\n<p>Here, <code>personName</code> is the <strong>argument</strong> (the placeholder).</p>\n</li>\n<li>\n<p><code>\"Hello, ${personName}!\"</code>, is the <strong>function body</strong> (which uses the\nplaceholder to create the greeting).</p>\n</li>\n</ul>\n<p>When you call the function, (click to see Output):</p>\n<pre><code class=\"language-nix\">greet \"Anonymous\"\n~ \"Hello, Anonymous!\"\n</code></pre>\n<ul>\n<li>\n<p>The value <code>\"Anonymous\"</code> is substituted for the <code>personName</code> placeholder within\nthe function body.</p>\n</li>\n<li>\n<p>This structure is the foundation of all Nix functions, whether simple or\ncomplex.</p>\n</li>\n</ul>\n<h3>Single-Argument Functions: The Basics</h3>\n<p>The simplest form of a Nix function takes a single argument. In Nix, function\ndefinitions like <code>x: x + 1</code> or <code>personName: \"Hello, ${personName}!\";</code> are\n<strong>anonymous lambda functions</strong>. They exist as values until they are assigned to\na variable.</p>\n<ul>\n<li>Click to see Output:</li>\n</ul>\n<pre><code class=\"language-nix\"># This is an anonymous lambda function value:\n# x: x + 1\ninc = x: x + 1;          # here we assigned our lambda to a variable `inc`\ninc 5\n~ 6\n</code></pre>\n<ul>\n<li>\n<p><code>x</code> is the argument.</p>\n</li>\n<li>\n<p><code>x + 1</code> is the function body.</p>\n</li>\n</ul>\n<p>This straightforward design makes single-argument functions easy to understand\nand use. But what if you need a function that seems to take multiple arguments?\nThat’s where <strong>currying</strong> comes in.</p>\n<h3>Simulating Multiple Arguments: Currying</h3>\n<p>To create functions that appear to take multiple arguments, Nix uses currying.\nThis involves nesting single-argument functions, where each function takes one\nargument and returns another function that takes the next argument, and so on.</p>\n<pre><code class=\"language-nix\">nix-repl&gt; multiply = x: (y: x*y)\nnix-repl&gt; multiply\n«lambda»\nnix-repl&gt; multiply 4\n«lambda»\nnix-repl&gt; (mul 4) 5\n20\n</code></pre>\n<p>We defined a function that takes the parameter <code>x</code>, the body returns another\nfunction. This other function takes a parameter <code>y</code> and returns <code>x*y</code>.\nTherefore, calling <code>multiply 4</code> returns a function like: <code>x: 4*y</code>. In turn, we\ncall the returned function with <code>5</code>, and get the expected result.</p>\n<h4>Currying example 2</h4>\n<pre><code class=\"language-nix\"># concat is equivalent to:\n# concat = x: (y: x + y);\nconcat = x: y: x + y;\nconcat 6 6    # Evaluates to 12\n12\n</code></pre>\n<p>Here, <code>concat</code> is actually <strong>two nested functions</strong></p>\n<ol>\n<li>\n<p>The <strong>first function</strong> takes <code>x</code> and returns another function.</p>\n</li>\n<li>\n<p>The <strong>second function</strong> takes <code>y</code> and performs <code>x + y</code></p>\n</li>\n</ol>\n<p>Nix interprets the colons (<code>:</code>) as separators for this chain of single-argument\nfunctions.</p>\n<p>Here’s how it works step by step:</p>\n<ul>\n<li>\n<p>When you call <code>concat 6</code>, the outer function binds <code>x</code> to <code>6</code> and returns a\nnew function: <code>y: 6 + y</code>.</p>\n</li>\n<li>\n<p>When you call that function with <code>6</code> (i.e., <code>concat 6 6</code>), it computes\n<code>6 + 6</code>, resulting in <code>12</code>.</p>\n</li>\n</ul>\n<p>This chaining is why Nix functions are so powerful—it allows you to build\nflexible, reusable functions.</p>\n<p>Currying is a powerful feature in Nix that enables you to partially apply\narguments to functions, leading to increased reusability. This behavior is a\ndirect consequence of Nix functions being “first-class citizens” (a concept\nwe’ll delve into later), and it proves invaluable for decomposing intricate\nlogic into a series of smaller, more focused functions.</p>\n<p><strong>Key Insight</strong>: Every colon in a function definition separates a <strong>single\nargument</strong> from its <strong>function body</strong>, even if that body is another function\ndefinition.</p>\n<h4>Greeting Example</h4>\n<p>Let’s explore currying with a more relatable example in the <code>nix repl</code>:</p>\n<pre><code class=\"language-nix\">nix repl\nnix-repl&gt; greeting = prefix: name: \"${prefix}, ${name}!\";\n\nnix-repl&gt; greeting \"Hello\"\n&lt;&lt;lambda @ &lt;&lt;string&gt;&gt;:1:10&gt;&gt; # partial application returns a lambda\n\nnix-repl&gt; greeting \"Hello\" \"Alice\"\n\"Hello, Alice!\"         # providing both arguments returns the expected result\n</code></pre>\n<p>This function is a chain of two single-argument functions:</p>\n<ol>\n<li>\n<p>The outer function takes <code>prefix</code> (e.g. <code>\"Hello\"</code>) and returns a function\nthat expects <code>name</code>.</p>\n</li>\n<li>\n<p>The inner function takes <code>name</code> (e.g. <code>\"Alice\"</code>) and combines it with\n<code>prefix</code> to produce the final string.</p>\n</li>\n</ol>\n<p>Thanks to <strong>lexical scope</strong> (where inner functions can access variables from\nouter functions), the inner function “remembers” the <code>prefix</code> value.</p>\n<h4>Partial Application: Using Functions Incrementally</h4>\n<p>Because of <strong>currying</strong>, you can apply arguments to a Nix function one at a\ntime. This is called <em>partial application</em>. When you provide only some of the\nexpected arguments, you get a new function that “remembers” the provided\narguments and waits for the rest.</p>\n<p><strong>Example:</strong></p>\n<p>Using our <code>greeting</code> function again:</p>\n<pre><code class=\"language-nix\">nix repl\nnix-repl&gt; greeting = prefix: name: \"${prefix}, ${name}!\";\nnix-repl&gt; helloGreeting = greeting \"Hello\";\nnix-repl&gt; helloGreeting \"Alice\"\n\"Hello, Alice\"\n</code></pre>\n<ul>\n<li><code>helloGreeting</code> is now a new function. It has already received the <code>prefix</code>\nargument (<code>\"Hello\"</code>), when we provide the second argument we get\n<code>\"Hello, Alice!\"</code></li>\n</ul>\n<p><strong>Benefits of Partial Application:</strong></p>\n<p>Partial application provides significant benefits by enabling you to derive\nspecialized functions from more general ones through the process of fixing\ncertain parameters. Additionally, it serves as a powerful tool for adapting\nexisting functions to fit the precise argument requirements of higher-order\nfunctions like <code>map</code> and <code>filter</code>.</p>\n<h4>Nix Functions being “first class citizens”</h4>\n<p>In the context of Nix, the phrase “Nix treats functions as first-class citizens”\nmeans that functions in Nix are treated as values, just like numbers, strings,\nor lists. They can be manipulated, passed around, and used in the same flexible\nways as other data types. This concept comes from functional programming and has\nspecific implications in Nix.</p>\n<p><strong>What It Means in Nix</strong></p>\n<ol>\n<li>Functions Can Be <strong>Assigned to Variables</strong>:</li>\n</ol>\n<ul>\n<li>\n<p>You can store a function in a variable, just like you would store a number or\nstring.</p>\n</li>\n<li>\n<p>Example:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">greet = name: \"Hello, ${name}!\";\n</code></pre>\n<ul>\n<li>Here, greet is a variable that holds a function.</li>\n</ul>\n<ol start=\"2\">\n<li>Functions Can Be <strong>Passed as Arguments</strong>:</li>\n</ol>\n<ul>\n<li>\n<p>You can pass a function to another function as an argument, allowing for\nhigher-order functions (functions that operate on other functions).</p>\n</li>\n<li>\n<p>Example:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">applyTwice = f: x: f (f x);\ninc = x: x + 1;\napplyTwice inc 5 # Output: 7 (increments 5 twice: 5 → 6 → 7)\n~ 7\n</code></pre>\n<ul>\n<li>Here, applyTwice takes a function <code>f</code> (in this case, <code>inc</code>) and applies it to\n<code>x</code> twice.</li>\n</ul>\n<ol start=\"3\">\n<li>Functions Can Be <strong>Returned from Functions</strong>:</li>\n</ol>\n<ul>\n<li>\n<p>Functions can produce other functions as their output, which is key to\ncurrying in Nix.</p>\n</li>\n<li>\n<p>Example:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">greeting = prefix: name: \"${prefix}, ${name}!\";\nhelloGreeting = greeting \"Hello\";  # Returns a function\nhelloGreeting \"Alice\"  # Output: \"Hello, Alice!\"\n~ \"Hello, Alice!\"\n</code></pre>\n<ul>\n<li>The greeting function returns another function when partially applied with\nprefix.</li>\n</ul>\n<ol start=\"4\">\n<li>Functions <strong>Are Values in Expressions</strong>:</li>\n</ol>\n<ul>\n<li>\n<p>Functions can be used anywhere a value is expected, such as in attribute sets\nor lists.</p>\n</li>\n<li>\n<p>Example:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">myFuncs = {\n  add = x: y: x + y;\n  multiply = x: y: x * y;\n};\nmyFuncs.add 3 4  # Output: 7\n~ 7\n</code></pre>\n<ul>\n<li>\n<p>Here, functions are stored as values in an attribute set.</p>\n</li>\n<li>\n<p>To try this in the <code>repl</code> just remove the semi-colon (<code>;</code>)</p>\n</li>\n</ul>\n<p><strong>Why This Matters in Nix</strong>:</p>\n<p>This functional approach is fundamental to Nix’s unique build system. In Nix,\n<strong>package builds (called derivations)</strong> are essentially functions. They take\nspecific <strong>inputs</strong> (source code, dependencies, build scripts) and\ndeterministically produce <strong>outputs</strong> (a built package).</p>\n<p>This design ensures <strong>atomicity</strong>: if a build does not succeed completely and\nperfectly, it produces no output at all. This prevents situations common in\nother package managers where partial updates or corrupted builds can leave your\nsystem in an inconsistent or broken state.</p>\n<p>Many NixOS and Home Manager modules are functions, and their first-class status\nmeans they can be combined, reused, or passed to other parts of the\nconfiguration system.</p>\n<p>Now that we understand the “first-class” nature of Nix Functions let’s see how\nthey fit into NixOS and Home Manager modules.</p>\n<h4>The Function Nature of NixOS and Home Manager Modules</h4>\n<p>It’s crucial to understand that most NixOS and Home Manager modules are\nfundamentally <strong>functions</strong>.</p>\n<p>These module functions typically accept a single argument: <strong>an attribute set</strong>\n(remember this, it’s important to understand).</p>\n<p><strong>Example</strong>:</p>\n<p>A practical NixOS module example for Thunar with plugins:</p>\n<pre><code class=\"language-nix\"># thunar.nix\n{pkgs, ...}: {\n  programs = {\n    thunar = {\n      enable = true;\n      plugins = with pkgs.xfce; [\n        thunar-archive-plugin\n        thunar-volman\n      ];\n    };\n  };\n}\n</code></pre>\n<ul>\n<li>To use this module I would need to import it into my <code>configuration.nix</code> or\nequivalent, shown here for completeness.</li>\n</ul>\n<pre><code class=\"language-nix\"># configuration.nix\n# ... snip ...\nimports = [ ../nixos/thunar.nix ];\n# ... snip ...\n</code></pre>\n<ul>\n<li>\n<p>This is actually a pretty good example of <code>with</code> making it a bit harder to\nreason where the plugins are from. You might instinctively try to trace a path\nlike <code>programs.thunar.plugins.pkgs.xfce</code> because you saw <code>pkgs.xfce</code> in the\n<code>with</code> statement. But that’s now how <code>with</code> works. The <code>pkgs.xfce</code> path exists\n<em>outside</em> the <code>plugins</code> list, defining the source of the items, not their\nnested structure within the list.</p>\n</li>\n<li>\n<p>To follow best practices you could write the above plugins section as:</p>\n</li>\n</ul>\n<pre><code class=\"language-nix\">plugins = [\n  pkgs.xfce.thunar-archive-plugin\n  pkgs.xfce.thunar-volman\n];\n</code></pre>\n<ul>\n<li>Now it’s clear that each plugin comes directly from <code>pkgs</code> and each will\nresolve to a derivation.\n<ul>\n<li>To be clear either way is fine, especially in such a small self contained\nmodule. If it were in a single file <code>configuration.nix</code> it would be a bit\nmore confusing to trace. Explicitness is your friend with Nix and\nmaintaining reproducability. <code>with</code> isn’t always bad but should be avoided\nat the top of a file for example to bring <code>nixpkgs</code> into scope, use <code>let</code>\ninstead.</li>\n</ul>\n</li>\n</ul>\n<p>The entire module definition is a function that takes one argument (an attribute\nset):<code>{ pkgs, ... }</code>. When this module is included in your configuration, the\nNixOS module system calls this function with a specific attribute set. This\nattribute set contains the available packages (<code>pkgs</code>), and other relevant\ninformation. The module then uses these values to define parts of your system.</p>\n<h3>Understanding passing and getting back arguments</h3>\n<p>For this example we will build the Hello derivation from the Nix Pills series.</p>\n<p>Create an <code>autotools.nix</code> with the following contents:</p>\n<pre><code class=\"language-nix\">pkgs: attrs: let\n  defaultAttrs = {\n    builder = \"${pkgs.bash}/bin/bash\";\n    args = [./builder.sh];\n    baseInputs = with pkgs; [\n      gnutar\n      gzip\n      gnumake\n      gcc\n      coreutils\n      gawk\n      gnused\n      gnugrep\n      binutils.bintools\n    ];\n    buildInputs = [];\n    system = builtins.currentSystem;\n  };\nin\n  derivation (defaultAttrs // attrs)\n</code></pre>\n<p>Let’s create the hello derivation:</p>\n<pre><code class=\"language-nix\">let\n  pkgs = import &lt;nixpkgs&gt; {};\n  mkDerivation = import ./autotools.nix pkgs;\nin\n  mkDerivation {\n    name = \"hello\";\n    src = ./hello-2.12.1.tar.gz;\n  }\n</code></pre>\n<ul>\n<li>You can get the tarball\n<a href=\"https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz\">here</a>, place it in the\nsame directory as <code>autotools.nix</code></li>\n</ul>\n<p>And finally the <code>builder.sh</code> that <code>autotools.nix</code> declares for the <code>args</code>\nattribute:</p>\n<pre><code class=\"language-bash\">#!/bin/bash\nset -e\nunset PATH\nfor p in $buildInputs $baseInputs; do\n    export PATH=$p/bin${PATH:+:}$PATH\ndone\n\ntar -xf $src\n\nfor d in *; do\n    if [ -d \"$d\" ]; then\n        cd \"$d\"\n        break\n    fi\ndone\n\n./configure --prefix=$out\nmake\nmake install\n</code></pre>\n<p>When you write:</p>\n<pre><code class=\"language-nix\">mkDerivation = import ./autotools.nix pkgs;\n</code></pre>\n<ul>\n<li>\n<p><code>import ./autotools.nix</code>: This evaluates the <code>autotools.nix</code> file. Because it\nstarts with <code>pkgs: attrs: ...</code>, it means that <code>autotools.nix</code> evaluates to a\nfunction that expects one argument named <code>pkgs</code>.</p>\n</li>\n<li>\n<p><code>... pkgs</code>: We are immediately calling that function (the one returned by\n<code>import ./autotools.nix</code>) and passing it our <code>pkgs</code> variable (which is the\nresult of <code>import &lt;nixpkgs&gt; {}</code>).</p>\n</li>\n</ul>\n<p><strong>This illustrates the concept of Currying in Nix</strong>:</p>\n<p>The function defined in <code>autotools.nix</code> (<code>pkgs: attrs: ...</code>) is a curried\nfunction. It’s a function that, when given its first argument (<code>pkgs</code>), returns\nanother function (which then expects <code>attrs</code>).</p>\n<p>The result of import <code>./autotools.nix pkgs</code> is that second, inner function:\n<code>attrs: derivation (defaultAttrs // attrs)</code>. This inner function is then bound\nto the <code>mkDerivation</code> variable, making it ready to be called with just the\nspecific attributes for your package (like <code>name</code> and <code>src</code>).</p>\n<p><strong>Understanding the <code>attrs</code> Argument</strong></p>\n<p>Now let’s focus on the second argument of our <code>autotools.nix</code> function: <code>attrs</code>.</p>\n<p>Recall the full function signature in <code>autotools.nix</code>:</p>\n<pre><code class=\"language-nix\">pkgs: attrs: let\n  # ... defaultAttrs definition ...\nin\n  derivation (defaultAttrs // attrs)\n</code></pre>\n<ol>\n<li>What <code>attrs</code> Represents:</li>\n</ol>\n<ul>\n<li>\n<p>Once <code>autotools.nix</code> has received its <code>pkgs</code> argument (and returned the inner\nfunction), this inner function is waiting for its final argument, which we\ncall <code>attrs</code>.</p>\n</li>\n<li>\n<p><code>attrs</code> is simply an attribute set (a key-value map in Nix). It’s designed to\nreceive all the specific properties of the individual package you want to\nbuild using this helper.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>How <code>attrs</code> is Used:</li>\n</ol>\n<ul>\n<li>\n<p>Look at the final line of <code>autotools.nix</code>:\n<code>derivation (defaultAttrs // attrs)</code>.</p>\n</li>\n<li>\n<p>The <code>//</code> operator in Nix performs an attribute set merge. It takes all\nattributes from <code>defaultAttrs</code> and combines them with all attributes from\n<code>attrs</code>.</p>\n</li>\n<li>\n<p>Crucially, if an attribute exists in both <code>defaultAttrs</code> and <code>attrs</code>, the\nvalue from <code>attrs</code> (the second operand) takes precedence and overrides the\ndefault value.</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>Applying attrs in the hello Derivation:</li>\n</ol>\n<ul>\n<li>In the <code>hello</code> derivation, we call <code>mkDerivation</code> like this:</li>\n</ul>\n<pre><code class=\"language-nix\">        mkDerivation {\n          name = \"hello\";\n          src = ./hello-2.12.1.tar.gz;\n        }\n</code></pre>\n<ul>\n<li>\n<p>The attribute set <code>{ name = \"hello\"; src = ./hello-2.12.1.tar.gz; }</code> is what\ngets passed as the <code>attrs</code> argument to the <code>mkDerivation</code> function (which,\nremember, is the inner function returned by <code>autotools.nix</code>).</p>\n</li>\n<li>\n<p>When derivation <code>(defaultAttrs // attrs)</code> is evaluated for “hello”, the <code>name</code>\nand <code>src</code> provided in the <code>attrs</code> set will be merged with all the\n<code>defaultAttrs</code> (like <code>builder</code>, <code>args</code>, <code>baseInputs</code>, etc.).</p>\n</li>\n</ul>\n<p>In summary:</p>\n<ul>\n<li>\n<p>The <code>pkgs</code> argument configures the general environment and available tools for\nthe builder.</p>\n</li>\n<li>\n<p>The <code>attrs</code> argument is where you provide the unique details for each specific\npackage you intend to build using this <code>autotools.nix</code> helper. It allows you\nto specify things like the package’s name, source code, version, and any\ncustom build flags, while still benefiting from all the sensible defaults\nprovided by <code>autotools.nix</code>. This separation makes <code>autotools.nix</code> a reusable\nand flexible “template” for creating derivations.</p>\n</li>\n</ul>\n<h4>Conclusion</h4>\n<p>Having explored the fundamental nature of functions in Nix, we can now see this\nconcept applies to more complex areas like NixOS configuration and derivations.\nIn the next chapter,\n<a href=\"https://saylesss88.github.io/NixOS_Modules_Explained_3.html\">NixOS Modules Explained</a>.\nWe will learn about NixOS Modules which are themselves functions most of the\ntime.</p>\n<h4>Resources</h4>\n<details>\n<summary> ✔️ Resources (Click to Expand) </summary>\n<ul>\n<li>\n<p><a href=\"https://nix.dev/tutorials/nix-language.html\">nix.dev Nix Lang Basics</a></p>\n</li>\n<li>\n<p><a href=\"https://nixos.org/guides/nix-pills/05-functions-and-imports.html\">nix pills Functions and Imports</a></p>\n</li>\n<li>\n<p><a href=\"https://zero-to-nix.com/concepts/nix-language/\">zero-to-nix Nix Lang</a></p>\n</li>\n<li>\n<p><a href=\"https://nixcloud.io/tour/?id=functions%2Fintroduction\">A tour of Nix “Functions”</a></p>\n</li>\n<li>\n<p><a href=\"https://learnxinyminutes.com/nix/\">learn Nix in y minutes</a></p>\n</li>\n<li>\n<p><a href=\"https://noogle.dev/\">noogle function library</a></p>\n</li>\n</ul>\n</details>\n",
      "date_published": "2025-11-21T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    },
    {
      "id": "https://saylesss88.github.io/Getting_Started_with_Nix_1.html",
      "url": "https://saylesss88.github.io/Getting_Started_with_Nix_1.html",
      "title": "Intro to Nix",
      "content_html": "<h1>Chapter1</h1>\n<details>\n<summary> ✔️ Click to Expand Table of Contents</summary>\n<!-- toc -->\n</details>\n<!-- ![gruv13](images/gruv13.png) -->\n<p><img src=\"images/trees1.cleaned.png\" alt=\"trees\" /></p>\n<h2>Intro</h2>\n<p>Welcome to <em>nix-book</em>, an introductory book about Nix. This book leans more\ntowards using Flakes but will contrast traditional Nix where beneficial.\nOriginally, this content started as a blog. I’m refining its flow to make it\nmore cohesive.</p>\n<p>In this chapter, I will touch on the different parts of the Nix ecosystem, give\na quick example of each and explain how they fit together.</p>\n<ul>\n<li>Click <a href=\"https://saylesss88.github.io/rss.xml\">Here</a>, or the logo on the top\nright, next to print for the RSS feed.</li>\n</ul>\n<details>\n<summary>\n- ✔️: Will indicate an expandable section, click the little triangle to expand.\n</summary>\n<ul>\n<li>These sections are expandable!</li>\n</ul>\n</details>\n<p>The code blocks have an option to hide code, where I find it reasonable I will\nhide the outputs of the expressions. Click the eye in the right corner of the\ncode block next to the copy clipboard.</p>\n<p>Example hover over top-right corner of code block and click the eye to see\nhidden text:</p>\n<pre><code class=\"language-nix\">{\n  attrset = { a = 2; b = 4; };\n~  hidden_set = { a = hidden; b = set; };\n}\n</code></pre>\n<blockquote>\n<p>❗ If you’re new to Nix, think of it as a recipe book for software: you\ndescribe what you want (declarative), and Nix ensures it’s built the same way\nevery time (reproducible).</p>\n</blockquote>\n<h3>Why Learn Nix?</h3>\n<p>The main reason to learn Nix is that it allows you to write declarative scripts\nfor reproducible software builds. Rather than mutate the global state and\ninstall packages to a global location such as <code>/usr/bin</code> Nix stores packages in\nthe Nix store, usually the directory <code>/nix/store</code>, where each package has its\nown unique subdirectory. This paradigm gives you some powerful features, such\nas:</p>\n<ul>\n<li>\n<p>Allowing multiple versions or variants of the same package at the same time.\nThis prevents “DLL hell” from different applications having dependencies on\ndifferent versions of the same package.</p>\n</li>\n<li>\n<p>Atomic upgrades: Upgrading or uninstalling an application cannot break other\napplications and either succeed completely or fail completely preventing\npartial upgrades breaking your system. The nix store is immutable preventing\npackage management operations from overwriting other packages. They wouldn’t\noverwrite each other anyways because the hashing scheme ensures that new\nversions or repeat packages end up at different paths.</p>\n</li>\n<li>\n<p>Nix is designed to provide hermetic builds that aren’t affected by the\nenvironment, this helps you make sure that when packaging software that the\ndependencies are complete because they must be explicitly declared as inputs.\nWith other package managers it is more difficult to be sure that an\nenvironment variable or something in your <code>$PATH</code> isn’t affecting your build.</p>\n</li>\n</ul>\n<p>Let’s dive into the key characteristics of Nix:</p>\n<table><thead><tr><th>Concept</th><th>Description</th></tr></thead><tbody>\n<tr><td><strong>Pure</strong></td><td>Functions don’t cause side effects.</td></tr>\n<tr><td><strong>Functional</strong></td><td>Functions can be passed as arguments and returned as results.</td></tr>\n<tr><td><strong>Lazy</strong></td><td>Not evaluated until needed to complete a computation.</td></tr>\n<tr><td><strong>Declarative</strong></td><td>Describing a system outcome.</td></tr>\n<tr><td><strong>Reproducible</strong></td><td>Operations that are performed twice return same results</td></tr>\n</tbody></table>\n<blockquote>\n<p>❗ Important: In Nix, everything is an expression, there are no statements.</p>\n<p>❗ Important: Values in Nix are immutable.</p>\n</blockquote>\n<h3>The Nix Ecosystem</h3>\n<p>The <strong>Nix Language</strong> is the foundation of the ecosystem and is used to write\n<strong>Nix Expressions</strong>.</p>\n<p>Example of a simple nix expression:</p>\n<pre><code class=\"language-nix\">{ hello = \"world\"; }\n# or\n\"foo\" + \"bar\"\n</code></pre>\n<p>While the Nix language provides the foundation for writing expressions, it is\nonly part of the ecosystem. These expressions become powerful when used within\nthe Nix Package Manager, which evaluates and realizes them into tangible\nsoftware builds and system configurations. This is where Nixpkgs and NixOS come\ninto play.</p>\n<h3>The Nix Package Manager, Nixpkgs, and NixOS</h3>\n<p>At the heart of the Nix ecosystem is <strong>Nix Package Manager</strong>. This powerful\nengine is responsible for orchestrating the entire process: taking <strong>Nix\nexpressions</strong> (like <em>package definitions</em> and <em>configuration modules</em>),\nevaluating them into precise <em>derivations</em>, executing their build steps (the\n<em>realization phase</em>), and meticulously managing the immutable Nix store.</p>\n<p>A cornerstone of the Nix ecosystem is <strong>Nixpkgs</strong>. This vast collection\ncomprises tens of thousands of Nix expressions that describe how to build a wide\narray of software packages from source. Nixpkgs is more than just a package\nrepository—it also contains <strong>NixOS Modules</strong>, declarative configurations that\ndefine system behavior, ensuring a structured and reproducible environment.\nThese modules enable users to declaratively describe a Linux system, with each\nmodule contributing to the desired state of the overall system by leveraging\n<em>package definitions</em> and <em>derivations</em>. This is how NixOS emerges: it is quite\nsimply the natural consequence of applying the Nix philosophy to building an\nentire Linux operating system.</p>\n<p>We will further expand our understanding of modules in\n<a href=\"https://saylesss88.github.io/NixOS_Modules_Explained_3.html\">Chapter 3</a></p>\n<p>The following is an example of a NixOS module that is part of the <code>nixpkgs</code>\ncollection:</p>\n<pre><code class=\"language-nix\"># nixpkgs/nixos/modules/programs/zmap.nix\n{\n  pkgs,\n  config,\n  lib,\n  ...\n}:\n\nlet\n  cfg = config.programs.zmap;\nin\n{\n  options.programs.zmap = {\n    enable = lib.mkEnableOption \"ZMap, a network scanner designed for Internet-wide network surveys\";\n  };\n\n  config = lib.mkIf cfg.enable {\n    environment.systemPackages = [ pkgs.zmap ];\n\n    environment.etc.\"zmap/blacklist.conf\".source = \"${pkgs.zmap}/etc/zmap/blacklist.conf\";\n    environment.etc.\"zmap/zmap.conf\".source = \"${pkgs.zmap}/etc/zmap.conf\";\n  };\n}\n</code></pre>\n<ul>\n<li>This module, <code>programs.zmap.nix</code>, demonstrates how NixOS configurations work.\nIt defines an enable option for the ZMap network scanner. If enabled by the\nuser in their system configuration, the module ensures the <code>zmap</code> package is\ninstalled and its default configuration files are placed in <code>/etc</code>, allowing\nZMap to be managed declaratively as part of the operating system.\n<ul>\n<li>\n<p>When <code>nixpkgs</code> is imported (e.g., in a NixOS configuration), the\nconfiguration options and settings defined by its modules (like\n<code>programs.zmap.nix</code>) become available for use, typically accessed via dot\nnotation (e.g., <code>config.programs.zmap.enable</code>). This ability to make such a\nhuge set of modules and packages readily available without a significant\nperformance penalty is due to Nix’s <strong>lazy evaluation</strong>; only the\nexpressions required for a particular build or configuration are actually\nevaluated.</p>\n</li>\n<li>\n<p>Most of the time you’ll simply <a href=\"https://search.nixos.org/packages\">search</a>\nto see if the package is already included in <code>nixpkgs</code> and follow the\ninstructions there to get it on your system. It is good practice to first\nsearch for the <a href=\"https://search.nixos.org/options?\">options</a> to see what\nconfigurable settings are available, and then proceed to search for the\npackage itself if you know it exists or if you need its specific package\ndefinition. When you look up the options for Zmap, <code>programs.zmap.enable</code> is\nall that is listed in this example.</p>\n</li>\n<li>\n<p>Home Manager uses the same underlying Nix module system as NixOS, and when\nyou do something like home.packages = with pkgs; you are referring to the\nsame package derivations from nixpkgs as you would with\n<code>environment.systemPackages</code>. However, Home Manager’s own configuration\nmodules (e.g., for <code>programs.zsh</code> or <code>git</code>) are distinct and reside in the\nHome Manager repository, designed for user-specific configurations.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>One of the main differentiating aspects of Nix, as opposed to traditional\npackage managers, is this concept that package builds are treated as pure\nfunctions. This functional paradigm ensures consistency and reproducibility,\nwhich are core tenets of the Nix philosophy.</p>\n<p><img src=\"images/nix_isnot_nixos.png\" alt=\"Nix is not\" /></p>\n<p><strong>Fig. X:</strong> Conceptual diagram illustrating the distinction between Nix and\nNixOS. Source: xeiaso, from the blog post “Making NixOS modules for fun and\n(hopefully) profit”, <a href=\"https://xeiaso.net/talks/asg-2023-nixos/\">https://xeiaso.net/talks/asg-2023-nixos/</a>.</p>\n<p>Nix expressions permeate the ecosystem—everything in Nix is an expression,\nincluding the next key components: package definitions and derivations.</p>\n<h3>Package Definitions &amp; Derivations</h3>\n<p><strong>Package Definitions</strong> are specialized expressions that tell Nix how to build\nsoftware.</p>\n<p>Example of a package definition:</p>\n<pre><code class=\"language-nix\"># hello.nix\n{pkgs ? import &lt;nixpkgs&gt; {}}:\npkgs.stdenv.mkDerivation {\n  pname = \"hello\";\n  version = \"2.12.1\";\n\n  src = pkgs.fetchurl {\n    url = \"https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz\";\n    sha256 = \"086vqwk2wl8zfs47sq2xpjc9k066ilmb8z6dn0q6ymwjzlm196cd\";\n  };\n\n  nativeBuildInputs = [pkgs.autoconf pkgs.automake pkgs.gcc];\n\n  configurePhase = ''\n    ./configure --prefix=$out\n  '';\n\n  buildPhase = ''\n    make\n  '';\n\n  installPhase = ''\n    make install\n  '';\n}\n</code></pre>\n<ol>\n<li><strong>Evaluation Phase</strong>:</li>\n</ol>\n<p>Now when you run something like:</p>\n<pre><code class=\"language-bash\">nix-instantiate hello.nix\nwarning: you did not specify '--add-root'; the result might be removed by the garbage collector\n/nix/store/p2hbg16a9kpqgx2nzcsq39wmnyxyq4jy-hello-2.12.1.drv\n</code></pre>\n<ul>\n<li>Nix evaluates the expression and produces a <code>.drv</code> file (the <strong>derivation</strong>),\na precise JSON-like blueprint describing how the package will be built. It\ndoes not contain the built software itself.</li>\n</ul>\n<ol start=\"2\">\n<li><strong>Realization Phase</strong>:</li>\n</ol>\n<p>When you run:</p>\n<pre><code class=\"language-bash\">nix-build hello.nix\n#...snip...\nshrinking RPATHs of ELF executables and libraries in /nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1\nshrinking /nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1/bin/hello\nchecking for references to /build/ in /nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1...\ngzipping man pages under /nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1/share/man/\npatching script interpreter paths in /nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1\nstripping (with command strip and flags -S -p) in  /nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1/bin\n/nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1\n</code></pre>\n<ul>\n<li>\n<p>Nix realizes the derivation by actually executing the build steps, fetching\nsources, compiling (if needed), and producing the final result (typically\nstored in e.g. <code>/nix/store/53hqyw72dijq3wb5kc0ln04g681gk6cp-hello-2.12.1</code>)</p>\n</li>\n<li>\n<p><code>nix-build</code> also creates a symlink named <code>result</code> in your current directory,\npointing to the final build output in the Nix store.</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>Execute the program:</li>\n</ol>\n<pre><code class=\"language-bash\">./result/bin/hello\nHello, world!\n</code></pre>\n<p><code>result/bin/hello</code> points to the executable inside the output of the\nderivation.The derivation describes how the package is built, but does not\ninclude the final binaries.</p>\n<p>To say that another way, the derivation is not the executable. The executable is\none of the derivations <code>outputs</code>. When Nix “realizes” a derivation, it executes\nthose build instructions, and the result is the actual built software, which\ngets placed into its own unique path in the Nix store.</p>\n<p>A single derivation can produce multiple outputs. The executable is typically\npart of the <code>out</code> output, specifically in its <code>bin</code> directory.</p>\n<p>Here is a small snippet of what a <code>.drv</code> file could look like, I got this from\nbuilding the hello derivation and running the following on the store path:</p>\n<pre><code class=\"language-bash\">nix show-derivation /nix/store/9na8mwp5zaprikqaqw78v6cdn1rxac7i-hello-2.12.1\n</code></pre>\n<pre><code class=\"language-nix\">{\n  \"/nix/store/871398c9cbskmzy6bvfnynr8yrlh7nk0-hello-2.12.1.drv\": {\n    \"args\": [\n      \"-e\",\n      \"/nix/store/v6x3cs394jgqfbi0a42pam708flxaphh-default-builder.sh\"\n    ],\n    \"builder\": \"/nix/store/1jzhbwq5rjjaqa75z88ws2b424vh7m53-bash-5.2p32/bin/bash\",\n    \"env\": {\n      \"__structuredAttrs\": \"\",\n      \"buildInputs\": \"\",\n      \"builder\": \"/nix/store/1jzhbwq5rjjaqa75z88ws2b424vh7m53-bash-5.2p32/bin/bash\",\n      \"cmakeFlags\": \"\",\n      \"configureFlags\": \"\",\n      \"depsBuildBuild\": \"\",\n      \"depsBuildBuildPropagated\": \"\",\n      \"depsBuildTarget\": \"\",\n      \"depsBuildTargetPropagated\": \"\",\n      \"depsHostHost\": \"\",\n      \"depsHostHostPropagated\": \"\",\n      \"depsTargetTarget\": \"\",\n      \"depsTargetTargetPropagated\": \"\",\n      \"doCheck\": \"\",\n      \"doInstallCheck\": \"\",\n      \"mesonFlags\": \"\",\n      \"name\": \"hello-2.12.1\",\n      \"nativeBuildInputs\": \"\",\n      \"out\": \"/nix/store/9na8mwp5zaprikqaqw78v6cdn1rxac7i-hello-2.12.1\",\n      \"outputs\": \"out\",\n      \"patches\": \"\",\n      \"pname\": \"hello\",\n      \"propagatedBuildInputs\": \"\",\n      \"propagatedNativeBuildInputs\": \"\",\n      \"src\": \"/nix/store/pa10z4ngm0g83kx9mssrqzz30s84vq7k-hello-2.12.1.tar.gz\",\n      \"stdenv\": \"/nix/store/80wijs24wjp619zmrasrh805bax02xjm-stdenv-linux\",\n      \"strictDeps\": \"\",\n      \"system\": \"x86_64-linux\",\n      \"version\": \"2.12.1\"\n    },\n# ... snip ...\n</code></pre>\n<h4>Conclusion</h4>\n<p>In this introductory chapter, we’ve laid the groundwork for understanding the\npowerful Nix ecosystem. We explored how the Nix Language forms the declarative\nbedrock, enabling us to define desired system states and software builds as\nexpressions. You saw how the Nix Package Manager orchestrates this process,\ntransforming those expressions into precise derivations during the evaluation\nphase, and then faithfully “realizing” them into reproducible, isolated\nartifacts within the immutable <code>/nix/store</code>.</p>\n<p>We also introduced the vast Nixpkgs collection, which provides tens of thousands\nof package definitions and forms the foundation for NixOS — a fully declarative\noperating system built on these principles—and even user-level configurations\nlike those managed by Home Manager. This unique functional approach, with its\nemphasis on immutability and lazy evaluation, is what enables Nix’s promises of\nconsistency, atomic upgrades, and truly hermetic builds, fundamentally changing\nhow we think about software and system management.</p>\n<h5>Related Sub-Chapters</h5>\n<ul>\n<li>\n<p>The <a href=\"https://saylesss88.github.io/nix/nix_language.html\">Nix Language</a></p>\n</li>\n<li>\n<p><a href=\"https://saylesss88.github.io/nix/nix_package_manager.html\">Nix Package Manager</a></p>\n</li>\n</ul>\n<p>Now that you have a foundational understanding of the Nix ecosystem and its core\noperational cycle, we are ready to delve deeper into the building blocks of Nix\nexpressions. In the next chapter,\n<a href=\"https://saylesss88.github.io/Understanding_Nix_Functions_2.html\">Understanding Nix Functions</a>,\nwe will peel back the layers and explore the intricacies of function arguments,\nadvanced patterns, scope, and how functions play a crucial role in building more\nsophisticated Nix expressions and derivations.</p>\n<p>Here are some resources that are helpful for getting started:</p>\n<h4>Resources</h4>\n<details>\n<summary> ✔️ Resources (Click to Expand)</summary>\n<ul>\n<li>\n<p><a href=\"https://search.nixos.org/packages\">NixOS Search</a></p>\n</li>\n<li>\n<p><a href=\"https://search.nixos.org/options?\">NixOS Options</a></p>\n</li>\n<li>\n<p><a href=\"https://home-manager-options.extranix.com/?query=&amp;release=master\">Extranix Home-Manager Option Search</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/nix-community/awesome-nix\">awesome-nix</a></p>\n</li>\n<li>\n<p><a href=\"https://wiki.nixos.org/wiki/Nix_ecosystem\">Nix Core Ecosystem</a>, Nix, NixOS,\nNix Lang, Nixpkgs are all distinctly different; related things which can be\nconfusing for beginners this article explains them.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/nixos/nixpkgs\">nixpkgs</a>: Vast package repository</p>\n</li>\n<li>\n<p><a href=\"https://nixos.org/guides/how-nix-works/\">How Nix Works</a></p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/manual/nix/2.26/language/types#type-attrs\">Nix Reference Manual Data Types</a>\nThe main Data Types you’ll come across in the Nix ecosystem</p>\n</li>\n<li>\n<p><a href=\"https://wiki.nixos.org/wiki/NixOS_Wiki\">NixOS Wiki</a></p>\n</li>\n<li>\n<p><a href=\"https://nix.dev/\">nix.dev</a>: Has become the top respected source of\ninformation in my opinion. There is a lot of great stuff in here, and they\nactively update the information.</p>\n</li>\n</ul>\n</details>\n",
      "date_published": "2025-11-21T00:00:00+00:00",
      "author": {
        "name": "saylesss88"
      }
    }
  ]
}