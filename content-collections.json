{
  "entries": [
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.168318696+00:00",
      "description": "\n",
      "draft": false,
      "path": "index.md",
      "preview_html": "",
      "tags": [],
      "title": "index"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.168318696+00:00",
      "description": "\n",
      "draft": false,
      "path": "nix/nix_language.md",
      "preview_html": "",
      "tags": [],
      "title": "nix_language"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.168195203+00:00",
      "description": "\n",
      "draft": false,
      "path": "nix/nix_package_manager.md",
      "preview_html": "",
      "tags": [],
      "title": "nix_package_manager"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.167428073+00:00",
      "description": "\n",
      "draft": false,
      "path": "installation/README.md",
      "preview_html": "",
      "tags": [],
      "title": "README"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.167309018+00:00",
      "description": "\n",
      "draft": false,
      "path": "nix/encrypted_zfs.md",
      "preview_html": "",
      "tags": [],
      "title": "encrypted_zfs"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.167259965+00:00",
      "description": "\n",
      "draft": false,
      "path": "nix/zfs_impermanence.md",
      "preview_html": "",
      "tags": [],
      "title": "zfs_impermanence"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.167176938+00:00",
      "description": "\n",
      "draft": false,
      "path": "nix/hardening_NixOS.md",
      "preview_html": "",
      "tags": [],
      "title": "hardening_NixOS"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.167132554+00:00",
      "description": "\n",
      "draft": false,
      "path": "nix/hardening_networking.md",
      "preview_html": "",
      "tags": [],
      "title": "hardening_networking"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.167090715+00:00",
      "description": "\n",
      "draft": false,
      "path": "nix/browsing_security.md",
      "preview_html": "",
      "tags": [],
      "title": "browsing_security"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.167049738+00:00",
      "description": "\n",
      "draft": false,
      "path": "nix/gpg-agent.md",
      "preview_html": "",
      "tags": [],
      "title": "gpg-agent"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.167006516+00:00",
      "description": "\n",
      "draft": false,
      "path": "nix/README.md",
      "preview_html": "",
      "tags": [],
      "title": "README"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.166954848+00:00",
      "description": "\n",
      "draft": false,
      "path": "nix/whonix_kvm.md",
      "preview_html": "",
      "tags": [],
      "title": "whonix_kvm"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.166871982+00:00",
      "description": "\n",
      "draft": false,
      "path": "installation/enc/lanzaboote.md",
      "preview_html": "",
      "tags": [],
      "title": "lanzaboote"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.166871982+00:00",
      "description": "\n",
      "draft": false,
      "path": "nix/secureboot_libvirt.md",
      "preview_html": "",
      "tags": [],
      "title": "secureboot_libvirt"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.166659009+00:00",
      "description": "\n",
      "draft": false,
      "path": "nix/kvm.md",
      "preview_html": "",
      "tags": [],
      "title": "kvm"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.166522020+00:00",
      "description": "\n",
      "draft": false,
      "path": "nix/cachix_devour.md",
      "preview_html": "",
      "tags": [],
      "title": "cachix_devour"
    },
    {
      "author": null,
      "collection": null,
      "date": "2026-01-20T12:11:31.166452829+00:00",
      "description": "\n",
      "draft": false,
      "path": "vcs/README.md",
      "preview_html": "",
      "tags": [],
      "title": "README"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2026-01-11T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "nixos_containers.md",
      "preview_html": "<p><img src=\"images/boxes.cleaned.png\" alt=\"boxes\" /></p><p>NixOS containers are lightweight <code>systemd-nspawn</code> containers managed\ndeclaratively through your NixOS configuration. They allow you to run separate,\nminimal NixOS instances on the same machine, each with its own services,\npackages, and (optionally) network stack.</p><p>❗ NixOS’ containers do not provide full security out of the box (just like\ndocker). They do give you a separate chroot, but a privileged user (root) in a\ncontainer can escape the container and become root on the host system.\n–<a href=\"https://blog.beardhatcode.be/2020/12/Declarative-Nixos-Containers.html\">beardhatcode Declarative-Nixos-Containers</a></p>",
      "tags": [
        "nixos",
        "containers"
      ],
      "title": "NixOS Containers"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-12-31T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "nixpkgs/rust_crate_to_nixpkgs.md",
      "preview_html": "<p>NOTE: This example assumes you’re packaging a crate that’s already on\ncrates.io, or you’re packaging an existing Rust project for nixpkgs.</p><p>Nixpkgs is a big repository, so it helps to start with a focused workflow:\ncreate a branch, add a package under <code>pkgs/by-name/</code>, build it, then open a PR.</p><pre><code class=\"language-bash\">git clone git@github.com:your-user/nixpkgs.git\ncd nixpkgs\ngit remote add upstream git@github.com:NixOS/nixpkgs.git\n</code></pre>\n<p>(SSH avoids HTTPS helper issues)</p>",
      "tags": [
        "packaging",
        "rust",
        "nixpkgs"
      ],
      "title": "Packaging a Rust crate for Nixpkgs"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-12-08T00:00:00+00:00",
      "description": "JJ Version Control",
      "draft": false,
      "path": "vcs/jujutsu.md",
      "preview_html": "<p><img src=\"../images/jujutsu.png\" alt=\"JJ Logo\" /></p><p>⚠️ <strong>Security Reminder</strong>: Never commit secrets (passwords, API keys, tokens,\netc.) in plain text to your Git repository. If you plan to publish your NixOS\nconfiguration, always use a secrets management tool like <code>sops-nix</code> or <code>agenix</code>\nto keep sensitive data safe. See the\n<a href=\"https://saylesss88.github.io/installation/enc/sops-nix.html\">Sops-Nix Guide</a>\nfor details.</p><p>Jujutsu (jj) is a modern, Git-compatible version control system designed to\nsimplify and improve the developer experience. It offers a new approach to\ndistributed version control, focusing on a more intuitive workflow, powerful\nundo capabilities, and a branchless model that reduces common pitfalls of Git.</p>",
      "tags": [
        "vcs",
        "jj"
      ],
      "title": "Jujutsu (JJ)"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-12-05T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "flakes/helix_flake.md",
      "preview_html": "<p><img src=\"../images/helix.png\" alt=\"Helix Logo\" />–<a href=\"https://helix-editor.com/\">helix-editor.com</a></p><p>As we’ve seen from previous examples, the helix editor repository includes a few\n<code>.nix</code> files including a <code>flake.nix</code>. Their flake uses a lot of idiomatic Nix\ncode and advanced features. First I will break down their <code>flake.nix</code> and\n<code>default.nix</code> to understand why they do certain things. And finally, we will\nchange the build to “debug” mode demonstrating how easily you can modify the\nbehavior of a package defined within a Nix flake without changing the original\nsource code or the upstream flake directly.</p><pre><code class=\"language-bash\">git clone https://github.com/helix-editor/helix.git\ncd helix\n</code></pre>\n<p>When you enter ",
      "tags": [
        "nixos",
        "flakes",
        "helix"
      ],
      "title": "Understanding the Helix Flake"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-11-30T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "intro_to_nushell_on_NixOS.md",
      "preview_html": "<p><img src=\"images/nu.png\" alt=\"Nu\" /></p><p><strong>TL;DR</strong>:I recently switched default shells from zsh to nushell, this post is\nabout some of the challenges and advantages of using nushell with NixOS.</p><p>While the average user might not immediately see significant advantages, those\nwho frequently work with structured data formats like JSON, YAML, and CSV –\nsuch as developers interacting with APIs, system administrators managing\nconfigurations, and data professionals – will likely find Nushell’s native\ndata handling and powerful pipeline capabilities a plus. Additionally, users\nwho value a more consistent and safer scripting experience might appreciate\nNushell’s language-first design and features like strong typing.</p>",
      "tags": [
        "nushell",
        "shells"
      ],
      "title": "Intro to Nushell"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-11-30T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "functions/functions_and_modules.md",
      "preview_html": "<p>When you start exploring NixOS configurations or tools like Home Manager, you’ll\nencounter a concept called Nix Modules. Modules are also functions, but they\nbehave differently regarding their arguments, which can be a source of\nconfusion.</p><p><strong>What are NixOS Modules</strong>?</p><p>Nix Modules are a powerful system built on top of basic Nix functions, primarily\nused for declarative system configurations (like NixOS, Home Manager, NixOps,\netc.). They allow you to define parts of your system configuration in separate\nfiles that are then composed together.</p>",
      "tags": [
        "nixos",
        "functions"
      ],
      "title": "Functions and NixOS Modules"
    },
    {
      "author": "saylesss88",
      "collection": "notes",
      "date": "2025-11-30T00:00:00+00:00",
      "description": "Git",
      "draft": false,
      "path": "vcs/git.md",
      "preview_html": "<p>⚠️ <strong>Important</strong>: Never commit secrets (passwords, API keys, tokens, etc.) in\nplain text to your Git repository. If you plan to publish your NixOS\nconfiguration, always use a secrets management tool like sops-nix or agenix to\nkeep sensitive data safe. See the\n<a href=\"https://saylesss88.github.io/installation/enc/sops-nix.html\">Sops-Nix Guide</a>\nfor details.</p><p>It’s also important to understand that <strong>all files in the <code>/nix/store</code> are\nworld-readable by default</strong> This has important security implications for anyone\nmanaging sensitive data on a NixOS system.</p><p>What Does “World-Readable” Mean?</p>",
      "tags": [
        "vcs",
        "git"
      ],
      "title": "Git"
    },
    {
      "author": "saylesss88",
      "collection": "notes",
      "date": "2025-11-29T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "Intro_to_Nix_Derivations.md",
      "preview_html": "<p><img src=\"images/gruv10.png\" alt=\"gruv10\" /></p><p>Nix’s build instructions, known as <strong>derivations</strong>, are defined using the Nix\nLanguage. These derivations can describe anything from individual software\npackages to complete system configurations. The Nix package manager then\ndeterministically “realizes” (builds) these derivations, ensuring consistency\nbecause they rely solely on a predefined set of inputs.</p><p>Most things in NixOS are built around derivations. Your NixOS system is\ndescribed by such a single system derivation. When you want to apply a new\nconfiguration, <code>nixos-rebuild</code> handles the process:</p>",
      "tags": [
        "notes",
        "derivations"
      ],
      "title": "Intro to Derivations"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-11-28T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "flakes/flake_outputs.md",
      "preview_html": "<p>Flake outputs are what the flake produces when built. Flakes can have multiple\noutputs simultaneously such as:</p><p><strong>Packages</strong>: Self-contained bundles that are built using derivations and\nprovide either some kind of software or dependencies of software.</p><p><a href=\"https://saylesss88.github.io/NixOS_Modules_Explained_3.html\">NixOS modules</a></p>",
      "tags": [
        "nixos",
        "flakes",
        "outputs"
      ],
      "title": "Flake outputs"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-11-28T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "flakes/flake_inputs.md",
      "preview_html": "<p>The attribute <code>inputs</code> specifies the dependencies of a flake, as an attrset\nmapping input names to flake references.</p><p>If a repository provides a <code>flake.nix</code> you can include it as an input in your\n<code>flake.nix</code>.</p><p>For example, I like yazi as my file explorer and have been using helix as my\neditor. To be able to get yazi to work with helix I needed the latest versions\nof both yazi and helix. One way to get the latest versions was to add their\nflakes as inputs to my flake:</p>",
      "tags": [
        "nixos",
        "flakes"
      ],
      "title": "Flake Inputs"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-11-28T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "flakes/flake_examples.md",
      "preview_html": "<p>This chapter provides practical examples to illustrate the concepts discussed in\n“Nix Flakes Explained.”</p><p>NixOS modules and configurations offer us a powerful and composable way to\ndefine and share system configurations. Imagine we have several independent\n“players,” each with their own unique set of configurations or modules. How do\nwe combine these individual contributions into a single, cohesive system without\ndirectly altering each player’s original flake?</p><p>This example demonstrates how flakes can extend and compose each other, allowing\nyou to layer configurations on top of existing ones. This is particularly useful\nwhen you want to:</p>",
      "tags": [
        "nixos",
        "flakes"
      ],
      "title": "Flake outputs"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-11-27T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "Nix_Pull_Requests.md",
      "preview_html": "<p><img src=\"images/gruv16.png\" alt=\"gruv16\" /></p><p><strong>Pull requests</strong> communicate changes to a branch in a repository. Once a pull\nrequest is opened, you can review changes with collaborators and add follow-up\ncommits.</p><p>A <strong>pull request</strong> is a proposal to merge a set of changes from one branch\ninto another. In a pull request, collaborators can review and discuss the\nproposed set of changes before they integrate the changes into the main\ncodebase.</p>",
      "tags": [
        "nixos",
        "nixpkgs"
      ],
      "title": "Nix Pull Requests"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-11-24T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "installation/unenc/unenc_impermanence.md",
      "preview_html": "<p>Figure 1: Impermanence Logo: Image of the Impermanence logo. Sourced from the</p><p><a href=\"https://github.com/nix-community/impermanence\">Impermanence repo</a></p><p>This guide is for an unencrypted setup, there are a few links at the end for\nencrypted setups. This guide follows the previous\n<a href=\"https://saylesss88.github.io/installation/unencrypted_setups.html\">minimal install guide</a>\nbut you should be able to adjust it carefully to meet your needs.</p>",
      "tags": [
        "nixos",
        "btrfs",
        "impermanence"
      ],
      "title": "Impermanence (Unencrypted BTRFS)"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-11-22T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "Working_with_Nixpkgs_Locally.md",
      "preview_html": "<p><img src=\"images/server_rack.cleaned.png\" alt=\"server_rack\" /></p><p>Nixpkgs, the package repository for NixOS, is a powerful resource for building\nand customizing software.</p><p>Working with a local copy enhances development, debugging, and contribution\nworkflows.</p>",
      "tags": [
        "nixos",
        "nixpkgs"
      ],
      "title": "Local Nixpkgs"
    },
    {
      "author": "saylesss88",
      "collection": null,
      "date": "2025-11-22T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "Debugging_and_Tracing_NixOS_Modules.md",
      "preview_html": "<p>This chapter covers debugging NixOS modules, focusing on tracing module options\nand evaluating merges.</p><p><img src=\"images/coding4.png\" alt=\"404\" /></p><p><a href=\"https://saylesss88.github.io/posts/nix_modules_explained/\">nix-modules-explained</a></p>",
      "tags": [],
      "title": "Debugging NixOS modules"
    },
    {
      "author": "saylesss88",
      "collection": "notes",
      "date": "2025-11-22T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "Comparing_Flakes_and_Traditional_Nix.md",
      "preview_html": "<p>A key benefit of Nix Flakes is their <em>default</em> enforcement of <strong>pure\nevaluation</strong>.</p><p>In Nix, an <strong>impure operation</strong> depends on something <em>outside</em> its explicit\ninputs. Examples include:</p><p>Impurity leads to unpredictable builds that may differ across systems or time.</p>",
      "tags": [
        "flakes",
        "nix"
      ],
      "title": "Comparing Flakes and Traditional Nix"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-11-22T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "functions/practical_functions.md",
      "preview_html": "<p><img src=\"images/coding6.png\" alt=\"coding6\" /></p><p><a href=\"https://gitlab.com/api/v4/projects/4207231/packages/generic/graphviz-releases/2.49.3/graphviz-2.49.3.tar.gz\">graphviz</a></p><p><a href=\"https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz\">hello</a></p>",
      "tags": [
        "nixos",
        "functions"
      ],
      "title": "Practical Nix Functions"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-11-22T00:00:00+00:00",
      "description": null,
      "draft": true,
      "path": "flakes/specialisations.md",
      "preview_html": "<p><strong>NixOS specialisations</strong> are a powerful feature that allow you to define\nalternative system configurations variations within a single NixOS setup. Each\nspecialisation can modify or extend the base configuration, and NixOS will\ngenerate separate boot entries for each, letting you choose at boot time (or\nswitch at runtime) which environment to use. This is ideal for testing,\nhardware-specific tweaks, or separating work and personal environments without\nmaintaining multiple configuration files</p><p>Specialisations are defined as attributes under the <code>specialisation</code> option in\nyour configuration. Each key (e.g., <code>niri-test</code>) represents a named\nspecialisation, and its configuration attribute contains the NixOS options to\napply on top of the base system</p",
      "tags": [
        "nixos",
        "specialisations"
      ],
      "title": "Multiple Profiles (Specialisations)"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-11-22T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "flakes/overlays.md",
      "preview_html": "<p><img src=\"../images/pokego.png\" alt=\"Pokego Logo\" />–<a href=\"https://github.com/rubiin/pokego\">pokego repo</a></p><p>Overlays are Nix functions that accept two arguments, <code>final</code> and <code>prev</code> and\nreturn a set of packages. Overlays are similar to <code>packageOverrides</code> as a way to\ncustomize Nixpkgs, <code>packageOverrides</code> acts as an overlay with only the <code>prev</code>\nargument. Therefore, <code>packageOverrides</code> is appropriate for basic use, but\noverlays are more powerful and easier to distribute.</p><p>Example:</p>",
      "tags": [
        "nixos",
        "overlays",
        "outputs"
      ],
      "title": "Extending Flakes with Overlays"
    },
    {
      "author": "saylesss88",
      "collection": null,
      "date": "2025-11-22T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "installation/unenc/unencrypted_setups.md",
      "preview_html": "<p>Figure 1: BTRFS Logo: Image of the BTRFS logo. Sourced from the BTRFS repo BTRFS\nlogo</p><p>Why I Chose BTRFS I chose BTRFS because I was already familiar with it from\nusing it with Arch Linux and I found it to be very easy to use. From what I’ve\nread, there are licensing issues between the Linux Kernel and ZFS which means\nthat ZFS is not part of the Linux Kernel; it’s maintained by the OpenZFS project\nand available as a separate kernel module. This can cause issues and make you\nthink more about your filesystem than I personally want to at this point.</p><p>A <strong>Btrfs subvolume</strong> is essentially a distinct section within a Btrfs\nfilesystem that maintains its own set of files and directories, along with a\nseparate inode numbering system. Unlike block-level partitions (such as ",
      "tags": [],
      "title": "Unencrypted Install (BTRFS)"
    },
    {
      "author": "saylesss88",
      "collection": null,
      "date": "2025-11-22T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "installation/enc/USB_keyfile.md",
      "preview_html": "<p>This allows you to use a USB stick for your keyfile, with a backup in case you\nwant or need it. There is a setting <code>fallbackToPassword</code> that protects you in\ncase something fails with the USB key.</p><p>First, I’ll show how to set up a dedicated USB stick for a keyfile. (i.e., one\nthat is only used for this). After that I will show the process of adding the\nkeyfile to a USB stick with existing data on it that you don’t want to lose.</p><p><strong>Generate the keyfile</strong></p>",
      "tags": [],
      "title": "USB Keyfile Unlock"
    },
    {
      "author": "saylesss88",
      "collection": null,
      "date": "2025-11-22T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "installation/enc/sops-nix.md",
      "preview_html": "<p><a href=\"https://github.com/getsops/sops?ref=blog.gitguardian.com\">SOPS</a>, short for\n<strong>S</strong>ecrets<strong>OP</strong>eration<strong>S</strong>, is an editor of encrypted files that supports\nquite a few BINARY formats and encrypts with AWS KMS, GCP KMS, Azure Key Vault,\nage, and PGP.</p><p>Managing secrets—like API keys, SSH deploy keys, and password hashes is a\ncritical part of system configuration, but it’s also one of the trickiest to do\nsecurely and reproducibly. Traditionally, secrets might be stored in ad hoc\nlocations, referenced by absolute paths, or managed manually outside of version\ncontrol. This approach makes it hard to share, rebuild, or audit your\nconfiguration, and increases the risk of accidental leaks or inconsistencies\nbetween systems.</p><p><code>sops-nix",
      "tags": [],
      "title": "Secrets Management (Sops-Nix)"
    },
    {
      "author": "saylesss88",
      "collection": null,
      "date": "2025-11-22T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "installation/enc/encrypted_impermanence.md",
      "preview_html": "<p>❗ Important Note: This guide details a setup involving encrypted partitions\nand impermanent NixOS. While powerful, such configurations require careful\nattention to detail. Incorrect steps, especially concerning encryption keys or\npersistent data paths, can lead to <strong>permanent data loss</strong>. Please read all\ninstructions thoroughly before proceeding and consider backing up any critical\ndata beforehand. This has only been tested with the disk layout described in\n<a href=\"https://saylesss88.github.io/installation/encrypted_manual.html\">Encrypted Setups</a></p><p>As a system operates, it gradually accumulates state on its root partition. This\nstate is stored in various directories such as <code>/etc</code> and <code>/var</code>, capturing all\nthe configuration changes, logs, and o",
      "tags": [],
      "title": "Impermanence (Encrypted)"
    },
    {
      "author": "saylesss88",
      "collection": null,
      "date": "2025-11-22T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "installation/enc/enc_install.md",
      "preview_html": "<p>NixOS supports file systems that are encrypted using LUKS (Linux Unified Key\nSetup). This guide walks you through an encrypted NixOS installation using Disko\nfor disk management and Btrfs for subvolumes. It is designed for users who want\nfull disk encryption and a modern filesystem layout. If you prefer an\nunencrypted setup, you can skip the LUKS and encryption steps, but this guide\nfocuses on security and flexibility.</p><p>If you choose to set up impermanence, ensure it matches your install. Encrypted\nSetup with Encrypted Impermanence and Unencrypted Setup with Unencrypted\nImpermanence.</p><p>❗ NOTE: This is a bit convoluted, there are a few paths you can follow. If\nyou choose to use the starter repo (<a href=\"https://github.com/saylesss88/my-flake\">https://github.com/saylesss88/my-fl",
      "tags": [],
      "title": "Encrypted Install"
    },
    {
      "author": "saylesss88",
      "collection": null,
      "date": "2025-11-22T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "nixpkgs/overlay.md",
      "preview_html": "<p>The following is done with a local clone of Nixpkgs located at <code>~/src/nixpkgs</code>.</p><p>In this example, we will create an overlay to override the version of\n<code>btrfs-progs</code>. In the root directory of our local clone of Nixpkgs\n(i.e.<code>~/src/nixpkgs</code>) we can run the following command to locate <code>btrfs-progs</code>\nwithin Nixpkgs:</p><pre><code class=\"language-bash\">fd 'btrfs-progs' .\n./pkgs/by-name/bt/btrfs-progs/\n</code></pre>\n<p>Open the <code>package.nix</code> in the above directory and copy the <code>src</code> block within\nthe <code>stdenv.mkDerivation</code> block like so:</p>",
      "tags": [],
      "title": "Version overrides with Overlays"
    },
    {
      "author": "saylesss88",
      "collection": "notes",
      "date": "2025-11-22T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "nixpkgs/local_package.md",
      "preview_html": "<p>This chapter demonstrates the fundamental pattern for creating a package. Every\npackage recipe is a file that declares a function. This function takes the\npackages dependencies as argument.</p><p>In this example we’ll make a simple package with <code>coreutils</code> and build it.\nDemonstrating the process of building and testing a local package.</p><p>This chapter will assume you have already have a cloned fork of Nixpkgs. I\nchoose to clone mine to the <code>~/src/</code> directory.</p>",
      "tags": [
        "nixos",
        "nixpkgs"
      ],
      "title": "Building Local Packages"
    },
    {
      "author": "saylesss88",
      "collection": "notes",
      "date": "2025-11-22T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "nixpkgs/fork_clone_contribute.md",
      "preview_html": "<p>In the <a href=\"https://github.com/NixOS/nixpkgs\">Nixpkgs</a> Repository.</p><p>Click Fork, then Create a new Fork.</p><p>Uncheck the box “Only fork the <code>master</code> branch”, for development we will need\nmore branches.</p>",
      "tags": [
        "git",
        "vcs",
        "nixpkgs"
      ],
      "title": "Fork, Clone, Contribute"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-11-21T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "Understanding_Top-Level_Attributes.md",
      "preview_html": "<p>This explanation is based on insights from Infinisil, a prominent figure in the\nNix community, to help clarify the concept of top-level attributes within NixOS\nmodules.</p><p>In a NixOS system, everything is built from a single “system derivation.” The\ncommand <code>nix-build '&lt;nixpkgs/nixos&gt;' -A system</code> initiates this build process.</p><p>The <code>-A system</code> part tells Nix to focus on the <code>system</code> attribute defined in the\n<code>'&lt;nixpkgs/nixos&gt;'</code> file (which is essentially <code>./default.nix</code> within the\nNixpkgs repository).</p>",
      "tags": [
        "nixos",
        "modules"
      ],
      "title": "Top-Level Attributes"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-11-21T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "Understanding_Nix_Functions.md",
      "preview_html": "<p><img src=\"images/trees2.cleaned.png\" alt=\"trees2\" /></p><p><strong>Functions</strong> are the building blocks of Nix, appearing everywhere in Nix\nexpressions and configurations. Mastering them is essential for writing\neffective Nix code and understanding tools like NixOS and Home Manager. This\nchapter explores how Nix functions work, focusing on their <strong>single-argument\nnature</strong>, <strong>currying</strong>, <strong>partial application</strong>, and their role in <strong>modules</strong>.</p><p>A <strong>Nix Function</strong> is a rule that takes an input (called an <strong>argument</strong>) and\nproduces an <strong>output</strong> based on that input. Unlike many programming languages,\nNix functions are designed to take exactly one argument at a time. This unique\napproach, co",
      "tags": [
        "nix",
        "functions"
      ],
      "title": "Understanding Nix Functions"
    },
    {
      "author": "saylesss88",
      "collection": null,
      "date": "2025-11-21T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "Package_Definitions_Explained.md",
      "preview_html": "<p><img src=\"images/coding2.png\" alt=\"coding2\" /></p><p>In Nix, the concept of a <strong>package</strong> can refer to two things:</p><p>A collection of files and data that constitute a piece of software or an\nartifact.</p>",
      "tags": [],
      "title": "Package Definitions Explained"
    },
    {
      "author": "saylesss88",
      "collection": null,
      "date": "2025-11-21T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "NixOS_Modules_Explained.md",
      "preview_html": "<p><img src=\"images/buildings1.png\" alt=\"buildings\" /></p><p><strong>TL;DR</strong>: In this chapter, we will break down the Nix module system used by\nboth NixOS and Home-Manager. We will discuss using home-manager as a module and\nthe flexibility that modules give us. We will touch on options and break down\nthe <code>vim</code> module from the Nixpkgs collection. Finally we will display how to\ntest modules with the repl.</p><p>Your <code>configuration.nix</code> is a module. For the Nixpkgs collection most modules\nare in <code>nixos/modules</code>.</p>",
      "tags": [],
      "title": "Nix Module System Explained"
    },
    {
      "author": "saylesss88",
      "collection": "blog",
      "date": "2025-11-21T00:00:00+00:00",
      "description": null,
      "draft": false,
      "path": "Nix_Flakes_Explained.md",
      "preview_html": "<p><img src=\"images/trees3.cleaned.png\" alt=\"trees3\" /></p><p>If you’re completely new, take a look at\n<a href=\"https://nixos.wiki/wiki/flakes#Installing_flakes\">this</a> to get flakes on your\nsystem.</p><p>For the Nix Flake man page type <code>man nix3 flake</code> and for a specific feature,\ntype something like <code>man nix3 flake-lock</code>.</p>",
      "tags": [
        "nix",
        "flakes"
      ],
      "title": "Nix Flakes Explained"
    }
  ]
}