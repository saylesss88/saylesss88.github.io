<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Getting Started with the Nix Language - nix-book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <a href="#" class="top-link" id="back-to-top">↑</a>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">nix-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-1"><a class="header" href="#chapter-1">Chapter 1</a></h1>
<!--toc:start-->
<ul>
<li><a href="#getting-started-with-the-nix-language">Getting Started with the Nix Language</a></li>
<li><a href="#why-learn-nix">Why Learn Nix?</a></li>
<li><a href="#syntax-basics">Syntax Basics</a></li>
<li><a href="#control-flow-with-expressions">Control Flow with Expressions</a></li>
<li><a href="#functions">Functions:</a>
<ul>
<li><a href="#derivations">Derivations</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#resources">Resources</a></li>
</ul>
<!--toc:end-->
<h2 id="getting-started-with-the-nix-language"><a class="header" href="#getting-started-with-the-nix-language">Getting Started with the Nix Language</a></h2>
<p><img src="images/gruv13.png" alt="gruv13" /></p>
<p>Welcome to the world of Nix, a powerful tool for reproducible and declarative
software management. In this chapter, we’ll explore the basics of the Nix
programming language, a pure, functional, and declarative language that
underpins Nix’s package manager and operating system. By the end, you’ll
understand Nix’s core concepts, syntax, and how to write simple expressions and
derivations.</p>
<blockquote>
<p>❗ If you're new to Nix, think of it as a recipe book for software: you
describe what you want (declarative), and Nix ensures it’s built the same way
every time (reproducible).</p>
</blockquote>
<h2 id="why-learn-nix"><a class="header" href="#why-learn-nix">Why Learn Nix?</a></h2>
<details>
<summary> ✔️ Why Learn Nix?(Click to Expand)</summary>
<p>Nix is often described as “JSON with functions.” It’s a declarative language
where you define outcomes, not step-by-step instructions. Instead of writing
sequential code, you create expressions that describe data structures,
functions, and dependencies. These expressions are evaluated lazily, meaning Nix
computes values only when needed, making it efficient for managing large
systems.</p>
</details>
<p>Let’s dive into the key characteristics of Nix:</p>
<div class="table-wrapper"><table><thead><tr><th>Concept</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Pure</strong></td><td>Functions don't cause side effects.</td></tr>
<tr><td><strong>Functional</strong></td><td>Functions can be passed as arguments and returned as results.</td></tr>
<tr><td><strong>Lazy</strong></td><td>Not evaluated until needed to complete a computation.</td></tr>
<tr><td><strong>Declarative</strong></td><td>Describing a system outcome.</td></tr>
<tr><td><strong>Reproducible</strong></td><td>Operations that are performed twice return same results</td></tr>
</tbody></table>
</div>
<blockquote>
<p>❗ Important: In Nix, everything is an expression, there are no statements.</p>
<p>❗ Important: Values in Nix are immutable.</p>
</blockquote>
<h2 id="syntax-basics"><a class="header" href="#syntax-basics">Syntax Basics</a></h2>
<p><img src="images/lambda1.png" alt="lambda1" /></p>
<ul>
<li>
<p><a href="https://nix.dev/manual/nix/2.24/language/">Nix Language Overview</a></p>
</li>
<li>
<p><a href="https://nixos.org/guides/nix-pills/04-basics-of-language">Basics of the Language Pill</a></p>
</li>
<li>
<p>Dashes are allowed as identifiers:</p>
</li>
</ul>
<pre><code class="language-nix">nix-repl&gt; a-b
error: undefined variable `a-b' at (string):1:1
nix-repl&gt; a - b
error: undefined variable `a' at (string):1:1
<span class="boring"> testing
</span></code></pre>
<blockquote>
<p>❗ Tip <code>a-b</code> is parsed as an identifier, not as subtraction.</p>
</blockquote>
<ul>
<li><strong>Strings</strong>: Strings are enclosed in double quotes (<code>"</code>) or two single quotes
(<code>''</code>).</li>
</ul>
<pre><code class="language-nix">nix-repl&gt; "stringDaddy"
"stringDaddy"
nix-repl&gt; ''
  This is a
  multi-line
  string
''
"This is a\nmulti-line\nstring.\n"
</code></pre>
<details>
<summary> ✔️ String Interpolation(Click to Expand)</summary>
<p>Is a language feature where a string, path, or attribute name can contain
expressions enclosed in <code>${ }</code>. This construct is called <em>interpolated string</em>,
and the expression inside is an <em>interpolated expression</em>.</p>
<p><a href="https://nix.dev/manual/nix/2.24/language/string-interpolation">string interpolation</a>.</p>
<p>Rather than writing:</p>
<pre><code class="language-nix">let path = "/usr/local"; in "--prefix=${path}"
</code></pre>
<ul>
<li>This evaluates to <code>"--prefix=/usr/local"</code>. Interpolated expressions must
evaluate to a string, path, or an attribute set with an outPath or
<code>__toString</code> attribute.</li>
</ul>
</details>
<ul>
<li><strong>Attribute sets</strong> are all over Nix code, they are name-value pairs wrapped in
curly braces, where the names must be unique:</li>
</ul>
<pre><code class="language-nix">{
  string = "hello";
  int = 8;
}
</code></pre>
<ul>
<li>Attribute names usually don't need quotes.</li>
</ul>
<p>You can access attributes using dot notation:</p>
<pre><code class="language-nix">let person = { name = "Alice"; age = 30; }; in person.name
"Alice"
</code></pre>
<p>You will sometimes see attribute sets with <code>rec</code> prepended. This allows access
to attributes within the set:</p>
<ul>
<li>Click the 👀 to see the Output:</li>
</ul>
<pre><code class="language-nix">rec {
  x = y;
  y = 123;
}.x
<span class="boring"> 123
</span></code></pre>
<p><strong>Output</strong>: <code>123</code></p>
<p>or</p>
<pre><code class="language-nix">rec {
  one = 1;
  two = one + 1;
  three = two + 1;
}
<span class="boring"> {
</span><span class="boring">  one = 1;
</span><span class="boring">  three = 3;
</span><span class="boring">  two = 2;
</span><span class="boring"> }
</span></code></pre>
<pre><code class="language-nix"># This would fail:
{
  one = 1;
  two = one + 1;  # Error: undefined variable 'one'
  three = two + 1;
}
</code></pre>
<p>Recursive sets introduce the danger of <em>infinite recursion</em> For example:</p>
<pre><code class="language-nix">rec {
  x = y;
  y = x;
}.x
<span class="boring"> error:
</span><span class="boring">       … while evaluating the attribute 'x'
</span><span class="boring">         at «string»:2:3:
</span><span class="boring">            1| rec {
</span><span class="boring">            2|   x = y;
</span><span class="boring">             |   ^
</span><span class="boring">            3|   y = x;
</span><span class="boring">
</span><span class="boring">       error: infinite recursion encountered
</span><span class="boring">       at «string»:2:7:
</span><span class="boring">            1| rec {
</span><span class="boring">            2|   x = y;
</span><span class="boring">             |       ^
</span><span class="boring">            3|   y = x;
</span></code></pre>
<ul>
<li>
<p>Will crash with an <code>infinite recursion encountered</code> error message.</p>
</li>
<li>
<p>The
<a href="https://nix.dev/manual/nix/2.24/language/operators.html#update">attribute set update operator</a>
merges two attribute sets.</p>
</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">{ a = 1; b = 2; } // { b = 3; c = 4; }
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-nix">{ a = 1; b = 3; c = 4; }
</code></pre>
<ul>
<li>However, names on the right take precedence, and updates are shallow.</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-nix">{ a = { b = 1; }; } // { a = { c = 3; }; }
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code class="language-nix">{ a = { c = 3; }; }
</code></pre>
<ul>
<li>Above, key <code>b</code> was completely removed, because the whole <code>a</code> value was
replaced.</li>
</ul>
<p><strong>Inheriting Attributes</strong></p>
<ul>
<li>Click 👁️‍🗨️to see Output:</li>
</ul>
<pre><code class="language-nix">let x = 123; in
{
  inherit x;
  y = 456;
}
<span class="boring">{
</span><span class="boring">  x = 123;
</span><span class="boring">  y = 456;
</span><span class="boring">}
</span></code></pre>
<p>is equivalent to</p>
<pre><code class="language-nix">let x = 123; in
{
  x = x;
  y = 456;
}
<span class="boring">{
</span><span class="boring">  x = 123;
</span><span class="boring">  y = 456;
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p>❗: This works because <code>x</code> is added to the lexical scope by the <code>let</code>
construct.</p>
</blockquote>
<ul>
<li><code>inherit</code> is commonly used to pick specific variables from the function's
arguments, like in:</li>
</ul>
<pre><code class="language-nix">{ pkgs, lib }: ...
let someVar = ...; in { inherit pkgs lib someVar; ... }
</code></pre>
<ul>
<li>This shows another common use case beyond just <code>let</code> bindings.</li>
</ul>
<h2 id="control-flow-with-expressions"><a class="header" href="#control-flow-with-expressions">Control Flow with Expressions</a></h2>
<p><strong>If expressions</strong>:</p>
<ul>
<li>Click the 👀 to see the Output:</li>
</ul>
<pre><code class="language-nix">nix-repl&gt; a = 6
nix-repl&gt; b = 10
nix-repl&gt; if a &gt; b then "yes" else "no"
<span class="boring"> "no"
</span></code></pre>
<p><strong>Let expressions</strong>:</p>
<ul>
<li>Click the 👁️‍🗨️to see the Output:</li>
</ul>
<pre><code class="language-nix">let
  a = "foo";
  b = "fighter";
in a + b
<span class="boring"> "foofighter"
</span></code></pre>
<p><strong>With expressions</strong>:</p>
<pre><code class="language-nix">nix-repl&gt; longName = { a = 3; b = 4; }
nix-repl&gt; longName.a + longName.b
7
nix-repl&gt; with longName; a + b
7
</code></pre>
<p><strong>Laziness</strong>:</p>
<ul>
<li>Nix evaluates expressions only when needed. This is a great feature when
working with packages.</li>
</ul>
<pre><code class="language-nix">nix-repl&gt; let a = builtins.div 4 0; b = 6; in b
6
</code></pre>
<ul>
<li>Since <code>a</code> isn't needed, there's no error about division by zero, because the
expression is not in need to be evaluated. That's why we can have all the
packages defined on demand, yet have acces to specific packages very quickly.
Some of these examples came from the Nix pill series.</li>
</ul>
<p><strong>Default Values</strong>:</p>
<pre><code class="language-nix">{ x, y ? "foo", z ? "bar" }: z + y + x
<span class="boring"> «lambda @ «string»:1:1»
</span></code></pre>
<ul>
<li>Specifies a function that only requires an attribute named <code>x</code>, but optionally
accepts <code>y</code> and <code>z</code>.</li>
</ul>
<p><strong>@-patterns</strong>:</p>
<ul>
<li>An <code>@-pattern</code> provides a means of referring to the whole value being matched:</li>
</ul>
<pre><code class="language-nix">args@{ x, y, z, ... }: z + y + x + args.a
<span class="boring"> «lambda @ «string»:1:1»
</span># or
{ x, y, z, ... } @ args: z + y + x + args.a
<span class="boring"> «lambda @ «string»:1:1»
</span></code></pre>
<ul>
<li>Here, <code>args</code> is bound to the argument as <em>passed</em>, which is further matched
against the pattern <code>{ x, y, z, ... }</code>. The <code>@-pattern</code> makes mainly sense
with an ellipsis(<code>...</code>) as you can access attribute names as <code>a</code>, using
<code>args.a</code>, which was given as an additional attribute to the function.</li>
</ul>
<h2 id="functions"><a class="header" href="#functions">Functions:</a></h2>
<p>Functions are defined using this syntax, where <code>x</code> and <code>y</code> are attributes passed
into the function:</p>
<pre><code class="language-nix">{
  my_function = x: y: x + y;
}
</code></pre>
<p>The code below calls a function called <code>my_function</code> with the parameters <code>2</code> and
<code>3</code>, and assigns its output to the <code>my_value</code> field:</p>
<pre><code class="language-nix">{
  my_value = my_function 2 3;
}
my_value
<span class="boring"> 5
</span></code></pre>
<ul>
<li>The body of the function automatically returns the result of the function.
Functions are called by spaces between it and its parameters. No commas are
needed to separate parameters.</li>
</ul>
<h3 id="derivations"><a class="header" href="#derivations">Derivations</a></h3>
<p><img src="images/nix99.png" alt="nix99" /></p>
<ul>
<li>
<p>In Nix, the process of managing software starts with package definitions.
These are files written in the Nix language that describe how a particular
piece of software should be built. These package definitions, when processed
by Nix, are translated into derivations.</p>
</li>
<li>
<p>At its core, a derivation in Nix is a blueprint or a recipe that describes how
to build a specific software package or any other kind of file or directory.
It's a declarative specification of:</p>
</li>
<li>
<p>Inputs: What existing files or other derivations are needed as dependencies.</p>
</li>
<li>
<p>Build Steps: The commands that need to be executed to produce the desired
output.</p>
</li>
<li>
<p>Environment: The specific environment (e.g., build tools, environment
variables) required for the build process.</p>
</li>
<li>
<p>Outputs: The resulting files or directories that the derivation produces.</p>
</li>
</ul>
<p>Think of a package definition as the initial instructions, and the derivation as
the detailed, low-level plan that Nix uses to actually perform the build."</p>
<p>Again, a derivation is like a blueprint that describes how to build a specific
software package or any other kind of file or directory.</p>
<p><strong>Key Characteristics of Derivations:</strong></p>
<ul>
<li>
<p><strong>Declarative</strong>: You describe the desired outcome and the inputs, not the
exact sequence of imperative steps. Nix figures out the necessary steps based
on the builder and args.</p>
</li>
<li>
<p><strong>Reproducible</strong>: Given the same inputs and build instructions, a derivation
will always produce the same output. This is a cornerstone of Nix's
reproducibility.</p>
</li>
<li>
<p><strong>Tracked by Nix</strong>: Nix keeps track of all derivations and their outputs in
the Nix store. This allows for efficient management of dependencies and
ensures that different packages don't interfere with each other.</p>
</li>
<li>
<p><strong>Content-Addressed</strong>: The output of a derivation is stored in the Nix store
under a unique path that is derived from the hash of all its inputs and build
instructions. This means that if anything changes in the derivation, the
output will have a different path.</p>
</li>
</ul>
<p>Here's a simple Nix derivation that creates a file named hello in the Nix store
containing the text "Hello, World!":</p>
<details>
<summary> ✔️ Hello World Derivation Example (Click to expand):</summary>
<pre><code class="language-nix">{pkgs ? import &lt;nixpkgs&gt; {}}:
pkgs.stdenv.mkDerivation {
  name = "hello-world";

  dontUnpack = true;

  # No need for src = null; when dontUnpack = true;
  # src = null;

  buildPhase = ''
     # Create a shell script that prints "Hello, World!"
    echo '#!${pkgs.bash}/bin/bash' &gt; hello-output-file # Shebang line
    echo 'echo "Hello, World!"' &gt;&gt; hello-output-file # The command to execute
    chmod +x hello-output-file # Make it executable
  '';

  installPhase = ''
    mkdir -p $out/bin
    cp hello-output-file $out/bin/hello # Copy the file from build directory to $out/bin
  '';

  meta = {
    description = "A simple Hello World program built with Nix";
    homepage = null;
    license = pkgs.lib.licenses.unfree; # Ensure this is pkgs.lib.licenses.unfree
    maintainers = [];
  };
}
</code></pre>
<p>And a <code>default.nix</code> with the following contents:</p>
<pre><code class="language-nix">{ pkgs ? import &lt;nixpkgs&gt; {} }:

import ./hello.nix { pkgs = pkgs; }
</code></pre>
<ul>
<li>
<p><code>{ pkgs ? import &lt;nixpkgs&gt; {} }</code>: This is a function that takes an optional
argument <code>pkgs</code>. We need Nixpkgs to access standard build environments like
<code>stdenv</code>.</p>
</li>
<li>
<p><code>pkgs.stdenv.mkDerivation { ... }:</code> This calls the mkDerivation function from
the standard environment (stdenv). mkDerivation is the most common way to
define software packages in Nix.</p>
</li>
<li>
<p><code>name = "hello-world";</code>: Human-readable name of the derivation</p>
</li>
<li>
<p>The rest are the build phases and package metadata.</p>
</li>
</ul>
<p>To use the above derivation, save it as a <code>.nix</code> file (e.g. <code>hello.nix</code>). Then
build the derivation using, (Click 👁️‍🗨️to see Output):</p>
<pre><code class="language-bash">nix-build
~ this derivation will be built:
~   /nix/store/9mc855ijjdy3r6rdvrbs90cg2gf2q160-hello-world.drv
~ building '/nix/store/9mc855ijjdy3r6rdvrbs90cg2gf2q160-hello-world.drv'...
~ Running phase: patchPhase
~ Running phase: updateAutotoolsGnuConfigScriptsPhase
~ Running phase: configurePhase
~ no configure script, doing nothing
~ Running phase: buildPhase
~ Running phase: installPhase
~ Running phase: fixupPhase
~ shrinking RPATHs of ELF executables and libraries in /nix/store/2ydxh5pd9a6djv7npaqi9rm6gmz2f73b-hello-world
~ checking for references to /build/ in /nix/store/2ydxh5pd9a6djv7npaqi9rm6gmz2f73b-hello-world...
~ patching script interpreter paths in /nix/store/2ydxh5pd9a6djv7npaqi9rm6gmz2f73b-hello-world
~ stripping (with command strip and flags -S -p) in  /nix/store/2ydxh5pd9a6djv7npaqi9rm6gmz2f73b-hello-world/bin
~ /nix/store/2ydxh5pd9a6djv7npaqi9rm6gmz2f73b-hello-world
</code></pre>
<ul>
<li>
<p>Nix will execute the <code>buildPhase</code> and <code>installPhase</code></p>
</li>
<li>
<p>After a successful build, the output will be in the Nix store. You can find
the exact path by looking at the output of the nix build command (it will be
something like <code>/nix/store/your-hash-hello-world</code>).</p>
</li>
</ul>
<p>Run the "installed" program:</p>
<pre><code class="language-bash">./result/bin/hello
</code></pre>
<ul>
<li>This will execute the <code>hello</code> file from the Nix store and print <code>"Hello, World!"</code>.</li>
</ul>
</details>
<h3 id="evaluating-nix-files"><a class="header" href="#evaluating-nix-files">Evaluating Nix Files</a></h3>
<p>Use <code>nix-instantiate --eval</code> to evaluate the expression in a Nix file:</p>
<pre><code class="language-bash">echo 1 + 2 &gt; file.nix
nix-instantiate --eval file.nix
3
</code></pre>
<blockquote>
<p><strong>Note:</strong> <code>--eval</code> is required to evaluate the file and do nothing else. If
<code>--eval</code> is omitted, <code>nix-instantiate</code> expects the expression in the given
file to evaluate to a derivation.</p>
</blockquote>
<p>If you don't specify an argument, <code>nix-instantiate --eval</code> will try to read from
<code>default.nix</code> in the current directory.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>As we have now seen, this chapter touched on the basic syntax of function
definition and application, including concepts like currying. However, the power
and flexibility of Nix functions extend far beyond what we've covered so far.</p>
<p>In the next chapter,
<a href="https://saylesss88.github.io/Understanding_Nix_Functions_2.html">Understanding Nix Functions</a>
we will peel back the layers and explore the intricacies of function arguments,
advanced patterns, scope, and how functions play a crucial role in building more
sophisticated Nix expressions and derivations.</p>
<p>Here are some resources that I found helpful when learning the Nix Language.</p>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<details>
<summary> ✔️ Resources (Click to Expand)</summary>
<ul>
<li>
<p><a href="https://nix.dev/tutorials/nix-language.html">nix.dev nixlang-basics</a></p>
</li>
<li>
<p><a href="https://learnxinyminutes.com/nix/">learn nix in y minutes</a></p>
</li>
<li>
<p><a href="https://github.com/tazjin/nix-1p">nix onepager</a></p>
</li>
<li>
<p><a href="https://github.com/nix-community/awesome-nix">awesome-nix</a></p>
</li>
<li>
<p><a href="https://zero-to-nix.com/concepts/nix-language/">zero-to-nix nix lang</a></p>
</li>
<li>
<p><a href="https://nixos.org/guides/nix-pills/04-basics-of-language.html">nix-pills basics of nixlang</a></p>
</li>
</ul>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                            <a rel="next prefetch" href="Understanding_Nix_Functions_2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

                    <a rel="next prefetch" href="Understanding_Nix_Functions_2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
