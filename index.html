<!doctype html><html lang=en-us dir=ltr><head><meta name=generator content="Hugo 0.147.1"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://saylesss88.github.io/favicon.ico><meta property="og:url" content="https://saylesss88.github.io/"><meta property="og:site_name" content="NixOS Blog"><meta property="og:title" content="NixOS Blog"><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><title>NixOS Blog</title>
<link rel=stylesheet href=/css/main.min.9d7861a670d885bddfdca28e2bec973020e2e1f1b049a5849a85a2e0fa249e4c.css integrity="sha256-nXhhpnDYhb3f3KKOK+yXMCDi4fGwSaWEmoWi4Poknkw=" crossorigin=anonymous><link rel=stylesheet href=/css/palette/default.min.cfcbb0f894da76afbc5a46072e5cbec733a983f27395920a3cfdf6977053c351.css integrity="sha256-z8uw+JTadq+8WkYHLly+xzOpg/JzlZIKPP32l3BTw1E=" crossorigin=anonymous><script src=/js/main.86bb3d8e6f46df0fc97c2731e6b99175a13b87a4086acf578ff9b6992fcf32c1.js integrity="sha256-hrs9jm9G3w/JfCcx5rmRdaE7h6QIas9Xj/m2mS/PMsE=" crossorigin=anonymous></script><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH crossorigin=anonymous></head><body class=dark><main><h2><a href=/posts/using_overlays_to_add_packages/>Using_overlays_to_add_packages</a></h2><h1 id=using-overlays-to-add-packages-that-arent-in-nixpkgs>Using Overlays to add Packages that aren&rsquo;t in Nixpkgs</h1><p><strong>TOC</strong></p><ul><li><a href=#adding-the-overlays-output-to-your-flake>Adding the overlays output to your Flake</a></li><li><a href=#the-actual-overlay>The Actual Overlay</a></li><li><a href=#the-pokego-package-definition>The pokego Package definition</a></li><li><a href=#adding-the-overlay-to-your-configuration>Adding the overlay to your configuration</a></li><li><a href=#installing-pokego>Installing Pokego</a><ul><li><a href=#another-overlay-example>Another Overlay Example</a></li></ul></li></ul><figure><img src=images/pokego.png alt=window_view width=700></figure><p>It is very common to use overlays in Nix to install packages that aren&rsquo;t
available in the standard Nixpkgs repository.</p><ul><li><p>Overlays are one of the primary and recommended ways to extend and customize
your Nix environment. It&rsquo;s important to remember that Nix overlays are made to
allow you to modify or extend the package set provided by Nixpkgs (or other
Nix sources) without directly altering the original package definitions. This
is crucial for maintaining reproducibility and avoiding conflicts. Overlays
are essentially functions that take the previous package set and allow you to
add, modify, or remove packages.</p><h2><a href=/posts/nix_lang_basics/>Nix_lang_basics</a></h2><h1 id=the-nix-language>The Nix Language</h1><p><strong>TOC</strong></p><ul><li><a href=#the-nix-language>The Nix Language</a><ul><li><a href=#how-does-nix-work>How does Nix work</a></li><li><a href=#syntax-basics>Syntax Basics</a><ul><li><a href=#derivations>Derivations</a></li><li><a href=#evaluating-nix-files>Evaluating Nix Files</a></li><li><a href=#resources>Resources</a></li></ul></li></ul></li></ul><figure><img src=/images/gruv18.png alt=window_view width=700></figure><p>Nix as a programming language can be thought of as a kind of &ldquo;JSON, but with
functions&rdquo;.</p><p>All statements are declarative, meaning that there&rsquo;s no sequential flow of
instructions that makes up a Nix package. Instead, functions are called that
assign values to fields in attribute sets, which in turn may get assigned to
other values.</p><h2><a href=/posts/comparing_flakes_to_traditional_nix/>Comparing_flakes_to_traditional_nix</a></h2><h1 id=introduction-flakes-and-traditional-nix>Introduction: Flakes and Traditional Nix</h1><p><strong>TOC</strong></p><ul><li><p><a href=#introduction-flakes-and-traditional-nix>Introduction: Flakes and Traditional Nix</a></p><ul><li><a href=#what-is-purity-in-nix>What is Purity in Nix?</a></li><li><a href=#building-a-simple-hello-package-flakes-vs-traditional-nix>Building a Simple &ldquo;hello&rdquo; Package: Flakes vs. Traditional Nix</a></li><li><a href=#using-nix-flakes>Using Nix Flakes</a></li><li><a href=#using-traditional-nix>Using Traditional Nix</a> - <a href=#updating-nixpkgs>Updating Nixpkgs</a> - <a href=#updating-traditional-nix-using-niv>Updating Traditional Nix (using <code>niv</code>)</a> - <a href=#adding-home-manager-with-flakes>Adding Home-Manager with Flakes</a> - <a href=#adding-home-manager-with-traditional-nix>Adding Home-Manager with Traditional Nix</a></li></ul></li></ul><figure><img src=/images/nixWinter.png alt="nix winter" width=700></figure><ul><li>This post is based on notes from Nix-Hour #4, comparing Traditional Nix and Flakes, focusing on achieving pure build results. See the <a href="https://www.youtube.com/watch?v=atmoYyBAhF4">YouTube video</a> for the original content. This guide adapts the information for clarity and ease of understanding.</li></ul><h2 id=what-is-purity-in-nix>What is Purity in Nix?</h2><ul><li><p>A key benefit of Nix Flakes is their <em>default</em> enforcement of <strong>pure evaluation</strong>.</p><h2><a href=/posts/declarative_depinject/>Declarative_depinject</a></h2><h1 id=declarative-dependency-injection-in-nix-flakes>Declarative Dependency Injection in Nix Flakes</h1><p><strong>TOC</strong></p><ul><li><a href=#declarative-dependency-injection-in-nix-flakes>Declarative Dependency Injection in Nix Flakes</a><ul><li><a href=#the-problem-with-specialargs>The Problem with specialArgs</a><ul><li><a href=#a-declarative-solution-injecting-via-a-custom-option>A Declarative Solution: Injecting via a Custom Option</a><ul><li><a href=#benefits-of-this-approach>Benefits of this Approach</a></li><li><a href=#example-usage>Example Usage</a></li></ul></li><li><a href=#applying-dep-inject-to-home-manager-modules>Applying dep-inject to Home Manager Modules</a></li><li><a href=#conclusion>Conclusion</a></li></ul></li></ul></li></ul><figure><img src=/images/gruv6.png alt=cyber width=700></figure><p>This post explores a method for injecting dependencies into NixOS modules from
a flake in a more declarative way, offering an alternative to <code>specialArgs</code>.</p><h2 id=the-problem-with-specialargs>The Problem with specialArgs</h2><ul><li><p>As mentioned in <a href=https://saylesss88.github.io/posts/nix_flakes_tips/>post</a>,
<code>specialArgs</code> and <code>extraSpecialArgs</code> can be used to pass dependencies and
variables from flakes to modules.</p><h2><a href=/posts/derivations_explained/>Derivations_explained</a></h2><h1 id=introduction-to-nix-derivations>Introduction to Nix Derivations</h1><p><strong>TOC</strong></p><ul><li><a href=#introduction-to-nix-derivations>Introduction to Nix Derivations</a><ul><li><a href=#creating-derivations-in-nix>Creating Derivations in Nix</a></li><li><a href=#our-first-simple-derivation-understanding-the-builder>Our First Simple Derivation: Understanding the Builder</a><ul><li><a href=#why-a-builder-script>Why a Builder Script?</a></li><li><a href=#the-challenge-with-shebangs-in-nix>The Challenge with Shebangs in Nix</a></li><li><a href=#the-importance-of-statelessness-in-nix>The Importance of Statelessness in Nix</a><ul><li><a href=#our-builder-script>Our builder Script</a></li><li><a href=#our-second-derivation>Our Second Derivation</a></li><li><a href=#links-to-articles-about-derivations>Links To Articles about Derivations</a></li></ul></li></ul></li></ul></li></ul><figure><img src=/images/gruv10.png alt=gruv10 width=700></figure><ul><li><p>A derivation in Nix is a fundamental concept that describes how to build a piece of software or a resource (e.g., a package, library, or configuration file). Think of it as a recipe for creating something within the Nix ecosystem.</p><h2><a href=/posts/simple_nix_service/>Simple_nix_service</a></h2><h1 id=building-a-custom-nixos-service-with-flakes-and-overlays>Building a Custom NixOS Service with Flakes and Overlays</h1><p><strong>TOC</strong></p><ul><li><a href=#building-a-custom-nixos-service-with-flakes-and-overlays>Building a Custom NixOS Service with Flakes and Overlays</a><ul><li><a href=#create-project-directory>Create Project Directory</a></li><li><a href=#create-flake>Create flake</a></li><li><a href=#create-service-module>Create Service Module</a></li><li><a href=#add-nixosconfigurations-output>Add nixosConfigurations Output</a> - <a href=#build-the-system-configuration>Build the System Configuration</a></li></ul></li></ul><figure><img src=/images/gruv12.png alt=gruv12 width=700></figure><p>TL;DR NixOS&rsquo;s declarative configuration and flakes make it easy to create
custom services. This post shows how to build a minimal service using flakes
and overlays for a &ldquo;meow&rdquo; command</p><ul><li>This will be a complete minimal configuration for testing purposes.</li></ul><h2 id=create-project-directory>Create Project Directory</h2><p>Start by creating a directory to hold your project, I called mine <code>meow</code>:</p><h2><a href=/posts/nix_flakes_tips/>Nix_flakes_tips</a></h2><h1 id=shallow-clone-nixpkgs>Shallow Clone Nixpkgs</h1><p><strong>TOC</strong></p><ul><li><a href=#shallow-clone-nixpkgs>Shallow Clone Nixpkgs</a><ul><li><a href=#import-your-non-flake-wallpaper-repo>Import your Non-Flake Wallpaper Repo</a></li><li><a href=#understanding-patterns>Understanding @-patterns</a></li><li><a href=#understanding-specialargs>Understanding <code>specialArgs</code></a></li><li><a href=#set-up-flake-check-and-formatter-outputs>Set up Flake Check and Formatter Outputs</a> - <a href=#add-a-devshell-output>Add a devShell Output</a></li></ul></li></ul><figure><img src=/images/gruv8.png alt=gruv8 width=700></figure><ol><li>Shallow clone nixpkgs, the full Git history isn&rsquo;t always necessary and this
can speed up build times.</li></ol><ul><li>The only issue I&rsquo;ve had is <code>nix-index-database</code> not working well with the
shallow clone&mldr; Other than that no issues after running for a few months.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#75715e># flake.nix</span>
</span></span><span style=display:flex><span>inputs <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    nixpkgs<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;git+https://github.com/NixOS/nixpkgs?shallow=1&amp;ref=nixos-unstable&#34;</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li>Some times when you might need a full clone are debugging and working with
repository history but those are rare.</li></ul><h2 id=import-your-non-flake-wallpaper-repo>Import your Non-Flake Wallpaper Repo</h2><ol start=2><li>Importing your non-flake wallpapers repo:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#75715e># flake.nix</span>
</span></span><span style=display:flex><span>inputs <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    wallpapers <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>      url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:saylesss88/wallpapers&#34;</span>;
</span></span><span style=display:flex><span>      flake <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>After adding the input I can access individual wallpapers by adding the <code>inputs</code> argument and
something like <code>path = "${inputs.wallpapers}/Aesthetic Scenery.jpg";</code></li></ul><h2 id=understanding--patterns>Understanding @-patterns</h2><ol start=3><li>Understanding <code>@-patterns</code>, being able to reference your outputs argument set as a whole. An
<code>@-pattern</code> is a way for a function can access variadic attributes (i.e. varying number of
arguments).</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#75715e># flake.nix</span>
</span></span><span style=display:flex><span>inputs <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    home-manager<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:nix-community/home-manager/master&#34;</span>;
</span></span><span style=display:flex><span>    home-manager<span style=color:#f92672>.</span>inputs<span style=color:#f92672>.</span>nixpkgs<span style=color:#f92672>.</span>follows <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;nixpkgs&#34;</span>;
</span></span><span style=display:flex><span>    stylix<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:danth/stylix&#34;</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>outputs <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    self<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    nixpkgs<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    home-manager<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>} <span style=color:#f92672>@</span> inputs:
</span></span></code></pre></div><p>With the above example to add the modules to your nixosConfigurations you would add something
like this:</p><h2><a href=/posts/working_with_nixpkgs_locally/>Working_with_nixpkgs_locally</a></h2><h1 id=working-with-nixpkgs-locally-benefits-and-best-practices>Working with Nixpkgs Locally: Benefits and Best Practices</h1><p><strong>TOC</strong></p><ul><li><a href=#working-with-nixpkgs-locally-benefits-and-best-practices>Working with Nixpkgs Locally: Benefits and Best Practices</a></li><li><a href=#i-why-work-with-nixpkgs-locally>I. Why Work with Nixpkgs Locally?</a><ul><li><a href=#a-faster-development-cycle>A. Faster Development Cycle</a></li><li><a href=#b-enhanced-version-control>B. Enhanced Version Control</a></li><li><a href=#c-flexible-debugging-capabilities>C. Flexible Debugging Capabilities</a></li><li><a href=#d-streamlined-contribution-workflow>D. Streamlined Contribution Workflow</a></li><li><a href=#e-up-to-date-documentation-source>E. Up-to-Date Documentation Source</a></li><li><a href=#f-optimized-storage-and-performance>F. Optimized Storage and Performance</a></li></ul></li><li><a href=#ii-flake-vs-non-flake-syntax-for-local-nixpkgs>II. Flake vs. Non-Flake Syntax for Local Nixpkgs</a><ul><li><a href=#a-flake-syntax-nix-build-package>A. Flake Syntax (<code>nix build .#&lt;package></code>)</a></li><li><a href=#b-non-flake-syntax-nix-build-f-package-or-nix-build-f-package>B. Non-Flake Syntax (<code>nix-build -f . &lt;package></code> or <code>nix build -f . &lt;package></code>)</a></li><li><a href=#iii-setting-up-a-local-nixpkgs-repository-efficiently>III. Setting Up a Local Nixpkgs Repository Efficiently</a></li><li><a href=#a-initial-clone-shallow-cloning>A. Initial Clone: Shallow Cloning</a></li><li><a href=#b-managing-branches-with-worktrees>B. Managing Branches with Worktrees</a></li></ul></li><li><a href=#iv-debugging-missing-dependencies-a-practical-example>IV. Debugging Missing Dependencies: A Practical Example</a><ul><li><a href=#b-local-source-code-search-with-rg-ripgrep>B. Local Source Code Search with <code>rg</code> (ripgrep)</a></li></ul></li><li><a href=#v-local-derivation-search-with-nix-locate>V. Local Derivation Search with <code>nix-locate</code></a></li><li><a href=#vi-key-benefits-of-working-with-nixpkgs-locally-recap>VI. Key Benefits of Working with Nixpkgs Locally (Recap)</a></li><li><a href=#vii-best-practices-and-tips-from-the-community>VII. Best Practices and Tips from the Community</a></li></ul><figure><img src=/images/gruv18.png alt=gruv18 width=700></figure><ul><li>Nixpkgs, the package repository for NixOS, is a powerful resource for building and customizing software.</li><li>Working with a local copy enhances development, debugging, and contribution workflows.</li><li>This post covers setting up a local Nixpkgs repository, searching for dependencies, and leveraging its advantages, incorporating tips from the Nix community.</li></ul><h1 id=i-why-work-with-nixpkgs-locally>I. Why Work with Nixpkgs Locally?</h1><ul><li><p>A local Nixpkgs repository offers significant advantages for Nix developers:</p><h2><a href=/posts/building_your_config_as_a_package/>Building_your_config_as_a_package</a></h2><h1 id=building-your-configuration-as-a-package>Building your configuration as a Package</h1><p><strong>TOC</strong></p><ul><li><a href=#building-your-configuration-as-a-package>Building your configuration as a Package</a><ul><li><a href=#benefits-of-nixosconfiguration-as-a-package>Benefits of nixosConfiguration as a Package</a></li><li><a href=#usage-and-deployment>Usage and Deployment</a></li><li><a href=#adding-a-configuration-vm-output>Adding a Configuration VM Output</a><ul><li><a href=#debugging>Debugging</a></li><li><a href=#understanding-atomicity>Understanding Atomicity</a></li></ul></li></ul></li></ul><figure><img src=/images/gruv4.png alt=gruv4 width=700></figure><ul><li><p>TL;DR This post demonstrates other ways to modularize your config as well as
going into more advanced outputs.</p></li><li><p>This allows you to build your configuration as a package allowing you to
separate the process of creating a configuration artifact and applying it to
the live system giving you a reusable artifact that can be used to deploy to
different systems. This can make it easier to isolate it from other parts of
your system making debugging easier.</p><h2><a href=/posts/conditional_configuration/>Conditional_configuration</a></h2><h1 id=conditional-configuration>Conditional Configuration</h1><p><strong>TOC</strong></p><ul><li><a href=#conditional-configuration>Conditional Configuration</a><ul><li><a href=#hyprland-module>Hyprland Module</a></li><li><a href=#wlogout-module>Wlogout Module</a></li><li><a href=#benefits-of-this-approach>Benefits of this Approach</a></li></ul></li></ul><figure><img src=/images/gruv5.png alt=gruv5 width=700></figure><p>With options it&rsquo;s easy to conditionally install something based on if another
program is enabled in your configuration.</p><h2 id=hyprland-module>Hyprland Module</h2><p>For example, if I have an option to enable or disable hyprland like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#75715e># hyprland.nix</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  pkgs<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  lib<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  config<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  inputs<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}: <span style=color:#66d9ef>let</span>
</span></span><span style=display:flex><span>  cfg <span style=color:#f92672>=</span> config<span style=color:#f92672>.</span>custom<span style=color:#f92672>.</span>hyprland;
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span> {
</span></span><span style=display:flex><span>  options<span style=color:#f92672>.</span>custom<span style=color:#f92672>.</span>hyprland <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    enable <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>mkOption {
</span></span><span style=display:flex><span>      type <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>types<span style=color:#f92672>.</span>bool;
</span></span><span style=display:flex><span>      default <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>      description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Enable hyprland module&#34;</span>;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>   config <span style=color:#f92672>=</span> lib<span style=color:#f92672>.</span>mkIf cfg<span style=color:#f92672>.</span>enable {
</span></span><span style=display:flex><span>    home<span style=color:#f92672>.</span>packages <span style=color:#f92672>=</span> <span style=color:#66d9ef>with</span> pkgs; [
</span></span><span style=display:flex><span>      <span style=color:#75715e># swww</span>
</span></span><span style=display:flex><span>      grim
</span></span><span style=display:flex><span>      slurp
</span></span><span style=display:flex><span>      wl-clipboard-rs
</span></span><span style=display:flex><span>      cliphist
</span></span><span style=display:flex><span>      swappy
</span></span><span style=display:flex><span>      ydotool
</span></span><span style=display:flex><span>      wpaperd
</span></span><span style=display:flex><span>      wofi
</span></span><span style=display:flex><span>      hyprpicker
</span></span><span style=display:flex><span>      pavucontrol
</span></span><span style=display:flex><span>      blueman
</span></span><span style=display:flex><span>      <span style=color:#75715e># lxqt.lxqt-policykit</span>
</span></span><span style=display:flex><span>      brightnessctl
</span></span><span style=display:flex><span>      polkit_gnome
</span></span><span style=display:flex><span>      wlr-randr
</span></span><span style=display:flex><span>      wtype
</span></span><span style=display:flex><span>      rose-pine-cursor
</span></span><span style=display:flex><span>      <span style=color:#75715e># nwg-look</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># yad</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e># gtk-engine-murrine</span>
</span></span><span style=display:flex><span>    ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># .. snip ..</span>
</span></span></code></pre></div><ul><li><p>Since the above module is set to false, it is necessary to add
<code>custom.hyprland.enable = true</code> to my <code>home.nix</code> to have Nix add it
to my configuration. And since <code>home.packages</code> is wrapped in
<code>config = lib.mkIf cfg.enable</code> Those packages will only be installed
if the module is enabled.</p><h2><a href=/posts/top_level_attributes_explained/>Top_level_attributes_explained</a></h2><h1 id=understanding-top-level-attributes-in-nixos-modules>Understanding Top-Level Attributes in NixOS Modules</h1><p><strong>TOC</strong></p><ul><li><a href=#understanding-top-level-attributes-in-nixos-modules>Understanding Top-Level Attributes in NixOS Modules</a><ul><li><a href=#how-options-relate-a-chain-of-influence>How Options Relate: A Chain of Influence</a></li><li><a href=#the-nixos-module-system-evaluating-options>The NixOS Module System: Evaluating Options</a></li><li><a href=#how-the-module-system-works-a-simplified-overview>How the Module System Works: A Simplified Overview</a></li></ul></li></ul><figure><img src=/images/gruv9.png alt=cyber width=700></figure><p>This explanation is based on insights from Infinisil, a prominent figure in the
Nix community, to help clarify the concept of top-level attributes within
NixOS modules.</p><h2 id=the-core-of-a-nixos-system-systembuildtoplevel>The Core of a NixOS System: <code>system.build.toplevel</code></h2><p>In a NixOS system, everything is built from a single &ldquo;system derivation.&rdquo; The
command <code>nix-build '&lt;nixpkgs/nixos>' -A system</code> initiates this build process.</p><h2><a href=/posts/nix_flakes_explained/>Nix_flakes_explained</a></h2><h1 id=nix-flakes-explained>Nix Flakes Explained</h1><p><strong>TOC</strong></p><ul><li><a href=#nix-flakes-explained>Nix Flakes Explained</a><ul><li><a href=#what-is-a-nix-flake>What is a Nix Flake?</a></li><li><a href=#key-concepts>Key Concepts</a></li><li><a href=#attribute-sets-the-building-blocks>Attribute Sets: The Building Blocks</a> - <a href=#further-resources>Further Resources</a></li></ul></li></ul><figure><img src=%27/images/gruv2.png%27 alt=gruv-worker width=700></figure><p>This explanation highlights common areas of confusion for those new to Nix
Flakes, aiming to clarify concepts rather than serve as a comprehensive guide.</p><h2 id=what-is-a-nix-flake>What is a Nix Flake?</h2><ul><li><p>At its core, a flake is a source tree (like a Git repository) that contains
a <code>flake.nix</code> file. This file provides a standardized way to access Nix
artifacts such as packages and modules.</p><h2><a href=/posts/understanding_package_definitions/>Understanding_package_definitions</a></h2><h1 id=understanding-package-definitions-in-nix>Understanding Package Definitions in Nix</h1><p><strong>TOC</strong></p><ul><li><a href=#understanding-package-definitions-in-nix>Understanding Package Definitions in Nix</a><ul><li><a href=#the-journey-from-definition-to-package>The Journey from Definition to Package</a></li><li><a href=#skeleton-of-a-derivation>Skeleton of a Derivation</a></li><li><a href=#example-a-simple-hello-package-definition>Example: A Simple &ldquo;Hello&rdquo; Package Definition</a><ul><li><a href=#swaytools-package-definition>Swaytools Package Definition</a></li><li><a href=#resources>Resources</a></li></ul></li></ul></li></ul><figure><img src=/images/gruv1.png alt=gruvvy-bedroom width=700></figure><p>In Nix, the concept of a <strong>package</strong> can refer to two things:</p><ul><li><p>A collection of files and data that constitute a piece of software or an
artifact.</p></li><li><p>A Nix <strong>expression</strong> that describes how to create such a collection. This
expression acts as a blueprint before the package exists in a tangible form.</p><h2><a href=/posts/nix_repl_tips/>Nix_repl_tips</a></h2><h1 id=nix-repl-list-available-commands>Nix Repl List available commands</h1><p><strong>TOC</strong></p><ul><li><a href=#nix-repl-list-available-commands>Nix Repl List available commands</a><ul><li><a href=#load-nix-expressions-directly>Load Nix expressions Directly</a><ul><li><a href=#load-flakes>Load Flakes</a></li></ul></li><li><a href=#debugging-with-a-flake-repl-output>Debugging with a Flake REPL output</a><ul><li><a href=#usage>Usage</a></li><li><a href=#debugging>Debugging</a></li></ul></li></ul></li></ul><figure><img src=/images/gruv11.png alt=gruv11 width=700></figure><p>List available commands with <code>:?</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>nix repl
</span></span><span style=display:flex><span>Nix <span style=color:#ae81ff>2</span><span style=color:#ae81ff>.24.11</span>
</span></span><span style=display:flex><span>Type :<span style=color:#f92672>?</span> for help<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>nix-repl<span style=color:#f92672>&gt;</span> :<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>The following commands are available:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&lt;expr&gt;</span>                       Evaluate and print expression
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&lt;x&gt;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&lt;expr&gt;</span>                 Bind expression to variable
</span></span><span style=display:flex><span>  :a<span style=color:#960050;background-color:#1e0010>,</span> :add <span style=color:#e6db74>&lt;expr&gt;</span>              Add attributes from resulting set to scope
</span></span><span style=display:flex><span>  :b <span style=color:#e6db74>&lt;expr&gt;</span>                    Build a derivation
</span></span><span style=display:flex><span>  :bl <span style=color:#e6db74>&lt;expr&gt;</span>                   Build a derivation<span style=color:#960050;background-color:#1e0010>,</span> creating GC roots in the
</span></span><span style=display:flex><span>                               working directory
</span></span><span style=display:flex><span>  :e<span style=color:#960050;background-color:#1e0010>,</span> :edit <span style=color:#e6db74>&lt;expr&gt;</span>             Open package or function in <span style=color:#960050;background-color:#1e0010>$</span>EDITOR
</span></span><span style=display:flex><span>  :i <span style=color:#e6db74>&lt;expr&gt;</span>                    Build derivation<span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#66d9ef>then</span> install result into
</span></span><span style=display:flex><span>                               current profile
</span></span><span style=display:flex><span>  :l<span style=color:#960050;background-color:#1e0010>,</span> :load <span style=color:#e6db74>&lt;path&gt;</span>             Load Nix expression and add it to scope
</span></span><span style=display:flex><span>  :lf<span style=color:#960050;background-color:#1e0010>,</span> :load-flake <span style=color:#e6db74>&lt;ref&gt;</span>       Load Nix flake and add it to scope
</span></span><span style=display:flex><span>  :p<span style=color:#960050;background-color:#1e0010>,</span> :print <span style=color:#e6db74>&lt;expr&gt;</span>            Evaluate and print expression recursively
</span></span><span style=display:flex><span>                               Strings are printed directly<span style=color:#960050;background-color:#1e0010>,</span> without escaping<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>  :q<span style=color:#960050;background-color:#1e0010>,</span> :quit                    Exit nix-repl
</span></span><span style=display:flex><span>  :r<span style=color:#960050;background-color:#1e0010>,</span> :reload                  Reload all files
</span></span><span style=display:flex><span>  :sh <span style=color:#e6db74>&lt;expr&gt;</span>                   Build dependencies of derivation<span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#66d9ef>then</span> start
</span></span><span style=display:flex><span>                               nix-shell
</span></span><span style=display:flex><span>  :t <span style=color:#e6db74>&lt;expr&gt;</span>                    Describe result of evaluation
</span></span><span style=display:flex><span>  :u <span style=color:#e6db74>&lt;expr&gt;</span>                    Build derivation<span style=color:#960050;background-color:#1e0010>,</span> <span style=color:#66d9ef>then</span> start nix-shell
</span></span><span style=display:flex><span>  :doc <span style=color:#e6db74>&lt;expr&gt;</span>                  Show documentation of a builtin function
</span></span><span style=display:flex><span>  :log <span style=color:#e6db74>&lt;expr&gt;</span>                  Show logs for a derivation
</span></span><span style=display:flex><span>  :te<span style=color:#960050;background-color:#1e0010>,</span> :trace-enable [bool]    Enable<span style=color:#960050;background-color:#1e0010>,</span> disable or toggle showing traces for
</span></span><span style=display:flex><span>                               errors
</span></span><span style=display:flex><span>  :<span style=color:#f92672>?</span><span style=color:#960050;background-color:#1e0010>,</span> :help                    Brings up this help menu
</span></span></code></pre></div><h2 id=load-nix-expressions-directly>Load Nix expressions Directly</h2><p>You can quickly evaluate a random Nix expression:</p><h2><a href=/posts/understanding_nix_functions/>Understanding_nix_functions</a></h2><h1 id=understanding-nix-functions>Understanding Nix Functions</h1><p><strong>TOC</strong></p><ul><li><a href=#understanding-nix-functions>Understanding Nix Functions</a><ul><li><a href=#the-single-argument-nature-of-nix-functions>The Single-Argument Nature of Nix Functions</a></li><li><a href=#identifying-function-structure-the-colon>Identifying Function Structure The Colon</a></li><li><a href=#function-declarations-single-and-multiple-arguments>Function Declarations Single and &ldquo;Multiple&rdquo; Arguments</a><ul><li><a href=#the-function-nature-of-nixos-and-home-manager-modules>The Function Nature of NixOS and Home Manager Modules</a></li><li><a href=#resources>Resources</a></li></ul></li></ul></li></ul><figure><img src=/images/nixLogo.png alt=NixFlakeLogo width=500></figure><p>Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.</p><h2 id=the-single-argument-nature-of-nix-functions>The Single-Argument Nature of Nix Functions</h2><p>A key concept to understand is that in Nix, every function conceptually takes <strong>exactly one argument</strong>. What might appear as multi-argument functions are actually achieved through a technique called <strong>currying</strong>, where a series of nested single-argument functions are used.</p><h2><a href=/posts/intro_to_jujutsu/>Intro_to_jujutsu</a></h2><h1 id=intro-to-jujutsu-using-jj-in-an-existing-git-repo>Intro to Jujutsu (Using jj in an existing Git Repo)</h1><p><strong>TOC</strong></p><ul><li><a href=#intro-to-jujutsu-using-jj-in-an-existing-git-repo>Intro to Jujutsu (Using jj in an existing Git Repo)</a><ul><li><a href=#jj-and-git-side-by-side>JJ and Git Side by Side</a></li><li><a href=#resources>Resources</a></li></ul></li></ul><p><img src=/images/jujutsu.png alt="Jujutsu Logo"></p><ul><li><p>You can use jujutsu (jj) with existing Git repositories with one command.
<code>jj git init --colocate</code> or <code>jj git init --git-repo /path/to/git_repository</code>.
The native repository format for jj is still a work in progress so people
typically use a <code>git</code> repository for backend.</p><h2><a href=/posts/nix_modules_explained/>Nix_modules_explained</a></h2><h1 id=nixos-modules>NixOS Modules</h1><ul><li><a href=#nixos-modules>NixOS Modules</a><ul><li><a href=#declaring-options>Declaring Options</a><ul><li><a href=#module-composition>Module Composition</a></li><li><a href=#nixos-modules-and-dependency-locking-with-npins>NixOS Modules and Dependency Locking with npins</a></li><li><a href=#resources-on-modules>Resources on Modules</a></li></ul></li></ul></li><li><a href=#videos>Videos</a></li><li>[<a href="https://www.youtube.com/watch?v=cZjOzOHb2ow">tweagModuleSystemRecursion</a>](#tweagmodulesystemrecursionhttpswwwyoutubecomwatchvczjozohb2ow)</li></ul><figure><img src=/images/gruv3.png alt=gruv3 width=700></figure><p>TL;DR: In this post I break down the NixOS module system and explain how to
define options. As well as how to test modules with the repl.</p><ul><li>Most modules are functions that take an attribute set and return an attribute
set.</li></ul><p><strong>Refresher</strong>:</p><ul><li>An <strong>attribute set</strong> is a collection of name-value pairs wrapped in curly
braces:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{
</span></span><span style=display:flex><span>  string <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello&#34;</span>;
</span></span><span style=display:flex><span>  int <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>A <strong>function</strong> with an attribute set argument:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{ a<span style=color:#f92672>,</span> b }: a <span style=color:#f92672>+</span> b
</span></span></code></pre></div><ul><li>The simplest possible <strong>NixOS Module</strong>:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{ <span style=color:#f92672>...</span> }:
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>NixOS produces a full system configuration by combining smaller, more isolated
and reusable components: <strong>Modules</strong>. In my opinion modules are one of the
first things you should understand when learning about NixOS.</p></main><script src=https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js integrity=sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz crossorigin=anonymous></script></body></html>