<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nix Flakes Explained - nix-book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <a href="#" class="top-link" id="back-to-top">↑</a>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">nix-book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-4"><a class="header" href="#chapter-4">Chapter 4</a></h1>
<!--toc:start-->
<ul>
<li><a href="#nix-flakes-explained">Nix Flakes Explained</a></li>
<li><a href="#what-is-a-nix-flake">What is a Nix Flake?</a></li>
<li><a href="#key-concepts">Key Concepts</a></li>
<li><a href="#nix-flake-commands">Nix Flake Commands</a></li>
<li><a href="#attribute-sets-the-building-blocks">Attribute Sets: The Building Blocks</a>
<ul>
<li><a href="#anatomy-of-flakenix">Anatomy of <code>flake.nix</code></a></li>
</ul>
</li>
<li><a href="#conclusion-unifying-your-nix-experience-with-flakes">Conclusion: Unifying Your Nix Experience with Flakes</a></li>
<li><a href="#further-resources">Further Resources</a></li>
</ul>
<!--toc:end-->
<h2 id="nix-flakes-explained"><a class="header" href="#nix-flakes-explained">Nix Flakes Explained</a></h2>
<img src="images/gruv15.png" width="800" height="600">
<p>If you're completely new, take a look at <a href="https://nixos.wiki/wiki/flakes#Installing_flakes">this</a>
to get flakes on your system.</p>
<p>Flakes replace stateful channels (which cause much confusion among novices) and
introduce a more intuitive and consistent CLI, making them a perfect opportunity
to start using Nix. -- Alexander Bantyev <a href="https://serokell.io/blog/practical-nix-flakes">Practical Nix Flakes</a></p>
<ul>
<li>
<p>The "state" being remembered and updated by channels is the specific revision
of the Nixpkgs repository that your local Nix installation considers "current"
for a given channel. When this state changes on your machine, your builds
diverge from others whose machines have a different, independently updated
channel state.</p>
<ul>
<li>Channels are also constantly updated on the remote servers. So, "nixos-unstable"
today refers to a different set of packages and versions than "nixos-unstable"
did yesterday or will tomorrow.</li>
</ul>
</li>
<li>
<p>Flakes solve this by making the exact revision of <code>nixpkgs</code> (and other dependencies)
an explicit input within your <code>flake.nix</code> file, pinned in the <code>flake.lock</code>. This
means the state is explicitly defined in the configuration itself, not
implicitly managed by a global system setting.</p>
</li>
</ul>
<h2 id="what-is-a-nix-flake"><a class="header" href="#what-is-a-nix-flake">What is a Nix Flake?</a></h2>
<ul>
<li>
<p><strong>Nix flakes</strong> are independent components in the Nix ecosystem. They define
their own <strong>dependencies</strong> (inputs) and what they produce (outputs), which can
include <strong>packages</strong>, <strong>deployment configurations</strong>, or <strong>Nix functions</strong> for
other flakes to use.</p>
</li>
<li>
<p>At its core, a flake is a source tree (like a Git repository) that contains
a <code>flake.nix</code> file in its root directory. This file provides a standardized
way to access Nix artifacts such as packages and modules.</p>
</li>
<li>
<p>Flakes provide a standard way to write Nix expressions (and therefore packages)
whose dependencies are version-pinned in a lock file, improving reproducibility
of Nix installations. -- NixOS Wiki</p>
</li>
<li>
<p>Think of <code>flake.nix</code> as the central entry point of a flake. It not only
defines what the flake produces but also declares its dependencies.</p>
</li>
</ul>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<p><code>flake.nix</code>: <strong>The Heart of a Flake</strong></p>
<ul>
<li>The <code>flake.nix</code> file is mandatory for any flake. It must contain an attribute
set with at least one required attribute: <code>outputs</code>. It can also optionally
include <code>description</code> and <code>inputs</code>.</li>
<li><strong>Basic Structure:</strong></li>
</ul>
<pre><code class="language-nix">{
  description = "Package description";
  inputs = { /* Dependencies go here */ };
  outputs = { /* What the flake produces */ };
  nixConfig = { /* Advanced configuration options */ };
}
</code></pre>
<h2 id="nix-flake-commands"><a class="header" href="#nix-flake-commands">Nix Flake Commands</a></h2>
<details>
<summary> ✔️ Flake Commands (Click to Expand) </summary>
<blockquote>
<p><code>nix flake</code> provides subcommands for creating, modifying and querying <em>Nix
Flakes</em>. Flakes are the unit for packaging Nix code in a reproducible and
discoverable way. They can have dependencies on other flakes, making it possible
to have multi-repository Nix projects.</p>
</blockquote>
<p>— From <a href="https://nix.dev/manual/nix/2.28/command-ref/new-cli/nix3-flake">nix.dev Reference Manual</a></p>
<ul>
<li>
<p>The main thing to note here is that <code>nix flake</code> is used to manage Nix flakes
and that Flake commands are whitespace separated rather than hyphen <code>-</code>
separated.</p>
</li>
<li>
<p>Flakes do provide some advantages when it comes to discoverability of outputs.</p>
</li>
<li>
<p>For Example, two helpful commands to inspect a flake are:</p>
<ul>
<li>
<p><a href="https://nix.dev/manual/nix/2.28/command-ref/new-cli/nix3-flake-show">nix flake show</a>
command: Show the outputs provided by a flake.</p>
</li>
<li>
<p><a href="https://nix.dev/manual/nix/2.28/command-ref/new-cli/nix3-flake-check">nix flake check</a>
command: check whether the flake evaluates and run its tests.</p>
</li>
</ul>
</details>
</li>
</ul>
<h2 id="attribute-sets-the-building-blocks"><a class="header" href="#attribute-sets-the-building-blocks">Attribute Sets: The Building Blocks</a></h2>
<details>
<summary> ✔️ Attribute set Refresher (Click to Expand) </summary>
<ul>
<li>
<p><strong>Attribute sets</strong> are fundamental in Nix. They are simply collections of
name-value pairs wrapped in curly braces <code>{}</code>.</p>
<ul>
<li>Example, (click to see Output):</li>
</ul>
<pre><code class="language-nix">let
  my_attrset = { foo = "bar"; };
in
my_attrset.foo
<span class="boring"> "bar"
</span></code></pre>
</li>
<li>
<p><strong>Top-Level Attributes of a Flake</strong>:</p>
<ul>
<li>Flakes have specific <strong>top-level attributes</strong> that can be accessed directly
(without dot notation). The most common ones are <code>inputs</code>, <code>outputs</code>,
and <code>nixConfig</code>.</li>
</ul>
</details>
</li>
</ul>
<h3 id="anatomy-of-flakenix"><a class="header" href="#anatomy-of-flakenix">Anatomy of <code>flake.nix</code></a></h3>
<p><img src="images/Flakes.png" alt="Flakes" /></p>
<p><code>inputs</code>: <strong>Declaring Dependencies</strong></p>
<ul>
<li>
<p>The <code>inputs</code> attribute set specifies the other flakes that your current
flake depends on.</p>
</li>
<li>
<p>Each key in the <code>inputs</code> set is a name you choose for the dependency, and
the value is a reference to that flake (usually a URL or a Git Repo).</p>
</li>
<li>
<p>To access something from a dependency, you generally go through the <code>inputs</code>
attribute (e.g., <code>inputs.helix.packages</code>).</p>
<ul>
<li><strong>Example:</strong> This declares dependencies on the <code>nixpkgs</code> and <code>import-cargo</code>
flakes:</li>
</ul>
<pre><code class="language-nix">inputs = {
  import-cargo.url = "github:edolstra/import-cargo";
  nixpkgs.url = "nixpkgs";
};
</code></pre>
<ul>
<li>
<p>When Nix evaluates your flake, it fetches and evaluates each input. These
evaluated inputs are then passed as an attribute set to the outputs function,
with the keys matching the names you gave them in the inputs set.</p>
</li>
<li>
<p>The special input <code>self</code> is a reference to the <code>outputs</code> and the source tree of
the current flake itself.</p>
</li>
</ul>
</li>
</ul>
<p><strong><code>outputs</code>: Defining What Your Flake Provides</strong></p>
<ul>
<li>
<p>The <strong><code>outputs</code></strong> attribute defines what your flake makes available. This can
include packages, NixOS modules, development environments (<code>devShells</code>) and
other Nix derivations.</p>
</li>
<li>
<p>Flakes can output arbitrary Nix values. However, certain outputs have
specific meanings for Nix commands and must adhere to particular types
(often derivations, as described in the
<a href="https://nixos.wiki/wiki/Flakes">output schema</a>).</p>
</li>
<li>
<p>You can inspect the outputs of a flake using the command:</p>
</li>
</ul>
<pre><code class="language-nix">nix flake show
</code></pre>
<blockquote>
<p>This command takes a flake URI and displays its outputs in a tree structure,
showing the attribute paths and their corresponding types.</p>
</blockquote>
<p><strong>Understanding the <code>outputs</code> Function</strong></p>
<ul>
<li>
<p>Beginners often mistakenly think that self and nixpkgs within
<code>outputs = { self, nixpkgs, ... }: { ... }</code> are the outputs themselves.
Instead, they are the <em>input arguments</em> (often called <em>output arguments</em>)
to the outputs function.</p>
</li>
<li>
<p>The outputs function in <code>flake.nix</code> always takes a single argument,
which is an attribute set. The syntax <code>{ self, nixpkgs, ... }</code> is Nix's
way of destructuring this single input attribute set to extract the values
associated with the keys self and nixpkgs.</p>
</li>
</ul>
<p><strong>Referencing the Current Flake</strong> (<code>self</code>)</p>
<ul>
<li>
<p><code>self</code> provides a way to refer back to the current flake from within the
outputs function. You can use it to access other top-level attributes like
inputs (e.g., <code>self.inputs</code>).</p>
</li>
<li>
<p>The outputs function always receives an argument conventionally named self,
which represents the entire flake, including all its top-level attributes.
You'll typically use self to reference things defined within your own flake
(e.g., <code>self.packages.my-package</code>).</p>
</li>
</ul>
<p><strong>Variadic Attributes (...) and @-patterns</strong></p>
<ul>
<li>
<p>The <code>...</code> syntax in the input arguments of the outputs function indicates
variadic attributes, meaning the input attribute set can contain more
attributes than just those explicitly listed (like <code>self</code> and <code>nixpkgs</code>).</p>
<p><strong>Example:</strong></p>
<pre><code class="language-nix">mul = { a, b, ... }: a * b;
mul { a = 3; b = 4; c = 2; } # 'c' is an extra attribute
</code></pre>
<p>However, you cannot directly access these extra attributes within the
function body unless you use the @-pattern:</p>
<ul>
<li>(Click for Output)</li>
</ul>
<pre><code class="language-nix">mul = s@{ a, b, ... }: a  b  s.c; # 's' now refers to the entire input set
mul { a = 3; b = 4; c = 2; } # Output: 24
<span class="boring"> 24
</span></code></pre>
<ul>
<li>
<p>When used in the outputs function argument list (e.g.,
<code>outputs = { pkgs, ... } @ inputs)</code>, the @-pattern binds the entire input
attribute set to a name (in this case, <code>inputs</code>) while also allowing you to
destructure specific attributes like pkgs.</p>
</li>
<li>
<p><strong>What <code>outputs = { pkgs, ... } @ inputs: { ... };</code> does:</strong></p>
</li>
</ul>
</li>
</ul>
<ol>
<li>
<p><strong>Destructuring:</strong> It tries to extract the value associated with the key
<code>pkgs</code> from the input attribute set and binds it to the variable <code>pkgs</code>.
The <code>...</code> allows for other keys in the input attribute set to be ignored
during this direct destructuring.</p>
</li>
<li>
<p><strong>Binding the Entire Set:</strong> It binds the entire input attribute set to the
variable inputs.</p>
<ul>
<li>Example <code>flake.nix</code>:</li>
</ul>
</li>
</ol>
<pre><code class="language-nix">{
inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
inputs.home-manager.url = "github:nix-community/home-manager";

outputs = { self, nixpkgs, ... } @ attrs: { # A `packages` output for the x86_64-linux platform
packages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello;

    # A `nixosConfigurations` output (for a NixOS system named "fnord")
    nixosConfigurations.fnord = nixpkgs.lib.nixosSystem {
      system = "x86_64-linux";
      specialArgs = attrs;
      modules = [ ./configuration.nix ];
    };

};
}
</code></pre>
<p><strong>Platform Specificity in Outputs</strong></p>
<ul>
<li>Flakes ensure that their outputs are consistent across different evaluation
environments. Therefore, any package-related output must explicitly specify
the target platform (a combination of architecture and OS, <code>x86_64-linux</code>).</li>
</ul>
<p><strong>legacyPackages Explained</strong></p>
<ul>
<li><code>legacyPackages</code> is a way for flakes to interact with the traditional,
less structured package organization of nixpkgs. Instead of packages being
directly at the top level (e.g., <code>pkgs.hello</code>), <code>legacyPackages</code> provides a
platform-aware way to access them within the flake's structured output format
(e.g., <code>nixpkgs.legacyPackages.x86_64-linux.hello</code>). It acts as a bridge
between the flake's expected output structure and nixpkgs's historical
organization.</li>
</ul>
<p><strong>The Sole Argument of outputs</strong></p>
<ul>
<li>It's crucial to remember that the outputs function accepts only one argument,
which is an attribute set. The <code>{ self, nixpkgs, ... }</code> syntax is simply
destructuring that single input attribute set.</li>
</ul>
<p><strong>Outputs of the Flake (Return Value)</strong></p>
<ul>
<li>The outputs of the flake refer to the attribute set that is returned by the
<code>outputs</code> function. This attribute set can contain various named outputs like
<code>packages</code>, <code>nixosConfigurations</code>, <code>devShells</code>, etc.</li>
</ul>
<p><strong>Imports: Including Other Nix Expressions</strong></p>
<ul>
<li>
<p>The <code>import</code> function in Nix is used to evaluate the Nix expression found at
a specified path (usually a file or directory) and return its value.</p>
</li>
<li>
<p>Basic Usage: import <code>./path/to/file.nix</code></p>
</li>
</ul>
<p><strong>Passing Arguments During Import</strong></p>
<ul>
<li>You can also pass an attribute set as an argument to the Nix expression being
imported:</li>
</ul>
<pre><code class="language-nix">let
myHelpers = import ./lib/my-helpers.nix { pkgs = nixpkgs; };
in
# ... use myHelpers
</code></pre>
<ul>
<li>In this case, the Nix expression in <code>./lib/my-helpers.nix</code> is likely a
function that expects an argument (often named <code>pkgs</code> by convention):</li>
</ul>
<pre><code class="language-nix"># ./lib/my-helpers.nix

{ pkgs }:
let
myPackage = pkgs.stdenv.mkDerivation {
name = "my-package"; # ...
};
in
myPackage
</code></pre>
<ul>
<li>By passing <code>{ pkgs = nixpkgs; }</code> during the import, you are providing the
nixpkgs value from your current <code>flake.nix</code> scope to the pkgs parameter
expected by the code in <code>./lib/my-helpers.nix</code>.</li>
</ul>
<p><strong>Importing Directories (<code>default.nix</code>)</strong></p>
<ul>
<li>When you use import with a path that points to a directory, Nix automatically
looks for a file named <code>default.nix</code> within that directory. If found, Nix
evaluates the expressions within <code>default.nix</code> as if you had specified its
path directly in the import statement.</li>
</ul>
<h2 id="conclusion-unifying-your-nix-experience-with-flakes"><a class="header" href="#conclusion-unifying-your-nix-experience-with-flakes">Conclusion: Unifying Your Nix Experience with Flakes</a></h2>
<p>In this chapter, we've explored Nix Flakes as a powerful and modern approach to
managing Nix projects, from development environments to entire system
configurations. We've seen how they provide structure, dependency management,
and reproducibility through well-defined inputs and outputs. Flakes offer a
cohesive way to organize your Nix code and share it with others.</p>
<p>As we've worked with the flake.nix file, you've likely noticed its structure –
a top-level attribute set defining various outputs like devShells, packages,
nixosConfigurations, and more. These top-level attributes are not arbitrary;
they follow certain conventions and play specific roles within the Flake
ecosystem.</p>
<p>In the next chapter, <a href="https://saylesss88.github.io/Understanding_Top-Level_Attributes_5.html">Understanding Top-Level Attributes</a>
we will delve deeper into the meaning and purpose of these common top-level
attributes. We'll explore how they are structured, what kind of expressions they
typically contain, and how they contribute to the overall functionality and
organization of your Nix Flakes. Understanding these attributes is key to
effectively leveraging the full potential of Nix Flakes.</p>
<h2 id="further-resources"><a class="header" href="#further-resources">Further Resources</a></h2>
<details>
<summary> ✔️ Resources (Click to Expand)</summary>
<ul>
<li>
<p><a href="https://tsawyer87.github.io/posts/nix_flakes_tips/">Nix Flakes Tips and Tricks</a></p>
</li>
<li>
<p><a href="https://serokell.io/blog/practical-nix-flakes">practical-nix-flakes</a></p>
</li>
<li>
<p><a href="https://www.tweag.io/blog/2020-07-31-nixos-flakes/">tweag nix-flakes</a></p>
</li>
<li>
<p><a href="https://nixos.wiki/wiki/Flakes">NixOS-wiki Flakes</a></p>
</li>
<li>
<p><a href="https://nix.dev/concepts/flakes.html">nix.dev flakes</a></p>
</li>
<li>
<p><a href="https://jade.fyi/blog/flakes-arent-real/">flakes-arent-real</a></p>
</li>
<li>
<p><a href="https://mhwombat.codeberg.page/nix-book/#_attribute_set_operations">wombats-book-of-nix</a></p>
</li>
<li>
<p><a href="https://zero-to-nix.com/concepts/flakes/">zero-to-nix flakes</a></p>
</li>
<li>
<p><a href="https://nixos-and-flakes.thiscute.world/">nixos-and-flakes-book</a></p>
</li>
<li>
<p><a href="https://flakehub.com/">FlakeHub</a></p>
</li>
</ul>
<p><img src="images/nixosnix.png" alt="FlakeHub" /></p>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="NixOS_Modules_Explained_3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="Understanding_Top-Level_Attributes_5.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="NixOS_Modules_Explained_3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="Understanding_Top-Level_Attributes_5.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
