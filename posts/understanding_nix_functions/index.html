<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Understanding_nix_functions | NixOS Blog</title>
<meta name=title content="Understanding_nix_functions"><meta name=description content="Understanding Nix Functions
TOC

Understanding Nix Functions

The Single-Argument Nature of Nix Functions
Identifying Function Structure The Colon
Function Declarations Single and &ldquo;Multiple&rdquo; Arguments

The Function Nature of NixOS and Home Manager Modules
Resources








Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.
The Single-Argument Nature of Nix Functions
A key concept to understand is that in Nix, every function conceptually takes exactly one argument. What might appear as multi-argument functions are actually achieved through a technique called currying, where a series of nested single-argument functions are used."><meta name=author content="T Sawyer"><meta name=keywords content><meta property="og:url" content="https://saylesss88.github.io/posts/understanding_nix_functions/"><meta property="og:site_name" content="NixOS Blog"><meta property="og:title" content="Understanding_nix_functions"><meta property="og:description" content="Understanding Nix Functions TOC
Understanding Nix Functions The Single-Argument Nature of Nix Functions Identifying Function Structure The Colon Function Declarations Single and “Multiple” Arguments The Function Nature of NixOS and Home Manager Modules Resources Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.
The Single-Argument Nature of Nix Functions A key concept to understand is that in Nix, every function conceptually takes exactly one argument. What might appear as multi-argument functions are actually achieved through a technique called currying, where a series of nested single-argument functions are used."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-14T19:17:32-04:00"><meta property="article:modified_time" content="2025-05-14T19:17:32-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Understanding_nix_functions"><meta name=twitter:description content="Understanding Nix Functions TOC
Understanding Nix Functions The Single-Argument Nature of Nix Functions Identifying Function Structure The Colon Function Declarations Single and “Multiple” Arguments The Function Nature of NixOS and Home Manager Modules Resources Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.
The Single-Argument Nature of Nix Functions A key concept to understand is that in Nix, every function conceptually takes exactly one argument. What might appear as multi-argument functions are actually achieved through a technique called currying, where a series of nested single-argument functions are used."><meta itemprop=name content="Understanding_nix_functions"><meta itemprop=description content="Understanding Nix Functions TOC
Understanding Nix Functions The Single-Argument Nature of Nix Functions Identifying Function Structure The Colon Function Declarations Single and “Multiple” Arguments The Function Nature of NixOS and Home Manager Modules Resources Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.
The Single-Argument Nature of Nix Functions A key concept to understand is that in Nix, every function conceptually takes exactly one argument. What might appear as multi-argument functions are actually achieved through a technique called currying, where a series of nested single-argument functions are used."><meta itemprop=datePublished content="2025-05-14T19:17:32-04:00"><meta itemprop=dateModified content="2025-05-14T19:17:32-04:00"><meta itemprop=wordCount content="813"><meta name=referrer content="no-referrer-when-downgrade"><link href=/original.min.css rel=stylesheet><link href=/syntax.min.css rel=stylesheet></head><body><header><a class=skip-link href=#main-content>Skip to main content</a>
<a href=/ class=title><h1>NixOS Blog</h1></a><nav><a href=https://saylesss88.github.io/index.xml>RSS</a></nav></header><main id=main-content><h1>Understanding_nix_functions</h1><p class=byline><time datetime=2025-05-14 pubdate>2025-05-14
</time>· T Sawyer</p><content><h1 id=understanding-nix-functions>Understanding Nix Functions</h1><p><strong>TOC</strong></p><ul><li><a href=#understanding-nix-functions>Understanding Nix Functions</a><ul><li><a href=#the-single-argument-nature-of-nix-functions>The Single-Argument Nature of Nix Functions</a></li><li><a href=#identifying-function-structure-the-colon>Identifying Function Structure The Colon</a></li><li><a href=#function-declarations-single-and-multiple-arguments>Function Declarations Single and &ldquo;Multiple&rdquo; Arguments</a><ul><li><a href=#the-function-nature-of-nixos-and-home-manager-modules>The Function Nature of NixOS and Home Manager Modules</a></li><li><a href=#resources>Resources</a></li></ul></li></ul></li></ul><figure><img src=/images/nixLogo.png alt=NixFlakeLogo width=500></figure><p>Functions are a fundamental concept in Nix and are prevalent throughout Nix code. Grasping how they work is crucial for understanding and writing Nix expressions.</p><h2 id=the-single-argument-nature-of-nix-functions>The Single-Argument Nature of Nix Functions</h2><p>A key concept to understand is that in Nix, every function conceptually takes <strong>exactly one argument</strong>. What might appear as multi-argument functions are actually achieved through a technique called <strong>currying</strong>, where a series of nested single-argument functions are used.</p><h2 id=identifying-function-structure-the-colon>Identifying Function Structure The Colon</h2><p>The colon (<code>:</code>) acts as a clear separator within a function definition:</p><ul><li><strong>Left of the Colon:</strong> This is the function&rsquo;s <strong>argument</strong>. It&rsquo;s a placeholder name for a value that will be provided when the function is called.</li><li><strong>Right of the Colon:</strong> This is the <strong>function body</strong>. It&rsquo;s the expression that will be evaluated when the function is invoked.</li></ul><p><strong>Think of function arguments as naming values that aren&rsquo;t known in advance.</strong> These names are placeholders that get filled with specific values when the function is used.</p><p><strong>Example:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>greet <span style=color:#f92672>=</span> personName: <span style=color:#e6db74>&#34;Hello, </span><span style=color:#e6db74>${</span>personName<span style=color:#e6db74>}</span><span style=color:#e6db74>!&#34;</span>;</span></span></code></pre></div><ul><li><p>Here, <code>personName</code> is the <strong>argument</strong> (the placeholder).</p></li><li><p><code>"Hello, ${personName}!"</code>, is the <strong>function body</strong> (the expression that
uses the placeholder).</p></li></ul><p>When you call the function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>greet <span style=color:#e6db74>&#34;Anonymous&#34;</span>  <span style=color:#75715e># Evaluates to &#34;Hello, Anonymous!&#34;</span></span></span></code></pre></div><p>The value <code>"Anonymous"</code> is substituted for the <code>personName</code> placeholder within
the function body.</p><h2 id=function-declarations-single-and-multiple-arguments>Function Declarations Single and &ldquo;Multiple&rdquo; Arguments</h2><p><strong>Single-Argument Functions</strong></p><p>The simplest form of a Nix function takes a single argument:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>inc <span style=color:#f92672>=</span> x: x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>inc <span style=color:#ae81ff>5</span>  <span style=color:#75715e># Evaluates to 6</span></span></span></code></pre></div><ul><li><p><code>x</code> is the argument.</p></li><li><p><code>x + 1</code> is the function body.</p></li></ul><p><strong>Simulating Multiple Arguments: Currying</strong></p><p>To create functions that appear to take multiple arguments, Nix uses currying.
This involves nesting single-argument functions, where each function takes one
argument and returns another function that takes the next argument, and so on.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>concat <span style=color:#f92672>=</span> x: y: x <span style=color:#f92672>+</span> y;
</span></span><span style=display:flex><span>concat <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>6</span>    <span style=color:#75715e># Evaluates to 12</span></span></span></code></pre></div><p>Nix interprets the colons as separators for this chain of single-argument
functions.</p><p><strong>Understanding the Chain:</strong></p><p>Consider the <code>greeting</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>greeting <span style=color:#f92672>=</span> prefix: name: <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>prefix<span style=color:#e6db74>}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>${</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>!&#34;</span>;</span></span></code></pre></div><p>This is effectively a chain:</p><ol><li><strong>Outer Function</strong>: <code>prefix: (name: "${prefix}, ${name}!")</code></li></ol><ul><li><p>Takes one argument: <code>prefix</code>.</p></li><li><p>Its body is another function definition: name: <code>"${prefix}, ${name}!"</code>.</p></li></ul><p>2 <strong>Inner Function:</strong> <code>name: "${prefix}, ${name}!"</code></p><ul><li><p>Takes one argument: <code>name</code>.</p></li><li><p>Its body uses both its own argument (<code>name</code>) and the argument from the
outer function&rsquo;s scope (prefix).</p></li></ul><p><strong>Step-by-Step Evaluation:</strong></p><p>When you call <code>greeting "Hello" "Alice"</code>:</p><ol><li><code>greeting "Hello"</code>:</li></ol><ul><li><p>The <code>greeting</code> function is called with <code>"Hello"</code> as the <code>prefix</code>.</p></li><li><p>The outer function returns the inner function:
<code>name: "Hello, ${name}!"</code> (where <code>prefix</code> is now fixed as `&ldquo;Hello&rdquo;`` in its
scope).</p></li></ul><ol start=2><li><code>(greeting "Hello") "Alice"</code>:</li></ol><ul><li><p>The resulting inner function is then called with <code>"Alice"</code> as the <code>name</code>.</p></li><li><p>The inner function evaluates its body: <code>"Hello, ${"Alice"}!"</code>, resulting in
<code>"Hello, Alice!"</code>.</p></li></ul><p><strong>Key Insight</strong>: Every colon in a function definition separates a single
argument from its function body, even if that body is another function
definition.</p><p><strong>Partial Application: Using Functions Incrementally</strong></p><p>Because of currying, you can apply arguments to a Nix function one at a time.
This is called partial application. When you provide only some of the expected
arguments, you get a new function that &ldquo;remembers&rdquo; the provided arguments and
waits for the rest.</p><p><strong>Example:</strong></p><p>Using our <code>greeting</code> function again:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>greeting <span style=color:#f92672>=</span> prefix: name: <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>prefix<span style=color:#e6db74>}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>${</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>!&#34;</span>;</span></span></code></pre></div><p>If we only provide the prefix:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>helloGreeting <span style=color:#f92672>=</span> greeting <span style=color:#e6db74>&#34;Hello&#34;</span>;</span></span></code></pre></div><ul><li><code>helloGreeting</code> is now a new function. It has already received the <code>prefix</code>
argument (<code>"Hello"</code>) and is waiting for the <code>name</code> argument.</li></ul><p>Calling <code>helloGreeting</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>helloGreeting <span style=color:#e6db74>&#34;Sally&#34;</span> <span style=color:#75715e># Evaluates to &#34;Hello, Sally!&#34;</span></span></span></code></pre></div><p><strong>Benefits of Partial Application:</strong></p><ul><li><p><strong>Creating Specialized Functions</strong>: You can create more specific functions
from general ones by fixing some of their parameters.</p></li><li><p><strong>Adapting to Higher-Order Functions</strong>: Many functions that operate on other
functions (like <code>map</code> and <code>filter</code>) expect functions with a certain number of
arguments. Partial application allows you to adapt existing functions to fit
these requirements.</p></li></ul><h3 id=the-function-nature-of-nixos-and-home-manager-modules>The Function Nature of NixOS and Home Manager Modules</h3><p>It&rsquo;s crucial to understand that most NixOS and Home Manager modules are
fundamentally <strong>functions</strong>.</p><ul><li>These module functions typically accept a single argument: an
<strong>attribute set</strong>.</li></ul><p><strong>Example</strong>:</p><p>A simplified Nginx service module:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{ config<span style=color:#f92672>,</span> lib<span style=color:#f92672>,</span> pkgs<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }: {
</span></span><span style=display:flex><span>services<span style=color:#f92672>.</span>nginx<span style=color:#f92672>.</span>enable <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>services<span style=color:#f92672>.</span>nginx<span style=color:#f92672>.</span>package <span style=color:#f92672>=</span> pkgs<span style=color:#f92672>.</span>nginx;
</span></span><span style=display:flex><span>services<span style=color:#f92672>.</span>nginx<span style=color:#f92672>.</span>settings<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;http-port&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;8080&#34;</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><ul><li><p>The entire module definition is a function that takes one argument:
<code>{ config, lib, pkgs, ... }</code>.</p></li><li><p>When this module is included in your configuration, the NixOS module system
calls this function with a specific attribute set. This attribute set contains
the current system configuration (<code>config</code>), the Nix standard library (<code>lib</code>),
the available packages (<code>pkgs</code>), and other relevant information. The module
then uses these values to define parts of your system.</p></li></ul><h3 id=resources>Resources</h3><ul><li><p><a href=https://nix.dev/tutorials/nix-language.html>nix.dev Nix Lang Basics</a></p></li><li><p><a href=https://nixos.org/guides/nix-pills/05-functions-and-imports.html>nix pills Functions and Imports</a></p></li><li><p><a href=https://zero-to-nix.com/concepts/nix-language/>zero-to-nix Nix Lang</a></p></li><li><p><a href="https://nixcloud.io/tour/?id=functions%2Fintroduction">A tour of Nix &ldquo;Functions&rdquo;</a></p></li><li><p><a href=https://learnxinyminutes.com/nix/>learn Nix in y minutes</a></p></li><li><p><a href=https://noogle.dev/>noogle function library</a></p></li></ul></content><p></p></main><footer><small>|</small></footer></body></html>