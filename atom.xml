<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>nix-book</title><id>https://saylesss88.github.io/atom.xml</id><updated>1970-01-01T00:00:00+00:00</updated><link href="https://saylesss88.github.io/atom.xml" rel="self"/><link href="https://saylesss88.github.io/atom2.xml" rel="next"/><subtitle>An mdBook-generated site</subtitle><entry><title>Understanding the Helix Flake</title><id>https://saylesss88.github.io/flakes/helix_flake_4.4.html</id><updated>2025-12-05T00:00:00+00:00</updated><link href="https://saylesss88.github.io/flakes/helix_flake_4.4.html" rel="alternate"/><content type="html">&lt;h1&gt;Chapter 4.4&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;p&gt;&lt;img src=&quot;../images/helix.png&quot; alt=&quot;Helix Logo&quot; /&gt;‚Äì&lt;a href=&quot;https://helix-editor.com/&quot;&gt;helix-editor.com&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Understanding the Helix Flake and Modifying its Behavior&lt;/h1&gt;
&lt;p&gt;As we‚Äôve seen from previous examples, the helix editor repository includes a few
&lt;code&gt;.nix&lt;/code&gt; files including a &lt;code&gt;flake.nix&lt;/code&gt;. Their flake uses a lot of idiomatic Nix
code and advanced features. First I will break down their &lt;code&gt;flake.nix&lt;/code&gt; and
&lt;code&gt;default.nix&lt;/code&gt; to understand why they do certain things. And finally, we will
change the build to ‚Äúdebug‚Äù mode demonstrating how easily you can modify the
behavior of a package defined within a Nix flake without changing the original
source code or the upstream flake directly.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Let‚Äôs clone the Helix repository:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git clone https://github.com/helix-editor/helix.git
cd helix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you enter the &lt;code&gt;helix&lt;/code&gt; directory, &lt;code&gt;direnv&lt;/code&gt; is setup for you already. All you
would have to do is &lt;code&gt;direnv allow&lt;/code&gt; and it will ask you a few questions then you
are good to go. Looking at their &lt;code&gt;.envrc&lt;/code&gt; it mentions ‚Äútry to use flakes, if it
fails use normal nix (i.e., shell.nix)‚Äù. If it‚Äôs successful you‚Äôll see a long
list of environment variables displayed.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Enter the Development Shell:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The Helix project‚Äôs &lt;code&gt;flake.nix&lt;/code&gt; includes a &lt;code&gt;devShells.default&lt;/code&gt; output,
specifically designed for development.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix develop
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;You‚Äôre now in a fully configured development environment:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;When you run &lt;code&gt;nix develop&lt;/code&gt;, Nix builds and drops you into a shell environment
with all the dependencies specified in &lt;code&gt;devShells.default&lt;/code&gt;. This means you
don‚Äôt have to manually install or manage tools like Rust, Cargo, or Clang,
it‚Äôs all handled declaratively through Nix.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can now build and run the project using its standard tooling:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cargo check
cargo build
cargo run
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Making Changes and Testing Them&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Since you‚Äôre in a reproducible environment, you can confidently hack on the
project without worrying about your system setup. Try modifying some code in
&lt;code&gt;helix&lt;/code&gt; and rebuilding with Cargo. The Nix shell ensures consistency for every
contributor or device you work on.&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Run Just the Binary&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you only want to run the compiled program without entering the shell, use the
nix run command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix run
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This builds and runs the default package defined by the flake. In the case of
Helix, this launches the &lt;code&gt;hx&lt;/code&gt; editor directly.&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;Build Without Running&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To just build the project and get the path to the output binary:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You‚Äôll find the compiled binary under &lt;code&gt;./result/bin&lt;/code&gt;.&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;Pinning and Reproducing&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Because the project uses a flake, you can ensure full reproducibility by pinning
the inputs. For example, you can clone with &lt;code&gt;--recurse-submodules&lt;/code&gt; and copy the
&lt;code&gt;flake.lock&lt;/code&gt; to ensure you‚Äôre using the same dependency versions as upstream.
This is great for debugging or sharing exact builds.&lt;/p&gt;
&lt;p&gt;‚úÖ Recap:&lt;/p&gt;
&lt;p&gt;With flakes, projects like Helix provide everything you need for development and
running in a single &lt;code&gt;flake.nix&lt;/code&gt;. You can nix develop to get started hacking, nix
run to quickly try it out, and nix build to produce binaries all without
installing or polluting your system.&lt;/p&gt;
&lt;h2&gt;Understanding the Helix flake.nix&lt;/h2&gt;
&lt;p&gt;The helix flake is full of idiomatic Nix code and displays some of the more
advanced things a flake can provide:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{
  description = &quot;A post-modern text editor.&quot;;

  inputs = {
    nixpkgs.url = &quot;github:nixos/nixpkgs/nixos-unstable&quot;;
    rust-overlay = {
      url = &quot;github:oxalica/rust-overlay&quot;;
      inputs.nixpkgs.follows = &quot;nixpkgs&quot;;
    };
  };

  outputs = {
    self,
    nixpkgs,
    rust-overlay,
    ...
  }: let
    inherit (nixpkgs) lib;
    systems = [
      &quot;x86_64-linux&quot;
      &quot;aarch64-linux&quot;
      &quot;x86_64-darwin&quot;
      &quot;aarch64-darwin&quot;
    ];
    eachSystem = lib.genAttrs systems;
    pkgsFor = eachSystem (system:
      import nixpkgs {
        localSystem.system = system;
        overlays = [(import rust-overlay) self.overlays.helix];
      });
    gitRev = self.rev or self.dirtyRev or null;
  in {
    packages = eachSystem (system: {
      inherit (pkgsFor.${system}) helix;
      /*
      The default Helix build. Uses the latest stable Rust toolchain, and unstable
      nixpkgs.

      The build inputs can be overridden with the following:

      packages.${system}.default.override { rustPlatform = newPlatform; };

      Overriding a derivation attribute can be done as well:

      packages.${system}.default.overrideAttrs { buildType = &quot;debug&quot;; };
      */
      default = self.packages.${system}.helix;
    });
    checks =
      lib.mapAttrs (system: pkgs: let
        # Get Helix&apos;s MSRV toolchain to build with by default.
        msrvToolchain = pkgs.pkgsBuildHost.rust-bin.fromRustupToolchainFile ./rust-toolchain.toml;
        msrvPlatform = pkgs.makeRustPlatform {
          cargo = msrvToolchain;
          rustc = msrvToolchain;
        };
      in {
        helix = self.packages.${system}.helix.override {
          rustPlatform = msrvPlatform;
        };
      })
      pkgsFor;

    # Devshell behavior is preserved.
    devShells =
      lib.mapAttrs (system: pkgs: {
        default = let
          commonRustFlagsEnv = &quot;-C link-arg=-fuse-ld=lld -C target-cpu=native --cfg tokio_unstable&quot;;
          platformRustFlagsEnv = lib.optionalString pkgs.stdenv.isLinux &quot;-Clink-arg=-Wl,--no-rosegment&quot;;
        in
          pkgs.mkShell {
            inputsFrom = [self.checks.${system}.helix];
            nativeBuildInputs = with pkgs;
              [
                lld
                cargo-flamegraph
                rust-bin.nightly.latest.rust-analyzer
              ]
              ++ (lib.optional (stdenv.isx86_64 &amp;amp;&amp;amp; stdenv.isLinux) cargo-tarpaulin)
              ++ (lib.optional stdenv.isLinux lldb)
              ++ (lib.optional stdenv.isDarwin darwin.apple_sdk.frameworks.CoreFoundation);
            shellHook = &apos;&apos;
              export RUST_BACKTRACE=&quot;1&quot;
              export RUSTFLAGS=&quot;&apos;&apos;${RUSTFLAGS:-&quot;&quot;} ${commonRustFlagsEnv} ${platformRustFlagsEnv}&quot;
            &apos;&apos;;
          };
      })
      pkgsFor;

    overlays = {
      helix = final: prev: {
        helix = final.callPackage ./default.nix {inherit gitRev;};
      };

      default = self.overlays.helix;
    };
  };
  nixConfig = {
    extra-substituters = [&quot;https://helix.cachix.org&quot;];
    extra-trusted-public-keys = [&quot;helix.cachix.org-1:ejp9KQpR1FBI2onstMQ34yogDm4OgU2ru6lIwPvuCVs=&quot;];
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Top-Level Metadata&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{
  description = &quot;A post-modern text editor.&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This sets a human-readable description for the flake.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Inputs&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;inputs = {
  nixpkgs.url = &quot;github:nixos/nixpkgs/nixos-unstable&quot;;
  rust-overlay = {
    url = &quot;github:oxalica/rust-overlay&quot;;
    inputs.nixpkgs.follows = &quot;nixpkgs&quot;;
  };
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;nixpkgs&lt;/code&gt;: Uses the &lt;code&gt;nixos-unstable&lt;/code&gt; branch of the Nixpkgs repository.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;rust-overlay&lt;/code&gt;: follows the same &lt;code&gt;nixpkgs&lt;/code&gt;, ensuring compatibility between
inputs.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Outputs Function&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;outputs = { self, nixpkgs, rust-overlay, ... }:
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This defines what this flake exports, including &lt;code&gt;packages&lt;/code&gt;, &lt;code&gt;devShells&lt;/code&gt;, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Common Setup&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;let
  inherit (nixpkgs) lib;
  systems = [ ... ];
  eachSystem = lib.genAttrs systems;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;systems&lt;/code&gt;: A list of the supported systems&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;eachSystem&lt;/code&gt;: A Helper to map over all platforms.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;pkgsFor = eachSystem (system:
  import nixpkgs {
    localSystem.system = system;
    overlays = [(import rust-overlay) self.overlays.helix];
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This imports &lt;code&gt;nixpkgs&lt;/code&gt; for each system and applies overlays&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;üì¶ &lt;code&gt;packages&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;packages = eachSystem (system: {
  inherit (pkgsFor.${system}) helix;
  default = self.packages.${system}.helix;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;For each platform:
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Includes a &lt;code&gt;helix&lt;/code&gt; package (defined in &lt;code&gt;./default.nix&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sets &lt;code&gt;default&lt;/code&gt; to &lt;code&gt;helix&lt;/code&gt; (used by &lt;code&gt;nix build&lt;/code&gt;, &lt;code&gt;nix run&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let‚Äôs look at the helix &lt;code&gt;default.nix&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{
  lib,
  rustPlatform,
  callPackage,
  runCommand,
  installShellFiles,
  git,
  gitRev ? null,
  grammarOverlays ? [],
  includeGrammarIf ? _: true,
}: let
  fs = lib.fileset;

  src = fs.difference (fs.gitTracked ./.) (fs.unions [
    ./.envrc
    ./rustfmt.toml
    ./screenshot.png
    ./book
    ./docs
    ./runtime
    ./flake.lock
    (fs.fileFilter (file: lib.strings.hasInfix &quot;.git&quot; file.name) ./.)
    (fs.fileFilter (file: file.hasExt &quot;svg&quot;) ./.)
    (fs.fileFilter (file: file.hasExt &quot;md&quot;) ./.)
    (fs.fileFilter (file: file.hasExt &quot;nix&quot;) ./.)
  ]);

  # Next we actually need to build the grammars and the runtime directory
  # that they reside in. It is built by calling the derivation in the
  # grammars.nix file, then taking the runtime directory in the git repo
  # and hooking symlinks up to it.
  grammars = callPackage ./grammars.nix {inherit grammarOverlays includeGrammarIf;};
  runtimeDir = runCommand &quot;helix-runtime&quot; {} &apos;&apos;
    mkdir -p $out
    ln -s ${./runtime}/* $out
    rm -r $out/grammars
    ln -s ${grammars} $out/grammars
  &apos;&apos;;
in
  rustPlatform.buildRustPackage (self: {
    cargoLock = {
      lockFile = ./Cargo.lock;
      # This is not allowed in nixpkgs but is very convenient here: it allows us to
      # avoid specifying `outputHashes` here for any git dependencies we might take
      # on temporarily.
      allowBuiltinFetchGit = true;
    };

    nativeBuildInputs = [
      installShellFiles
      git
    ];

    buildType = &quot;release&quot;;

    name = with builtins; (fromTOML (readFile ./helix-term/Cargo.toml)).package.name;
    src = fs.toSource {
      root = ./.;
      fileset = src;
    };

    # Helix attempts to reach out to the network and get the grammars. Nix doesn&apos;t allow this.
    HELIX_DISABLE_AUTO_GRAMMAR_BUILD = &quot;1&quot;;

    # So Helix knows what rev it is.
    HELIX_NIX_BUILD_REV = gitRev;

    doCheck = false;
    strictDeps = true;

    # Sets the Helix runtime dir to the grammars
    env.HELIX_DEFAULT_RUNTIME = &quot;${runtimeDir}&quot;;

    # Get all the application stuff in the output directory.
    postInstall = &apos;&apos;
      mkdir -p $out/lib
      installShellCompletion ${./contrib/completion}/hx.{bash,fish,zsh}
      mkdir -p $out/share/{applications,icons/hicolor/{256x256,scalable}/apps}
      cp ${./contrib/Helix.desktop} $out/share/applications/Helix.desktop
      cp ${./logo.svg} $out/share/icons/hicolor/scalable/apps/helix.svg
      cp ${./contrib/helix.png} $out/share/icons/hicolor/256x256/apps/helix.png
    &apos;&apos;;

    meta.mainProgram = &quot;hx&quot;;
  })
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Breaking Down &lt;code&gt;helix/default.nix&lt;/code&gt;&lt;/h3&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand `helix/default.nix` breakdown &lt;/summary&gt;
&lt;p&gt;This &lt;code&gt;default.nix&lt;/code&gt; file is a Nix derivation that defines how to build the Helix
editor itself. It‚Äôs designed to be called by the main &lt;code&gt;flake.nix&lt;/code&gt; as part of its
&lt;code&gt;packages&lt;/code&gt; output.&lt;/p&gt;
&lt;p&gt;Here‚Äôs a breakdown of its components:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Function Arguments&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{
  lib,
  rustPlatform,
  callPackage,
  runCommand,
  installShellFiles,
  git,
  gitRev ? null,
  grammarOverlays ? [],
  includeGrammarIf ? _: true,
}:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;lib&lt;/code&gt;: The Nixpkgs &lt;code&gt;lib&lt;/code&gt; (library) functions, essential for common operations
like &lt;code&gt;fileset&lt;/code&gt; and &lt;code&gt;strings&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rustPlatform&lt;/code&gt;: A helper function from Nixpkgs specifically for building Rust
projects. It provides a &lt;code&gt;buildRustPackage&lt;/code&gt; function, which simplifies the
process significantly.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;callPackage&lt;/code&gt;: A Nixpkgs function used to instantiate a Nix expression (like
&lt;code&gt;grammars.nix&lt;/code&gt;) with its dependencies automatically supplied from the current
Nix environment.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;runCommand&lt;/code&gt;: A Nixpkgs primitive that creates a derivation by running a shell
command. It‚Äôs used here to construct the &lt;code&gt;runtimeDir&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;installShellFiles&lt;/code&gt;: A utility from Nixpkgs for installing shell completion
files.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git&lt;/code&gt;: The Git package, needed for determining the &lt;code&gt;gitRev&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gitRev ? null&lt;/code&gt;: The Git revision of the Helix repository. It‚Äôs an optional
argument, defaulting to null. This is passed in from the main &lt;code&gt;flake.nix&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;grammarOverlays ? []&lt;/code&gt;: An optional list of overlays for grammars, allowing
customization.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;includeGrammarIf ? _: true&lt;/code&gt;: An optional function to control which grammars are
included.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;strong&gt;Local Variables&lt;/strong&gt; (&lt;code&gt;let ... in&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;let
  fs = lib.fileset;

  src = fs.difference (fs.gitTracked ./.) (fs.unions [
    ./.envrc
    ./rustfmt.toml
    ./screenshot.png
    ./book
    ./docs
    ./runtime
    ./flake.lock
    (fs.fileFilter (file: lib.strings.hasInfix &quot;.git&quot; file.name) ./.)
    (fs.fileFilter (file: file.hasExt &quot;svg&quot;) ./.)
    (fs.fileFilter (file: file.hasExt &quot;md&quot;) ./.)
    (fs.fileFilter (file: file.hasExt &quot;nix&quot;) ./.)
  ]);

  grammars = callPackage ./grammars.nix { inherit grammarOverlays includeGrammarIf; };
  runtimeDir = runCommand &quot;helix-runtime&quot; {} &apos;&apos;
    mkdir -p $out
    ln -s ${./runtime}/* $out
    rm -r $out/grammars
    ln -s ${grammars} $out/grammars
  &apos;&apos;;
in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fs = lib.fileset;&lt;/code&gt;: Aliases &lt;code&gt;lib.fileset&lt;/code&gt; for convenient file set operations.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;src&lt;/code&gt;: This is a crucial part. It defines the source files that will be used to
build Helix by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Taking all Git-tracked files in the current directory (&lt;code&gt;fs.gitTracked ./.&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Excluding configuration files (e.g., &lt;code&gt;.envrc&lt;/code&gt;, &lt;code&gt;flake.lock&lt;/code&gt;), documentation
(&lt;code&gt;.md&lt;/code&gt;), images (&lt;code&gt;.svg&lt;/code&gt;), and Nix files (&lt;code&gt;.nix&lt;/code&gt;) using &lt;code&gt;fs.difference&lt;/code&gt; and
&lt;code&gt;fs.unions&lt;/code&gt;. This ensures a clean build input, reducing Nix store size and
avoiding unnecessary rebuilds.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;grammars&lt;/code&gt;: Builds syntax grammars by calling &lt;code&gt;grammars.nix&lt;/code&gt;, passing
&lt;code&gt;grammarOverlays&lt;/code&gt; (for customizing grammar builds) and &lt;code&gt;includeGrammarIf&lt;/code&gt; (a
filter for selecting grammars).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;runtimeDir&lt;/code&gt;: Creates a runtime directory for Helix by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Symlinking the &lt;code&gt;runtime&lt;/code&gt; directory from the source.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Replacing the &lt;code&gt;grammars&lt;/code&gt; subdirectory with a symlink to the &lt;code&gt;grammars&lt;/code&gt;
derivation, ensuring Helix uses Nix-managed grammars.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;strong&gt;The Build Derivation&lt;/strong&gt; (&lt;code&gt;rustPlatform.buildRustPackage&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The core of this &lt;code&gt;default.nix&lt;/code&gt; is the &lt;code&gt;rustPlatform.buildRustPackage&lt;/code&gt; call,
which is a specialized builder for Rust projects:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;in
  rustPlatform.buildRustPackage (self: {
    cargoLock = {
      lockFile = ./Cargo.lock;
      # ... comments ...
      allowBuiltinFetchGit = true;
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cargoLock&lt;/code&gt;: Specifies how Cargo dependencies are handled.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lockFile = ./Cargo.lock;&lt;/code&gt; Points to the &lt;code&gt;Cargo.lock&lt;/code&gt; file for reproducible
builds.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;allowBuiltinFetchGit = true&lt;/code&gt;: Allows Cargo to fetch Git dependencies directly
from repositories specified in &lt;code&gt;Cargo.lock&lt;/code&gt;. This is discouraged in Nixpkgs
because it can break build reproducibility, but it‚Äôs used here for convenience
during development, eliminating the need to manually specify &lt;code&gt;outputHashes&lt;/code&gt; for
Git dependencies.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;nativeBuildInputs = [
      installShellFiles
      git
    ];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;nativeBuildInputs&lt;/code&gt;: Are tools needed during the build process but not
necessarily at runtime.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;buildType = &quot;release&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;buildType&lt;/code&gt;: Specifies that Helix should be built in ‚Äúrelease‚Äù mode (optimized).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;name = with builtins; (fromTOML (readFile ./helix-term/Cargo.toml)).package.name;
    src = fs.toSource {
      root = ./.;
      fileset = src;
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;: Dynamically sets the package name by reading it from the &lt;code&gt;Cargo.toml&lt;/code&gt;
file.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;src&lt;/code&gt;: Uses the &lt;code&gt;src&lt;/code&gt; file set defined earlier as the source for the build.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# Helix attempts to reach out to the network and get the grammars. Nix doesn&apos;t allow this.
    HELIX_DISABLE_AUTO_GRAMMAR_BUILD = &quot;1&quot;;

    # So Helix knows what rev it is.
    HELIX_NIX_BUILD_REV = gitRev;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Environment Variables&lt;/strong&gt;: Sets environment variables that Helix uses.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HELIX_DISABLE_AUTO_GRAMMAR_BUILD = &quot;1&quot;&lt;/code&gt;: Prevents Helix from downloading
grammars during the build, as Nix‚Äôs sandboxed environment disallows network
access. Instead, grammars are provided via the &lt;code&gt;runtimeDir&lt;/code&gt; derivation.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HELIX_NIX_BUILD_REV = gitRev&lt;/code&gt;: Embeds the specified Git revision (or &lt;code&gt;null&lt;/code&gt; if
unspecified) into the Helix binary, allowing Helix to display its version or
commit hash.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;doCheck = false;
   strictDeps = true;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;doCheck = false;&lt;/code&gt;: Skips running tests during the build. This is common for
faster builds, especially in CI/CD, but tests are often run in a separate
&lt;code&gt;checks&lt;/code&gt; output (as seen in the &lt;code&gt;flake.nix&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;strictDeps = true;&lt;/code&gt;: Ensures that all dependencies are explicitly declared.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# Sets the Helix runtime dir to the grammars
env.HELIX_DEFAULT_RUNTIME = &quot;${runtimeDir}&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# Sets the Helix runtime dir to the grammars
env.HELIX_DEFAULT_RUNTIME = &quot;${runtimeDir}&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;env.HELIX_DEFAULT_RUNTIME&lt;/code&gt;: Tells Helix where to find its runtime files
(including the Nix-managed grammars).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# Get all the application stuff in the output directory.
postInstall = &apos;&apos;
  mkdir -p $out/lib
  installShellCompletion ${./contrib/completion}/hx.{bash,fish,zsh}
  mkdir -p $out/share/{applications,icons/hicolor/{256x256,scalable}/apps}
  cp ${./contrib/Helix.desktop} $out/share/applications/Helix.desktop
  cp ${./logo.svg} $out/share/icons/hicolor/scalable/apps/helix.svg
  cp ${./contrib/helix.png} $out/share/icons/hicolor/256x256/apps/helix.png
&apos;&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;postInstall&lt;/code&gt;: A shell script that runs after the main build is complete. This
is used for installing additional files that are part of the Helix distribution
but not directly built by Cargo.&lt;/p&gt;
&lt;p&gt;Installs shell completion files (&lt;code&gt;hx.bash&lt;/code&gt;, &lt;code&gt;hx.fish&lt;/code&gt;, &lt;code&gt;hx.zsh&lt;/code&gt;). This enables
tab completion.&lt;/p&gt;
&lt;p&gt;Installs desktop entry files (&lt;code&gt;Helix.desktop&lt;/code&gt;) and icons (&lt;code&gt;logo.svg&lt;/code&gt;,
&lt;code&gt;helix.png&lt;/code&gt;) for desktop integration for GUI environments.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;    meta.mainProgram = &quot;hx&quot;;

})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;meta.mainProgram&lt;/code&gt;: Specifies the primary executable provided by this package,
allowing &lt;code&gt;nix run&lt;/code&gt; to automatically execute &lt;code&gt;hx&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A lot going on in this derivation!&lt;/p&gt;
&lt;/details&gt;
&lt;h3&gt;Making Actual Changes&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Locate the &lt;code&gt;packages&lt;/code&gt; output section. It looks like this:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;packages = eachSystem (system: {
      inherit (pkgsFor.${system}) helix;
      /*
      The default Helix build. Uses the latest stable Rust toolchain, and unstable
      nixpkgs.

      The build inputs can be overridden with the following:

      packages.${system}.default.override { rustPlatform = newPlatform; };

      Overriding a derivation attribute can be done as well:

      packages.${system}.default.overrideAttrs { buildType = &quot;debug&quot;; };
      */
      default = self.packages.${system}.helix;
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Modify the &lt;code&gt;default&lt;/code&gt; package. The comments actually tell us exactly how to do
this. We want to use &lt;code&gt;overrideAttrs&lt;/code&gt; to change the &lt;code&gt;buildType&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Change this line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;default = self.packages.${system}.helix;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;default = self.packages.${system}.helix.overrideAttrs { buildType = &quot;debug&quot;; };
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This tells Nix to take the standard Helix package definition and override one
of its internal attributes (&lt;code&gt;buildType&lt;/code&gt;) to ‚Äúdebug‚Äù instead of ‚Äúrelease‚Äù.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Build the ‚ÄúHacked‚Äù Helix:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix build
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Nix will now rebuild Helix, but this time, it will compile it in debug mode.
You‚Äôll likely notice the build takes a bit longer, and the resulting binary
will be larger due to the included debugging symbols.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Run the Debug Binary:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./result/bin/hx
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;You‚Äôre now running your custom-built debug version of Helix! This is useful if
you were, for example, attatching a debugger.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is a simple yet powerful ‚Äúhack‚Äù that demonstrates how easily you can modify
the behavior of a package defined within a Nix flake without changing the
original source code or the upstream flake directly. You‚Äôre simply telling Nix
how you‚Äôd like your version of the package to be built.&lt;/p&gt;
&lt;h3&gt;Another way to Modify Behavior&lt;/h3&gt;
&lt;p&gt;Since we are already familiar with the structure and behavior of Helix‚Äôs
&lt;code&gt;flake.nix&lt;/code&gt;, we can leverage that understanding to create our own Nix flake. By
analyzing how Helix organizes its &lt;code&gt;inputs&lt;/code&gt;, &lt;code&gt;outputs&lt;/code&gt;, and package definitions,
we gain the confidence to modify and extend a flake‚Äôs functionality to suit our
specific needs‚Äîwhether that‚Äôs customizing builds, adding overlays, or
integrating with home-manager.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a &lt;code&gt;flake.nix&lt;/code&gt; in your own directory (outside the helix repo):&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{
  description = &quot;Customized Helix build with debug features&quot;;

  inputs = {
    helix.url = &quot;github:helix-editor/helix&quot;;
    nixpkgs.url = &quot;github:nixos/nixpkgs/nixos-unstable&quot;;
    rust-overlay = {
      url = &quot;github:oxalica/rust-overlay&quot;;
      inputs.nixpkgs.follows = &quot;nixpkgs&quot;;
    };
  };
  outputs = {
    self,
    helix,
    nixpkgs,
    rust-overlay,
  }: let
    system = &quot;x86_64-linux&quot;;
    pkgs = import nixpkgs {
      system = system;
      overlays = [rust-overlay.overlay.overlays.default];
    };
  in {
    packages.${system}.default = helix.packages.${system}.helix.overrideAttrs (old: {
      buildType = &quot;debug&quot;;

      # Add additional cargo features
      cargoBuildFlags =
        (old.cargoBuildFlags or [])
        ++ [
          &quot;--features&quot;
          &quot;tokio-console&quot;
        ];

      # Inject custom RUSTFLAGS
      RUSTFLAGS = (old.RUSTFLAGS or &quot;&quot;) + &quot; -C debuginfo=2 -C opt-level=1&quot;;
    });
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix flake check
warning: creating lock file &apos;&quot;/home/jr/world/flake.lock&quot;&apos;:
‚Ä¢ Added input &apos;helix&apos;:
    &apos;github:helix-editor/helix/8961ae1dc66633ea6c9f761896cb0d885ae078ed?narHash=sha256-f14perPUk%2BH15GyGRbg0Akqhn3rxFnc6Ez5onqpzu6A%3D&apos; (2025-05-29)
‚Ä¢ Added input &apos;helix/nixpkgs&apos;:
    &apos;github:nixos/nixpkgs/5135c59491985879812717f4c9fea69604e7f26f?narHash=sha256-Vr3Qi346M%2B8CjedtbyUevIGDZW8LcA1fTG0ugPY/Hic%3D&apos; (2025-02-26)
‚Ä¢ Added input &apos;helix/rust-overlay&apos;:
    &apos;github:oxalica/rust-overlay/d342e8b5fd88421ff982f383c853f0fc78a847ab?narHash=sha256-3SdPQrZoa4odlScFDUHd4CUPQ/R1gtH4Mq9u8CBiK8M%3D&apos; (2025-02-27)
‚Ä¢ Added input &apos;helix/rust-overlay/nixpkgs&apos;:
    follows &apos;helix/nixpkgs&apos;
‚Ä¢ Added input &apos;nixpkgs&apos;:
    &apos;github:nixos/nixpkgs/96ec055edbe5ee227f28cdbc3f1ddf1df5965102?narHash=sha256-7doLyJBzCllvqX4gszYtmZUToxKvMUrg45EUWaUYmBg%3D&apos; (2025-05-28)
‚Ä¢ Added input &apos;rust-overlay&apos;:
    &apos;github:oxalica/rust-overlay/405ef13a5b80a0a4d4fc87c83554423d80e5f929?narHash=sha256-k0nhPtkVDQkVJckRw6fGIeeDBktJf1BH0i8T48o7zkk%3D&apos; (2025-05-30)
‚Ä¢ Added input &apos;rust-overlay/nixpkgs&apos;:
    follows &apos;nixpkgs&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;nix flake check&lt;/code&gt; command will generate a &lt;code&gt;flake.lock&lt;/code&gt; file if one doesn‚Äôt
exist, and the warnings you see indicate that new inputs are being added and
locked to specific versions for reproducibility. This is expected behavior for
a new or modified flake.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Inspect the outputs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix flake show
path:/home/jr/world?lastModified=1748612128&amp;amp;narHash=sha256-WEYtptarRrrm0Jb/0PJ/b5VPqLkCk5iEenjbKYU4Xm8%3D
‚îî‚îÄ‚îÄ‚îÄpackages
    ‚îî‚îÄ‚îÄ‚îÄx86_64-linux
        ‚îî‚îÄ‚îÄ‚îÄdefault: package &apos;helix-term&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;‚îî‚îÄ‚îÄ‚îÄpackages&lt;/code&gt; line indicates that our flake exposes a top-level
&lt;code&gt;packages&lt;/code&gt; attribute.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;‚îî‚îÄ‚îÄ‚îÄx86_64-linux&lt;/code&gt;: System architecture specificity&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;‚îî‚îÄ‚îÄ‚îÄdefault: package &apos;helix-term&apos;&lt;/code&gt; Signifies that within the &lt;code&gt;x86_64-linux&lt;/code&gt;
packages, there‚Äôs a package named &lt;code&gt;default&lt;/code&gt;. This is a special name that
allows you to omit the package name when using commands like &lt;code&gt;nix build&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;package &apos;helix-term&apos;&lt;/code&gt; This is the most direct confirmation of our ‚Äúhack‚Äù. It
tells us that our &lt;code&gt;default&lt;/code&gt; package is &lt;code&gt;helix-term&lt;/code&gt;. This confirms that our
&lt;code&gt;overrideAttrs&lt;/code&gt; in the &lt;code&gt;packages.${system}.default&lt;/code&gt; section successfully
targeted and modified the Helix editor package, which is internally named
&lt;code&gt;helix-term&lt;/code&gt; by the Helix flake.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;What This Does&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;overrideAttrs&lt;/code&gt; lets you change &lt;em&gt;only&lt;/em&gt; parts of the derivation without
rewriting everything.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;buildType = &quot;debug&quot;&lt;/code&gt; enables debug builds.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cargoBuildFlags&lt;/code&gt; adds extra features passed to Cargo, e.g.,
&lt;code&gt;--features tokio-console&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RUSTFLAGS&lt;/code&gt; gives you even more control over compiler behavior, optimization
levels, etc.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Run It&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix run
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or drop into the dev shell:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix develop
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;(assuming you also wire in a &lt;code&gt;devShells&lt;/code&gt; output)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Adding the &lt;code&gt;devShells&lt;/code&gt; output&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Since we already have the helix flake as an input to our own &lt;code&gt;flake.nix&lt;/code&gt; we can
now forward or extend Helix‚Äôs &lt;code&gt;devShells&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;outputs = { self, nixpkgs, helix, rust-overlay, ... }: {
  devShells = helix.devShells;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or if you want to pick a specific system:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;outputs = { self, nixpkgs, helix, rust-overlay ... }:
  let
    system = &quot;x86_64-linux&quot;;
  in {
    devShells.${system} = helix.devShells.${system};
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Optional: Combine with your own&lt;/strong&gt; &lt;code&gt;devShell&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;You can also extend or merge it with your own shell like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;outputs = { self, nixpkgs, helix, rust-overlay, ... }:
  let
    system = &quot;x86_64-linux&quot;;
    pkgs = import nixpkgs { inherit system; };
  in {
    devShells.${system} = {
      default = pkgs.mkShell {
        name = &quot;my-shell&quot;;
        inputsFrom = [ helix.devShells.${system}.default ];
        buildInputs = [ pkgs.git ];
      };
    };
  };
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><title>Intro to Nushell</title><id>https://saylesss88.github.io/intro_to_nushell_on_NixOS.html</id><updated>2025-11-30T00:00:00+00:00</updated><link href="https://saylesss88.github.io/intro_to_nushell_on_NixOS.html" rel="alternate"/><content type="html">&lt;h1&gt;Chapter 12&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;p&gt;&lt;img src=&quot;images/nu.png&quot; alt=&quot;Nu&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Intro to Nushell on NixOS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;:I recently switched default shells from zsh to nushell, this post is
about some of the challenges and advantages of using nushell with NixOS.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;While the average user might not immediately see significant advantages, those
who frequently work with structured data formats like JSON, YAML, and CSV ‚Äì
such as developers interacting with APIs, system administrators managing
configurations, and data professionals ‚Äì will likely find Nushell‚Äôs native
data handling and powerful pipeline capabilities a plus. Additionally, users
who value a more consistent and safer scripting experience might appreciate
Nushell‚Äôs language-first design and features like strong typing.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I‚Äôll start with some of the unique build design choices and unique features
that I think make Nushell special, then show an example using Nushell to
manipulate JSON data. Finally, I will highlight some of the visually appealing
aspects of Nushell and lastly I share some resources for learning more.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;The Good&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Nushell borrows concepts from many shells and languages and is itself both a
programming language and a shell. Because of this, it has its own way of
working with files, directories, websites, and more.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nushell is powerful and has many essential commands built directly into the
shell (‚Äúinternal‚Äù commands) rather than a link to an executable. You can use
this set of commands across different operating systems, having this
consistency is helpful when creating cross-platform code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When internal Nushell commands (like &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;sort-by&lt;/code&gt;,
etc.) produce output, they generally do so in Nushell‚Äôs structured data format
(tables or records). This is the shell‚Äôs native way of representing
information.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Beyond these foundational strengths, Nushell offers a range of unique features
that enhance its functionality and make it particularly well-suited for
data-heavy tasks. Here are some highlights that showcase its versatility.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Some Unique Features&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Besides the built-in commands, Nushell has a
&lt;a href=&quot;https://www.nushell.sh/book/standard_library.html&quot;&gt;standard library&lt;/a&gt; Nushell
operates on &lt;em&gt;structured data&lt;/em&gt;. You could call it a ‚Äúdata-first‚Äù shell and
programming language.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Also included, is a full-featured dataframe processing engine using
&lt;a href=&quot;https://github.com/pola-rs/polars&quot;&gt;Polars&lt;/a&gt; if you want to process large data
efficiently directly in your shell, check out the
&lt;a href=&quot;https://www.nushell.sh/book/dataframes.html&quot;&gt;Dataframes-Docs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Multi-Line Editing&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When writing a long command you can press Enter to add a newline and move to
the next line. For example:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;ls            |    # press enter
where name =~ |    # press enter, comments after pipe ok
get name      |    # press enter
mv ...$in ./backups/
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;This allows you to cycle through the entire multi-line command using the up
and down arrow keys and then customize different lines or sections of the
command.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You can manually insert a newline using &lt;code&gt;Alt+Enter&lt;/code&gt; or &lt;code&gt;Shift+Enter&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://www.nushell.sh/book/line_editor.html&quot;&gt;Reedline-Editor&lt;/a&gt; is
powerful and provides good &lt;code&gt;vi-mode&lt;/code&gt; or &lt;code&gt;emacs&lt;/code&gt; support built in.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It‚Äôs default &lt;code&gt;Ctrl+r&lt;/code&gt; history command is nice to work with out of the box.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://www.nushell.sh/book/explore.html#parameters&quot;&gt;explore&lt;/a&gt; command, is
nu‚Äôs version of a table pager, just like &lt;code&gt;less&lt;/code&gt; but for table structured data:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;$nu | explore --peek
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;With the above command you can navigate with vim keybinds or arrow keys.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;These features demonstrate Nushell‚Äôs user-friendly interface, but what truly
sets it apart is its underlying design as a structured data scripting
language. This ‚Äúlanguage-first‚Äù approach powers many of its distinctive
capabilities.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;images/explore.png&quot; alt=&quot;explore&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unique design&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Fundamentally designed as a structured data scripting language&lt;/strong&gt;: and then
it acts as a shell on top of that foundation. This ‚Äúlanguage first‚Äù approach
is what gives it many of its distinctive features and makes it a powerful
scripting language. I reiterate this here because of the implications of this.
A few of those features are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Pipelines of structured data&lt;/strong&gt;: Unlike traditional shells that primarily
deal with plain text streams, Nushell pipelines operate on tables of
structured data. Each command can understand and manipulate this structured
data directly.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Consistent syntax&lt;/strong&gt;: Its syntax is more consistent and predictable
compared to the often quirky syntax of Bash and Zsh, drawing inspiration
from other programming languages.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Strong typing&lt;/strong&gt; Nushell has a type system, which helps catch errors early
and allows for more robust scripting.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;First-class data types&lt;/strong&gt;: It treats various data formats (like JSON, CSV,
TOML) as native data types, making it easier to work with them. Because of
this, Nushell aims to replace the need for external tools like &lt;code&gt;jq&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;,
&lt;code&gt;sed&lt;/code&gt;, &lt;code&gt;cut&lt;/code&gt;, and even some uses of &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;curl&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Variables are Immutable by Default&lt;/strong&gt;: Nushell‚Äôs commands are based on a
functional-style of programming which requires immutability, sound familiar?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Nushell‚Äôs Environment is Scoped&lt;/strong&gt;: Nushell takes many design cues from
compiled languages, one is that languages should avoid global mutable state.
Shells have commonly used global mutation to update the environment, Nushell
attempts to steer clear of this increasing reproducability.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Single-use Environment Variables&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;FOO=BAR $env.FOO
# =&amp;gt; BAR
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Permanent Environment Variables&lt;/strong&gt;: In your &lt;code&gt;config.nu&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;# config.nu
$env.FOO = &apos;BAR&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nushell.sh/book/coming_from_bash.html&quot;&gt;Coming-From-Bash&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;These design principles make Nushell a powerful tool for scripting, but
they‚Äôre best understood through a hands-on example. Let‚Äôs see how Nushell‚Äôs
structured data capabilities shine in a common task: processing a JSON file.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;: I wanted to provide a practical example to illustrate some of these
‚ÄúGood‚Äù features in action. And break it down for better understanding.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Let‚Äôs consider a common task: processing data from a JSON file. Imagine you
have a file containing a list of users with their names and ages. With
traditional shells, you‚Äôd likely need to rely on external tools like &lt;code&gt;jq&lt;/code&gt; to
parse and filter this data. However, Nushell can handle this directly within
its own commands.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For this example you could create a &lt;code&gt;test&lt;/code&gt; directory and move to it:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir test ; cd test
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Create a &lt;code&gt;users.json&lt;/code&gt; with the following contents:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;üëá users.json&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;[
  { &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25 },
  { &quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 30 },
  { &quot;name&quot;: &quot;Charlie&quot;, &quot;age&quot;: 20 }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;And create the following &lt;code&gt;filter.nu&lt;/code&gt; that first converts &lt;code&gt;users.json&lt;/code&gt; into its
own internal structured data format with the &lt;code&gt;open&lt;/code&gt; command, then to filters
out people under &lt;code&gt;21&lt;/code&gt; with the &lt;code&gt;where&lt;/code&gt; control flow construct, then selects
the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; columns, sorts them by age, and finally converts them
back to &lt;code&gt;json&lt;/code&gt; and saves them to a file called &lt;code&gt;filtered_users.json&lt;/code&gt;. A lot
happening in a 6 line script.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;# filter.nu
open users.json           # Read JSON file into structured data
| where age &amp;gt; 21         # Filter users older than 21
| select name age        # Select only name and age columns
| sort-by age            # Sort by age
| to json                # Convert back to JSON
| save filtered_users.json # Save result to a new file
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;open&lt;/code&gt; command takes data from a file (or even a URL in some cases) and
parses it and converts it into Nushells own internal structured data format.
So this command isn‚Äôt just showing you the contents of &lt;code&gt;users.json&lt;/code&gt; but doing
a conversion to Nu‚Äôs special structured format.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;open users.json
‚ï≠‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ # ‚îÇ  name   ‚îÇ age ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 0 ‚îÇ Alice   ‚îÇ  25 ‚îÇ
‚îÇ 1 ‚îÇ Bob     ‚îÇ  30 ‚îÇ
‚îÇ 2 ‚îÇ Charlie ‚îÇ  20 ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;source&lt;/code&gt; command in Nushell is used to execute the commands within a
script file (like &lt;code&gt;filter.nu&lt;/code&gt;) in the current Nushell environment. It‚Äôs
similar to running the script directly in the shell, but keeps the shell open
for further use. In this example, &lt;code&gt;source filter.nu&lt;/code&gt; runs the commands inside
&lt;code&gt;filter.nu&lt;/code&gt;, processing the &lt;code&gt;users.json&lt;/code&gt; file and creating the
&lt;code&gt;filtered_users.json&lt;/code&gt; file:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;source filter.nu
# View the contents with bat
bat filtered_users.json
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       ‚îÇ File: filtered_users.json
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1   ‚îÇ [
   2   ‚îÇ   {
   3   ‚îÇ     &quot;name&quot;: &quot;Alice&quot;,
   4   ‚îÇ     &quot;age&quot;: 25
   5   ‚îÇ   },
   6   ‚îÇ   {
   7   ‚îÇ     &quot;name&quot;: &quot;Bob&quot;,
   8   ‚îÇ     &quot;age&quot;: 30
   9   ‚îÇ   }
  10   ‚îÇ ]
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;As you can see, without needing any external tools, Nushell was able to read,
filter, select, sort, and then re-serialize JSON data using a clear and
concise pipeline. This demonstrates its power in handling structured data
natively, making common data manipulation tasks within the shell significantly
more streamlined and readable compared to traditional approaches.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;In the filter.nu example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;# filter.nu
open users.json           # Read JSON file into structured data
| where age &amp;gt; 21         # Filter users older than 21
| select name age        # Select only name and age columns
| sort-by age            # Sort by age
| to json                # Convert back to JSON
| save filtered_users.json # Save result to a new file
&lt;/code&gt;&lt;/pre&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Summary of above Command (Click to Expand)&lt;/summary&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;open users.json&lt;/code&gt;: Produces a &lt;strong&gt;Nushell table&lt;/strong&gt; representing the data.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;| where age &amp;gt; 21&lt;/code&gt;: Receives the table, filters rows based on the &lt;code&gt;age&lt;/code&gt;
column, and outputs a new, filtered table.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;| select name age&lt;/code&gt;: Receives the filtered table, selects only the &lt;code&gt;name&lt;/code&gt; and
&lt;code&gt;age&lt;/code&gt; columns, and outputs a table with fewer columns.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;| sort-by age&lt;/code&gt;: Receives the table, sorts the rows based on the &lt;code&gt;age&lt;/code&gt;
column, and outputs a sorted table.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;| to json&lt;/code&gt;: Receives the sorted table and converts it back into JSON text.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;| save filtered_users.json&lt;/code&gt;: Receives the JSON text and saves it to a file.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;So, while the concept of piping is the same, the nature of the data flowing
through the Nushell pipeline is richer and more structured, enabling more
powerful and direct data manipulation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;While Nushell‚Äôs strengths, like its structured data pipelines, make it a
game-changer for many tasks, it‚Äôs not without its challenges, especially when
integrated with NixOS‚Äôs Bash-centric ecosystem. Let‚Äôs explore some of the
limitations you might encounter when adopting Nushell as your default shell.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;h3&gt;The Bad&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;While the project is still maturing, the active community and ongoing
improvements are promising. Don‚Äôt get too discouraged by the following, there
would be a bad section for any shell imo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There are many similarities so it can be easy to forget that some Bash (and
POSIX in general) style constructs just won‚Äôt work in Nushell. Considering
that NixOS seems to have been designed for bash, even Zsh isn‚Äôt fully
compatable you may want to think twice before you choose Nushell as your
default.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The documentation is incomplete and written by devs for devs imo, it is quite
a bit different from anything else I‚Äôve seen so there is a bit of a learning
curve. Nushell is generally still considered to be in a stage where it might
not be the most seamless or trouble-free experience as a daily driver default
shell for most users, especially on a system like NixOS known for its unique
approach.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/haslersn/any-nix-shell&quot;&gt;any-nix-shell&lt;/a&gt; project doesn‚Äôt
include Nushell as with many others because of it‚Äôs lack of maturity.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The following addition comes from Joey_McKur‚Äôs sugggestion, on mentioning the
&lt;code&gt;job&lt;/code&gt; command as one of the biggest criticisms against Nu because it doesn‚Äôt
support background tasks. I should also note that Nushell‚Äôs team is aware of
these criticisms and actively working on improving job control.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Limited Feature Set Compared to Traditional Job Control:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Lack of Full POSIX Job Control&lt;/strong&gt;: Nushell‚Äôs job control doesn‚Äôt yet fully
implement all the features and signals defined by POSIX job control (e.g.,
more nuanced signal handling, stopped jobs). While it covers the basics, users
accustomed to advanced Bash job control might find it lacking.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Foregrounding Behavior&lt;/strong&gt;: There have been criticisms about how foregrounding
jobs interacts with the terminal and potential issues with signal propagation.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Output Handling Challenges&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Interleaved Output&lt;/strong&gt;: Managing the output of multiple backgrounded jobs can
sometimes be messy, with output from different jobs potentially interleaving
in the terminal. While Nushell tries to handle this, it‚Äôs not always as clean
as desired.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Redirection Complexity&lt;/strong&gt;: Redirecting the input and output of backgrounded
jobs can be less straightforward than in Bash, sometimes requiring more
explicit handling.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Integration with Pipelines:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Backgrounding Pipelines&lt;/strong&gt;: Backgrounding complex pipelines with multiple
stages can sometimes lead to unexpected behavior or difficulties in managing
the entire pipeline as a single job.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Error Reporting:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Difficult to Track Errors in Background Jobs&lt;/strong&gt;: Identifying and debugging
errors in backgrounded jobs can be less direct than with foreground processes,
and the job command‚Äôs output might not always provide sufficient information
for troubleshooting.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Many of Nushell‚Äôs challenges stem from its departure from traditional shell
conventions, particularly those of Bash, which NixOS heavily relies on. To
better understand these differences and how they impact your workflow, let‚Äôs
compare Nushell‚Äôs static, structured approach to Bash‚Äôs dynamic, text-based
model.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Key Differences Between Nushell &amp;amp; Bash&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;Feature&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;Bash (Dynamic)&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;Nushell (Static)&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Code Execution&lt;/td&gt;&lt;td&gt;Line-by-line&lt;/td&gt;&lt;td&gt;Whole script parsed first&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Error Detection&lt;/td&gt;&lt;td&gt;Runtime errors only&lt;/td&gt;&lt;td&gt;Catches errors before running&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Support for &lt;code&gt;eval&lt;/code&gt;&lt;/td&gt;&lt;td&gt;‚úÖ Allowed&lt;/td&gt;&lt;td&gt;‚ùå Not supported&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Custom Parsing&lt;/td&gt;&lt;td&gt;Limited&lt;/td&gt;&lt;td&gt;Built-in semantic analysis&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;IDE Features&lt;/td&gt;&lt;td&gt;Basic syntax highlighting&lt;/td&gt;&lt;td&gt;Advanced integration, linting, and formatting&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; doesn‚Äôt work use &lt;code&gt;;&lt;/code&gt; instead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; is used as the greater-than operator for comparisons:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;&quot;hello&quot; | save output.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;is equivalent to the following in bash:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;echo &quot;hello&quot; &amp;gt; output.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;If you notice above the nushell command doesn‚Äôt require an &lt;code&gt;echo&lt;/code&gt; prefix, this
is because Nushell has &lt;strong&gt;Implicit Return&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;&quot;Hello, World&quot; == (echo &quot;Hello, World&quot;)
# =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The above example shows that the string, &lt;code&gt;&quot;Hello, World&quot;&lt;/code&gt; is equivalent to the
output value from &lt;code&gt;echo &quot;Hello, World&quot;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Every Command Returns a Value&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;let p = 7
print $p  # 7
$p * 6    # 42
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Understanding these differences highlights why Nushell feels so distinct from
Bash, but it‚Äôs the shell‚Äôs advanced features and integrations that truly make
it shine. Let‚Äôs dive into some of the beautiful and powerful tools and custom
commands that elevate Nushell for NixOS users.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;The Beautiful and Powerful&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ctrl+t&lt;/code&gt; List Commands with carapace and fzf:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/nu4.png&quot; alt=&quot;nu4&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Carapace&lt;/code&gt;
&lt;a href=&quot;https://carapace-sh.github.io/carapace-bin/install.html&quot;&gt;Carapace-Bin Install&lt;/a&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The folling is showing tab completion, I typed &lt;code&gt;hx fl&amp;lt;TAB&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/nu9.png&quot; alt=&quot;nu9&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Carapace&lt;/code&gt; man example:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/nu7.png&quot; alt=&quot;nu7&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Custom Nushell Commands&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Most of the following scripts come from the
&lt;a href=&quot;https://github.com/nushell/nu_scripts#&quot;&gt;nu_scripts repo&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The following command allows you to choose which input to update interactively
with fzf.&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to See Command&lt;/summary&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;# nix.nu
# upgrade system packages
# `nix-upgrade` or `nix-upgrade -i`
def nix-upgrade [
  flake_path: string = &quot;/home/jr/flake&quot;, # path that contains a flake.nix
  --interactive (-i) # select packages to upgrade interactively
]: nothing -&amp;gt; nothing {
  let working_path = $flake_path | path expand
  if not ($working_path | path exists) {
    echo &quot;path does not exist: $working_path&quot;
    exit 1
  }
  let pwd = $env.PWD
  cd $working_path
  if $interactive {
    let selections = nix flake metadata . --json
    | from json
    | get locks.nodes
    | columns
    | str join &quot;\n&quot;
    | fzf --multi --tmux center,20%
    | lines
    # Debug: Print selections to verify
    print $&quot;Selections: ($selections)&quot;
    # Check if selections is empty
    if ($selections | is-empty) {
      print &quot;No selections made.&quot;
      cd $pwd
      return
    }
    # Use spread operator to pass list items as separate arguments
    nix flake update ...$selections
  } else {
    nix flake update
  }
  cd $pwd
  nh os switch $working_path
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;nix-upgrade
# or for individual packages
nix-upgrade -i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/nu5.png&quot; alt=&quot;nu5&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;ns&lt;/code&gt; command is designed to search for Nix packages using &lt;code&gt;nix search&lt;/code&gt; and
present the results in a cleaner format, specifically removing the
architecture and operating system prefix that nix search often includes.&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click To Expand&lt;/summary&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;def ns [
    term: string # Search target.
] {

    let info = (
        sysctl -n kernel.arch kernel.ostype
        | lines
        | {arch: ($in.0|str downcase), ostype: ($in.1|str downcase)}
    )

    nix search --json nixpkgs $term
        | from json
        | transpose package description
        | flatten
        | select package description version
        | update package {|row| $row.package | str replace $&quot;legacyPackages.($info.arch)-($info.ostype).&quot; &quot;&quot;}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;ns fzf&amp;lt;ENTER&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/nu10.png&quot; alt=&quot;nu10&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nufetch&lt;/code&gt; command:&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click To Expand&lt;/summary&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;# `nufetch` `(nufetch).packages`
def nufetch [] {
{
&quot;kernel&quot;: $nu.os-info.kernel_version,
&quot;nu&quot;: $env.NU_VERSION,
&quot;packages&quot;: (ls /etc/profiles/per-user | select name | prepend [[name];
[&quot;/run/current-system/sw&quot;]] | each { insert &quot;number&quot; (nix path-info --recursive
 ($in | get name) | lines | length) | insert &quot;size&quot; ( nix path-info -S
 ($in | get name) | parse -r &apos;\s(.*)&apos; | get capture0.0 | into filesize) | update
 &quot;name&quot; ($in | get name | parse -r &apos;.*/(.*)&apos; | get capture0.0 | if $in == &quot;sw&quot;
 {&quot;system&quot;} else {$in}) | rename &quot;environment&quot;}),
&quot;uptime&quot;: (sys host).uptime
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;&lt;img src=&quot;images/nu1.png&quot; alt=&quot;nu1&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;duf&lt;/code&gt; command, I have mine aliased to &lt;code&gt;df&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;images/nu8.png&quot; alt=&quot;nu8&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ps&lt;/code&gt; command:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;images/ps.png&quot; alt=&quot;ps&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nix-list-system&lt;/code&gt; command lists all installed packages:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nu&quot;&gt;# list all installed packages
def nix-list-system []: nothing -&amp;gt; list&amp;lt;string&amp;gt; {
  ^nix-store -q --references /run/current-system/sw
  | lines
  | filter { not ($in | str ends-with &apos;man&apos;) }
  | each { $in | str replace -r &apos;^[^-]*-&apos; &apos;&apos; }
  | sort
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-list-system
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;images/nu6.png&quot; alt=&quot;nu6&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;These custom Nushell commands showcase its flexibility, but sometimes you need
to work around Nushell‚Äôs limitations, like compatability with certain NixOS
tools. This is where &lt;code&gt;just&lt;/code&gt; and &lt;code&gt;justfiles&lt;/code&gt; come in, simplifying complex
workflows and bridging gaps in Nushell‚Äôs functionality.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Using Just and Justfiles&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The following is my &lt;code&gt;justfile&lt;/code&gt; that I keep right next to my &lt;code&gt;flake.nix&lt;/code&gt; it
simplifies some commands and makes things work that weren‚Äôt working with
nushell for my case, you‚Äôll have to change it to match your configuration.
It‚Äôs not perfect but works for my use case, take whats useful and leave the
rest.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You‚Äôll first need to install &lt;a href=&quot;https://github.com/casey/just&quot;&gt;just&lt;/a&gt; to make use
of &lt;code&gt;justfiles&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# nix shell nixpkgs#just nixpkgs#nushell
set shell := [&quot;nu&quot;, &quot;-c&quot;]
flake_path := &quot;/home/jr/flake&quot;
hostname := &quot;magic&quot;
home_manager_output := &quot;jr@magic&quot;

utils_nu := absolute_path(&quot;utils.nu&quot;)

default:
    @just --list
# Rebuild
[group(&apos;nix&apos;)]
fr:
    nh os switch --hostname {{hostname}} {{flake_path}}

# Flake Update
[group(&apos;nix&apos;)]
fu:
    nh os switch  --hostname {{hostname}} --update {{flake_path}}

# Update specific input
# Usage: just upp nixpkgs
[group(&apos;nix&apos;)]
upp input:
    nix flake update {{input}}
# Test
[group(&apos;nix&apos;)]
ft:
    nh os test --hostname {{hostname}} {{flake_path}}
# Collect Garbage
[group(&apos;nix&apos;)]
ncg:
    nix-collect-garbage --delete-old ; sudo nix-collect-garbage -d ; sudo /run/current-system/bin/switch-to-configuration boot

[group(&apos;nix&apos;)]
cleanup:
    nh clean all

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;To list available commands type, (you must be in the same directory as the
justfile): &lt;code&gt;just&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;images/just2.png&quot; alt=&quot;just&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;So &lt;code&gt;just fmt&lt;/code&gt; will run &lt;code&gt;nix fmt&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A lot of the &lt;code&gt;.nu&lt;/code&gt; files came from this repo by BlindFS:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/blindFS/modern-dot-files/tree/main&quot;&gt;modern-dot-files&lt;/a&gt; he
uses Nix Darwin so there are a few changes for NixOS. I found this through
&lt;a href=&quot;https://github.com/nushell/this_week_in_nu&quot;&gt;this_week_in_nu&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/TSawyer87/flakes/tree/main/homeManagerModules/shells/nushell&quot;&gt;my-nu-config&lt;/a&gt;
If you use this, you‚Äôll need to change the first line of &lt;code&gt;fzf.nu&lt;/code&gt; to the
location of your config. You‚Äôll also need to change the constants at the top
of &lt;code&gt;config.nu&lt;/code&gt;. These are my old dotfiles, I have recently updated and made
sure this config is up to date with recent nushell changes. Also, change the
&lt;code&gt;let flake_path = ($env.HOME | path join &quot;flake&quot;)&lt;/code&gt; to your flake path.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The examples use this starship
config&lt;a href=&quot;https://github.com/Aylur/dotfiles/blob/main/home/starship.nix&quot;&gt;Aylur-dotfiles&lt;/a&gt;
The logic on the bottom enables starship for Nushell, Zsh, and Bash!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you wan‚Äôt to use my config you‚Äôll have to enable the experimental-feature
&lt;code&gt;pipe-operators&lt;/code&gt; in the same place you enable flakes and nix-command.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There are still situations where I need to switch to zsh or bash to get
something to work i.e. &lt;code&gt;nix-shell&lt;/code&gt; and a few others.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From custom commands to &lt;code&gt;justfile&lt;/code&gt; integrations, Nushell offers a wealth of
tools to enhance your NixOS experience, even if occasional workarounds are
needed. To dive deeper into Nushell and tailor it to your needs, here are some
valuable resources to explore, from official documentation to community-driven
configurations.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Resources&lt;/h4&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Resources &lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nushell.sh/book/&quot;&gt;Nushell-Book&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nushell.sh/cookbook/&quot;&gt;Nushell-Cookbook&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nushell/nu_scripts&quot;&gt;nu_scripts&lt;/a&gt; some of the custom
commands came from here.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nushell/nushell/tree/main/crates/nu-utils/src/default_files&quot;&gt;nushell sample-config&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nushell/awesome-nu#plugins&quot;&gt;awesome-nu repo&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nushell/showcase&quot;&gt;nu showcase-repo&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://discord.com/invite/NtAbbGn&quot;&gt;discord&lt;/a&gt; You can find custom commands,
configurations, etc here.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
</content></entry><entry><title>Git</title><id>https://saylesss88.github.io/vcs/git.html</id><updated>2025-11-30T00:00:00+00:00</updated><link href="https://saylesss88.github.io/vcs/git.html" rel="alternate"/><content type="html">&lt;h1&gt;Version Control with Git&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;!-- ![Git Logo](../images/git1.png) --&gt;
&lt;p&gt;‚ö†Ô∏è &lt;strong&gt;Important&lt;/strong&gt;: Never commit secrets (passwords, API keys, tokens, etc.) in
plain text to your Git repository. If you plan to publish your NixOS
configuration, always use a secrets management tool like sops-nix or agenix to
keep sensitive data safe. See the
&lt;a href=&quot;https://saylesss88.github.io/installation/enc/sops-nix.html&quot;&gt;Sops-Nix Guide&lt;/a&gt;
for details.&lt;/p&gt;
&lt;p&gt;It‚Äôs also important to understand that &lt;strong&gt;all files in the &lt;code&gt;/nix/store&lt;/code&gt; are
world-readable by default&lt;/strong&gt; This has important security implications for anyone
managing sensitive data on a NixOS system.&lt;/p&gt;
&lt;p&gt;What Does ‚ÄúWorld-Readable‚Äù Mean?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;All files in /nix/store are readable by any user on the system.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This is by design, the nix store is intended to be shared, immutable store of
all packages and configuration files.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Permissions are typically set to &lt;code&gt;r-xr-xr-x&lt;/code&gt;(read and execute for everyone)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Security Implications&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Never store secrets or sensitive data in plane text in the Nix store.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you include secrets directly in your configuration, they will end up in the
&lt;code&gt;/nix/store&lt;/code&gt; and be accessible to any user or process on the system.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This applies to files, environment variables, and any data embedded in
derivations.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Best Practices&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Always use a secrets management tool (like &lt;code&gt;sops-nix&lt;/code&gt; or &lt;code&gt;agenix&lt;/code&gt;) that
decrypts secrets at activation time and stores them outside the Nix store,
with restricted permissions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Do not embed secrets directly in Nix expressions or configuration files that
will be build into the store.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Even hashed passwords can be vulnerable when stored in a public repository, be
conscious of what you store where.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you‚Äôre unsure about what‚Äôs safe to share, start with a private repository.
This gives you time to learn about secrets management and review your
configuration before making anything public.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;First, I‚Äôll briefly explain some of the limitations of NixOS Rollbacks and then
I‚Äôll go into how Git compliments them.&lt;/p&gt;
&lt;h2&gt;Limitations of NixOS Rollbacks&lt;/h2&gt;
&lt;p&gt;NixOS is famous for its ability to roll back to previous system generations,
either from the boot menu or with commands like &lt;code&gt;nixos-rebuild --rollback&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When you perform rollbacks in NixOS, whether from the boot menu or using
commands like &lt;code&gt;nixos-rebuild --rollback&lt;/code&gt; only the contents and symlinks managed
by the Nix store are affected. The rollback works by switching which system
generation is active, atomically updating symlinks to point to the previous
version of all packages, &lt;code&gt;systemd&lt;/code&gt; units and services stored in &lt;code&gt;/nix/store&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, it‚Äôs important to understand what these rollbacks actually do and what
they don‚Äôt do. What NixOS Rollbacks Cover&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;System generations: When you rebuild your system, NixOS creates a new
‚Äúgeneration‚Äù that you can boot into or roll back to. This includes all
packages, services, and system configuration managed by Nix.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Quick recovery: If an upgrade breaks your system, you can easily select an
older generation at boot and get back to a working state&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Key Limitations&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Configuration files are not reverted&lt;/strong&gt;: Rolling back only changes which
system generation is active, it does not revert your actual configuration
files (like &lt;code&gt;configuration.nix&lt;/code&gt; or your flake files)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;User data and service data are not rolled back&lt;/strong&gt;: Only files managed by Nix
are affected. Databases, user files, and other persistent data remain
unchanged, which can cause problems if, for example, a service migrates its
database schema during an upgrade&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Manual changes persist&lt;/strong&gt;: Any manual edits to configuration files or system
state outside of Nix are not reverted by a rollback&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;How Git Helps&lt;/h2&gt;
&lt;!-- ![Git Logo 2](../images/git3.png) --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://docs.github.com/en/github-cli/github-cli/quickstart&quot;&gt;gh-cli&lt;/a&gt;,
simplifies quite a few things for working with GitHub from the command line.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Tracks every configuration change&lt;/strong&gt;: By version-controlling your NixOS
configs with Git, you can easily see what changed, when, and why.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;True config rollback&lt;/strong&gt;: If a configuration change causes issues, you can use
&lt;code&gt;git checkout&lt;/code&gt; or &lt;code&gt;git revert&lt;/code&gt; to restore your config files to a previous good
state, then rebuild your system&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Safer experimentation&lt;/strong&gt;: You can confidently try new settings or upgrades,
knowing you can roll back both your system state (with NixOS generations) and
your config files (with Git).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Collaboration and backup&lt;/strong&gt;: Git lets you share your setup, collaborate with
others, and restore your configuration if your machine is lost or damaged.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In summary: NixOS rollbacks are powerful for system state, but they don‚Äôt manage
your configuration file history. Git fills this gap, giving you full control and
traceability over your NixOS configs making your system both robust and truly
reproducible. Version control is a fundamental tool for anyone working with
NixOS, whether you‚Äôre customizing your desktop, managing servers, or sharing
your configuration with others. Git is the most popular version control system
and is used by the NixOS community to track, share, and back up system
configurations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Why use Git with NixOS?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Track every change&lt;/strong&gt;: Git lets you record every modification to your
configuration files, so you can always see what changed, when, and why.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Experiment safely&lt;/strong&gt;: Try new settings or packages without fear‚Äîif something
breaks, you can easily roll back to a previous working state.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sync across machines&lt;/strong&gt;: With Git, you can keep your NixOS setups in sync
between your laptop, desktop, or servers, and collaborate with others.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Disaster recovery&lt;/strong&gt;: Accidentally delete your config? With Git, you can
restore it from your repository in minutes.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Installing Git on NixOS&lt;/p&gt;
&lt;p&gt;You can install Git by adding it to your system packages in your
configuration.nix or via Home Manager:&lt;/p&gt;
&lt;h2&gt;Git Tips&lt;/h2&gt;
&lt;!-- ![Octocat](../images/octocat.png) --&gt;
&lt;p&gt;If you develop good git practices on your own repositories it will make it
easier to contribute with others as well as get help from others.&lt;/p&gt;
&lt;h2&gt;Atomic Commits&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Atomic commits&lt;/strong&gt; are a best practice in Git where each commit represents a
single, focused, and complete change to the codebase. The main characteristics
of atomic commits are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;One purpose&lt;/strong&gt;: Each commit should address only one logical change or task.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Complete&lt;/strong&gt;: The commit should leave the codebase in a working state.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Descriptive&lt;/strong&gt;: The commit message should be able to clearly summarize the
change in a single sentence.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Why Atomic Commits Matter&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Easier debugging&lt;/strong&gt;: You can use tools like &lt;code&gt;git bisect&lt;/code&gt; to quickly find
which commit introduced a bug, since each commit is isolated.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Simpler reverts&lt;/strong&gt;: You can revert without affecting unrelated changes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Better collaboration&lt;/strong&gt;: Code reviews and merges are more manageable when
changes are small and focused.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When you lump together a bunch of changes into a single commit it can lead to
quite a few undesirable consequences. They make it harder to track down bugs,
it‚Äôs more difficult to revert undesired changes without reverting desired ones,
make larger tickets harder to manage.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Every time a logical component is completed, commit it&lt;/strong&gt;. Smaller commits make
it easier for other devs and yourself to understand the changes and roll them
back if necessary. This also makes it easier to share your code with others to
get help when needed and makes merge conflicts less frequent and complex.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Finish the component, then commit it&lt;/strong&gt;: There‚Äôs really no reason to commit
unfinished work, use &lt;code&gt;git stash&lt;/code&gt; for unfinished work and &lt;code&gt;git commit&lt;/code&gt; for when
the logical component is complete. Use common sense and break complex components
into logical chunks that can be finished quickly to allow yourself to commit
more often.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Write Good Commit Messages&lt;/strong&gt;: Begin with a summary of your changes, add a line
of whitespace between the summary and the body of your message. Make it clear
why this change was necessary. Use consistent language with generated messages
from commands like &lt;code&gt;git merge&lt;/code&gt; which is imperative and present tense
(&lt;code&gt;&amp;lt;&amp;lt;change&amp;gt;&amp;gt;&lt;/code&gt;, not &lt;code&gt;&amp;lt;&amp;lt;changed&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;lt;changes&amp;gt;&amp;gt;&lt;/code&gt;).&lt;/p&gt;
&lt;h3&gt;Tips for Keeping Commits Atomic with a Linear History&lt;/h3&gt;
&lt;p&gt;Squashing limits the benefits of atomic commits as it combines them all into a
single commit as if you didn‚Äôt take the time to write them all out atomically.&lt;/p&gt;
&lt;p&gt;üß† Why Rebasing Wins for Linear History&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;No Merge Bubbles: Rebasing avoids those extra merge commits that clutter
&lt;code&gt;git log --graph&lt;/code&gt;. You get a clean, readable timeline.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Atomic Commit Integrity: Each commit stands alone and tells a story. Rebasing
preserves that narrative without diluting it with merge noise.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Better Blame &amp;amp; Bisect: Tools like git blame and git bisect work best when
history is linear and logical.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Time-Travel Simplicity: Cherry-picking or reverting is easier when commits
aren‚Äôt tangled in merge commits.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By default, when you run &lt;code&gt;git pull&lt;/code&gt; git merges the commits into your local repo.
To change this to a rebase you can set the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git config --global pull.rebase true
git config --global rebase.autoStash true
git config --global fetch.prune true  # auto delets remote-tracking branches that no longer exist
git config --global pull.ff only          # blocks merge pulls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note: With pull.ff only pulls will fail if they would have had to merge. This
could happen if your local branch has diverged from the remote (e.g., someone
pushed new commits and you also committed locally) &lt;code&gt;git pull&lt;/code&gt; will throw an
error like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;fatal: Not possible to fast-forward, aborting.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;How to fix it&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You basically do what Git won‚Äôt auto-do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git fetch origin
git rebase origin/main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This rewinds your local commits, applies remote commits, and replays yours on
top, keeping the history linear.&lt;/p&gt;
&lt;p&gt;If you don‚Äôt care about your local changes and want to discard them you can use
the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git reset --hard origin/main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This just makes your branch identical to the remote, no rebase required. This
prevents rogue merge commits, preserving atomic commits and linear logs.&lt;/p&gt;
&lt;p&gt;You could set an alias for this with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git config --global alias.grs &apos;!git fetch origin &amp;amp;&amp;amp; git rebase origin/main&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To check whether a setting is active or now you can use:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git config --get rebase.autoStash
true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To set these options with home-manager:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# ... snip ...
    extraConfig = lib.mkOption {
      type = lib.types.attrs;
      default = {
        commit.gpgsign = true;
        gpg.format = &quot;ssh&quot;;
        user.signingkey = &quot;/etc/ssh/ssh_host_ed25519_key.pub&quot;;
        extraConfig = {
          pull = {
            rebase = true;
            ff = &quot;only&quot;;
        };
        };
        rebase = {
          autoStash = true; # Auto stashes and unstashes local changes during rebase
        };
        fetch = {
          prune = true; # Automatically deletes remote-tracking branches that no longer exist
        };
# ... snip ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Time Travel in Git&lt;/h2&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Time Travel Section &lt;/summary&gt;
&lt;p&gt;&lt;strong&gt;View an old commit&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git checkout &amp;lt;commit_hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This puts you in a ‚Äúdetached HEAD‚Äù state, letting you explore code as it was at
that commit. To return, checkout your branch again.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Go back and keep history (revert)&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git revert &amp;lt;commit_hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Go back and rewrite history (reset)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Soft reset (keep changes staged):&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git reset --soft &amp;lt;commit_hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Mixed reset (keep changes in working directory):&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git reset &amp;lt;commit_hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Hard reset (discard all changes after the commit):&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git reset --hard &amp;lt;commit_hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Use the above command with caution, it can delete commits from history.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Relative time travel:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git reset --hard HEAD@{5.minutes.ago}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git reset --hard HEAD@{yesterday}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Create a branch from the past&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git checkout -b &amp;lt;new-brach&amp;gt; &amp;lt;commit_hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This starts a new branch from any previous commit, preserving current changes.&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;Some repositories have guidelines, such as Nixpkgs:&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Nixpkgs Commit Conventions &lt;/summary&gt;
&lt;p&gt;&lt;strong&gt;Commit conventions&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a commit for each logical unit.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check for unnecessary whitespace with &lt;code&gt;git diff --check&lt;/code&gt; before committing.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you have commits pkg-name: oh, forgot to insert whitespace: squash commits
in this case. Use &lt;code&gt;git rebase -i&lt;/code&gt;. See Squashing Commits for additional
information.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For consistency, there should not be a period at the end of the commit
message‚Äôs summary line (the first line of the commit message).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When adding yourself as maintainer in the same pull request, make a separate
commit with the message maintainers: &lt;code&gt;add &amp;lt;handle&amp;gt;&lt;/code&gt;. Add the commit before
those making changes to the package or module. See Nixpkgs Maintainers for
details.&lt;/p&gt;
&lt;p&gt;Make sure you read about any commit conventions specific to the area you‚Äôre
touching. See: Commit conventions for changes to &lt;code&gt;pkgs&lt;/code&gt;. Commit conventions
for changes to &lt;code&gt;lib&lt;/code&gt;. Commit conventions for changes to &lt;code&gt;nixos&lt;/code&gt;. Commit
conventions for changes to &lt;code&gt;doc&lt;/code&gt;, the Nixpkgs manual.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Writing good commit messages&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In addition to writing properly formatted commit messages, it‚Äôs important to
include relevant information so other developers can later understand why a
change was made. While this information usually can be found by digging code,
mailing list/Discourse archives, pull request discussions or upstream changes,
it may require a lot of work.&lt;/p&gt;
&lt;p&gt;Package version upgrades usually allow for simpler commit messages, including
attribute name, old and new version, as well as a reference to the relevant
release notes/changelog. Every once in a while a package upgrade requires more
extensive changes, and that subsequently warrants a more verbose message.&lt;/p&gt;
&lt;p&gt;Pull requests should not be squash merged in order to keep complete commit
messages and GPG signatures intact and must not be when the change doesn‚Äôt make
sense as a single commit.&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;A &lt;strong&gt;Git workflow&lt;/strong&gt; is a recipe or recommendation for how to use Git to
accomplish work in a consistent and productive manner. Having a defined workflow
lets you leverage Git effectively and consistently. This is especially important
when working on a team.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt; is the &lt;em&gt;default name&lt;/em&gt; (alias) for the &lt;strong&gt;remote repository&lt;/strong&gt; that your
&lt;strong&gt;local repository&lt;/strong&gt; is connected to, usually the one you cloned from.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remote Repositories&lt;/strong&gt; are versions of your project that are hosted on the
internet or network somewhere.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;When you run &lt;code&gt;git push origin main&lt;/code&gt;, you‚Äôre telling Git to push your changes
to the remote repo called &lt;code&gt;origin&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You can see which URL &lt;code&gt;origin&lt;/code&gt; points to with &lt;code&gt;git remote -v&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You can have multiple remotes (like &lt;code&gt;origin&lt;/code&gt;, &lt;code&gt;upstream&lt;/code&gt;, etc.) each pointing
to a different remote repo. Each of which is generally either read-only or
read/write for you. Collaborating involves managing these remotes and pushing
and pulling data to and from them when you need to share work.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ùó You can have a remote repo on your local machine. The word ‚Äúremote‚Äù doesn‚Äôt
imply that the repository is somewhere else, only that it‚Äôs elsewhere.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;The name &lt;code&gt;origin&lt;/code&gt; is just a convention, it‚Äôs not special. It is automatically
set when you clone a repo.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- ![git local remote](../images/git_local-remote.png) --&gt;
&lt;p&gt;&lt;strong&gt;Local&lt;/strong&gt; is your local copy of the repository, git tracks the differences
between &lt;strong&gt;local&lt;/strong&gt; and &lt;strong&gt;remote&lt;/strong&gt; which is a repo hosted elsewhere (e.g., GitHub
GitLab etc.)&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;Upstream&lt;/strong&gt; in Git typically refers to the original repository from which
your local repository or fork was derived. The &lt;strong&gt;Upstream&lt;/strong&gt; is the remote repo
that serves as the main source of truth, often the original project you forked
from. You typically fetch changes from upstream to update your local repo with
the latest updates from the original project, but you don‚Äôt push to upstream
unless you have write access.&lt;/p&gt;
&lt;h3&gt;A Basic Git Workflow&lt;/h3&gt;
&lt;!-- ![Git logo 3](../images/git2.png) --&gt;
&lt;ol&gt;
&lt;li&gt;Initialize your Repository:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you haven‚Äôt already created a Git repo in your NixOS config directory (for
example, in your flake or &lt;code&gt;/etc/nixos&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd ~/flake
git init
git add .
git commit -m &quot;Initial commit: NixOS Configuration&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Taking this initial snapshot with Git is a best practice‚Äîit captures the exact
state of your working configuration before you make any changes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The command &lt;code&gt;git add .&lt;/code&gt; stages all files in the directory (and its
subdirectories) for commit, meaning Git will keep track of them in your
project history.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The command &lt;code&gt;git commit -m &quot;message&quot;&lt;/code&gt; then saves a snapshot of these staged
files, along with your descriptive message, into the repository.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Think of a commit as a ‚Äúsave point‚Äù in your project. You can always go back
to this point if you need to, making it easy to experiment or recover from
mistakes. This two-step process, staging with &lt;code&gt;git add&lt;/code&gt; and saving with
&lt;code&gt;git commit&lt;/code&gt; is at the heart of how Git tracks and manages changes over
time.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- ![git commit add](../images/git-add-commit.png) --&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Make and Track Changes:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now that you‚Äôve saved a snapshot of your working configuration, you‚Äôre free to
experiment and try new things, even if they might break your setup.&lt;/p&gt;
&lt;p&gt;Suppose you want to try a new desktop environment, like Xfce. You edit your
&lt;code&gt;configuration.nix&lt;/code&gt; to add:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;services.xserver.desktopManager.xfce.enable = true;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You run:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nixos-rebuild switch # if configuration.nix is in /etc/nixos/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But something goes wrong: the system boots, but your desktop is broken or won‚Äôt
start. You decide to roll back using the boot menu or:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nixos-rebuild switch --rollback
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;What happens?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Your system reverts to the previous working generation in &lt;code&gt;/nix/store&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;But: Your &lt;code&gt;configuration.nix&lt;/code&gt; file is still changed, it still has the line
enabling Xfce. If you rebuild again, you‚Äôll get the same broken system,
because your config itself wasn‚Äôt rolled back.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;How does Git Help on Failure?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Git gives you quite a few options and ways to inspect what has been done.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Use &lt;code&gt;git status&lt;/code&gt; to see what‚Äôs changed, and &lt;code&gt;git checkout -- &amp;lt;file&amp;gt;&lt;/code&gt; to
restore any file to its last committed state.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Review your changes with &lt;code&gt;git diff&lt;/code&gt; to see exactly what you modified before
deciding whether to keep or revert those changes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reset everything with &lt;code&gt;git reset --hard HEAD&lt;/code&gt;, this will discard all local
changes and return to your last commit.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With Git you can simply run:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git checkout HEAD~1 configuration.nix
# or, if you committed before the change:
git revert &amp;lt;commit-hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Show the full hash of the latest commit:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git rev-parse HEAD
f53fef375d89496c0174e70ce94993d43335098e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Short hash:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git log --pretty=format:&apos;%h&apos; -n 1
f53fef3
git revert f53fef3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Show a list of Recent commits:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git log
# a list of all commits, with hashes, author, date, and message
git log --oneline
git log --oneline
f53fef3 (HEAD -&amp;gt; main) thunar
b34ea22 thunar
801cbcf thunar
5e72ba5 sops
8b67c59 sops
1a353cb sops
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can copy the commit hash from any of these and use it in commands like
&lt;code&gt;git checkout &amp;lt;hash&amp;gt;&lt;/code&gt; or &lt;code&gt;git revert &amp;lt;hash&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Commit successful experiments&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If your changes work, stage, and commit them:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git add .
# or more specifically the file you changed or created
git add configuration.nix
git commit -m &quot;Describe the new feature or fix&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Basic Branching&lt;/h3&gt;
&lt;p&gt;With Git you‚Äôre always on a branch and the default branch is &lt;code&gt;master&lt;/code&gt;. Many
change it to &lt;code&gt;main&lt;/code&gt; because of the suggestion Git gives you. I think people are
too easily offended these days, just keep this in mind that &lt;code&gt;main&lt;/code&gt; and &lt;code&gt;master&lt;/code&gt;
refer to the main development branch.&lt;/p&gt;
&lt;p&gt;You can get a listing of your current branches with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git branch
* (no branch)
  main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;*&lt;/code&gt; is next to the current branch and is where the &lt;code&gt;HEAD&lt;/code&gt; is currently
pointing. It says &lt;code&gt;(no branch)&lt;/code&gt; because I‚Äôm currently in detached &lt;code&gt;HEAD&lt;/code&gt; where
&lt;code&gt;HEAD&lt;/code&gt; points to no branch. The reason for this is because I‚Äôve been trying out
Jujutsu VCS and that‚Äôs JJ‚Äôs default setting, a detached &lt;code&gt;HEAD&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Git actually gives you a warning about working in a detached &lt;code&gt;HEAD&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;You are in &apos;detached HEAD&apos; state. You can make experimental
changes and commit them, and you can discard any commits you make
in this state without impacting any branch by switching back.

If you want to create a new branch to retain commits you create,
you can do so now (using &apos;git switch -c &amp;lt;new-branch-name&amp;gt;&apos;) or
later (using &apos;git branch &amp;lt;new-branch-name&amp;gt; &amp;lt;commit-id&amp;gt;&apos;).

See &apos;git help switch&apos; for details.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To attach the &lt;code&gt;HEAD&lt;/code&gt; (i.e., have the pointer pointing to a branch), use the
&lt;code&gt;git checkout&lt;/code&gt; command&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git checkout main
Switched to branch &apos;main&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git branch
* main
# Ensure that you have the latest &quot;tip&quot; from the remote repository `origin`
git fetch origin main
From github.com:sayls8/flake
 * branch            main       -&amp;gt; FETCH_HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although we‚Äôre working on our own repo and there is basically no chance of our
local branch diverging from our remote, it‚Äôs still good to get in the practice
of getting everything in sync before merging or rebasing etc.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git fetch&lt;/code&gt; doesn‚Äôt update &lt;code&gt;main&lt;/code&gt;, it just updates your references. To update
&lt;code&gt;main&lt;/code&gt; you would use &lt;code&gt;git pull origin/main&lt;/code&gt; or &lt;code&gt;git rebase origin/main&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;You can inspect your upstream branches with the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git remote show origin
* remote origin
  Fetch URL: git@github.com:saylesss88/flake.git
  Push  URL: git@github.com:saylesss88/flake.git
  HEAD branch: main
  Remote branch:
    main tracked
  Local ref configured for &apos;git push&apos;:
    main pushes to main (fast-forwardable)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;* branch     main      -&amp;gt; FETCH_HEAD&lt;/code&gt;: This line signifies that the &lt;code&gt;main&lt;/code&gt;
branch from the remote repository (likely &lt;code&gt;origin&lt;/code&gt;) was successfully fetched,
and the commit ID of its current tip (its latest commit) is now stored in your
local &lt;code&gt;FETCH_HEAD&lt;/code&gt; reference.&lt;/p&gt;
&lt;p&gt;Now that we know our local &lt;code&gt;main&lt;/code&gt; is up to date with our remote &lt;code&gt;origin/main&lt;/code&gt; we
can safely create a new feature branch:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git checkout -b feature/prose_wrap
Switched to a new branch &apos;feature/prose_wrap&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Right now the branch &lt;code&gt;feature/prose_wrap&lt;/code&gt; is exactly the same as &lt;code&gt;main&lt;/code&gt; and we
can safely make changes without affecting &lt;code&gt;main&lt;/code&gt;. We can try crazy or even
‚Äúdangerous‚Äù things and always be able to revert to a working state with
&lt;code&gt;git checkout main&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If our crazy idea works out, we can then merge our feature branch into &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ok the feature works, I‚Äôve added and committed the change. Now it‚Äôs time to
point the &lt;code&gt;HEAD&lt;/code&gt; to &lt;code&gt;main&lt;/code&gt; and then either merge or rebase the feature branch
into &lt;code&gt;main&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git checkout main
git fetch origin main
git merge feature/prose_wrap
Updating c8bd54c..b281f79
Fast-forward
 home/editors/helix/default.nix | 69 +++++++++++++++++++++++++++++++--------------------------------------
 1 file changed, 31 insertions(+), 38 deletions(-)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;‚Äúfast-forward‚Äù means that our &lt;code&gt;feature/prose_wrap&lt;/code&gt; branch was directly ahead
of the last commit on &lt;code&gt;main&lt;/code&gt;. When you merge one commit with another commit
that can be reached by following the first commits history, remember the
feature branch is exactly the same as &lt;code&gt;main&lt;/code&gt; until I made another commit. If
the branches diverged more and the history can‚Äôt be followed, Git will perform
a 3-way merge where it creates a new ‚Äúmerge commit‚Äù that combines the 2
changes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you have a bunch of branches and forget which have been merged yet use:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git branch --merged
feature/prose_wrap
* main
# OR to see branches that haven&apos;t been merged use:
git branch --no-merged
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It‚Äôs now safe to delete the feature branch:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git branch -d feature/prose_wrap
Deleted branch feature/prose_wrap (was b281f79)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ùó TIP: If your feature branch has a lot of sloppy commits that won‚Äôt be of
much benefit to anyone, squash them first then merge. The workflow would look
something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; # Make sure you&apos;re on the main branch
 git checkout main

 # Merge the feature branch with squash
 git merge --squash feature/prose_wrap
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This combines all the commits in your branch and adds them to your &lt;code&gt;main&lt;/code&gt;
staging area, it doesn‚Äôt move HEAD or create a merge commit for you. To
apply the changes into one big commit, finalize it with:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; git commit -m &quot;Add prose wrapping feature&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is often referred to as the ‚Äúsquash commit‚Äù.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Branching means to diverge from the main line of development and continue to do
work without risking messing up your main branch. There are a few commits on
your main branch so to visualize this it would look something like this, image
is from &lt;a href=&quot;https://git-scm.com/book/en/v2&quot;&gt;Pro Git&lt;/a&gt;:&lt;/p&gt;
&lt;!-- ![Git Branch 1](../images/git-branch3.png) --&gt;
&lt;h2&gt;Nix flake update example with branches&lt;/h2&gt;
&lt;p&gt;Let‚Äôs say you haven‚Äôt ran &lt;code&gt;nix flake update&lt;/code&gt; in a while and you don‚Äôt want to
introduce errors to your working configuration. To do so we can first, make sure
we don‚Äôt lose any changes on our main branch:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git add .
git commit -m &quot;Staging changes before switching branches&quot;
# I always like to make sure the configuration will build before pushing to git
sudo nixos-rebuild switch --flake .
# If everything builds and looks correct
git push origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OR, if you have incomplete changes that you don‚Äôt want to commit yet you can
stash them with &lt;code&gt;git stash&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git status
On branch main
Your branch is ahead of &apos;origin/main&apos; by 1 commit.
  (use &quot;git push&quot; to publish your local commits)

Changes not staged for commit:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
  (use &quot;git restore &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)
        modified:   home/git.nix

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we want to switch branches, without committing the incomplete changes to
&lt;code&gt;git.nix&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git stash
Saved working directory and index state WIP on main: 0e46d6b git: lol alias

git status
On branch main
Your branch is ahead of &apos;origin/main&apos; by 1 commit.
  (use &quot;git push&quot; to publish your local commits)

nothing to commit, working tree clean
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ùó &lt;code&gt;git stash&lt;/code&gt; is equivalent to &lt;code&gt;git stash push&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To see which stashes you have stored, use &lt;code&gt;git sash list&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git stash list
stash@{0}: WIP on main: 0e46d6b git: lol alias
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To apply the most recent stash:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git stash apply
git add home/git.nix
On branch main
Your branch is ahead of &apos;origin/main&apos; by 1 commit.
  (use &quot;git push&quot; to publish your local commits)

Changes not staged for commit:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
  (use &quot;git restore &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)
        modified:   home/git.nix

# or for multiple stashes
git stash apply stash@{2}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running &lt;code&gt;git stash apply&lt;/code&gt; applies the changes that were in your stash but
doesn‚Äôt automatically restage them, to apply the changes and stage them in one
command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git stash apply --index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let‚Äôs create our branch so we can safely update:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git checkout -b update-test
Switched to a new branch &apos;update-test&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-b&lt;/code&gt; is to switch to the branch that was just created&lt;/p&gt;
&lt;p&gt;Some may prefer a more descriptive branch name such as: &lt;code&gt;update/flake-inputs&lt;/code&gt;, I
kept it short for the example. Or if your company uses an issue tracker,
including the ticket number in the branch name can be helpful:
&lt;code&gt;update/123-flake-inputs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The above command is equivalent to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git branch update-test
git checkout update-test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;del&gt;Now our branches would look something like this, note how both branches
currently point to the same commit:&lt;/del&gt; I discovered that Git Book has pretty
restrictive licensing and will eventually find a replacement.&lt;/p&gt;
&lt;!-- ![Git Branch 2](../images/git-branch2.png) --&gt;
&lt;p&gt;Now, lets run our update:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix flake update
sudo nixos-rebuild test --flake .
# If everything looks ok let&apos;s try applying the changes
sudo nixos-rebuild switch --flake .
# And if everything looks ok:
git add .
git commit -m &quot;feat: Updated all flake inputs&quot;
git push origin update-test
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ùó This is the same workflow for commiting a PR. After you first fork and
clone the repo you want to work on, you then create a new feature branch and
push to that branch on your fork. This allows you to create a PR comparing
your changes to their existing configuration.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;del&gt;At this point our graph would look similar to the following&lt;/del&gt;:&lt;/p&gt;
&lt;!-- ![Git Branch 3](../images/git-branch1.png) --&gt;
&lt;p&gt;If we are satisfied, we can switch back to our &lt;code&gt;main&lt;/code&gt; branch and merge
&lt;code&gt;update-test&lt;/code&gt; into it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git checkout main
git merge origin/update-test
git branch -D update-test
sudo nixos-rebuild test --flake .
sudo nixos-rebuild switch --flake .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It‚Äôs good practice to delete a branch after you‚Äôve merged and are done with it.&lt;/p&gt;
&lt;h2&gt;Rebasing Branches&lt;/h2&gt;
&lt;p&gt;To combine two seperate branches into one unified history you typically use
&lt;code&gt;git merge&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt; takes two commit pointers and finds a common base commit between
them, it then creates a ‚Äúmerge commit‚Äù that combines the changes.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rebase&lt;/code&gt; is used to move a sequence of commits to a new base commit.&lt;/p&gt;
&lt;!-- ![Git rebase](../images/rebase.png) --&gt;
&lt;h2&gt;Configure Git Declaratively&lt;/h2&gt;
&lt;p&gt;The following example is the &lt;code&gt;git.nix&lt;/code&gt; from the hydenix project it shows some
custom options and a way to manage everything from a single location:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# git.nix from hydenix: declarative Git configuration for Home Manager
{ lib, config, ... }:

let
  cfg = config.hydenix.hm.git;
in
{

  options.hydenix.hm.git = {
    enable = lib.mkOption {
      type = lib.types.bool;
      default = config.hydenix.hm.enable;
      description = &quot;Enable git module&quot;;
    };

    name = lib.mkOption {
      type = lib.types.nullOr lib.types.str;
      default = null;
      description = &quot;Git user name&quot;;
    };

    email = lib.mkOption {
      type = lib.types.nullOr lib.types.str;
      default = null;
      description = &quot;Git user email&quot;;
    };
  };

  config = lib.mkIf cfg.enable {

    programs.git = {
      enable = true;
      userName = cfg.name;
      userEmail = cfg.email;
      extraConfig = {
        init.defaultBranch = &quot;main&quot;;
        pull.rebase = false;
      };
    };
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ùó You can easily change the name of the option, everything after &lt;code&gt;config.&lt;/code&gt; is
custom. So you could change it to for example, &lt;code&gt;config.custom.git&lt;/code&gt; and you
would enable it with &lt;code&gt;custom.git.enable = true;&lt;/code&gt; in your &lt;code&gt;home.nix&lt;/code&gt; or
equivalent.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Then he has a &lt;code&gt;hm/default.nix&lt;/code&gt; with the following to enable it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;#...snip...

 # hydenix home-manager options go here
  hydenix.hm = {
    #! Important options
    enable = true;
      git = {
        enable = true; # enable git module
        name = null; # git user name eg &quot;John Doe&quot;
        email = null; # git user email eg &quot;john.doe@example.com&quot;
      };
    }

    # ... snip ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can enable git, and set your git username as well as git email right here.&lt;/p&gt;
&lt;h3&gt;Resources&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/luismts/495d982e8c5b1a0ced4a57cf3d93cf60&quot;&gt;GitCommitBestPractices&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://git-scm.com/book/en/v2&quot;&gt;ProGit&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://ohshitgit.com/&quot;&gt;Oh shit Git&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><title>JJ VCS</title><id>https://saylesss88.github.io/vcs/jujutsu.html</id><updated>2025-11-30T00:00:00+00:00</updated><link href="https://saylesss88.github.io/vcs/jujutsu.html" rel="alternate"/><content type="html">&lt;h1&gt;Version Control with JJ&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;p&gt;&lt;img src=&quot;../images/jujutsu.png&quot; alt=&quot;JJ Logo&quot; /&gt;&lt;/p&gt;
&lt;div style=&quot;font-size: 0.8em; margin-top: 10px;&quot;&gt;
  **Image Source:** This image is from the [Jujutsu VCS repository](https://github.com/jj-vcs/jj) and is licensed under the Apache 2.0 License.
&lt;/div&gt;
&lt;p&gt;‚ö†Ô∏è &lt;strong&gt;Security Reminder&lt;/strong&gt;: Never commit secrets (passwords, API keys, tokens,
etc.) in plain text to your Git repository. If you plan to publish your NixOS
configuration, always use a secrets management tool like &lt;code&gt;sops-nix&lt;/code&gt; or &lt;code&gt;agenix&lt;/code&gt;
to keep sensitive data safe. See the
&lt;a href=&quot;https://saylesss88.github.io/installation/enc/sops-nix.html&quot;&gt;Sops-Nix Guide&lt;/a&gt;
for details.&lt;/p&gt;
&lt;h2&gt;Getting Started&lt;/h2&gt;
&lt;p&gt;Jujutsu (jj) is a modern, Git-compatible version control system designed to
simplify and improve the developer experience. It offers a new approach to
distributed version control, focusing on a more intuitive workflow, powerful
undo capabilities, and a branchless model that reduces common pitfalls of Git.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Recommended resources&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://steveklabnik.github.io/jujutsu-tutorial/&quot;&gt;Steve‚Äôs Jujutsu Tutorial&lt;/a&gt;
(most up to date). Steve does an excellent job explaining the ins and outs of
Jujutsu.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://zerowidth.com/2025/jj-tips-and-tricks/&quot;&gt;zerowidth jj-tips-and-tricks&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Official:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj help -k tutorial
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Every time you run a &lt;code&gt;jj&lt;/code&gt; command, it examines the working copy and takes a
snapshot.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Command help:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj &amp;lt;command&amp;gt; --help
jj git init --help
jj git push --help
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;üîë Key Concepts&lt;/h2&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Key Concepts &lt;/summary&gt;
&lt;ol&gt;
&lt;li&gt;Working Copy as Commit&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In JJ your working copy is always a real commit. Any changes you make are
automatically recorded in this working commit. The working copy is always
(&lt;code&gt;@&lt;/code&gt;) and the Parent commit is always &lt;code&gt;(@-)&lt;/code&gt; keep this in mind.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There is &lt;strong&gt;no staging area&lt;/strong&gt; (index) as in Git. You do not need to run
&lt;code&gt;git add&lt;/code&gt; or &lt;code&gt;git commit&lt;/code&gt; for every change. Modifications are always tracked
in the current commit.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Branchless Workflow and Bookmarks&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JJ does not have the concept of a ‚Äúcurrent branch.‚Äù Instead, use bookmarks,
which are named pointers to specific commits.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bookmarks do not move automatically. Commands like &lt;code&gt;jj new&lt;/code&gt; and &lt;code&gt;jj commit&lt;/code&gt;
move the working copy, but the bookmark stays were it was. Use
&lt;code&gt;jj bookmark move&lt;/code&gt; to move bookmarks. (e.g., &lt;code&gt;jj bookmark move main&lt;/code&gt;). You can
also use &lt;code&gt;jj bookmark set main -r @&lt;/code&gt; to explicitly set the main bookmark to
point at the working copy commit.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Only commits referenced by bookmarks are pushed to remotes, preventing
accidental sharing of unfinished work.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Automatic Tracking and Simpler Workflow&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Adding or removing files is automatically tracked, no need for explicit &lt;code&gt;add&lt;/code&gt;
or &lt;code&gt;rm&lt;/code&gt; commands.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The working copy acts as a live snapshot of your workspace. Commands first
sync filesystem changes into this commit, then perform the requested
operation, and finally update the working copy if needed.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Operation Log and Undo&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JJ records every operation (commits, merges, rebases, etc.) in an &lt;strong&gt;operation
log&lt;/strong&gt;. Inspect it with: &lt;code&gt;jj op log&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You can view and undo any previous operation, not just the most recent one,
making it easy to recover from mistakes, a feature not present in Git‚Äôs core
CLI.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;First-Class Conflict Handling&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Conflicts happen when JJ can‚Äôt figure out how to merge different changes made to
the same file.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Conflicts are stored inside commits, not just in the working directory. You
can resolve them at any time, not just during a merge or rebase.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Conflict markers are inserted directly into files, and JJ can reconstruct the
conflict state from these markers. You can resolve conflicts by editing the
files or using &lt;code&gt;jj resolve&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;Revsets and Filesets&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Revsets&lt;/strong&gt;: JJ‚Äôs powerful query language for selecting sets of commits,
inspired by Mercurial. For example, &lt;code&gt;jj log -r &quot;author(alice) &amp;amp; file(*.py)&quot;&lt;/code&gt;
lists all commits by Alice that touch Python files.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Filesets&lt;/strong&gt;:JJ supports a functional language for selecting sets of files,
allowing advanced file-based queries and operations.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style=&quot;text-align: left&quot;&gt;Feature&lt;/th&gt;&lt;th style=&quot;text-align: left&quot;&gt;Git&lt;/th&gt;&lt;th style=&quot;text-align: left&quot;&gt;Jujutsu (jj)&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;Staging Area&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Yes (git add/index)&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;No, working copy is always a commit&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;Commit Workflow&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Stage ‚Üí Commit&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;All changes auto-recorded in working commit&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;Branches&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Central to workflow&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Optional, bookmarks used for sharing&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;Undo/Redo&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Limited, complex&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Easy, operation log for undo&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;Conflict Handling&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Manual, can be confusing&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Conflicts tracked in commits, easier to fix&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;Integration with Git&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Native&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Fully compatible, can switch back anytime&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;Anonymous branches: In Git a branch is a pointer to a commit that needs a
name.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you haven‚Äôt taken the time to deep dive Git, it may be a good time to learn
about a new way of doing Version Control that is actually less complex and
easier to mentally map out in my opinion.&lt;/p&gt;
&lt;p&gt;Jujutsu is a new front-end to Git, and it‚Äôs a new design for distributed version
control. ‚Äìjj init&lt;/p&gt;
&lt;p&gt;You can use jujutsu (jj) with existing Git repositories with one command.
&lt;code&gt;jj git init --colocate&lt;/code&gt; or &lt;code&gt;jj git init --git-repo /path/to/git_repository&lt;/code&gt;.
The native repository format for jj is still a work in progress so people
typically use a &lt;code&gt;git&lt;/code&gt; repository for backend.&lt;/p&gt;
&lt;p&gt;Unlike &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt; has no index ‚Äústaging area‚Äù. It treats the working copy as an
actual commit. When you make changes to files, these changes are automatically
recorded to the working commit. There‚Äôs no need to explicitly stage changes
because they are already part of the commit that represents your current working
state.&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;&lt;strong&gt;Simplified Workflow&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Check where you‚Äôre at, JJ doesn‚Äôt care about commits without descriptions but
Git and GitHub do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj st
Working copy  (@) now at: zuknrzrx 8a20bfa7 (empty) (no description set)
Parent commit (@-)      : yzppulzo bdd64e8d main | (empty) &quot;Enable Rofi and update nu func for jj&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that the Working copy is &lt;code&gt;(empty)&lt;/code&gt; and has &lt;code&gt;(no description set)&lt;/code&gt;,
lets give it a description:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj desc -m &quot;My feature&quot;
# ...edit files...
# Check where we&apos;re at again
jj st
Working copy changes:
M home/jj.nix
Working copy  (@) : zuknrzrx bcd3d965 My feature
Parent commit (@-): yzppulzo bdd64e8d main | (empty) &quot;Enable Rofi and update nu func for jj&quot;

# Tell JJ which branch we&apos;re interested in
jj bookmark set main
# Push this change to main
jj git push
Changes to push to origin:
  Move forward bookmark main from bdd64e8d6ea5 to bcd3d96567f8
remote: Resolving deltas: 100% (3/3), completed with 3 local objects.
Warning: The working-copy commit in workspace &apos;default&apos; became immutable, so a new commit has been created on top of it.
Working copy  (@) now at: ktlywzlx 8e88ddbe (empty) (no description set)
Parent commit (@-)      : zuknrzrx bcd3d965 main | My feature
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;What is the Jujutsu Working Copy&lt;/h2&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click To Expand Working Copy Description &lt;/summary&gt;
&lt;p&gt;The &lt;strong&gt;working copy&lt;/strong&gt; in Jujutsu is an actual &lt;strong&gt;commit&lt;/strong&gt; that represents the
current state of the files you‚Äôre working on. Unlike Git, where the working copy
is separate from commits and changes must be explicitly staged and committed, in
JJ the working copy is a live commit that automatically records changes as you
modify files.&lt;/p&gt;
&lt;p&gt;Adding or removing files in the working copy implicitly tracks or untracks them
without needing explicit commands like &lt;code&gt;git add&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The working copy commit acts as a snapshot of your current workspace. When you
run commands, Jujutsu first syncs the filesystem changes into this commit, then
performs the requested operation, and finally updates the working copy if needed&lt;/p&gt;
&lt;p&gt;To finalize your current changes and start a new set of changes, you use the
&lt;code&gt;jj new&lt;/code&gt; command, which creates a new working-copy commit on top of the current
one. This replaces the traditional Git workflow of staging and committing
changes separately.&lt;/p&gt;
&lt;p&gt;Conflicts in the working copy are represented by inserting conflict markers
directly into the files. Jujutsu tracks the conflicting parts and can
reconstruct the conflict state from these markers. You resolve conflicts by
editing these markers and then committing the resolution in the working copy&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This means that you don‚Äôt need to worry about making a change, running
&lt;code&gt;git add .&lt;/code&gt;, running &lt;code&gt;git commit -m &quot;commit message&quot;&lt;/code&gt; because it‚Äôs already
done for you. This is handy with flakes by preventing a ‚Äúdirty working tree‚Äù
and can instantly be rebuilt after making a change.&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;h2&gt;Example JJ Module&lt;/h2&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand JJ home-manager module example &lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;For &lt;code&gt;lazygit&lt;/code&gt; fans, Nixpkgs has &lt;code&gt;lazyjj&lt;/code&gt;. I‚Äôve seen that it‚Äôs recommended to
use jj with &lt;code&gt;meld&lt;/code&gt;. I‚Äôll share my &lt;code&gt;jj.nix&lt;/code&gt; here for an example:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I got a lot of the aliases and such from the
&lt;a href=&quot;https://zerowidth.com/2025/jj-tips-and-tricks/&quot;&gt;zerowidth&lt;/a&gt; post, this has
been a game changer:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{
  lib,
  config,
  pkgs,
  # userVars ? {},
  #
  #
  #
  ...
}: let
  cfg = config.custom.jj;
in {
  options.custom.jj = {
    enable = lib.mkOption {
      type = lib.types.bool;
      default = true;
      description = &quot;Enable the Jujutsu (jj) module&quot;;
    };

    userName = lib.mkOption {
      type = lib.types.nullOr lib.types.str;
      default = &quot;sayls8&quot;;
      description = &quot;Jujutsu user name&quot;;
    };

    userEmail = lib.mkOption {
      type = lib.types.nullOr lib.types.str;
      default = &quot;sayls8@proton.me&quot;;
      description = &quot;Jujutsu user email&quot;;
    };

    packages = lib.mkOption {
      type = lib.types.listOf lib.types.package;
      default = with pkgs; [lazyjj meld];
      description = &quot;Additional Jujutsu-related packages to install&quot;;
    };

    settings = lib.mkOption {
      type = lib.types.attrs;
      default = {
        ui = {
          # default-command = &quot;log-recent&quot;;
          default-command = [&quot;status&quot; &quot;--no-pager&quot;];
          diff-editor = &quot;gitpatch&quot;;
          # diff-editor = [&quot;nvim&quot; &quot;-c&quot; &quot;DiffEditor&quot; &quot;$left&quot; &quot;$right&quot; &quot;$output&quot;];
          # diff-formatter = [&quot;meld&quot; &quot;$left&quot; &quot;$right&quot;];
          merge-editor = &quot;:builtin&quot;;
          conflict-marker-style = &quot;diff&quot;;
        };
        git = {
          # remove the need for `--allow-new` when pushing new bookmarks
          auto-local-bookmark = true;
          push-new-bookmarks = true;
        };
        revset-aliases = {
          &quot;closest_bookmark(to)&quot; = &quot;heads(::to &amp;amp; bookmarks())&quot;;
          &quot;immutable_heads()&quot; = &quot;builtin_immutable_heads() | remote_bookmarks()&quot;;
          # The following command is incorrect, TODO
          # &quot;default()&quot; = &quot;coalesce(trunk(),root())::present(@) | ancestors(visible_heads() &amp;amp; recent(), 2)&quot;;
          &quot;recent()&quot; = &quot;committer_date(after:&apos;1 month ago&apos;)&quot;;
          trunk = &quot;main@origin&quot;;
        };
        template-aliases = {
          &quot;format_short_change_id(id)&quot; = &quot;id.shortest()&quot;;
        };
        merge-tools.gitpatch = {
          program = &quot;sh&quot;;
          edit-args = [
            &quot;-c&quot;
            &apos;&apos;
              set -eu
              rm -f &quot;$right/JJ-INSTRUCTIONS&quot;
              git -C &quot;$left&quot; init -q
              git -C &quot;$left&quot; add -A
              git -C &quot;$left&quot; commit -q -m baseline --allow-empty
              mv &quot;$left/.git&quot; &quot;$right&quot;
              git -C &quot;$right&quot; add --intent-to-add -A
              git -C &quot;$right&quot; add -p
              git -C &quot;$right&quot; diff-index --quiet --cached HEAD &amp;amp;&amp;amp; { echo &quot;No changes done, aborting split.&quot;; exit 1; }
              git -C &quot;$right&quot; commit -q -m split
              git -C &quot;$right&quot; restore . # undo changes in modified files
              git -C &quot;$right&quot; reset .   # undo --intent-to-add
              git -C &quot;$right&quot; clean -q -df # remove untracked files
            &apos;&apos;
          ];
        };
        aliases = {
          c = [&quot;commit&quot;];
          ci = [&quot;commit&quot; &quot;--interactive&quot;];
          e = [&quot;edit&quot;];
          i = [&quot;git&quot; &quot;init&quot; &quot;--colocate&quot;];
          tug = [&quot;bookmark&quot; &quot;move&quot; &quot;--from&quot; &quot;closest_bookmark(@-)&quot; &quot;--to&quot; &quot;@-&quot;];
          log-recent = [&quot;log&quot; &quot;-r&quot; &quot;default() &amp;amp; recent()&quot;];
          nb = [&quot;bookmark&quot; &quot;create&quot; &quot;-r&quot; &quot;@-&quot;]; # new bookmark
          upmain = [&quot;bookmark&quot; &quot;set&quot; &quot;main&quot;];
          squash-desc = [&quot;squash&quot; &quot;::@&quot; &quot;-d&quot; &quot;@&quot;];
          rebase-main = [&quot;rebase&quot; &quot;-d&quot; &quot;main&quot;];
          amend = [&quot;describe&quot; &quot;-m&quot;];
          pushall = [&quot;git&quot; &quot;push&quot; &quot;--all&quot;];
          push = [&quot;git&quot; &quot;push&quot; &quot;--allow-new&quot;];
          pull = [&quot;git&quot; &quot;fetch&quot;];
          dmain = [&quot;diff&quot; &quot;-r&quot; &quot;main&quot;];
          l = [&quot;log&quot; &quot;-T&quot; &quot;builtin_log_compact&quot;];
          lf = [&quot;log&quot; &quot;-r&quot; &quot;all()&quot;];
          r = [&quot;rebase&quot;];
          s = [&quot;squash&quot;];
          si = [&quot;squash&quot; &quot;--interactive&quot;];
        };
        revsets = {
          # log = &quot;main@origin&quot;;
          # log = &quot;master@origin&quot;;
        };
      };
      description = &quot;Jujutsu configuration settings&quot;;
    };
  };

  config = lib.mkIf cfg.enable {
    home.packages = cfg.packages;

    programs.jujutsu = {
      enable = true;
      settings = lib.mergeAttrs cfg.settings {
        user = {
          name = cfg.userName;
          email = cfg.userEmail;
        };
      };
    };
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In my &lt;code&gt;home.nix&lt;/code&gt; I have this to enable it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;custom = {
    jj = {
        enable = true;
        userName = &quot;sayls8&quot;;
        userEmail = &quot;sayls8@proton.me&quot;;
        packages = &quot;&quot;;
    };
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;The &lt;code&gt;custom.jj&lt;/code&gt; module allows me to override the username, email, packages, and
whether jj is enabled from a single, centralized place within my Nix
configuration. So only if jj is enabled, &lt;code&gt;lazyjj&lt;/code&gt; and &lt;code&gt;meld&lt;/code&gt; will be installed.&lt;/p&gt;
&lt;p&gt;With the above &lt;code&gt;gitpatch&lt;/code&gt; setup, say you did more work than you want to commit
which is common with jj since it automatically tracks everything. I can now run:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj commit -i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And an interactive diff will come up allowing you to choose what to include in
the current commit. This also works for &lt;code&gt;jj split -i&lt;/code&gt; and &lt;code&gt;jj squash -i&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Example, using &lt;code&gt;jj commit -i&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/jj-gitpatch.png&quot; alt=&quot;jj commit -i&quot; /&gt;&lt;/p&gt;
&lt;p&gt;You can also use the &lt;code&gt;jj tug&lt;/code&gt; command to make pushing to a remote more
straightforward. Since JJ‚Äôs bookmarks don‚Äôt automatically move as they do with
Git, you can use &lt;code&gt;jj tug&lt;/code&gt; after you‚Äôve made a few commits to move the bookmark
that is closest to the parent commit of your current position to your current
commit:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj tug
jj git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;tug&lt;/code&gt; alias works for both the squash and edit workflows. After running
&lt;code&gt;jj tug&lt;/code&gt;, &lt;code&gt;jj git push&lt;/code&gt; should work. If you get an error saying no bookmarks to
move, you can run &lt;code&gt;jj new&lt;/code&gt; and then run &lt;code&gt;jj tug&lt;/code&gt;, this happens when the bookmark
is already at the parent commit.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# jj.nix
mb = [&quot;bookmark&quot; &quot;set&quot; &quot;-r&quot; &quot;@&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another option would be to run &lt;code&gt;jj mb main&lt;/code&gt; before running &lt;code&gt;jj git push&lt;/code&gt; in this
situation, but you will have to describe the commit first.&lt;/p&gt;
&lt;h2&gt;Issues I‚Äôve Noticed&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../images/jj2.png&quot; alt=&quot;jj tree&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I have run into a few issues, such as every flake command reloading every single
input every time. &lt;strong&gt;What I mean by this is what you see when you run a flake
command for the first time, it adds all of your flakes inputs.&lt;/strong&gt; I believe the
fix for this is deleting and regenerating your &lt;code&gt;flake.lock&lt;/code&gt;. The same thing can
happen when you move your flake from one location to another.&lt;/p&gt;
&lt;p&gt;JJ doesn‚Äôt seem to automatically track completely new files, running
&lt;code&gt;git add /file/path.nix&lt;/code&gt; enables JJ to start tracking the new file.&lt;/p&gt;
&lt;p&gt;That said, I recommend doing just that after running something like
&lt;code&gt;jj git init --colocate&lt;/code&gt;. Delete your &lt;code&gt;flake.lock&lt;/code&gt; and run &lt;code&gt;nix flake update&lt;/code&gt;,
&lt;code&gt;nix flake lock --recreate-lock-file&lt;/code&gt; still works but is being depreciated.&lt;/p&gt;
&lt;p&gt;Sometimes the auto staging doesn‚Äôt pick up the changes in your configuration so
rebuilding changes nothing, this has been more rare but happens occasionally.&lt;/p&gt;
&lt;p&gt;One of the most fundamental differences between Jujutsu and Git is how pushing
works. If you‚Äôre coming from Git, it‚Äôs important to understand this shift so you
don‚Äôt get tripped up by ‚Äúnothing happened‚Äù warnings or missing changes on your
remote.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In Git, you‚Äôre always ‚Äúon‚Äù a branch (e.g., &lt;code&gt;main&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When you make a commit, the branch pointer automatically moves forward.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git push&lt;/code&gt; pushes the current branch‚Äôs new commits to the remote.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you forget to switch branches, you might accidentally push to the wrong
place, but you rarely have to think about ‚Äúmoving‚Äù the branch pointer
yourself.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;The JJ Push Model&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JJ has no concept of a ‚Äúcurrrent branch‚Äù&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bookmarks &lt;strong&gt;do not&lt;/strong&gt; move automatically. When you make a new commit, the
bookmark (e.g., &lt;code&gt;main&lt;/code&gt;) stays where it was. You must explicitly move it to
your new commit with &lt;code&gt;jj bookmark set main&lt;/code&gt; (or create a new one).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JJ only pushes commits that are referenced by bookmarks. If your latest work
isn‚Äôt pointed to by a bookmark, &lt;code&gt;jj git push&lt;/code&gt; will do nothing and warn you.
This is to prevent accidental pushes and gives you more control over what gets
shared.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Typical JJ Push Workflow&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Check out where your working copy and Parent commit are, you will notice that
jj highlights the minimal amount of characters needed to reference this
change:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj st
Working copy changes:
M README.md
Working copy  (@) : mnkrokmt 7f0558f8 say hello and goodbye
Parent commit (@-): ywyvxrts 986d16f5 main | test3
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;We can see that &lt;code&gt;ywy&lt;/code&gt; is the &lt;code&gt;main&lt;/code&gt; branch so lets create our change on top of
that. We can also see that it‚Äôs (&lt;code&gt;@-&lt;/code&gt;), and this is actually what &lt;code&gt;main&lt;/code&gt; will
always be. Once I understood this everything came together.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj new @-
Working copy  (@) now at: kxwrsmmu bc7e8144 (empty) (no description set)
Parent commit (@-)      : ywyvxrts 986d16f5 main | test3
Added 0 files, modified 1 files, removed 0 files
jj desc @ -m &quot;Add a devShell&quot;
Working copy  (@) now at: kxwrsmmu eacafd73 (empty) Add a devShell
Parent commit (@-)      : ywyvxrts 986d16f5 main | test3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Being more explicit about your commands ensures both you and jj know where
everything should go. (i.e. &lt;code&gt;jj desc @ -m&lt;/code&gt; explicitly describes &lt;code&gt;@&lt;/code&gt;, the working
copy.) This will save you some headaches.&lt;/p&gt;
&lt;p&gt;Our new change, the Working copy is now built off of &lt;code&gt;main&lt;/code&gt;. The working copy
will always be (&lt;code&gt;@&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Make some changes&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj st
Working copy changes:
A dev/flake.lock
A dev/flake.nix
Working copy  (@) : kxwrsmmu 42b011cd Add a devShell
Parent commit (@-): ywyvxrts 986d16f5 main | test3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now I‚Äôm done, and since we built this change on top of &lt;code&gt;main&lt;/code&gt; the following
command will tell jj we know what we want to push:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj bookmark set main
jj git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you forget to move a bookmark, JJ will warn you and nothing will be pushed.
This is a safety feature, not a bug. That‚Äôs what the &lt;code&gt;mb&lt;/code&gt; alias does, moves the
bookmark to the working copy.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# home-manager alias (move bookmark)
mb = [&quot;bookmark&quot; &quot;set&quot; &quot;-r&quot; &quot;@&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you really have problems, &lt;code&gt;jj git push --change @&lt;/code&gt; explicitly pushes the
working copy.&lt;/p&gt;
&lt;p&gt;This is a bit different than Git and takes some getting used to but you don‚Äôt
need to move the bookmark after every commit, just when you want to push. I know
I‚Äôve made the mistake of pushing to the wrong branch before this should prevent
that.&lt;/p&gt;
&lt;h2&gt;Here‚Äôs an example of using JJ in an existing Git repo&lt;/h2&gt;
&lt;p&gt;Say I have my configuration flake in the &lt;code&gt;~/flakes/&lt;/code&gt; directory that is an
existing Git repository. To use JJ as the front-end I could do something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd ~/flakes
jj git init --colocate
Done importing changes from the underlying Git repo.
Setting the revset alias `trunk()` to `main@origin`
Initialized repo in &quot;.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;By default, JJ defines &lt;code&gt;trunk()&lt;/code&gt; as the main development branch of your remote
repository. This is usually set to &lt;code&gt;main@origin&lt;/code&gt;, but could be named something
else. This means that whenever you use &lt;code&gt;trunk()&lt;/code&gt; in JJ commands, it will
resolve to the latest commit on &lt;code&gt;main@origin&lt;/code&gt;. This makes it easier to refer
to the main branch in scripts and commands without hardcoding the branch name.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Bookmarks&lt;/strong&gt; in jj are named pointers to specific revisions, similar to
branches in Git. When you first run &lt;code&gt;jj git init --colocate&lt;/code&gt; in a git repo, you
will likely get a Hint saying ‚ÄúRun the following command to keep local bookmarks
updated on future pulls‚Äù.:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj bookmark list
track main@origin

jj st
The working copy has no changes.
Working copy  (@) : qzxomtxq 925eca75 (empty) (no description set)
Parent commit (@-): qnpnrklz bf291074 main | notes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This shows that running &lt;code&gt;jj git init --colocate&lt;/code&gt; automatically started tracking
&lt;code&gt;main&lt;/code&gt; in this case. If it doesn‚Äôt, use &lt;code&gt;jj bookmark track main@origin&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I‚Äôll create a simple change in the &lt;code&gt;README.md&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj st
Working copy changes:
M README.md
Working copy  (@) : qzxomtxq b963dff0 (no description set)
Parent commit (@-): qnpnrklz bf291074 main | notes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that the working copy now contains a modified file &lt;code&gt;M README.md&lt;/code&gt; and
has no description set. Lets give it a description before pushing to github.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj desc @ -m &quot;Added to README&quot;
jj bookmark set main -r @
Moved 1 bookmarks to pxwnopqo 1e6e08a2 main* | Added to README
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;jj bookmark set main -r @&lt;/code&gt; moves the &lt;code&gt;main&lt;/code&gt; bookmark to the current revision
(the working copy), which is the explicit, recommended way to update bookmarks
in JJ. Without this step, your bookmark will continue to point at the old
commit, not your latest work. This is a major difference from Git.&lt;/p&gt;
&lt;p&gt;And finally push to GitHub:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj git push
Changes to push to origin:
  Move forward bookmark main from bf291074125e to e2a75e45237b
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
Warning: The working-copy commit in workspace &apos;default&apos; became immutable, so a new commit has been created on top of it.
Working copy  (@) now at: pxwnopqo 8311444b (empty) (no description set)
Parent commit (@-)      : qzxomtxq e2a75e45 main | Added to README
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;Create a Repo without an existing Git Repo&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Or&lt;/strong&gt; to do this in a directory that isn‚Äôt already a git repo you can do
something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cargo new hello-world --vcs=none
cd hello-world
jj git init
Initialized repo in &quot;.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;JJ and Git Side by Side&lt;/h3&gt;
&lt;p&gt;Or for example, with Git if you wanted to move to a different branch before
running &lt;code&gt;nix flake update&lt;/code&gt; to see if it introduced errors before merging with
your main branch, you could do something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git checkout -b update-test

nix flake update

sudo nixos-rebuild test --flake .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you‚Äôre satisfied you can merge:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git checkout main
git add . # Stage the change
git commit -m &quot;update&quot;
git merge update-test
git branch -D update-test
sudo nixos-rebuild switch --flake .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With JJ a similar workflow could be:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Run &lt;code&gt;jj st&lt;/code&gt; to see what you have:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj st
The working copy has no changes.
Working copy  (@) : ttkstzzn 3f55c42c (empty) (no description set)
Parent commit (@-): wppknozq e3558ef5 main@origin | jj diff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don‚Äôt have a description set for the working copy set it now.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj desc @ -m &quot;enable vim&quot;
jj st
The working copy has no changes.
Working copy  (@) : ttkstzzn 63fda123 (empty) enable vim
Parent commit (@-): wppknozq e3558ef5 main@origin | jj diff
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Start from the working copy (which is mutable). The working copy in JJ is
itself a commit that you can edit and squash changes into. Since &lt;code&gt;main&lt;/code&gt; is
immutable, you can create your new change by working on top of the working
copy commit.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Create a new change off of the working copy:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj new @
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Make your edits:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj st
Working copy changes:
M home/editors/vim.nix
Working copy  (@) : qrsxltmt 494b5f18 (no description set)
Parent commit (@-): wytnnnto a07e775c (empty) enable vim
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Squash your changes into the new change:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj squash
The working copy has no changes.
Working copy  (@) : tmlwppnu ba06bb99 (empty) (no description set)
Parent commit (@-): wytnnnto 52928ed9 enable vim
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This moves your working copy changes into the new commit you just created.&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Describe the new change, this might feel weird but the &lt;code&gt;jj squash&lt;/code&gt; command
created a new commit that you have to describe again:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj desc @ -m &quot;Enabled Vim&quot;
Working copy  (@) : tmlwppnu 5c1569c3 (empty) Enabled Vim
Parent commit (@-): wytnnnto 52928ed9 enable vim
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;Set the bookmark to the Parent commit that was squashed into:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj bookmark set wyt
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;Finally Push to the remote repository:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj git push --allow-new
Changes to push to origin:
  Add bookmark wyt to 5c1569c35b22
remote: Resolving deltas: 100% (4/4), completed with 4 local objects.
remote:
remote: Create a pull request for &apos;wyt&apos; on GitHub by visiting:
remote:      https://github.com/sayls8/flake/pull/new/wyt
remote:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command does the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Uploads your bookmark and the associated commit to the remote repository
(e.g., GitHub).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the bookmark is new (not present on the remote), &lt;code&gt;--allow-new&lt;/code&gt; tells JJ
it‚Äôs okay to create it remotely.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;After pushing, GitHub (or your code host) will usually suggest creating a pull
request for your new branch/bookmark, allowing you or your collaborators to
review and merge the change into main.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Merging your Change into &lt;code&gt;main&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Option 1. Go to the URL suggested in the output, visit in this case:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;https://github.com/sayls8/flake/pull/new/wyt
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Click Create PR&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click Merge PR if it shows it can merge cleanly.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Option 2.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Switch to &lt;code&gt;main&lt;/code&gt; (if not already there):&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj bookmark set main
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Create a new change that combines the new change with &lt;code&gt;main&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj new tml wyt -m &quot;Merge: enable vim&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This creates a new commit with both &lt;code&gt;tml&lt;/code&gt; and &lt;code&gt;wyt&lt;/code&gt; as parents, which is how JJ
handles merges (since &lt;code&gt;jj merge&lt;/code&gt; depreciated). JJ merges are additive and
history-preserving by design especially for folks used to Git‚Äôs fast-forward and
squash options.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;With &lt;code&gt;jj&lt;/code&gt; you‚Äôre creating a new commit rather than a new branch.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Amending vs. Squashing: Git‚Äôs &lt;code&gt;git commit --amend&lt;/code&gt; updates the last commit.
&lt;code&gt;jj squash&lt;/code&gt; combines the current commit with its parent, effectively doing the
same thing in terms of history.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Merging: Git‚Äôs merge command is explicit. In &lt;code&gt;jj&lt;/code&gt;, the concept is similar, but
since there‚Äôs no branch, you‚Äôre ‚Äúmerging‚Äù by moving your working commit to
include these changes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No need to delete branches: Since there are no branches in &lt;code&gt;jj&lt;/code&gt;, there‚Äôs no
equivalent to &lt;code&gt;git branch -D&lt;/code&gt; to clean up. Instead commits that are no longer
needed can be ‚Äúabandoned‚Äù with &lt;code&gt;jj abandon&lt;/code&gt; if you want to clean up your
commit graph.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;jj describe&lt;/code&gt; without a flag just opens &lt;code&gt;$EDITOR&lt;/code&gt; where you can write your
commit message save and exit.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In &lt;code&gt;git&lt;/code&gt;, we finish a set of changes to our code by committing, but in &lt;code&gt;jj&lt;/code&gt; we
start new work by creating a change, and &lt;em&gt;then&lt;/em&gt; make changes to our code. It‚Äôs
more useful to write an initial description of your intended changes, and then
refine it as you work, than it is creating a commit message after the fact.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I have heard that jj can struggle with big repositories such as Nixpkgs and
have noticed some issues here and there when using with NixOS. I‚Äôm hoping that
as the project matures, it gets better on this front.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;The 2 main JJ Workflows&lt;/h2&gt;
&lt;h3&gt;The Squash Workflow&lt;/h3&gt;
&lt;p&gt;This workflow is the most similar to Git and Git‚Äôs index.&lt;/p&gt;
&lt;p&gt;The workflow:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Describe the work we want to do with &lt;code&gt;jj desc -m &quot;message&quot;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We create a new empty change on top of that one with &lt;code&gt;jj new&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When we are done with a feature, we run &lt;code&gt;jj squash&lt;/code&gt; to move the changes from
&lt;code&gt;@&lt;/code&gt; into the change we described in step 1. &lt;code&gt;@&lt;/code&gt; is where your working copy is
positioned currently.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For example, let‚Äôs say we just ran &lt;code&gt;jj git init --colocate&lt;/code&gt; in our configuration
Flake directory making it a &lt;code&gt;jj&lt;/code&gt; repo as well using git for backend.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd flake
jj git init --colocate
jj log
@  lnmmxwko sayls8@proton.me 2025-06-27 10:14:57 1eac6aa0
‚îÇ  (empty) (no description set)
‚óã  qnknltto sayls8@proton.me 2025-06-27 09:04:08 git_head() 5358483a
‚îÇ  (empty) jj
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above log output shows that running &lt;code&gt;jj git init&lt;/code&gt; creates an empty working
commit (&lt;code&gt;@&lt;/code&gt;) on top of the &lt;code&gt;git_head()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj desc -m &quot;Switch from nixVim to NVF&quot;
jj new  # Create a new empty change
jj log
@  nmnmznmm sayls8@proton.me 2025-06-27 10:16:30 52dd7ee0
‚îÇ  (empty) (no description set)
‚óã  lnmmxwko sayls8@proton.me 2025-06-27 10:16:24 git_head() 3e8f9f3a
‚îÇ  (empty) Switch from nixVim to NVF
‚óã  qnknltto sayls8@proton.me 2025-06-27 09:04:08 5358483a
‚îÇ  (empty) jj
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above log shows that running &lt;code&gt;jj desc&lt;/code&gt; changes the current (&lt;code&gt;@&lt;/code&gt;) commits
description, and then &lt;code&gt;jj new&lt;/code&gt; creates a new empty commit on top of it, moving
(&lt;code&gt;@&lt;/code&gt;) to this new empty commit.&lt;/p&gt;
&lt;p&gt;The ‚ÄúSwitch from nixVim to NVF‚Äù commit is now the parent of (&lt;code&gt;@&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Now, we‚Äôd make the necessary changes and to add them to the commit we just
described in the previous steps.&lt;/p&gt;
&lt;p&gt;The changes are automatically ‚Äústaged‚Äù so theres no need to &lt;code&gt;git add&lt;/code&gt; them, so
we just make the changes and squash them.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj squash  # Squash the commit into its parent commit (i.e., our named commit)
jj log
@  zsxsolsq sayls8@proton.me 2025-06-27 10:18:01 2c35d83f
‚îÇ  (empty) (no description set)
‚óã  lnmmxwko sayls8@proton.me 2025-06-27 10:18:01 git_head() 485eaee9
‚îÇ  (empty) Switch from nixVim to NVF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This shows &lt;code&gt;jj squashes&lt;/code&gt; effect, it merges the changes from the current (&lt;code&gt;@&lt;/code&gt;)
commit into its parent. The (&lt;code&gt;@&lt;/code&gt;) then moves to this modified parent, and a new
empty commit is created on top, ready for the next set of changes.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nixos-rebuild switch --flake .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We‚Äôre still in the nameless commit and can either continue working or run
&lt;code&gt;jj desc -m &quot;&quot;&lt;/code&gt; again describing our new change, then &lt;code&gt;jj new&lt;/code&gt; and &lt;code&gt;jj squash&lt;/code&gt;
it‚Äôs pretty simple. The nameless commit is used as an adhoc staging area.&lt;/p&gt;
&lt;p&gt;When you are ready to push, it‚Äôs important to know where your working copy
currently is and if it‚Äôs attached to a bookmark. It‚Äôs common for &lt;code&gt;jj new&lt;/code&gt; to
detach the head, all you have to do is tell JJ which branch to attach to, then
push:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj st
Working copy changes:
M hosts/magic/configuration.nix
M hosts/magic/container.nix
Working copy  (@) : youptvvn 988e6fc9 (no description set)
Parent commit (@-): qlwqromx 4bb754fa mdbook container
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above output means that the working copy has modifications (&lt;code&gt;M&lt;/code&gt;) in two
files. And these changes are not yet committed.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj bookmark set main
jj git push
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;The Edit Workflow&lt;/h3&gt;
&lt;p&gt;This workflow adds a few new commands &lt;code&gt;jj edit&lt;/code&gt;, and &lt;code&gt;jj next&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here‚Äôs the workflow:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Create a new change to work on the new feature with &lt;code&gt;jj new&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If everything works exactly as planned, we‚Äôre done.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If we realize we want to break this big change up into multiple smaller ones,
we do it by making a new change before the current one, swapping to it, and
making the necessary change.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lastly, we go back to the main change.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The squash workflow leaves &lt;code&gt;@&lt;/code&gt; at an empty undescribed change, with this
workflow, &lt;code&gt;@&lt;/code&gt; will often be on the existing change.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;@&lt;/code&gt; wasn‚Äôt at an empty change, we would start this workflow with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj new -m &quot;Switch from NVF to nixVim&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;since our &lt;code&gt;@&lt;/code&gt; is already at an empty change, we‚Äôll just describe it and get
started:&lt;/p&gt;
&lt;p&gt;For this example, lets say we want to revert back to nixVim:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj desc -m &quot;Switch from NVF to nixVim&quot;
jj log
@  zsxsolsq sayls8@proton.me 2025-06-27 10:18:47 606abaa7
‚îÇ  (empty) Switch from NVF to nixVim
‚óã  lnmmxwko sayls8@proton.me 2025-06-27 10:18:01 git_head() 485eaee9
‚îÇ  (empty) Switch from nixVim to NVF
‚óã  qnknltto sayls8@proton.me 2025-06-27 09:04:08 5358483a
‚îÇ  (empty) jj
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, this shows &lt;code&gt;jj desc&lt;/code&gt; renaming the current empty &lt;code&gt;@&lt;/code&gt; commit.&lt;/p&gt;
&lt;p&gt;We make the changes, and it‚Äôs pretty straightforward so we‚Äôre done, every change
is automatically staged so we can just run &lt;code&gt;sudo nixos-rebuild switch --flake .&lt;/code&gt;
now to apply the changes.&lt;/p&gt;
&lt;p&gt;If we wanted to make more changes that aren‚Äôt described we can use &lt;code&gt;jj new -B&lt;/code&gt;
which is similar to &lt;code&gt;git add -a&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj new -B @ -m &quot;Adding LSP to nixVim&quot;
Rebased 1 descendant commits
Working copy  (@) now at: lpnxxxpo bf929946 (empty) Adding LSP to nixVim
Parent commit (@-)      : lnmmxwko 485eaee9 (empty) Switch from nixVim to NVF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;-B&lt;/code&gt; tells jj to create the new change &lt;em&gt;before&lt;/em&gt; the current one and it
creates a rebase. We created a change before the one we‚Äôre on, it automatically
rebased our original change. This operation will &lt;em&gt;always&lt;/em&gt; succeed with jj, we
will have our working copy at the commit we‚Äôve just inserted.&lt;/p&gt;
&lt;p&gt;You can see below that &lt;code&gt;@&lt;/code&gt; moved down one commit:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj log
‚óã  zsxsolsq sayls8@proton.me 2025-06-27 10:22:03 ad0713b6
‚îÇ  (empty) Switch from NVF to nixVim
@  lpnxxxpo sayls8@proton.me 2025-06-27 10:22:03 bf929946
‚îÇ  (empty) Adding LSP to nixVim
‚óã  lnmmxwko sayls8@proton.me 2025-06-27 10:18:01 git_head() 485eaee9
‚îÇ  (empty) Switch from nixVim to NVF
‚óã  qnknltto sayls8@proton.me 2025-06-27 09:04:08 5358483a
‚îÇ  (empty) jj
‚óã  qnknltto sayls8@proton.me 2025-06-27 09:04:08 git_head()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The ‚ÄúAdding LSP to nixVim‚Äù commit is directly above ‚ÄúSwitch from nixVim to NVF‚Äù
(the old &lt;code&gt;git_head()&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;The ‚ÄúSwitch from NVF to nixVim‚Äù commit (which was your &lt;code&gt;@&lt;/code&gt; before &lt;code&gt;jj new -B&lt;/code&gt;)
is now above ‚ÄúAdding LSP to nixVim‚Äù in the log output, meaning ‚ÄúAdding LSP to
nixVim‚Äù is its new parent.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@&lt;/code&gt; has moved to ‚ÄúAdding LSP to nixVim‚Äù&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jj log&lt;/code&gt; example output&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Operation Log and Undo&lt;/h2&gt;
&lt;p&gt;JJ records every operation (commits, merges, rebases, etc.) in an operation log.
You can view and undo previous operations, making it easy to recover from
mistakes, a feature not present in Git‚Äôs core CLI&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj op log
@  fbf6e626df22 jr@magic 15 minutes ago, lasted 9 milliseconds
‚îÇ  new empty commit
‚îÇ  args: jj new -B @ -m &apos;Adding LSP to nixVim&apos;
‚óã  bde40b7c17cf jr@magic 19 minutes ago, lasted 8 milliseconds
‚îÇ  describe commit 2c35d83f75031dc582bf28b64d4af1c218177f90
‚îÇ  args: jj desc -m &apos;Switch from NVF to nixVim&apos;
‚óã  3a2bfe1c0b0a jr@magic 19 minutes ago, lasted 8 milliseconds
‚îÇ  squash commits into 3e8f9f3a6a58fef86906e16e9b4375afb43e73e3
‚îÇ  args: jj squash
‚óã  80abcb58dcb6 jr@magic 21 minutes ago, lasted 8 milliseconds
‚îÇ  new empty commit
‚îÇ  args: jj new
‚óã  8c80314cbcd7 jr@magic 21 minutes ago, lasted 8 milliseconds
‚îÇ  describe commit 1eac6aa0b88ba014785ee9c1c2ad6e2abc6206e9
‚îÇ  args: jj desc -m &apos;Switch from nixVim to NVF&apos;
‚óã  44b5789cb4d1 jr@magic 22 minutes ago, lasted 6 milliseconds
‚îÇ  track remote bookmark main@origin
‚îÇ  args: jj bookmark track main@origin
‚óã  dbefee04aa85 jr@magic 23 minutes ago, lasted 4 milliseconds
‚îÇ  import git head
‚îÇ  args: jj git init --git-repo .
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj op undo &amp;lt;operation-id&amp;gt;
# or
jj op restore &amp;lt;operation-id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;Conflict Resolution&lt;/h2&gt;
&lt;p&gt;In JJ, conflicts live inside commits and can be resolved at any time, not just
during a merge. This makes rebasing and history editing safer and more flexible&lt;/p&gt;
&lt;p&gt;JJ treats conflicts as first-class citizens: conflicts can exist inside commits,
not just in the working directory. This means if a merge or rebase introduces a
conflict, the conflicted state is saved in the commit itself, and you can
resolve it at any time there‚Äôs no need to resolve conflicts immediately or use
‚Äú&lt;code&gt;--continue&lt;/code&gt;‚Äù commands as in Git&lt;/p&gt;
&lt;p&gt;Here‚Äôs how it works:&lt;/p&gt;
&lt;p&gt;When you check out or create a commit with conflicts, JJ materializes the
conflicts as markers in your files (similar to Git‚Äôs conflict markers)&lt;/p&gt;
&lt;p&gt;You can resolve conflicts by editing the files to remove the markers, or by
using:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj resolve
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;Revsets&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://jj-vcs.github.io/jj/latest/revsets/&quot;&gt;Jujutsu Revsets&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JJ includes a powerful query language for selecting commits. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jj log -r &quot;author(alice) &amp;amp; file(*.py)&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command lists all commits by Alice that touch Python files.&lt;/p&gt;
&lt;h2&gt;Filesets&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://jj-vcs.github.io/jj/latest/filesets/&quot;&gt;Jujutsu Filesets&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Jujutsu supports a functional language for selecting a set of files. Expressions
in this language are called ‚Äúfilesets‚Äù (the idea comes from Mercurial). The
language consists of file patterns, operators, and functions. ‚ÄìJJ Docs&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Jujutsu (jj) offers a streamlined, branchless, and undo-friendly approach to
version control, fully compatible with Git but designed to be easier to use and
reason about. Its workflows, operation log, and conflict handling provide a
safer and more flexible environment for managing code changes, making it a
compelling alternative for both new and experienced developers.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Resources&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://steveklabnik.github.io/jujutsu-tutorial/&quot;&gt;steves_jj_tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jj-vcs/jj&quot;&gt;jj_github&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://jj-vcs.github.io/jj/latest/tutorial/&quot;&gt;official_tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://v5.chriskrycho.com/essays/jj-init/&quot;&gt;jj_init&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><title>Functions and NixOS Modules</title><id>https://saylesss88.github.io/functions/functions_and_modules_2.2.html</id><updated>2025-11-30T00:00:00+00:00</updated><link href="https://saylesss88.github.io/functions/functions_and_modules_2.2.html" rel="alternate"/><content type="html">&lt;h1&gt;Functions and NixOS Modules&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;p&gt;When you start exploring NixOS configurations or tools like Home Manager, you‚Äôll
encounter a concept called Nix Modules. Modules are also functions, but they
behave differently regarding their arguments, which can be a source of
confusion.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What are NixOS Modules&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;Nix Modules are a powerful system built on top of basic Nix functions, primarily
used for declarative system configurations (like NixOS, Home Manager, NixOps,
etc.). They allow you to define parts of your system configuration in separate
files that are then composed together.&lt;/p&gt;
&lt;p&gt;Each module is typically a Nix function that returns an attribute set with
specific keys like &lt;code&gt;options&lt;/code&gt;, &lt;code&gt;config&lt;/code&gt;, and &lt;code&gt;imports&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Automatic Arguments in Modules&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Unlike the functions we‚Äôve been writing, Nix‚Äôs module system automatically
passes a standard set of arguments to every module function it evaluates. You
don‚Äôt explicitly pass these arguments when you &lt;code&gt;import&lt;/code&gt; a module file; the
module system handles it for you.&lt;/p&gt;
&lt;p&gt;The most common automatic arguments you‚Äôll see are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;config&lt;/code&gt;: The aggregated configuration options of all modules combined. This
is what you use to read other configuration values.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;options&lt;/code&gt;: The definitions of all available configuration options across all
modules.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;pkgs&lt;/code&gt;: The standard Nixpkgs set, equivalent to &lt;code&gt;import &amp;lt;nixpkgs&amp;gt; {}&lt;/code&gt;. This is
incredibly convenient as you don‚Äôt need to import it in every module.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;lib&lt;/code&gt;: The Nixpkgs utility library (&lt;code&gt;pkgs.lib&lt;/code&gt;), providing helper functions
for common tasks.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;specialArgs&lt;/code&gt;: An attribute set of extra arguments to be passed to the module
functions.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A typical module might start like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# Example NixOS module
{ config, pkgs, lib, ... }: # These arguments are passed automatically by the module system
{
  # ... module options and configuration
  environment.systemPackages = [ pkgs.firefox pkgs.git ];
  services.nginx.enable = true;
  # ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above module, the only required argument is &lt;code&gt;pkgs&lt;/code&gt; because we explicitly
use it in the module (i.e. &lt;code&gt;pkgs.firefox&lt;/code&gt;). Editors have pretty good support for
letting you know if you‚Äôre missing arguments or have unnecessary ones. &lt;code&gt;config&lt;/code&gt;,
and &lt;code&gt;lib&lt;/code&gt; and would be required if we were setting any options in this module.&lt;/p&gt;
&lt;p&gt;This automatic passing of arguments is a core feature of the module system that
simplifies writing configurations, as you always have access to &lt;code&gt;pkgs&lt;/code&gt;, &lt;code&gt;lib&lt;/code&gt;,
and the evolving &lt;code&gt;config&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; without boilerplate.&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;specialArgs&lt;/code&gt;: Passing Custom Arguments to Modules&lt;/h4&gt;
&lt;p&gt;While the module system passes a standard set of arguments automatically, what
if you need to pass additional, custom data to your modules that isn‚Äôt part of
the standard &lt;code&gt;config&lt;/code&gt;, &lt;code&gt;pkgs&lt;/code&gt;, &lt;code&gt;lib&lt;/code&gt;, or &lt;code&gt;options&lt;/code&gt;? This is where &lt;code&gt;specialArgs&lt;/code&gt;
comes in.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;specialArgs&lt;/code&gt; is an attribute you can pass to the &lt;code&gt;import&lt;/code&gt; function when you
load a module (or a set of modules). It‚Äôs typically used to provide data that
your modules need but isn‚Äôt something Nixpkgs would normally manage.&lt;/p&gt;
&lt;p&gt;For example, in a &lt;code&gt;configuration.nix&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# From your configuration.nix
{ config, pkgs, lib, ... }: # Standard module arguments

let
  myCustomValue = &quot;helloWorld&quot;;
in
{
  # ... imports all modules, including your custom ones
  imports = [
    ./hardware-configuration.nix
    ./my-webserver-module.nix
  ];

  # This is where specialArgs would be used (often in import statements)
  # Example: passing a custom value to ALL modules:
  # (in module context, this is more complex, but conceptually)
  # let
  #   allModules = [ ./my-module.nix ];
  # in
  # lib.nixosSystem {
  #   modules = allModules;
  #   specialArgs = {
  #     username = &quot;johndoe&quot;;
  #     mySecretKey = &quot;/run/keys/ssh_key&quot;;
  #   };
  #   # ...
  # };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then, inside &lt;code&gt;my-webserver-module.nix&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# my-webserver-module.nix
{ config, pkgs, lib, username, mySecretKey, ... }: # username and mySecretKey come from specialArgs
{
  # ... use username and mySecretKey in your module
  users.users.${username} = {
    isNormalUser = true;
    extraGroups = [ &quot;wheel&quot; &quot;networkmanager&quot; ];
    # ...
  };
  # ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Any argument listed in a module‚Äôs function signature that is not one of the
standard &lt;code&gt;config&lt;/code&gt;, &lt;code&gt;pkgs&lt;/code&gt;, &lt;code&gt;lib&lt;/code&gt;, &lt;code&gt;options&lt;/code&gt; (or &lt;code&gt;pkgs.callPackage&lt;/code&gt;, etc., which
are often implicit through &lt;code&gt;pkgs&lt;/code&gt;) must be provided via &lt;code&gt;specialArgs&lt;/code&gt; at the
point where the modules are composed.&lt;/p&gt;
&lt;p&gt;Any values listed in a module that aren‚Äôt automatically passed via Nixpkgs must
be explicitly provided through &lt;code&gt;specialArgs&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;specialArgs&lt;/code&gt; and &lt;code&gt;extraSpecialArgs&lt;/code&gt; with Flakes&lt;/h3&gt;
&lt;p&gt;NixOS modules use &lt;code&gt;specialArgs&lt;/code&gt; and Home-Manager uses &lt;code&gt;extraSpecialArgs&lt;/code&gt; to
allow you to pass extra arguments.&lt;/p&gt;
&lt;p&gt;Or with Flakes it would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{
  description = &quot;My Flake&quot;;
  inputs = {
    nixpkgs.url = &quot;github:nixos/nixpkgs/nixos-unstable&quot;;
    home-manager.url = &quot;github:nix-community/home-manager&quot;;
    home-manager.inputs.nixpkgs.follows = &quot;nixpkgs&quot;;
   };

  outputs = { self, nixpkgs, home-manager, ... }:
    let
      lib = nixpkgs.lib;
      pkgs = nixpkgs.legacyPackages.${&quot;x86_64-linux&quot;};
      system = &quot;x86_64-linux&quot;;
  host = &quot;magic&quot;;
  username = &quot;jr&quot;;
  userVars = {
    timezone = &quot;America/New_York&quot;;
    locale = &quot;en_US.UTF-8&quot;;
    gitUsername = &quot;TSawyer87&quot;;
    dotfilesDir = &quot;~/.dotfiles&quot;;
    wm = &quot;hyprland&quot;;
    browser = &quot;firefox&quot;;
    term = &quot;ghostty&quot;;
    editor = &quot;hx&quot;;
    keyboardLayout = &quot;us&quot;;
  };
    in {
      nixosConfigurations = {
        YOURHOSTNAME = lib.nixosSystem {
          system = &quot;x86_64-linux&quot;;
          modules = [ ./configuration.nix ];
          specialArgs = {
            inherit userVars; # == userVars = userVars;
            inherit host;
            inherit username;
          };
        };
      };
      homeConfigurations = {
        USERNAME = home-manager.lib.homeManagerConfiguration {
          inherit pkgs;
          modules = [ ./home.nix ];
          extraSpecialArgs = {
            inherit userVars;
            inherit host;
            inherit username;
            # or it can be written like this:
            # inherit userVars host username;
          };
        };
      };
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now if I want to use any of these arguments in modules I can by any module file
referenced by my configuration.&lt;/p&gt;
&lt;p&gt;For example, the following is a &lt;code&gt;git.nix&lt;/code&gt; module that uses the variables from
the flake passed from &lt;code&gt;extraSpecialArgs&lt;/code&gt; in this case because it‚Äôs a
home-manager module:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# git.nix
{ userVars, ... }: {
  programs = {
    git = {
      enable = true;
      userName = userVars.gitUsername;
    };
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style=&quot;text-align: left&quot;&gt;Feature&lt;/th&gt;&lt;th style=&quot;text-align: left&quot;&gt;Regular Nix Function (e.g., &lt;code&gt;hello.nix&lt;/code&gt;)&lt;/th&gt;&lt;th style=&quot;text-align: left&quot;&gt;Nix Module (e.g., &lt;code&gt;my-config-module.nix&lt;/code&gt;)&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;Arguments&lt;/strong&gt;&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;You must explicitly pass every single argument.&lt;/strong&gt;&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;Automatically receives &lt;code&gt;config&lt;/code&gt;, &lt;code&gt;pkgs&lt;/code&gt;, &lt;code&gt;lib&lt;/code&gt;, &lt;code&gt;options&lt;/code&gt;, etc.&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;Custom Args&lt;/strong&gt;&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Passed directly in the function call.&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Passed via &lt;code&gt;specialArgs&lt;/code&gt; when the modules are composed.&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;Boilerplate&lt;/strong&gt;&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Often needs &lt;code&gt;pkgs = import &amp;lt;nixpkgs&amp;gt; {};&lt;/code&gt; if not explicitly passed.&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;pkgs&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; are always available automatically.&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;Purpose&lt;/strong&gt;&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Defines a package, a utility, or a single value.&lt;/td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Defines a reusable part of a declarative system configuration.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
</content></entry><entry><title>Intro to Derivations</title><id>https://saylesss88.github.io/Intro_to_Nix_Derivations_7.html</id><updated>2025-11-29T00:00:00+00:00</updated><link href="https://saylesss88.github.io/Intro_to_Nix_Derivations_7.html" rel="alternate"/><content type="html">&lt;h1&gt;Chapter 7&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;h2&gt;Introduction to Nix Derivations&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;images/gruv10.png&quot; alt=&quot;gruv10&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Nix‚Äôs build instructions, known as &lt;strong&gt;derivations&lt;/strong&gt;, are defined using the Nix
Language. These derivations can describe anything from individual software
packages to complete system configurations. The Nix package manager then
deterministically ‚Äúrealizes‚Äù (builds) these derivations, ensuring consistency
because they rely solely on a predefined set of inputs.&lt;/p&gt;
&lt;p&gt;Most things in NixOS are built around derivations. Your NixOS system is
described by such a single system derivation. When you want to apply a new
configuration, &lt;code&gt;nixos-rebuild&lt;/code&gt; handles the process:&lt;/p&gt;
&lt;p&gt;It first builds this derivation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build &apos;&amp;lt;nixpkgs/nixos&amp;gt;&apos; -A system
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, once the build is complete, it switches to that new system:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;result/bin/switch-to-configuration
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the build, &lt;code&gt;nixos-rebuild&lt;/code&gt; updates a crucial symbolic link:
&lt;code&gt;/run/current-system&lt;/code&gt; This symlink always points to the active, running version
of your system in the Nix store. In essence, the &lt;code&gt;/run/current-system&lt;/code&gt; path is
the currently active system derivation. This design choice gives NixOS its
powerful atomic upgrade and rollback capabilities: changing your system involves
building a new system derivation and updating this symlink to point to the
latest version.&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt; ls -lsah /run/current-system
 0 lrwxrwxrwx 1 root root 85 May 23 12:11 /run/current-system -&amp;gt; /nix/store/
 cy2c0kxpjrl7ajlg9v3zh898mhj4dyjv-nixos-system-magic-25.11.20250520.2795c50
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;-&amp;gt;&lt;/code&gt; indicates a symlink and it‚Äôs pointing to a &lt;strong&gt;store path&lt;/strong&gt; which is
the result of a derivation being built (the system closure)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For beginners, the analogy of a cooking recipe is helpful:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ingredients (Dependencies):&lt;/strong&gt; What other software or libraries are needed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Steps (Build Instructions):&lt;/strong&gt; The commands to compile, configure, and
install.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Final Dish (Output):&lt;/strong&gt; The resulting package or resource.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A Nix derivation encapsulates all this information, telling Nix what inputs to
use, how to build it, and what the final output should be.&lt;/p&gt;
&lt;p&gt;Nix derivations run in &lt;strong&gt;pure&lt;/strong&gt;, &lt;strong&gt;isolated environments&lt;/strong&gt;, meaning they
&lt;strong&gt;cannot&lt;/strong&gt; access the internet during the build phase. This ensures that builds
are reproducible ‚Äì they don‚Äôt depend on external sources that might change over
time.&lt;/p&gt;
&lt;p&gt;There are &lt;code&gt;Fixed-output-derivations&lt;/code&gt; that allow fetching resources during the
build process by explicitly specifying the expected hash upfront. Just keep this
in mind that normal derivations don‚Äôt have network access.&lt;/p&gt;
&lt;h2&gt;Creating Derivations in Nix&lt;/h2&gt;
&lt;p&gt;The primary way to define packages in Nix is through the &lt;code&gt;mkDerivation&lt;/code&gt;
function, which is part of the standard environment (&lt;code&gt;stdenv&lt;/code&gt;). While a
lower-level &lt;code&gt;derivation&lt;/code&gt; function exists for advanced use cases, &lt;code&gt;mkDerivation&lt;/code&gt;
simplifies the process by automatically managing dependencies and the build
environment.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mkDerivation&lt;/code&gt; (and &lt;code&gt;derivation&lt;/code&gt;) takes a set of attributes as its argument. At
a minimum, you‚Äôll often encounter these essential attributes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;name:&lt;/strong&gt; A human-readable identifier for the derivation (e.g., ‚Äúfoo‚Äù,
‚Äúhello.txt‚Äù). This helps you and Nix refer to the package.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;system:&lt;/strong&gt; Specifies the target architecture for the build (e.g.,
&lt;code&gt;builtins.currentSystem&lt;/code&gt; for your current machine).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;builder:&lt;/strong&gt; Defines the program that will execute the build instructions
(e.g., &lt;code&gt;bash&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;How do we pass these required attributes to the &lt;code&gt;derivation&lt;/code&gt; function?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Functions in Nix often take a single argument which is an attribute set. For
&lt;code&gt;derivation&lt;/code&gt; and &lt;code&gt;mkDerivation&lt;/code&gt;, this takes the form
&lt;code&gt;functionName { attribute1 = value1; attribute2 = value2; ... }&lt;/code&gt;, where the &lt;code&gt;{}&lt;/code&gt;
encloses the set of attributes being passed as the function‚Äôs argument.&lt;/p&gt;
&lt;p&gt;Remember that &lt;code&gt;derivation&lt;/code&gt; and &lt;code&gt;mkDerivation&lt;/code&gt; take a set (i.e. &lt;code&gt;{}&lt;/code&gt;) of
attributes as its first argument. So, in order to pass the required attributes
you would do something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;nix-repl&amp;gt; pkgs = import &amp;lt;nixpkgs&amp;gt; {}

nix-repl&amp;gt; d = derivation {
            name = &quot;mydrv&quot;;
            builder = &quot;${pkgs.bash}/bin/bash&quot;;
            args = [
              &quot;-c&quot; # Tells bash to execute the following string as a command
              &apos;&apos;
                # Explicitly set PATH to include coreutils bin directory
                export PATH=&quot;${pkgs.coreutils}/bin:$PATH&quot;
                mkdir $out
              &apos;&apos;
            ];
            system = builtins.currentSystem;
          }

nix-repl&amp;gt; :b d
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;When I was starting out, seeing the above written in the following format made
it clearer in my mental map that we were passing these attributes as arguments
but both accomplish the same thing.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;d = derivation { name = &quot;myname&quot;; builder = &quot;${coreutils}/bin/true&quot;; system = builtins.currentSystem; }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;When you write &lt;code&gt;pkgs = import &amp;lt;nixpkgs&amp;gt; {};&lt;/code&gt;, you are importing the Nixpkgs
&lt;code&gt;default.nix&lt;/code&gt; file, which resolves to a function. Calling that function by
passing it an empty attribute set &lt;code&gt;{}&lt;/code&gt; as its argument. The function then
evaluates and returns the entire &lt;code&gt;pkgs&lt;/code&gt; attribute set. To specify a different
system for example, you could do something like:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;pkgsForAarch64 = import &amp;lt;nixpkgs&amp;gt; { system = &quot;aarch64-linux&quot;; };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So when you see:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;import &amp;lt;nixpkgs&amp;gt; { overlays = []; config = {}; }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Instead, these empty sets explicitly override any global or implicit
overlays/configurations that Nix might otherwise pick up from environment
variables (like &lt;code&gt;NIXPKGS_CONFIG&lt;/code&gt;), default locations (like
&lt;code&gt;~/.config/nixpkgs/config.nix&lt;/code&gt; or &lt;code&gt;~/.config/nixpkgs/overlays&lt;/code&gt;), or other
mechanisms.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This is to prevent accidental partial application from other parts of your
configuration and is saying ‚ÄúDo not pass any custom configuration options for
this particular import‚Äù&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;derivation&lt;/code&gt; is a pre-made, built-in function in the Nix language. Here, we
are passing it an attribute set as argument with the three required
attributes. (&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;builder&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, and we added an extra argument
&lt;code&gt;args&lt;/code&gt;.)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;The Hello World Derivation&lt;/h2&gt;
&lt;p&gt;For this example, first create a &lt;code&gt;hello&lt;/code&gt; directory and add the
&lt;a href=&quot;https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz&quot;&gt;Hello tarball&lt;/a&gt; to said
directory.&lt;/p&gt;
&lt;p&gt;Now lets create the classic Hello derivation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# hello.nix
let
  pkgs = import &amp;lt;nixpkgs&amp;gt; { };
in
derivation {
  name = &quot;hello&quot;;
  builder = &quot;${pkgs.bash}/bin/bash&quot;;
  args = [ ./hello_builder.sh ];
  inherit (pkgs)
    gnutar
    gzip
    gnumake
    gcc
    coreutils
    gawk
    gnused
    gnugrep
    ;
  bintools = pkgs.binutils.bintools;
  src = ./hello-2.12.1.tar.gz;
  system = builtins.currentSystem;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;As you can see, this isn‚Äôt the only required file but is a recipe outlining
how to build the &lt;code&gt;hello&lt;/code&gt; package. The &lt;code&gt;tar.gz&lt;/code&gt; package can be found
&lt;a href=&quot;https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz&quot;&gt;here&lt;/a&gt; You would just place
the tarball in the same directory as the derivation along with the following
&lt;code&gt;hello_builder.sh&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# hello_builder.sh
export PATH=&quot;$gnutar/bin:$gcc/bin:$gnumake/bin:$coreutils/bin:$gawk/bin:$gzip/bin:$gnugrep/bin:$gnused/bin:$bintools/bin&quot;
tar -xzf $src
cd hello-2.12.1
./configure --prefix=$out
make
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And build it with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build hello.nix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally execute it with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./result/bin/hello
Hello, world!
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Simple Rust Derivation&lt;/h2&gt;
&lt;p&gt;Create a &lt;code&gt;simple.rs&lt;/code&gt; with the following contents:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
  println!(&quot;Simple Rust!&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And a &lt;code&gt;rust_builder.sh&lt;/code&gt; like this (this is our builder script):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# rust_builder.sh
# Set up the PATH to include rustc coreutils and gcc
export PATH=&quot;$rustc/bin:$coreutils/bin:$gcc/bin&quot;

# IMPORTANT: Create the $out directory BEFORE rustc tries to write to it
mkdir -p &quot;$out&quot;

# Compile the Rust source code and place the executable inside $out
rustc -o &quot;$out/simple_rust&quot; &quot;$src&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we‚Äôll enter the &lt;code&gt;nix repl&lt;/code&gt; and build it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;‚ùØ nix repl
Nix 2.28.3
Type :? for help.

nix-repl&amp;gt; :l &amp;lt;nixpkgs&amp;gt;
added 3950 variables.

# Define the variables for rustc, coreutils, bash, AND gcc from the loaded nixpkgs
nix-repl&amp;gt; rustc = pkgs.rustc

nix-repl&amp;gt; coreutils = pkgs.coreutils

nix-repl&amp;gt; bash = pkgs.bash

nix-repl&amp;gt; gcc = pkgs.gcc

# Now define the derivation
nix-repl&amp;gt; simple_rust_program = derivation {
            name = &quot;simple-rust-program&quot;;
            builder = &quot;${bash}/bin/bash&quot;;
            args = [ ./rust_builder.sh ];
            rustc = rustc;
            coreutils = coreutils;
            gcc = gcc;
            src = ./simple.rs;
            system = builtins.currentSystem;
          }

nix-repl&amp;gt; :b simple_rust_program
This derivation produced the following outputs:
out -&amp;gt; /nix/store/fmyqr2d3ph0lpnxd0xppwvwyhv3iyb7y-simple-rust-program
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-store -r /nix/store/fmyqr2d3ph0lpnxd0xppwvwyhv3iyb7y-simple-rust-program

warning: you did not specify &apos;--add-root&apos;; the result might be removed by the garbage collector
/nix/store/fmyqr2d3ph0lpnxd0xppwvwyhv3iyb7y-simple-rust-program
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This simple Rust example, built with a direct derivation call, illustrates:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;How Nix explicitly manages every single tool in your build environment
(&lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;rustc&lt;/code&gt;, &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;coreutils&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The strict isolation of Nix builds, where nothing is implicitly available.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The deterministic mapping of inputs to unique output paths in the Nix store.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The above example shows the fundamental structure of a Nix derivation, how
it‚Äôs defined within the &lt;code&gt;nix-repl&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.drv&lt;/code&gt; files are intermediate files that describe how to build a derivation;
it‚Äôs the bare minimum information.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;When Derivations are Built&lt;/h2&gt;
&lt;p&gt;Nix doesn‚Äôt build derivations during the evaluation of your Nix expressions.
Instead, it processes your code in two main phases (and why you need to use
&lt;code&gt;:b simple_rust_program&lt;/code&gt; or &lt;code&gt;nix-store -r&lt;/code&gt; to actually build or realize it):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Evaluation/Instantiate Phase: This is when Nix parses and interprets your
.nix expression. The result is a precise derivation description (often
represented as a .drv file on disk), and the unique ‚Äúout paths‚Äù where the
final built products will go are calculated. No actual code is compiled or
executed yet. Achieved with &lt;code&gt;nix-instantiate&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Realize/Build Phase: Only after a derivation has been fully described does
Nix actually execute its build instructions. It first ensures all the
derivation‚Äôs inputs (dependencies) are built, then runs the builder script
in an isolated environment, and places the resulting products into their
designated ‚Äúout paths‚Äù in the Nix store. Achieved with &lt;code&gt;nix-store -r&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Referring to other derivations&lt;/h2&gt;
&lt;p&gt;The way that we can refer to other packages/derivations is to use the &lt;code&gt;outPath&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;outPath&lt;/code&gt; describes the location of the files of that derivation. Nix can
then convert the derivation set into a string:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix repl
nix-repl&amp;gt; :l &amp;lt;nixpkgs&amp;gt;
nix-repl&amp;gt; fzf
¬´derivation /nix/store/vw1zag9q4xvf10z24j1qybji7wfsz78v-fzf-0.62.0.drv¬ª
nix-repl&amp;gt; fzf.outPath
&quot;/nix/store/z3ayhjslz72ldiwrv3mn5n7rs96p2g8a-fzf-0.62.0&quot;
nix-repl&amp;gt; builtins.toString fzf
&quot;/nix/store/z3ayhjslz72ldiwrv3mn5n7rs96p2g8a-fzf-0.62.0&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;As long as there is an &lt;code&gt;outPath&lt;/code&gt; attribute, Nix will do the ‚Äúset to string
conversion‚Äù.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Produce a development shell from a derivation&lt;/h2&gt;
&lt;p&gt;Building on the concept of a derivation as a recipe, let‚Äôs create our first
practical derivation. This example shows how to define a temporary development
environment (a shell) using stdenv.mkDerivation, which is the primary function
for defining packages in Nix.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# my-shell.nix
# We use a `let` expression to bring `pkgs` and `stdenv` into scope.
# This is a recommended practice over `with import &amp;lt;nixpkgs&amp;gt; {}`
# for clarity and to avoid potential name collisions.
let
  pkgs = import &amp;lt;nixpkgs&amp;gt; {};
  stdenv = pkgs.stdenv; # Access stdenv from the imported nixpkgs
in

# Make a new &quot;derivation&quot; that represents our shell
stdenv.mkDerivation {
  name = &quot;my-environment&quot;;

  # The packages in the `buildInputs` list will be added to the PATH in our shell
  buildInputs = [
    # cowsay is an arbitrary package
    # see https://nixos.org/nixos/packages.html to search for more
    pkgs.cowsay
    pkgs.fortune
  ];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Usage&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-shell my-shell.nix
fortune | cowsay
 _________________________________________
/ &quot;Lines that are parallel meet at        \
| Infinity!&quot; Euclid repeatedly, heatedly, |
| urged.                                  |
|                                         |
| Until he died, and so reached that      |
| vicinity: in it he found that the       |
| damned things diverged.                 |
|                                         |
\ -- Piet Hein                            /
 -----------------------------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;To exit type: &lt;code&gt;exit&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This Nix expression defines a temporary development shell. Let‚Äôs break it down:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;pkgs = import &amp;lt;nixpkgs&amp;gt; {};&lt;/code&gt;: Standard way to get access to all the packages
and helper functions (i.e. &lt;code&gt;nixpkgs.lib&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stdenv = pkgs.stdenv;&lt;/code&gt;: &lt;code&gt;stdenv&lt;/code&gt; provides us &lt;code&gt;mkDerivation&lt;/code&gt; and is from the
&lt;code&gt;nixpkgs&lt;/code&gt; collection.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stdenv.mkDerivation { ... };&lt;/code&gt;: This is the core function for creating
packages.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stdenv&lt;/code&gt; provides a set of common build tools and conventions.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mkDerivation&lt;/code&gt; takes an attribute set (a collection of key-value pairs) as its
argument.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;name = &quot;my-environment&quot;;&lt;/code&gt;: This gives your derivation a human-readable name.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;buildInputs = [ pkgs.cowsay ];&lt;/code&gt;: This is a list of dependencies that will be
available in the build environment of this derivation (or in the &lt;code&gt;PATH&lt;/code&gt; if you
enter the shell created by this derivation). &lt;code&gt;pkgs.cowsay&lt;/code&gt; refers to the
&lt;code&gt;cowsay&lt;/code&gt; package from the imported &lt;code&gt;pkgs&lt;/code&gt; collection.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The command &lt;code&gt;nix-instantiate --eval my-shell.nix&lt;/code&gt; evaluates the Nix expression
in the file. It does not build the derivation. Instead, it returns the Nix value
that the expression evaluates to.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate --eval my-shell.nix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This value is a structured data type that encapsulates all the attributes (like
&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, &lt;code&gt;buildInputs&lt;/code&gt;, etc.) required to build the derivation. Your
output shows this detailed internal representation of the derivation‚Äôs ‚Äúrecipe‚Äù
as understood by Nix. This is useful for debugging and inspecting the
derivation‚Äôs definition.&lt;/p&gt;
&lt;h2&gt;Our Second Derivation: Understanding the Builder&lt;/h2&gt;
&lt;details&gt;
&lt;summary&gt; Understanding the Builder (Click to Expand) &lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;To understand how derivations work, let‚Äôs create a very basic example using a
bash script as our &lt;code&gt;builder&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Why a Builder Script?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;builder&lt;/code&gt; attribute in a derivation tells Nix &lt;em&gt;how&lt;/em&gt; to perform the build
steps. A simple and common way to define these steps is with a bash script.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;The Challenge with Shebangs in Nix&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In typical Unix-like systems, you might start a bash script with a shebang
(&lt;code&gt;#!/bin/bash&lt;/code&gt; or &lt;code&gt;#!/usr/bin/env bash&lt;/code&gt;) to tell the system how to execute it.
However, in Nix derivations, we generally avoid this.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt; Nix builds happen in an isolated environment where the exact path
to common tools like &lt;code&gt;bash&lt;/code&gt; isn‚Äôt known beforehand (it resides within the Nix
store). Hardcoding a path or relying on the system‚Äôs &lt;code&gt;PATH&lt;/code&gt; would break Nix‚Äôs
stateless property.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;The Importance of Statelessness in Nix&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Stateful Systems (Traditional):&lt;/strong&gt; When you install software traditionally,
it often modifies the core system environment directly. This can lead to
dependency conflicts and makes rollbacks difficult.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Stateless Systems (Nix):&lt;/strong&gt; Nix takes a different approach. When installing a
package, it creates a unique, immutable directory in the Nix store. This
means:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;No Conflicts:&lt;/strong&gt; Different versions of the same package can coexist without
interfering with each other.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reliable Rollback:&lt;/strong&gt; You can easily switch back to previous versions
without affecting system-wide files.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reproducibility:&lt;/strong&gt; Builds are more likely to produce the same result
across different machines if they are ‚Äúpure‚Äù (don‚Äôt rely on external system
state).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;The Isolated Nix Build Environment: A Quick Overview&lt;/h3&gt;
&lt;p&gt;When Nix executes a builder script, it sets up a highly controlled and pristine
environment to ensure &lt;strong&gt;reproducibility&lt;/strong&gt; and &lt;strong&gt;isolation&lt;/strong&gt;. Here‚Äôs what
happens:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Fresh Start:&lt;/strong&gt; Nix creates a temporary, empty directory for the build and
makes it the current working directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Clean Environment:&lt;/strong&gt; It completely clears the environment variables from
your shell.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Controlled Inputs:&lt;/strong&gt; Nix then populates the environment with &lt;em&gt;only&lt;/em&gt; the
variables essential for the build, such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$NIX_BUILD_TOP&lt;/code&gt;: The path to the temporary build directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$PATH&lt;/code&gt;: Carefully set to include only the explicit &lt;code&gt;buildInputs&lt;/code&gt; you‚Äôve
specified, preventing reliance on arbitrary system tools.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$HOME&lt;/code&gt;: Set to &lt;code&gt;/homeless-shelter&lt;/code&gt; to prevent programs from reading
user-specific configuration files.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Variables for each declared output (&lt;code&gt;$out&lt;/code&gt;, etc.), indicating where the
final results should be placed in the Nix store.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Execution &amp;amp; Logging:&lt;/strong&gt; The builder script is run with its specified
arguments. All its output (stdout/stderr) is captured in a log.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Clean Up &amp;amp; Registration:&lt;/strong&gt; If successful, the temporary directory is
removed. Nix then scans the build outputs for references to other store
paths, ensuring all dependencies are correctly tracked for future use and
garbage collection. Finally, it normalizes file permissions and timestamps
in the output for consistent hashing.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This meticulous setup ensures that your builds are independent of the machine
they run on and always produce the same result, given the same inputs.&lt;/p&gt;
&lt;h2&gt;Our builder Script&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;For our first derivation, we‚Äôll create a simple &lt;code&gt;builder.sh&lt;/code&gt; file in the
current directory:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# builder.sh
declare -xp
echo foo &amp;gt; $out
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The command &lt;code&gt;declare -xp&lt;/code&gt; lists exported variables (it‚Äôs a bash builtin
function).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nix needs to know where the final built product (the ‚Äúcake‚Äù in our earlier
analogy) should be placed. So, during the derivation process, Nix calculates a
unique output path within the Nix store. This path is then made available to
our builder script as an environment variable named &lt;code&gt;$out&lt;/code&gt;. The &lt;code&gt;.drv&lt;/code&gt; file,
which is the recipe, contains instructions for the builder, including setting
up this &lt;code&gt;$out&lt;/code&gt; variable. Our builder script will then put the result of its
work (in this case, the ‚Äúfoo‚Äù file) into this specific &lt;code&gt;$out&lt;/code&gt; directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;As mentioned earlier we need to find the nix store path to the bash
executable, common way to do this is to load Nixpkgs into the repl and check:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-repl&amp;gt; :l &amp;lt;nixpkgs&amp;gt;
Added 3950 variables.
nix-repl&amp;gt; &quot;${bash}&quot;
&quot;/nix/store/ihmkc7z2wqk3bbipfnlh0yjrlfkkgnv6-bash-4.2-p45&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, with this little trick we are able to refer to &lt;code&gt;bin/bash&lt;/code&gt; and create our
derivation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-repl&amp;gt; d = derivation { name = &quot;foo&quot;; builder = &quot;${bash}/bin/bash&quot;;
 args = [ ./builder.sh ]; system = builtins.currentSystem; }
nix-repl&amp;gt; :b d
[1 built, 0.0 MiB DL]

this derivation produced the following outputs:
  out -&amp;gt; /nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The contents of the resulting store path (&lt;code&gt;/nix/store/...-foo&lt;/code&gt;) now contain
the file &lt;code&gt;foo&lt;/code&gt;, as intended. We have successfully built a derivation!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Derivations are the primitive that Nix uses to define packages. ‚ÄúPackage‚Äù is a
loosely defined term, but a derivation is simply the result of calling
&lt;code&gt;builtins.derivation&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;h2&gt;Our Last Derivation&lt;/h2&gt;
&lt;p&gt;Create a new directory and a &lt;code&gt;hello.nix&lt;/code&gt; with the following contents:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# hello.nix
{
  stdenv,
  fetchzip,
}:

stdenv.mkDerivation {
  pname = &quot;hello&quot;;
  version = &quot;2.12.1&quot;;

  src = fetchzip {
    url = &quot;https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz&quot;;
    sha256 = &quot;&quot;;
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Save this file to &lt;code&gt;hello.nix&lt;/code&gt; and run &lt;code&gt;nix-build&lt;/code&gt; to observe the build failure:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Click to expand output:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;$ nix-build hello.nix
~error: cannot evaluate a function that has an argument without a value (&apos;stdenv&apos;)
~       Nix attempted to evaluate a function as a top level expression; in
~       this case it must have its arguments supplied either by default
~       values, or passed explicitly with &apos;--arg&apos; or &apos;--argstr&apos;. See
~       https://nix.dev/manual/nix/stable/language/constructs.html#functions.
~
~       at /home/nix-user/hello.nix:3:3:
~
~            2| {
~            3|   stdenv,
~             |   ^
~            4|   fetchzip,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: The expression in &lt;code&gt;hello.nix&lt;/code&gt; is a &lt;em&gt;function&lt;/em&gt;, which only produces
it‚Äôs intended output if it is passed the correct &lt;em&gt;arguments&lt;/em&gt;.(i.e. &lt;code&gt;stdenv&lt;/code&gt; is
available from &lt;code&gt;nixpkgs&lt;/code&gt; so we need to import &lt;code&gt;nixpkgs&lt;/code&gt; before we can use
&lt;code&gt;stdenv&lt;/code&gt;):&lt;/p&gt;
&lt;p&gt;The recommended way to do this is to create a &lt;code&gt;default.nix&lt;/code&gt; file in the same
directory as the &lt;code&gt;hello.nix&lt;/code&gt; with the following contents:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# default.nix
let
  nixpkgs = fetchTarball &quot;https://github.com/NixOS/nixpkgs/tarball/nixos-24.05&quot;;
  pkgs = import nixpkgs { config = {}; overlays = []; };
in
{
  hello = pkgs.callPackage ./hello.nix { };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This allows you to run &lt;code&gt;nix-build -A hello&lt;/code&gt; to realize the derivation in
&lt;code&gt;hello.nix&lt;/code&gt;, similar to the current convention used in Nixpkgs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Click to expand Output:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;nix-build -A hello
~error: hash mismatch in fixed-output derivation &apos;/nix/store/pd2kiyfa0c06giparlhd1k31bvllypbb-source.drv&apos;:
~         specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
~            got:    sha256-1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=
~error: 1 dependencies of derivation &apos;/nix/store/b4mjwlv73nmiqgkdabsdjc4zq9gnma1l-hello-2.12.1.drv&apos; failed to build
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Another way to do this is with
&lt;a href=&quot;https://nix.dev/manual/nix/2.24/command-ref/nix-prefetch-url&quot;&gt;nix-prefetch-url&lt;/a&gt;
It is a utility to calculate the sha beforehand.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-prefetch-url https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz
path is &apos;/nix/store/pa10z4ngm0g83kx9mssrqzz30s84vq7k-hello-2.12.1.tar.gz&apos;
086vqwk2wl8zfs47sq2xpjc9k066ilmb8z6dn0q6ymwjzlm196cd
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;When you use &lt;code&gt;nix-prefetch-url&lt;/code&gt;, you get a Base32 hash when nix needs SRI
format.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Run the following command to convert from Base32 to SRI:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix hash to-sri --type sha256 086vqwk2wl8zfs47sq2xpjc9k066ilmb8z6dn0q6ymwjzlm196cd
sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This actually fetched a different sha than the Nix compiler returned in the
example where we replace the empty sha with the one Nix gives us. The
difference was that &lt;code&gt;fetchzip&lt;/code&gt; automatically extracts archives before
computing the hash and slight differences in the metadata cause different
results. I had to switch from &lt;code&gt;fetchzip&lt;/code&gt; to &lt;code&gt;fetchurl&lt;/code&gt; to get the correct
results.
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Extracted archives can differ in timestamps, permissions, or compression
details, causing different hash values.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A simple takeaway is to use &lt;code&gt;fetchurl&lt;/code&gt; when you need an exact match, and
&lt;code&gt;fetchzip&lt;/code&gt; when working with extracted contents.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://nixos.org/manual/nixpkgs/stable/#fetchurl&quot;&gt;fetchurl&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fetchurl&lt;/code&gt; returns a &lt;code&gt;fixed-output derivation&lt;/code&gt;(FOD): A derivation where a
cryptographic hash of the output is determined in advance using the
outputHash attribute, and where the builder executable has access to the
network.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lastly replace the empty sha256 placeholder with the returned value from the
last command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# hello.nix
{
  stdenv,
  fetchzip,
}:

stdenv.mkDerivation {
  pname = &quot;hello&quot;;
  version = &quot;2.12.1&quot;;

  src = fetchzip {
    url = &quot;https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz&quot;;
    sha256 = &quot;sha256-1kJjhtlsAkpNB7f6tZEs+dbKd8z7KoNHyDHEJ0tmhnc=&quot;;
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run &lt;code&gt;nix-build -A hello&lt;/code&gt; again and you‚Äôll see the derivation successfully
builds.&lt;/p&gt;
&lt;h2&gt;Best Practices&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Reproducible source paths&lt;/strong&gt;: If we built the following derivation in
&lt;code&gt;/home/myuser/myproject&lt;/code&gt; then the store path of &lt;code&gt;src&lt;/code&gt; will be
&lt;code&gt;/nix/store/&amp;lt;hash&amp;gt;-myproject&lt;/code&gt; causing the build to no longer be reproducible:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;let pkgs = import &amp;lt;nixpkgs&amp;gt; {}; in

pkgs.stdenv.mkDerivation {
  name = &quot;foo&quot;;
  src = ./.;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ùó TIP: Use &lt;code&gt;builtins.path&lt;/code&gt; with the &lt;code&gt;name&lt;/code&gt; attribute set to something fixed.
This will derive the symbolic name of the store path from the &lt;code&gt;name&lt;/code&gt; instead
of the working directory:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;let pkgs = import &amp;lt;nixpkgs&amp;gt; {}; in

pkgs.stdenv.mkDerivation {
  name = &quot;foo&quot;;
  src = builtins.path { path = ./.; name = &quot;myproject&quot;; };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;In this chapter, we‚Äôve laid the groundwork for understanding Nix derivations,
the fundamental recipes that define how software and other artifacts are built
within the Nix ecosystem. We‚Äôve explored their key components ‚Äì inputs, builder,
build phases, and outputs ‚Äì and how they contribute to Nix‚Äôs core principles of
reproducibility and isolated environments. Derivations are the workhorses behind
the packages and tools we use daily in Nix.&lt;/p&gt;
&lt;p&gt;As you‚Äôve learned, derivations offer a powerful and principled approach to
software management. However, the way we organize and manage these derivations,
along with other Nix expressions and dependencies, has evolved over time.
Traditionally, Nix projects often relied on patterns involving &lt;code&gt;default.nix&lt;/code&gt;
files, channel subscriptions, and manual dependency management.&lt;/p&gt;
&lt;p&gt;A more recent and increasingly popular approach to structuring Nix projects and
managing dependencies is through Nix Flakes. Flakes introduce a standardized
project structure, explicit input tracking, and a more robust way to ensure
reproducible builds across different environments.&lt;/p&gt;
&lt;p&gt;In our next chapter,
&lt;a href=&quot;https://saylesss88.github.io/Comparing_Flakes_and_Traditional_Nix_8.html&quot;&gt;Comparing Flakes and Traditional Nix&lt;/a&gt;,
we will directly compare and contrast these two approaches. We‚Äôll examine the
strengths and weaknesses of traditional Nix practices in contrast to the
benefits and features offered by Nix Flakes. This comparison will help you
understand the motivations behind Flakes and when you might choose one approach
over the other for your Nix projects.&lt;/p&gt;
&lt;p&gt;As you can see below, there is a ton of information on derivations freely
available.&lt;/p&gt;
&lt;h4&gt;Links To Articles about Derivations&lt;/h4&gt;
&lt;details&gt;
&lt;summary&gt; Click To Expand Resources &lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://nixos.org/guides/nix-pills/06-our-first-derivation&quot;&gt;NixPillsOurFirstDerivation&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://nixos.org/guides/nix-pills/07-working-derivation&quot;&gt;NixPills-WorkingDerivation&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://nix.dev/manual/nix/2.24/language/derivations&quot;&gt;nix.dev-Derivations&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://nix.dev/tutorials/packaging-existing-software&quot;&gt;nix.dev-packagingExistingSoftware&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://ianthehenry.com/posts/how-to-learn-nix/my-first-derivation/&quot;&gt;howToLearnNix-MyFirstDerivation&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://ianthehenry.com/posts/how-to-learn-nix/derivations-in-detail/&quot;&gt;howToLearnNix-DerivationsInDetail&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sam.today/blog/creating-a-super-simple-derivation-learning-nix-pt-3&quot;&gt;Sparky/blog-creatingASuperSimpleDerivation&lt;/a&gt; #
How to learn Nix&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sam.today/blog/derivations-102-learning-nix-pt-4&quot;&gt;Sparky/blog-Derivations102&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://scrive.github.io/nix-workshop/04-derivations/01-derivation-basics.html&quot;&gt;ScriveNixWorkshop-nixDerivationBasics&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://zero-to-nix.com/concepts/derivations/&quot;&gt;zeroToNix-Derivations&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tweag.io/blog/2021-02-17-derivation-outputs-and-output-paths/&quot;&gt;Tweag-derivationOutputs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://ayats.org/blog/nix-tuto-2&quot;&gt;theNixLectures-Derivations&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://bmcgee.ie/posts/2023/02/nix-what-are-fixed-output-derivations-and-why-use-them/&quot;&gt;bmcgee-whatAreFixed-OutputDerivations&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
</content></entry><entry><title>index</title><id>https://saylesss88.github.io/index.html</id><updated>2025-11-28T20:30:18+00:00</updated><link href="https://saylesss88.github.io/index.html" rel="alternate"/><content type="html"></content></entry><entry><title>Flake outputs</title><id>https://saylesss88.github.io/flakes/flake_examples_4.3.html</id><updated>2025-11-28T00:00:00+00:00</updated><link href="https://saylesss88.github.io/flakes/flake_examples_4.3.html" rel="alternate"/><content type="html">&lt;h1&gt;Nix Flake Examples&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;p&gt;This chapter provides practical examples to illustrate the concepts discussed in
‚ÄúNix Flakes Explained.‚Äù&lt;/p&gt;
&lt;h2&gt;Example showing the extensibility of Flakes&lt;/h2&gt;
&lt;p&gt;NixOS modules and configurations offer us a powerful and composable way to
define and share system configurations. Imagine we have several independent
‚Äúplayers,‚Äù each with their own unique set of configurations or modules. How do
we combine these individual contributions into a single, cohesive system without
directly altering each player‚Äôs original flake?&lt;/p&gt;
&lt;p&gt;This example demonstrates how flakes can extend and compose each other, allowing
you to layer configurations on top of existing ones. This is particularly useful
when you want to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Build upon a base configuration without modifying its source.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Combine features from multiple independent flakes into a single system.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create specialized versions of an existing configuration.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let‚Äôs simulate this by creating a players directory with three sub-directories:
&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;second&lt;/code&gt;, and &lt;code&gt;third&lt;/code&gt;. Each of these will contain its own &lt;code&gt;flake.nix&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir players
cd players
mkdir first
mkdir second
mkdir third
cd first
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now create a &lt;code&gt;flake.nix&lt;/code&gt; with the following contents:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# flake.nix
{
  inputs = {
    nixpkgs.url = &quot;github:nixos/nixpkgs/nixos-24.11&quot;;
  };

  outputs = {
    self,
    nixpkgs,
  }: {
    nixosModules.default = {
      config,
      pkgs,
      lib,
      ...
    }: {
      # Create a file `/etc/first-file`
      environment.etc.first-file.text = &quot;Hello player # 1!&quot;;
      boot.initrd.includeDefaultModules = false;
      documentation.man.enable = false;
      boot.loader.grub.enable = false;
      fileSystems.&quot;/&quot;.device = &quot;/dev/null&quot;;
      system.stateVersion = &quot;24.11&quot;;
    };
    nixosConfigurations.testing = nixpkgs.lib.nixosSystem {
      system = &quot;x86_64-linux&quot;;
      modules = [
        self.nixosModules.default
      ];
    };
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This demonstrates using &lt;code&gt;self&lt;/code&gt; to reference this flake from within its own
outputs. This is the main use for &lt;code&gt;self&lt;/code&gt; with flakes. Without &lt;code&gt;self&lt;/code&gt;, I
wouldn‚Äôt have a direct way to refer to the &lt;code&gt;nixosModules.default&lt;/code&gt; that‚Äôs
defined within the same flake.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now in the &lt;code&gt;players/second&lt;/code&gt; directory create this &lt;code&gt;flake.nix&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# flake.nix
{
  inputs = {
    nixpkgs.url = &quot;github:nixos/nixpkgs/nixos-24.11&quot;;
  };

  outputs = {
    self,
    nixpkgs,
  }: {
    nixosModules.default = {
      config,
      pkgs,
      lib,
      ...
    }: {
      # Create a file `/etc/second-file`
      environment.etc.second-file.text = &quot;Hello player # 2!&quot;;
    };
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nixosModules.default&lt;/code&gt; is a module which is a function that, when called by
the NixOS module system, returns an attribute set representing a piece of
system configuration.
&lt;ul&gt;
&lt;li&gt;Within that attribute set, it specifies that the file &lt;code&gt;/etc/second-file&lt;/code&gt;
should exist with ‚ÄúHello player # 2!‚Äù as its content.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And finally in &lt;code&gt;players/third&lt;/code&gt; create another &lt;code&gt;flake.nix&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# flake.nix
{
  inputs = {
    first.url = &quot;/home/jr/players/first&quot;;
    nixpkgs.follows = &quot;first/nixpkgs&quot;;
    second = {
      url = &quot;/home/jr/players/second&quot;;
      inputs.nixpkgs.follows = &quot;first/nixpkgs&quot;;
    };
  };

  outputs = {
    self,
    nixpkgs,
    first,
    second,
  }:
    first.outputs
    // {
      nixosConfigurations.testing = first.nixosConfigurations.testing.extendModules {
        modules = [
          second.nixosModules.default
        ];
      };
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;You‚Äôll have to change the locations to where you placed your &lt;code&gt;players&lt;/code&gt;
directory in the &lt;code&gt;inputs&lt;/code&gt; above.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In your &lt;code&gt;third&lt;/code&gt; directory inspect it with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Ôåì  ~/players/third
‚ùØ nix flake show
path:/home/jr/players/third?lastModified=1748271697&amp;amp;narHash=sha256-oNzkC6X9hA0MpOBmJSZ89w4znXxv4Q5EkFhp0ewehY0%3D
‚îú‚îÄ‚îÄ‚îÄnixosConfigurations
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄtesting: NixOS configuration
‚îî‚îÄ‚îÄ‚îÄnixosModules
    ‚îî‚îÄ‚îÄ‚îÄdefault: NixOS module
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and build it with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix build .#nixosConfigurations.testing.config.system.build.toplevel
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cat result/etc/first-file
Hello player # 1!
cat result/etc/second-file
Hello player # 2!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Understanding the Extension&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As you saw in the &lt;code&gt;flake.nix&lt;/code&gt; for the third player, we leveraged two key flake
features to combine and extend the previous configurations:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Attribute Set Union&lt;/strong&gt; (&lt;code&gt;//&lt;/code&gt; operator):&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;outputs = { ..., first, second, ... }:
first.outputs // { # ... your extensions here ...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;//&lt;/code&gt; (attribute set union) operator allows us to take all the outputs from
&lt;code&gt;first.outputs&lt;/code&gt; (which includes its &lt;code&gt;nixosConfigurations&lt;/code&gt; and &lt;code&gt;nixosModules&lt;/code&gt;)
and then overlay or add to them on the right-hand side. This means our third
flake will inherit all the outputs from first, but we can then modify or add new
ones without changing the first flake itself.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;code&gt;config.extendModules&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;    nixosConfigurations.testing = first.nixosConfigurations.testing.extendModules {
      modules = [
        second.nixosModules.default
      ];
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the core of the extension. We‚Äôre taking the testing NixOS configuration
defined in the first flake (&lt;code&gt;first.nixosConfigurations.testing&lt;/code&gt;) and then
calling its &lt;code&gt;extendModules&lt;/code&gt; function. This function allows us to inject
additional NixOS modules into an already defined system configuration. In this
case, we‚Äôre adding the default module from the second flake
(&lt;code&gt;second.nixosModules.default&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;By combining these techniques, the third flake successfully creates a NixOS
configuration that includes both the settings from first (like &lt;code&gt;/etc/first-file&lt;/code&gt;
and the base system options) and the settings from second (like
&lt;code&gt;/etc/second-file&lt;/code&gt;), all without directly altering the first or second flakes.
This demonstrates the incredible power of flake extensibility for building
complex, modular, and composable systems.&lt;/p&gt;
</content></entry><entry><title>Flake Inputs</title><id>https://saylesss88.github.io/flakes/flake_inputs_4.1.html</id><updated>2025-11-28T00:00:00+00:00</updated><link href="https://saylesss88.github.io/flakes/flake_inputs_4.1.html" rel="alternate"/><content type="html">&lt;h1&gt;Nix Flake Inputs&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;p&gt;The attribute &lt;code&gt;inputs&lt;/code&gt; specifies the dependencies of a flake, as an attrset
mapping input names to flake references.&lt;/p&gt;
&lt;p&gt;If a repository provides a &lt;code&gt;flake.nix&lt;/code&gt; you can include it as an input in your
&lt;code&gt;flake.nix&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, I like yazi as my file explorer and have been using helix as my
editor. To be able to get yazi to work with helix I needed the latest versions
of both yazi and helix. One way to get the latest versions was to add their
flakes as inputs to my flake:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{
	inputs = {
		nixpkgs.url = &quot;github:NixOS/nixpkgs/nixos-24.11&quot;;
		home-manager = {
			url = &quot;github:nix-community/home-manager/release-24.11&quot;;
			inputs.nixpkgs.follows = &quot;nixpkgs&quot;;
		};
    helix = {
      url = &quot;github:helix-editor/helix&quot;;
      inputs.nixpkgs.follows = &quot;nixpkgs&quot;;
    };
		yazi.url = &quot;github:sxyazi/yazi&quot;;
	};
	outputs = { nixpkgs, home-manager, ... } @ inputs: {
	# ... snip ... #
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Now to use this input, I would reference these inputs in both my yazi and
helix modules:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# yazi.nix
{ pkgs, config, inputs, ... }: {
	programs.yazi = {
		enable = true;
		package = inputs.yazi.packages.${pkgs.system}.default;
	};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# helix.nix
{ pkgs, config, inputs, ... }: {
	programs.helix = {
		enable = true;
		package = inputs.helix.packages.${pkgs.system}.helix;
	};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Understanding &lt;code&gt;.default&lt;/code&gt; vs. Named Outputs (e.g., &lt;code&gt;.helix&lt;/code&gt;) from the Source&lt;/p&gt;
&lt;p&gt;The difference between &lt;code&gt;inputs.yazi.packages.${pkgs.system}.default&lt;/code&gt; and
&lt;code&gt;inputs.helix.packages.${pkgs.system}.helix&lt;/code&gt; comes down to how the respective
upstream flakes define their outputs. You can always inspect a flake‚Äôs
&lt;code&gt;flake.nix&lt;/code&gt; or use &lt;code&gt;nix flake show &amp;lt;flake-reference&amp;gt;&lt;/code&gt; to understand its
structure.&lt;/p&gt;
&lt;h2&gt;Helix &lt;code&gt;flake.nix&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Let‚Äôs look at the relevant section of Helix‚Äôs &lt;code&gt;flake.nix&lt;/code&gt; click the eye to see
the full flake:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;~ {
~   description = &quot;A post-modern text editor.&quot;;
~
~   inputs = {
~     nixpkgs.url = &quot;github:nixos/nixpkgs/nixos-unstable&quot;;
~     rust-overlay = {
~       url = &quot;github:oxalica/rust-overlay&quot;;
~       inputs.nixpkgs.follows = &quot;nixpkgs&quot;;
~     };
~   };
~
~   outputs = {
~     self,
~     nixpkgs,
~     rust-overlay,
~     ...
~   }: let
~     inherit (nixpkgs) lib;
~     systems = [
~       &quot;x86_64-linux&quot;
~       &quot;aarch64-linux&quot;
~       &quot;x86_64-darwin&quot;
~       &quot;aarch64-darwin&quot;
~     ];
~     eachSystem = lib.genAttrs systems;
~     pkgsFor = eachSystem (system:
~       import nixpkgs {
~         localSystem.system = system;
~         overlays = [(import rust-overlay) self.overlays.helix];
~       });
~     gitRev = self.rev or self.dirtyRev or null;
   in {
     packages = eachSystem (system: {
       inherit (pkgsFor.${system}) helix;
       /*
       The default Helix build. Uses the latest stable Rust toolchain, and unstable
       nixpkgs.

       The build inputs can be overridden with the following:

       packages.${system}.default.override { rustPlatform = newPlatform; };

       Overriding a derivation attribute can be done as well:

       packages.${system}.default.overrideAttrs { buildType = &quot;debug&quot;; };
       */
      default = self.packages.${system}.helix;
    });
~    checks =
~      lib.mapAttrs (system: pkgs: let
~        # Get Helix&apos;s MSRV toolchain to build with by default.
~        msrvToolchain = pkgs.pkgsBuildHost.rust-bin.fromRustupToolchainFile ./rust-toolchain.toml;
~        msrvPlatform = pkgs.makeRustPlatform {
~          cargo = msrvToolchain;
~          rustc = msrvToolchain;
~        };
~      in {
~        helix = self.packages.${system}.helix.override {
~          rustPlatform = msrvPlatform;
~        };
~      })
~      pkgsFor;
~
~    # Devshell behavior is preserved.
~    devShells =
~      lib.mapAttrs (system: pkgs: {
~        default = let
~          commonRustFlagsEnv = &quot;-C link-arg=-fuse-ld=lld -C target-cpu=native --cfg tokio_unstable&quot;;
~          platformRustFlagsEnv = lib.optionalString pkgs.stdenv.isLinux &quot;-Clink-arg=-Wl,--no-rosegment&quot;;
~        in
~          pkgs.mkShell {
~            inputsFrom = [self.checks.${system}.helix];
~            nativeBuildInputs = with pkgs;
~              [
~                lld
~                cargo-flamegraph
~                rust-bin.nightly.latest.rust-analyzer
~              ]
~              ++ (lib.optional (stdenv.isx86_64 &amp;amp;&amp;amp; stdenv.isLinux) cargo-tarpaulin)
~              ++ (lib.optional stdenv.isLinux lldb)
~              ++ (lib.optional stdenv.isDarwin darwin.apple_sdk.frameworks.CoreFoundation);
~            shellHook = &apos;&apos;
~              export RUST_BACKTRACE=&quot;1&quot;
~              export RUSTFLAGS=&quot;&apos;&apos;${RUSTFLAGS:-&quot;&quot;} ${commonRustFlagsEnv} ${platformRustFlagsEnv}&quot;
~            &apos;&apos;;
~          };
~      })
~      pkgsFor;
~
~    overlays = {
~      helix = final: prev: {
~        helix = final.callPackage ./default.nix {inherit gitRev;};
~      };
~
~      default = self.overlays.helix;
~    };
~  };
~  nixConfig = {
~    extra-substituters = [&quot;https://helix.cachix.org&quot;];
~    extra-trusted-public-keys = [&quot;helix.cachix.org-1:ejp9KQpR1FBI2onstMQ34yogDm4OgU2ru6lIwPvuCVs=&quot;];
~  };
~}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dissecting &lt;code&gt;inherit (pkgsFor.${system}) helix;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Imagine the Nix evaluation process for Helix &lt;code&gt;flake.nix&lt;/code&gt; in the &lt;code&gt;outputs&lt;/code&gt;
section:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;packages = eachSystem (system: { ... });&lt;/code&gt; Part iterates through each
&lt;code&gt;system&lt;/code&gt; (like &lt;code&gt;x86_64-linux&lt;/code&gt;). For each &lt;code&gt;system&lt;/code&gt;, it‚Äôs creating an attribute
set that will become &lt;code&gt;self.packages.${system}&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Inside the &lt;code&gt;eachSystem&lt;/code&gt; function, for a specific system (e.g.
&lt;code&gt;x86_64-linux&lt;/code&gt;): The code is building an attribute set that will ultimately
be assigned to &lt;code&gt;self.packages.x86_64-linux&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When you write &lt;code&gt;inherit (sourceAttrset) attributeName;&lt;/code&gt;, it‚Äôs equivalent to
writing &lt;code&gt;attributeName = sourceAttrset.attributeName;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So, &lt;code&gt;inherit (pkgsFor.${system}) helix;&lt;/code&gt; is equivalent to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;helix = pkgsFor.${system}.helix;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Therefore, because of &lt;code&gt;inherit (pkgsFor.${system}) helix;&lt;/code&gt;, the helix attribute
is explicitly defined under
&lt;code&gt;packages.${system}``. This is why you access it as &lt;/code&gt;inputs.helix.packages.${pkgs.system}.helix;`.&lt;/p&gt;
&lt;h2&gt;Yazi &lt;code&gt;flake.nix&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Now this is yazi‚Äôs &lt;code&gt;flake.nix&lt;/code&gt;, yazi‚Äôs documentation tells you to use &lt;code&gt;.default&lt;/code&gt;
but lets examine the flake and see why:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;~{
~  inputs = {
~    nixpkgs.url = &quot;github:NixOS/nixpkgs/nixpkgs-unstable&quot;;
~    flake-utils.url = &quot;github:numtide/flake-utils&quot;;
~    rust-overlay = {
~      url = &quot;github:oxalica/rust-overlay&quot;;
~      inputs.nixpkgs.follows = &quot;nixpkgs&quot;;
~    };
~  };
~
~  outputs =
~    {
~      self,
~      nixpkgs,
~      rust-overlay,
~      flake-utils,
~      ...
~    }:
~    flake-utils.lib.eachDefaultSystem (
~      system:
~      let
~        pkgs = import nixpkgs {
~          inherit system;
~          overlays = [ rust-overlay.overlays.default ];
~        };
~        toolchain = pkgs.rust-bin.stable.latest.default;
~        rustPlatform = pkgs.makeRustPlatform {
~          cargo = toolchain;
~          rustc = toolchain;
~        };
~
~        rev = self.shortRev or self.dirtyShortRev or &quot;dirty&quot;;
~        date = self.lastModifiedDate or self.lastModified or &quot;19700101&quot;;
~        version =
~          (builtins.fromTOML (builtins.readFile ./yazi-fm/Cargo.toml)).package.version
~          + &quot;pre${builtins.substring 0 8 date}_${rev}&quot;;
~      in
      {
        packages = {
          yazi-unwrapped = pkgs.callPackage ./nix/yazi-unwrapped.nix {
            inherit
              version
              rev
              date
              rustPlatform
              ;
          };
          yazi = pkgs.callPackage ./nix/yazi.nix { inherit (self.packages.${system}) yazi-unwrapped; };
          default = self.packages.${system}.yazi;
        };

~        devShells = {
~          default = pkgs.callPackage ./nix/shell.nix { };
~        };
~
~        formatter = pkgs.nixfmt-rfc-style;
~      }
~    )
~    // {
~      overlays = {
~        default = self.overlays.yazi;
~        yazi = _: prev: { inherit (self.packages.${prev.stdenv.system}) yazi yazi-unwrapped; };
~      };
~    };
~}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case using &lt;code&gt;inputs.yazi.packages.${pkgs.system}.yazi&lt;/code&gt; would also work&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;yazi = pkgs.callPackage ./nix/yazi.nix { inherit (self.packages.${system}) yazi-unwrapped; };&lt;/code&gt;
This line defines the yazi variable (or, more precisely, creates an attribute
named yazi within the &lt;code&gt;packages.${system}&lt;/code&gt; set). It assigns to this yazi
attribute the result of calling the Nix expression in &lt;code&gt;./nix/yazi.nix&lt;/code&gt; with
yazi-unwrapped as an argument. This yazi attribute represents the actual,
runnable Yazi package.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;default = self.packages.${system}.yazi;&lt;/code&gt; This line then aliases the yazi
package. It creates another attribute named &lt;code&gt;default&lt;/code&gt; within the same
&lt;code&gt;packages.${system}&lt;/code&gt; set and points it directly to the yazi attribute that was
just defined.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;So, when you access &lt;code&gt;inputs.yazi.packages.${pkgs.system}.default&lt;/code&gt;, you‚Äôre
effectively following the alias to the yazi package.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The choice to use &lt;code&gt;.default&lt;/code&gt; is primarily for convenience and adherence to a
common flake convention, making the flake easier for users to consume without
needing to dive into its internal structure.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><title>Flake outputs</title><id>https://saylesss88.github.io/flakes/flake_outputs_4.2.html</id><updated>2025-11-28T00:00:00+00:00</updated><link href="https://saylesss88.github.io/flakes/flake_outputs_4.2.html" rel="alternate"/><content type="html">&lt;h1&gt;Nix Flake Outputs&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;p&gt;Flake outputs are what the flake produces when built. Flakes can have multiple
outputs simultaneously such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Packages&lt;/strong&gt;: Self-contained bundles that are built using derivations and
provide either some kind of software or dependencies of software.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://saylesss88.github.io/NixOS_Modules_Explained_3.html&quot;&gt;NixOS modules&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nix development environments&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NixOS/templates&quot;&gt;Nix templates&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;outputs&lt;/code&gt; top-level attribute is actually a function that takes an
attribute set of inputs and returns an attribute set that is essentially a
recipe for building the flake.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Output Schema&lt;/h2&gt;
&lt;p&gt;Once the inputs are resolved, they‚Äôre passed to the &lt;code&gt;outputs&lt;/code&gt; attribute. This
&lt;code&gt;outputs&lt;/code&gt; attribute is, in fact, a function, as indicated by the &lt;code&gt;:&lt;/code&gt; colon (or
the &lt;code&gt;lambda&lt;/code&gt; syntax) that follows its definition. This function takes the
resolved inputs (and &lt;code&gt;self&lt;/code&gt;, the flake‚Äôs directory in the store) as arguments,
and its return value dictates the outputs of the flake, following this schema:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{ self, nixpkgs, ... }@inputs:
{
  # Executed by `nix flake check`
  checks.&quot;&amp;lt;system&amp;gt;&quot;.&quot;&amp;lt;name&amp;gt;&quot; = derivation;
  # Executed by `nix build .#&amp;lt;name&amp;gt;`
  packages.&quot;&amp;lt;system&amp;gt;&quot;.&quot;&amp;lt;name&amp;gt;&quot; = derivation;
  # Executed by `nix build .`
  packages.&quot;&amp;lt;system&amp;gt;&quot;.default = derivation;
  # Executed by `nix run .#&amp;lt;name&amp;gt;`
  apps.&quot;&amp;lt;system&amp;gt;&quot;.&quot;&amp;lt;name&amp;gt;&quot; = {
    type = &quot;app&quot;;
    program = &quot;&amp;lt;store-path&amp;gt;&quot;;
  };
  # Executed by `nix run . -- &amp;lt;args?&amp;gt;`
  apps.&quot;&amp;lt;system&amp;gt;&quot;.default = { type = &quot;app&quot;; program = &quot;...&quot;; };

  # Formatter (alejandra, nixfmt or nixpkgs-fmt)
  formatter.&quot;&amp;lt;system&amp;gt;&quot; = derivation;
  # Used for nixpkgs packages, also accessible via `nix build .#&amp;lt;name&amp;gt;`
  legacyPackages.&quot;&amp;lt;system&amp;gt;&quot;.&quot;&amp;lt;name&amp;gt;&quot; = derivation;
  # Overlay, consumed by other flakes
  overlays.&quot;&amp;lt;name&amp;gt;&quot; = final: prev: { };
  # Default overlay
  overlays.default = final: prev: { };
  # Nixos module, consumed by other flakes
  nixosModules.&quot;&amp;lt;name&amp;gt;&quot; = { config, ... }: { options = {}; config = {}; };
  # Default module
  nixosModules.default = { config, ... }: { options = {}; config = {}; };
  # Used with `nixos-rebuild switch --flake .#&amp;lt;hostname&amp;gt;`
  # nixosConfigurations.&quot;&amp;lt;hostname&amp;gt;&quot;.config.system.build.toplevel must be a derivation
  nixosConfigurations.&quot;&amp;lt;hostname&amp;gt;&quot; = {};
  # Used by `nix develop .#&amp;lt;name&amp;gt;`
  devShells.&quot;&amp;lt;system&amp;gt;&quot;.&quot;&amp;lt;name&amp;gt;&quot; = derivation;
  # Used by `nix develop`
  devShells.&quot;&amp;lt;system&amp;gt;&quot;.default = derivation;
  # Hydra build jobs
  hydraJobs.&quot;&amp;lt;attr&amp;gt;&quot;.&quot;&amp;lt;system&amp;gt;&quot; = derivation;
  # Used by `nix flake init -t &amp;lt;flake&amp;gt;#&amp;lt;name&amp;gt;`
  templates.&quot;&amp;lt;name&amp;gt;&quot; = {
    path = &quot;&amp;lt;store-path&amp;gt;&quot;;
    description = &quot;template description goes here?&quot;;
  };
  # Used by `nix flake init -t &amp;lt;flake&amp;gt;`
  templates.default = { path = &quot;&amp;lt;store-path&amp;gt;&quot;; description = &quot;&quot;; };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first line &lt;code&gt;{ self, nixpkgs, ... }@ inputs:&lt;/code&gt; defines the functions
parameters: It‚Äôs important to understand that within the scope of the &lt;code&gt;outputs&lt;/code&gt;
function &lt;code&gt;nixpkgs&lt;/code&gt; is available at the top-level because we explicitly passed it
as an argument but for individual modules outside this flake the scope is lost,
and you need to use &lt;code&gt;inputs.nixpkgs&lt;/code&gt; (or equivalent)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;It explicitly names the &lt;code&gt;self&lt;/code&gt; attribute, making it directly accessible. The
variadic &lt;code&gt;...&lt;/code&gt; ellipses part of the function signature is what allows all
your flake inputs to be brought into the function‚Äôs scope without having to
list each one explicitly.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It destructures all other attributes (your defined &lt;code&gt;inputs&lt;/code&gt;) into the
functions scope.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It gives you a convenient single variable, &lt;code&gt;inputs&lt;/code&gt;, that refers to the
entire attribute set passed to the &lt;code&gt;outputs&lt;/code&gt; function. This allows you to
access inputs either individually (e.g. &lt;code&gt;nixpkgs&lt;/code&gt;) or through the &lt;code&gt;inputs&lt;/code&gt;
variable (e.g. &lt;code&gt;inputs.nixpkgs&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You can also define additional arbitrary attributes, but these are the outputs
that Nix knows about.&lt;/p&gt;
&lt;p&gt;As you can see, the majority of the outputs within the outputs schema expect a
derivation. This means that for packages, applications, formatters, checks, and
development shells, you‚Äôll be defining a Nix derivation‚Äîa set of instructions
that tells Nix how to build a particular software component. This is central to
Nix‚Äôs declarative nature.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The command &lt;code&gt;nix flake show&lt;/code&gt;, takes a flake URI and prints all the outputs of
the flake as a nice tree structure, mapping attribute paths to the types of
values.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Ôåì  ~/players/third  3s
‚ùØ nix flake show
path:/home/jr/players/third?lastModified=1748272555&amp;amp;narHash=sha256-oNzkC6X9hA0MpOBmJSZ89w4znXxv4Q5EkFhp0ewehY0%3D
‚îú‚îÄ‚îÄ‚îÄnixosConfigurations
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄtesting: NixOS configuration
‚îî‚îÄ‚îÄ‚îÄnixosModules
    ‚îî‚îÄ‚îÄ‚îÄdefault: NixOS module
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To show you the structure of this little flake project:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Ôåì  ~/players
‚ùØ tree
Óóø .
‚îú‚îÄ‚îÄ Óóø first
‚îÇ   ‚îú‚îÄ‚îÄ Ôåì flake.lock
‚îÇ   ‚îú‚îÄ‚îÄ Ôåì flake.nix
‚îÇ   ‚îî‚îÄ‚îÄ Óóø result -&amp;gt; /nix/store/701vyaanmqchd2nnaq71y65v8ws11zx0-nixos-system-nixos-24.11.20250523.f09dede
‚îú‚îÄ‚îÄ Óóø second
‚îÇ   ‚îú‚îÄ‚îÄ Ôåì flake.lock
‚îÇ   ‚îî‚îÄ‚îÄ Ôåì flake.nix
‚îî‚îÄ‚îÄ Óóø third
    ‚îú‚îÄ‚îÄ Ôåì flake.lock
    ‚îú‚îÄ‚îÄ Ôåì flake.nix
    ‚îî‚îÄ‚îÄ Óóø result -&amp;gt; /nix/store/mlszr5ws3xaly8m4q9jslgs31w6w76y2-nixos-system-nixos-24.11.20250523.f09dede
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Simple Example providing an output&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# flake.nix
{
  outputs = { self }: {
    bada = &quot;bing&quot;;
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can then evaluate this specific output using &lt;code&gt;nix eval&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix eval .#bada
&quot;bing&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Outputs understood by Nix&lt;/h2&gt;
&lt;p&gt;While the attribute set that &lt;code&gt;outputs&lt;/code&gt; returns may contain arbitrary attributes,
meaning any valid Nix value. Some of the standard outputs are understood by
various &lt;code&gt;nix&lt;/code&gt; utilities. &lt;code&gt;packages&lt;/code&gt; is one of these:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# flake.nix
{
  inputs = {
    nixpkgs.url = &quot;github:nixos/nixpkgs&quot;;
  };

  outputs = { self, nixpkgs }: {
    # this is the re-exporting part!
    packages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello;
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Re-exporting happens when you take the value of &lt;code&gt;hello&lt;/code&gt; in its standard
derivation format, exactly as &lt;code&gt;nixpkgs&lt;/code&gt; produces it and assign it to an
attribute in your own flake‚Äôs outputs.
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;packages.x86_64-linux.hello&lt;/code&gt;(your flake‚Äôs output path) &lt;code&gt;=&lt;/code&gt;
&lt;code&gt; nixpkgs.legacyPackages.x86_64-linux.hello&lt;/code&gt;(the source from the &lt;code&gt;nixpkgs&lt;/code&gt;
flake‚Äôs output)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We‚Äôre saying, My flakes &lt;code&gt;hello&lt;/code&gt; package is exactly the same as the &lt;code&gt;hello&lt;/code&gt;
package found inside the &lt;code&gt;nixpkgs&lt;/code&gt; input flake.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It‚Äôs important to understand that within the scope of the &lt;code&gt;outputs&lt;/code&gt; function
(i.e. within your flake), &lt;code&gt;nixpkgs&lt;/code&gt; is available at the top-level (i.e. the
&lt;code&gt;= nixpkgs&lt;/code&gt; part) because we explicitly passed it as an argument but for
individual modules outside of this flake the scope is lost, and
&lt;code&gt;inputs.nixpkgs&lt;/code&gt; is needed.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following command builds the reexported package:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix build .#hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or run it with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix run .#hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You might notice &lt;code&gt;x86_64-linux&lt;/code&gt; appearing in the package path, and there‚Äôs a
good reason for it. Flakes are designed to provide &lt;em&gt;hermetic evaluation&lt;/em&gt;,
meaning their outputs should be identical regardless of the environment where
they‚Äôre built. A key factor in any build system is the platform (which combines
the architecture and operating system, like &lt;code&gt;x86_64-linux&lt;/code&gt; or &lt;code&gt;aarch64-darwin&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Because of Nix‚Äôs commitment to reproducibility across different systems, any
flake output that involves building software packages must explicitly specify
the platform. The standard approach is to structure these outputs as an
attribute set where the names are platforms, and the values are the outputs
specific to that platform. For the packages output, each platform-specific value
is itself an attribute set containing the various packages built for that
particular system.&lt;/p&gt;
&lt;h2&gt;Exporting Functions&lt;/h2&gt;
&lt;p&gt;This example outputs a &lt;code&gt;sayGoodbye&lt;/code&gt; function, via the &lt;code&gt;lib&lt;/code&gt; attribute, that
takes a name for its input and outputs a string saying Goodbye very nicely to
the person with that name:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{
  outputs = { self }: {
    lib = {
      sayGoodbye = name: &quot;Goodbye F*** Off, ${name}!&quot;;
    };
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You could then specify this flake as an input to another flake and use
&lt;code&gt;sayGoodbye&lt;/code&gt; however you‚Äôd like.&lt;/p&gt;
&lt;p&gt;Or load it into the &lt;code&gt;nix repl&lt;/code&gt; like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix repl
nix-repl&amp;gt; :lf .
nix-repl&amp;gt; lib.sayGoodbye
¬´lambda sayGoodbye @ /nix/store/665rwfvkwdx6kwvk9ldijp2a6jvcgv1n-source/flake.nix:4:20¬ª
nix-repl&amp;gt; lib.sayGoodbye &quot;Jr&quot;
&quot;Goodbye F*** Off, Jr!&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;As you can see, specifying &lt;code&gt;lib.sayGoodbye&lt;/code&gt; without any arguments returns a
function. (a lambda function)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Simplifying Multi-Platform Outputs with flake-utils&lt;/h2&gt;
&lt;p&gt;Manually repeating these platform definitions for every output (&lt;code&gt;packages&lt;/code&gt;,
&lt;code&gt;devShells&lt;/code&gt;, &lt;code&gt;checks&lt;/code&gt;, etc.) can quickly become verbose. This is where the
flake-utils helper flake comes in handy. It provides utilities to reduce
boilerplate when defining outputs for multiple systems.&lt;/p&gt;
&lt;p&gt;A commonly used function is &lt;code&gt;flake-utils.lib.eachDefaultSystem&lt;/code&gt;, which
automatically generates outputs for common platforms (like &lt;code&gt;x86_64-linux&lt;/code&gt;,
&lt;code&gt;aarch64-linux&lt;/code&gt;, &lt;code&gt;x86_64-darwin&lt;/code&gt;, &lt;code&gt;aarch64-darwin&lt;/code&gt;). This transforms your
outputs definition from manually listing each system to a more concise
structure:&lt;/p&gt;
&lt;h1&gt;Example using flake-utils&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{
  inputs = {
    nixpkgs.url = &quot;github:NixOS/nixpkgs/nixos-unstable&quot;;
    flake-utils.url = &quot;github:numtide/flake-utils&quot;; # Don&apos;t forget to add flake-utils to inputs!
  };

  outputs = {
    self,
    nixpkgs,
    flake-utils,
    ...
  }:
    flake-utils.lib.eachDefaultSystem (
      system: let
        pkgs = import nixpkgs {inherit system;};
      in {
        packages.hello = pkgs.hello; # Now directly defines &apos;hello&apos; for the current &apos;system&apos; # packages.default = self.packages.${system}.hello; # Optional default alias
        devShells.default = pkgs.mkShell {
          packages = [pkgs.hello];
        };
      }
    );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This flake-utils pattern is particularly useful for defining consistent
development environments across platforms, which can then be activated simply
by running &lt;code&gt;nix develop&lt;/code&gt; in the flake‚Äôs directory.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Adding Formatter, Checks, and Devshell Outputs&lt;/h3&gt;
&lt;p&gt;This is a minimal flake for demonstration with a hardcoded &lt;code&gt;system&lt;/code&gt;, for more
portability:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{
  description = &quot;NixOS configuration&quot;;

  inputs = {
    nixpkgs.url = &quot;github:nixos/nixpkgs/nixos-unstable&quot;;
    home-manager.url = &quot;github:nix-community/home-manager&quot;;
    home-manager.inputs.nixpkgs.follows = &quot;nixpkgs&quot;;
    treefmt-nix.url = &quot;github:numtide/treefmt-nix&quot;;
   };

  outputs = inputs@{ nixpkgs, home-manager, treefmt-nix, ... }: let

    system = &quot;x86_64-linux&quot;;
    host = &quot;your-hostname-goes-here&quot;;
      # Define pkgs with allowUnfree
    pkgs = import inputs.nixpkgs {
      inherit system;
      config.allowUnfree = true;
    };

        # Formatter configuration
    treefmtEval = treefmt-nix.lib.evalModule pkgs ./lib/treefmt.nix;

in {

    formatter.${system} = treefmtEval.config.build.wrapper;

    # Style check for CI
    checks.${system}.style = treefmtEval.config.build.check self;

    # Development shell
    devShells.${system}.default = import ./lib/dev-shell.nix {
      inherit inputs;
    };


    nixosConfigurations = {
      hostname = nixpkgs.lib.nixosSystem {
        system = &quot;x86_64-linux&quot;;
        modules = [
          ./configuration.nix
          home-manager.nixosModules.home-manager
          {
            home-manager.useGlobalPkgs = true;
            home-manager.useUserPackages = true;
            home-manager.users.jdoe = ./home.nix;

            # Optionally, use home-manager.extraSpecialArgs to pass
            # arguments to home.nix
          }
        ];
      };
    };
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in &lt;code&gt;lib/treefmt.nix&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# treefmt.nix
{
  projectRootFile = &quot;flake.nix&quot;;
  programs = {
    alejandra.enable = true;
    deadnix.enable = true;
    # rustfmt.enable = true;
    # shellcheck.enable = true;
    # prettier.enable = true;
    statix.enable = true;
    keep-sorted.enable = true;
    # nixfmt = {
    #   enable = true;
    #   # strict = true;
    # };
  };
  settings = {
    global.excludes = [
      &quot;LICENSE&quot;
      &quot;README.md&quot;
      &quot;.adr-dir&quot;
      &quot;nu_scripts&quot;
      # unsupported extensions
      &quot;*.{gif,png,svg,tape,mts,lock,mod,sum,toml,env,envrc,gitignore,sql,conf,pem,*.so.2,key,pub,py,narHash}&quot;
      &quot;data-mesher/test/networks/*&quot;
      &quot;nss-datamesher/test/dns.json&quot;
      &quot;*.age&quot;
      &quot;*.jpg&quot;
      &quot;*.nu&quot;
      &quot;*.png&quot;
      &quot;.jj/*&quot;
      &quot;Cargo.lock&quot;
      &quot;flake.lock&quot;
      &quot;hive/moonrise/borg-key-backup&quot;
      &quot;justfile&quot;
    ];
    formatter = {
      deadnix = {
        priority = 1;
      };
      statix = {
        priority = 2;
      };
      alejandra = {
        priority = 3;
      };
    };
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have a few commands available to us in our flake directory:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;nix fmt&lt;/code&gt;: Will format your whole configuration consistently&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;nix flake check&lt;/code&gt;: While this command was already available, it is now tied to
treefmt‚Äôs check which will check the style of your syntax and provide
suggestions.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And this is &lt;code&gt;lib/dev-shell.nix&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{
  inputs,
  system ? &quot;x86_64-linux&quot;,
}: let
  # Instantiate nixpkgs with the given system and allow unfree packages
  pkgs = import inputs.nixpkgs {
    inherit system;
    config.allowUnfree = true;
    overlays = [
      # Add overlays if needed, e.g., inputs.neovim-nightly-overlay.overlays.default
    ];
  };
in
  pkgs.mkShell {
    name = &quot;nixos-dev&quot;;
    packages = with pkgs; [
      # Nix tools
      nixfmt-rfc-style # Formatter
      deadnix # Dead code detection
      nixd # Nix language server
      nil # Alternative Nix language server
      nh # Nix helper
      nix-diff # Compare Nix derivations
      nix-tree # Visualize Nix dependencies

      # Code editing
      helix # Your editor

      # General utilities
      git
      ripgrep
      jq
      tree
    ];

    shellHook = &apos;&apos;
      echo &quot;Welcome to the NixOS development shell!&quot;
      echo &quot;System: ${system}&quot;
      echo &quot;Tools available: nixfmt, deadnix, nixd, nil, nh, nix-diff, nix-tree, helix, git, ripgrep, jq, tree&quot;
    &apos;&apos;;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you can run &lt;code&gt;nix develop&lt;/code&gt; in the flake directory and if successfull, you‚Äôll
see the &lt;code&gt;echo&lt;/code&gt; commands above and you will have all the tools available in your
environment without having to explicitly install them.&lt;/p&gt;
</content></entry><entry><title>Nix Pull Requests</title><id>https://saylesss88.github.io/Nix_Pull_Requests_11.html</id><updated>2025-11-27T00:00:00+00:00</updated><link href="https://saylesss88.github.io/Nix_Pull_Requests_11.html" rel="alternate"/><content type="html">&lt;h1&gt;Chapter 11&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;p&gt;&lt;img src=&quot;images/gruv16.png&quot; alt=&quot;gruv16&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Nix Pull Requests&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Pull requests&lt;/strong&gt; communicate changes to a branch in a repository. Once a pull
request is opened, you can review changes with collaborators and add follow-up
commits.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;strong&gt;pull request&lt;/strong&gt; is a proposal to merge a set of changes from one branch
into another. In a pull request, collaborators can review and discuss the
proposed set of changes before they integrate the changes into the main
codebase.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pull requests display the differences, or diffs, between the content in the
source branch and the content in the target branch.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph LR
    A[Your Local Repository] --&amp;gt; B(Feature Branch);
    B --&amp;gt; C{GitHub Repository};
    C -- &quot;Open Pull Request&quot; --&amp;gt; D[Pull Request on GitHub];
    D -- &quot;Review &amp;amp; Discussion&quot; --&amp;gt; D;
    D -- &quot;Merge&quot; --&amp;gt; E(Main Branch on GitHub);
    E --&amp;gt; F[Nixpkgs Users];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Explanation of the Diagram&lt;/strong&gt;:&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to see Explanation &lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;A[Your Local Repository]&lt;/strong&gt;: This represents the copy of the Nixpkgs repo on
your computer where you make changes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;B (Feature Branch)&lt;/strong&gt;: You create a dedicated branch (e.g.&lt;code&gt;my-pack-update&lt;/code&gt;)
to isolate your changes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;C {GitHub Repository}&lt;/strong&gt;: This is the central online repo for Nixpkgs on
Github. You push your feature branch to this repo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;C ‚Äì ‚ÄúOpen Pull Request‚Äù ‚Äì D [Pull Request on Github]&lt;/strong&gt;: You initiate a
pull request from your feature branch to the main branch (usually &lt;code&gt;master&lt;/code&gt; or
&lt;code&gt;main&lt;/code&gt;) through the GitHub interface.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;D [Pull Request on GitHub]&lt;/strong&gt;: This is where collaborators can see your
proposed changes, discuss them, and provide feedback.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;D ‚Äì ‚ÄúReview &amp;amp; Discussion‚Äù ‚Äì&amp;gt; D&lt;/strong&gt;: The pull request facilitates
communication and potential revisions based on the review.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;D ‚Äì ‚ÄúMerge‚Äù ‚Äì&amp;gt; E (Main Branch on GitHub)&lt;/strong&gt;: Once the changes are approved,
they are merged into the main branch of the Nixpkgs repository.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;E (Main Branch on GitHub)&lt;/strong&gt;: The main branch now contains the integrated
changes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;E ‚Äì&amp;gt; F [Nixpkgs Users]&lt;/strong&gt;): Eventually, these changes become available to
all Nixpkgs users through updates to their Nix installations.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;p&gt;Flakes often rely on having access to the full history of the Git repository to
correctly determine dependencies, identify specific revisions of inputs, and
evaluate the flake. Not in all situations will a shallow clone work and this is
one of them.&lt;/p&gt;
&lt;p&gt;If you have any changes to your local copy of Nixpkgs make sure to stash them
before the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git stash -u
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This command saves your uncommited changes (including staged files)
temporarily. You can restore them later with &lt;code&gt;git stash pop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Step 1 Clone Nixpkgs Locally&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you don‚Äôt have Nixpkgs locally, you‚Äôll need to clone it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git clone https://github.com/NixOS/nixpkgs.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Step 2 Find a Relevant Pull Request&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To find specifig commits and releases:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://status.nixos.org/&quot;&gt;status.nixos.org&lt;/a&gt; provides the latest tested commits
for each release - use when pinning to specific commits. List of active release
channels - use when tracking latest channel versions.&lt;/p&gt;
&lt;p&gt;The complete list of channels is available at
&lt;a href=&quot;https://channels.nixos.org/&quot;&gt;nixos.org/channels&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To find a relevant PR you can go to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NixOS/nixpkgs/pulls&quot;&gt;Nixpkgs Pull Requests&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The following example actually uses the
&lt;a href=&quot;https://github.com/NixOS/nix/pulls&quot;&gt;Nix Pull Requests&lt;/a&gt; the process is the
same, but that is an important distinction.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the Filters enter &lt;code&gt;stack trace&lt;/code&gt; for this example.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The pull request I chose was &lt;a href=&quot;https://github.com/nixos/nix/pull/8623&quot;&gt;8623&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Step 3 Add the Remote Repository (if necessary)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If the pull request is from a different repository than your local clone (as in
the case of the &lt;code&gt;nix&lt;/code&gt; PR while working in a &lt;code&gt;nixpkgs&lt;/code&gt; clone), you need to add
that repository as a remote. It‚Äôs common to name the main Nixpkgs remote
&lt;code&gt;origin&lt;/code&gt; and other related repositories like &lt;code&gt;nix&lt;/code&gt; as &lt;code&gt;upstream&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Assuming you are in your &lt;code&gt;nixpkgs&lt;/code&gt; clone and want to test a PR from the &lt;code&gt;nix&lt;/code&gt;
repository:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git remote add upstream https://github.com/NixOS/nix.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Step 4 Fetch the Pull Request Changes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fetch the Pull Request Information:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git fetch upstream refs/pull/8623/head:pr-8623
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This command fetches the branch named &lt;code&gt;head&lt;/code&gt; from the pull request &lt;code&gt;8623&lt;/code&gt; in
the &lt;code&gt;upstream&lt;/code&gt; remote and creates a local branch named &lt;code&gt;pr-8623&lt;/code&gt; that tracks
it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;:&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Output (Click to Enlarge) &lt;/summary&gt;
&lt;pre&gt;&lt;code&gt;remote: Enumerating objects: 104651, done.
remote: Counting objects: 100% (45/45), done.
remote: Compressing objects: 100% (27/27), done.
remote: Total 104651 (delta 33), reused 20 (delta 18), pack-reused 104606 (from 1)
Receiving objects: 100% (104651/104651), 61.64 MiB | 12.56 MiB/s, done.
Resolving deltas: 100% (74755/74755), done.
From https://github.com/NixOS/nix
 * [new ref]             refs/pull/8623/head -&amp;gt; pr-8623
 * [new tag]             1.0                 -&amp;gt; 1.0
 * [new tag]             1.1                 -&amp;gt; 1.1
 * [new tag]             1.10                -&amp;gt; 1.10
 * [new tag]             1.11                -&amp;gt; 1.11
 * [new tag]             1.11.1              -&amp;gt; 1.11.1
 * [new tag]             1.2                 -&amp;gt; 1.2
 * [new tag]             1.3                 -&amp;gt; 1.3
 * [new tag]             1.4                 -&amp;gt; 1.4
 * [new tag]             1.5                 -&amp;gt; 1.5
 * [new tag]             1.5.1               -&amp;gt; 1.5.1
 * [new tag]             1.5.2               -&amp;gt; 1.5.2
 * [new tag]             1.5.3               -&amp;gt; 1.5.3
 * [new tag]             1.6                 -&amp;gt; 1.6
 * [new tag]             1.6.1               -&amp;gt; 1.6.1
 * [new tag]             1.7                 -&amp;gt; 1.7
 * [new tag]             1.8                 -&amp;gt; 1.8
 * [new tag]             1.9                 -&amp;gt; 1.9
 * [new tag]             2.0                 -&amp;gt; 2.0
 * [new tag]             2.2                 -&amp;gt; 2.2
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;p&gt;&lt;strong&gt;Step 5 Checkout the Local Branch:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git checkout pr-8623
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or with the &lt;code&gt;gh&lt;/code&gt; cli:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gh pr checkout 8623
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Build and Test the Changes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Now we want to see if the code changes introduced by the pull request actually
build correctly within the Nix ecosystem.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Output (Click to Enlarge) &lt;/summary&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;error: builder for &apos;/nix/store/rk86daqgf6a9v6pdx6vcc5b580lr9f09-nix-2.20.0pre20240115_20b4959.drv&apos; failed with exit code 2;
   last 25 log lines:
   &amp;gt;
   &amp;gt;         _NIX_TEST_ACCEPT=1 make tests/functional/lang.sh.test
   &amp;gt;
   &amp;gt;     to regenerate the files containing the expected output,
   &amp;gt;     and then view the git diff to decide whether a change is
   &amp;gt;     good/intentional or bad/unintentional.
   &amp;gt;     If the diff contains arbitrary or impure information,
   &amp;gt;     please improve the normalization that the test applies to the output.
   &amp;gt; make: *** [mk/lib.mk:90: tests/functional/lang.sh.test] Error 1
   &amp;gt; make: *** Waiting for unfinished jobs....
   &amp;gt; ran test tests/functional/selfref-gc.sh... [PASS]
   &amp;gt; ran test tests/functional/store-info.sh... [PASS]
   &amp;gt; ran test tests/functional/suggestions.sh... [PASS]
   &amp;gt; ran test tests/functional/path-from-hash-part.sh... [PASS]
   &amp;gt; ran test tests/functional/gc-auto.sh... [PASS]
   &amp;gt; ran test tests/functional/path-info.sh... [PASS]
   &amp;gt; ran test tests/functional/flakes/show.sh... [PASS]
   &amp;gt; ran test tests/functional/fetchClosure.sh... [PASS]
   &amp;gt; ran test tests/functional/completions.sh... [PASS]
   &amp;gt; ran test tests/functional/build.sh... [PASS]
   &amp;gt; ran test tests/functional/impure-derivations.sh... [PASS]
   &amp;gt; ran test tests/functional/build-delete.sh... [PASS]
   &amp;gt; ran test tests/functional/build-remote-trustless-should-fail-0.sh... [PASS]
   &amp;gt; ran test tests/functional/build-remote-trustless-should-pass-2.sh... [PASS]
   &amp;gt; ran test tests/functional/nix-profile.sh... [PASS]
   For full logs, run:
     nix log /nix/store/rk86daqgf6a9v6pdx6vcc5b580lr9f09-nix-2.20.0pre20240115_20b4959.drv
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;nix build&lt;/code&gt;&lt;/strong&gt; (Part of the Nix Unified CLI):
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Declarative: when used within a Nix flake (&lt;code&gt;flake.nix&lt;/code&gt;), &lt;code&gt;nix build&lt;/code&gt; is a
bit more declarative. It understands the outputs defined in your flake.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clearer Output Paths: &lt;code&gt;nix build&lt;/code&gt; typically places build outputs in the
&lt;code&gt;./result&lt;/code&gt; directory by default (similar to &lt;code&gt;nix-build&lt;/code&gt;‚Äôs &lt;code&gt;result&lt;/code&gt; symlink)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Better Error Reporting: It gives more informative error messages.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Future Direction&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Benefits of using &lt;code&gt;nix build&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Flake Integration:&lt;/strong&gt; &lt;code&gt;nix build&lt;/code&gt; naturally understands the flake‚Äôs outputs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Development Shells:&lt;/strong&gt; When you are in a &lt;code&gt;nix develop&lt;/code&gt; shell, &lt;code&gt;nix build&lt;/code&gt; is
the more idiomatic way to build packages defined in your dev environment.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Consistency:&lt;/strong&gt; Using the unified CLI promotes a more consistent workflow.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;As you can see this build failed, as for why the build failed, the key part of
the error message is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;make: *** [mk/lib.mk:90: tests/functional/lang.sh.test] Error 1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This suggests that one of the functional tests (&lt;code&gt;lang.sh.test&lt;/code&gt;) failed. This
happens when the expected output of the test doesn‚Äôt match the actual output.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This can heppen when:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The test expectations are outdated due to changes in the codebase.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The test captures environment-specific or transient outputs that are not
properly normalized.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The test includes impure or non-deterministic information, making it hard to
verify.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To address this, _NIX_TEST_ACCEPT=1 is used as an override mechanism that tells
the test framework: &amp;gt; ‚ÄúAccept whatever output is generated as the new expected
result.‚Äù&lt;/p&gt;
&lt;p&gt;The message advises running:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;_NIX_TEST_ACCEPT=1 make tests/functional/lang.sh.test
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This will regenerate the expected output files, allowing you to inspect what
changed with &lt;code&gt;git diff&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git diff tests/functional/lang.sh.test
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Verifies if Changes are Intentional:&lt;/strong&gt; If the difference is reasonable and
expected (due to a legitimate update in the logic), you can commit these
changes to update the test suit. If not, you have to refine the test
normalization process further.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If the changes seem valid, commit them:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git add tests/functional/lang.sh.test
git commit -m &quot;Update expected test output for lang.sh.test&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running the following will provide the full logs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix log /nix/store/rk86daqgf6a9v6pdx6vcc5b580lr9f09-nix-2.20.0pre20240115_20b4959.drv
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Testing Nixpkgs pull requests is a vital part of contributing to a healthy and
reliable Nix ecosystem. By following these steps, you can help ensure that
changes are well-vetted before being merged, ultimately benefiting all Nix
users. Your efforts in testing contribute significantly to the quality and
stability of Nixpkgs.&lt;/p&gt;
</content></entry><entry><title>Unencrypted BTRFS Impermanence with Flakes</title><id>https://saylesss88.github.io/installation/unenc/unenc_impermanence.html</id><updated>2025-11-24T00:00:00+00:00</updated><link href="https://saylesss88.github.io/installation/unenc/unenc_impermanence.html" rel="alternate"/><content type="html">&lt;h1&gt;Unencrypted BTRFS Impermanence with Flakes&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;p&gt;Figure 1: Impermanence Logo: Image of the Impermanence logo. Sourced from the&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nix-community/impermanence&quot;&gt;Impermanence repo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This guide is for an unencrypted setup, there are a few links at the end for
encrypted setups. This guide follows the previous
&lt;a href=&quot;https://saylesss88.github.io/installation/unencrypted_setups.html&quot;&gt;minimal install guide&lt;/a&gt;
but you should be able to adjust it carefully to meet your needs.&lt;/p&gt;
&lt;p&gt;This section details how to set up impermanence on your NixOS system using BTRFS
subvolumes. With impermanence, your operating system‚Äôs root filesystem will
reset to a pristine state on each reboot, while designated directories and files
remain persistent. This provides a highly reliable and rollback-friendly system.&lt;/p&gt;
&lt;p&gt;In NixOS, ‚Äústate‚Äù is any data or condition of the system that isn‚Äôt defined in
your declarative configuration. The impermanence approach aims to make this
state temporary (ephemeral) or easily resettable, so your system always matches
your configuration and can recover from unwanted changes or corruption.&lt;/p&gt;
&lt;h2&gt;Impermanence: The Concept and Its BTRFS Implementation&lt;/h2&gt;
&lt;p&gt;In a traditional Linux system, most of this state is stored on the disk and
persists indefinitely unless manually deleted or modified. However, this can
lead to configuration drift, where the system accumulates changes (e.g., log
files, temporary files, or unintended configuration tweaks) that make it harder
to reproduce or maintain.&lt;/p&gt;
&lt;p&gt;Impermanence, in the context of operating systems, refers to a setup where the
majority of the system‚Äôs root filesystem (&lt;code&gt;/&lt;/code&gt;) is reset to a pristine state on
every reboot. This means any changes made to the system (e.g., installing new
packages, modifying system files outside of configuration management, creating
temporary files) are discarded upon shutdown or reboot.&lt;/p&gt;
&lt;h2&gt;What Does Impermanence Do?&lt;/h2&gt;
&lt;p&gt;Impermanence is a NixOS approach that makes the system stateless (or nearly
stateless) by wiping the root filesystem (&lt;code&gt;/&lt;/code&gt;) on each boot, ensuring a clean,
predictable starting point. Only explicitly designated data (persistent state)
is preserved across reboots, typically stored in specific locations like the
/nix/persist subvolume. This is possible because NixOS can boot with only the
&lt;code&gt;/boot&lt;/code&gt;, and &lt;code&gt;/nix&lt;/code&gt; directories. This achieves:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Clean Root Filesystem:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The root subvolume is deleted and recreated on each boot, erasing transient
state (e.g., temporary files, runtime data).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This ensures the system starts fresh, reducing clutter and making it behave
closer to a declarative system defined by your NixOS configuration.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Selective Persistence:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Critical state (e.g., user files, logs, system configuration) is preserved in
designated persistent subvolumes (e.g., /nix/persist, /var/log, /var/lib) or
files.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You control exactly what state persists by configuring
&lt;code&gt;environment.persistence.&quot;/nix/persist&quot;&lt;/code&gt; or other mechanisms.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;‚ùó The understanding around persisting &lt;code&gt;/var/lib/nixos&lt;/code&gt; seems to be evolving.
See,The importance of persisting &lt;code&gt;/var/lib/nixos&lt;/code&gt; See also necessary system
state&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Reproducibility and Security:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;By wiping transient state, impermanence prevents unintended changes from
accumulating, making the system more reproducible.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It enhances security by ensuring sensitive temporary data (e.g., /tmp, runtime
credentials) is erased on reboot.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Getting Started&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Add impermanence to your flake.nix. You will change the hostname in the flake
to match your networking.hostName.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# flake.nix
{
  description = &quot;NixOS configuration&quot;;

  inputs = {
    nixpkgs.url = &quot;github:nixos/nixpkgs/nixos-unstable&quot;;
    disko.url = &quot;github:nix-community/disko/latest&quot;;
    disko.inputs.nixpkgs.follows = &quot;nixpkgs&quot;;
    impermanence.url = &quot;github:nix-community/impermanence&quot;;
  };

  outputs = inputs@{ nixpkgs, ... }: {
    nixosConfigurations = {
      hostname = nixpkgs.lib.nixosSystem {
        system = &quot;x86_64-linux&quot;;
        modules = [
          ./configuration.nix
          inputs.disko.nixosModules.disko
          inputs.impermanence.nixosModules.impermanence
        ];
      };
    };
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Discover where your root subvolume is located with &lt;code&gt;findmnt&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Before configuring impermanence, it‚Äôs crucial to know the device path and
subvolume path of your main BTRFS partition where the root filesystem (/) is
located. This information is needed for the mount command within the
impermanence script.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;findmnt /
TARGET   SOURCE         FSTYPE OPTIONS
/        /dev/disk/by-partlabel/disk-main-root[/root]
                        btrfs  rw,noatime,compress=zstd:3,ssd,discard=async,space_cache=v2,subvolid=275,sub
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From the SOURCE column, note the full path, including the device (e.g.,
&lt;code&gt;/dev/disk/by-partlabel/disk-main-root&lt;/code&gt;) and the subvolume in brackets (e.g.,
&lt;code&gt;[/root]&lt;/code&gt;). You will use the device path in the next step&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/dev/disk/by-partlabel/disk-main-root&lt;/code&gt; is a symlink to the actual device path
(e.g. &lt;code&gt;/dev/nvme0n1p2&lt;/code&gt;), but using the partlabel is generally more robust for
scripts.&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Create an impermanence.nix:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now, create a new file named &lt;code&gt;impermanence.nix&lt;/code&gt; in your configuration directory
(i.e. your flake directory). This file will contain all the specific settings
for your impermanent setup, including BTRFS subvolume management and persistent
data locations. Since this file is right next to your &lt;code&gt;configuration.nix&lt;/code&gt;,
you‚Äôll just add an &lt;code&gt;imports = [ ./impermanence.nix&lt;/code&gt; ] to your
&lt;code&gt;configuration.nix&lt;/code&gt; apply it to your configuration.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{lib, ...}: {
  #  Reset root subvolume on boot
  boot.initrd.postResumeCommands = lib.mkAfter &apos;&apos;
    mkdir /btrfs_tmp
      mount /dev/disk/by-partlabel/disk-main-root /btrfs_tmp # CONFIRM THIS IS CORRECT FROM findmnt
      if [[ -e /btrfs_tmp/root ]]; then
        mkdir -p /btrfs_tmp/old_roots
        timestamp=$(date --date=&quot;@$(stat -c %Y /btrfs_tmp/root)&quot; &quot;+%Y-%m-%-d_%H:%M:%S&quot;)
        mv /btrfs_tmp/root &quot;/btrfs_tmp/old_roots/$timestamp&quot;
      fi

      delete_subvolume_recursively() {
        IFS=$&apos;\n&apos;
        for i in $(btrfs subvolume list -o &quot;$1&quot; | cut -f 9- -d &apos; &apos;); do
          delete_subvolume_recursively &quot;/btrfs_tmp/$i&quot;
        done
        btrfs subvolume delete &quot;$1&quot;
      }

      for i in $(find /btrfs_tmp/old_roots/ -maxdepth 1 -mtime +30); do
        delete_subvolume_recursively &quot;$i&quot;
      done

      btrfs subvolume create /btrfs_tmp/root
      umount /btrfs_tmp
  &apos;&apos;;

  # Use /persist as the persistence root, matching Disko&apos;s mountpoint
  environment.persistence.&quot;/nix/persist&quot; = {
    hideMounts = true;
    directories = [
      &quot;/etc&quot; # System configuration (Keep this here for persistence via bind-mount)
      &quot;/var/spool&quot; # Mail queues, cron jobs
      &quot;/srv&quot; # Web server data, etc.
      &quot;/root&quot;
    ];
    files = [
    ];
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With btrfs subvolumes since each directory is its own subvolume, when the root
is wiped on reboot the subvolumes are untouched.&lt;/p&gt;
&lt;h3&gt;Applying Your Impermanence Configuration&lt;/h3&gt;
&lt;p&gt;Once you have completed all the steps and created or modified the necessary
files (&lt;code&gt;flake.nix&lt;/code&gt;, &lt;code&gt;impermanence.nix&lt;/code&gt;), you need to apply these changes to your
NixOS system.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Navigate to your NixOS configuration directory (where your flake.nix is
located).&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd /path/to/your/flake
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Rebuild and Switch: Execute the &lt;code&gt;nixos-rebuild switch&lt;/code&gt; command. This command
will:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Evaluate your flake.nix and the modules it imports (including your new
impermanence.nix).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Build a new NixOS system closure based on your updated configuration.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Activate the new system configuration, making it the current running system.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ùó NOTE: On the first rebuild after setting up impermanence, you may find that
you‚Äôre not in the password database or cannot log in/sudo. This occurs because
the initial state of your new ephemeral root filesystem, including /etc (where
user passwords are stored), is fresh. It has to do with the timing of when
environment.persistence takes effect during the first boot.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;To avoid this password issue, before your first nixos-rebuild switch for
impermanence, run:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo mkdir -p /nix/persist/etc # Ensure the target directory exists
sudo cp -a /etc/* /nix/persist/etc
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This copies your current /etc directory contents (including existing user
passwords) into your persistent &amp;gt;&amp;gt;storage.&lt;/li&gt;
&lt;li&gt;Crucially: You must also ensure that &lt;code&gt;/etc&lt;/code&gt; is explicitly included in your
&lt;code&gt;environment.persistence.&quot;/nix/persist&quot;&lt;/code&gt;.directories list in your
&lt;code&gt;impermanence.nix&lt;/code&gt; like we did above, (or main configuration). This
configures &amp;gt;NixOS to persistently bind-mount &lt;code&gt;/nix/persist/etc&lt;/code&gt; over &lt;code&gt;/etc&lt;/code&gt;
on every subsequent boot. Once these steps are done and you reboot, your
user passwords should function correctly, and future rebuilds will &amp;gt; not
present this problem.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nixos-rebuild switch --flake .#hostname # Replace &apos;hostname&apos; with your actual system hostname
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Perform an Impermanence Test (Before Reboot):&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Before you reboot, create a temporary directory and file in a non-persistent
location. Since you haven‚Äôt explicitly added &lt;code&gt;/imperm_test&lt;/code&gt; to your
&lt;code&gt;environment.persistence.&quot;/nix/persist&quot;&lt;/code&gt; directories, this file should not
survive a reboot.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir /imperm_test
echo &quot;This should be Gone after Reboot&quot; | sudo tee /imperm_test/testfile
ls -l /imperm_test/testfile # Verify the file exists
cat /imperm_test/testfile # Verify content
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Reboot Your System: For the impermanence setup to take full effect and for
your root filesystem to be reset for the first time, you must reboot your
machine.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Verify Impermanence (After Reboot):&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;After the system has rebooted, check if the test directory and file still
exist:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ls -l /imperm_test/testfile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should see an output like &lt;code&gt;ls: cannot access &apos;/imperm_test/testfile&apos;&lt;/code&gt;: No
such file or directory. This confirms that the &lt;code&gt;/imperm_test&lt;/code&gt; directory and its
contents were indeed ephemeral and were removed during the reboot process,
indicating your impermanence setup is working correctly!&lt;/p&gt;
&lt;p&gt;Your system should now come up with a fresh root filesystem, and only the data
specified in your &lt;code&gt;environment.persistence.&quot;/nix/persist&quot;&lt;/code&gt; configuration will be
persistent.&lt;/p&gt;
&lt;h3&gt;Recovery with nixos-enter and chroot&lt;/h3&gt;
&lt;p&gt;This is if you followed the minimal_install guide, it will need to be changed
for a different disk layout.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Chroot&quot;&gt;Chroot&lt;/a&gt; is an operation that changes the
apparent root directory for the current running process and their children. A
program that is run in such a modified environment cannot access files and
commands outside that environmental directory tree. This modified environment is
called a chroot jail. ‚ÄìNixOS wiki&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nixos-enter&lt;/code&gt; allows you to access a NixOS installation from a NixOS rescue
system. To use, setup &lt;code&gt;/mnt&lt;/code&gt; as described in the
&lt;a href=&quot;https://nixos.org/manual/nixos/stable/#sec-installation&quot;&gt;installation manual&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;üõ†Ô∏è Recovery: Chroot into Your NixOS Btrfs+Impermanence System&lt;/p&gt;
&lt;p&gt;Take note of your layout from commands like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo fdisk -l
lsblk
sudo btrfs subvol list /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also inspect your &lt;code&gt;disk-config.nix&lt;/code&gt; to ensure you refer to the correct &lt;code&gt;subvol=&lt;/code&gt;
names.&lt;/p&gt;
&lt;p&gt;If you need to repair your system (e.g., forgot root password, fix a broken
config, etc.), follow these steps to chroot into your NixOS install:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Boot a Live ISO&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Boot from a NixOS (or any recent Linux) live USB.&lt;/p&gt;
&lt;p&gt;Open a terminal and become root:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo -i
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Identify Your Devices&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Your main disk is &lt;code&gt;/dev/nvme0n1&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;EFI partition: &lt;code&gt;/dev/nvme0n1p1&lt;/code&gt; (mounted at &lt;code&gt;/boot&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Root partition: &lt;code&gt;/dev/nvme0n1p2&lt;/code&gt; (Btrfs, with subvolumes)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Mount the Btrfs Root Subvolume&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;First, mount the Btrfs partition somewhere temporary (not as / yet):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mount -o subvol=root,compress=zstd,noatime /dev/nvme0n1p2 /mnt
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Mount Other Subvolumes&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now mount your other subvolumes as defined in your &lt;code&gt;disko.nix&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# Mount Other Subvolumes
# (Ensure /mnt directories are created for each *mountpoint*)

# Home
mkdir -p /mnt/home
mount -o subvol=home,compress=zstd,noatime /dev/nvme0n1p2 /mnt/home

# IMPORTANT: No separate mount for /mnt/home/user, as it&apos;s a nested subvolume
# and handled by the /home mount.

# Nix store
mkdir -p /mnt/nix
mount -o subvol=nix,compress=zstd,noatime /dev/nvme0n1p2 /mnt/nix

# Nix persist
mkdir -p /mnt/nix/persist
# CRITICAL: Based our disko.nix, the subvolume name is &apos;persist&apos;, not &apos;nix/persist&apos;
mount -o subvol=persist,compress=zstd,noatime /dev/nvme0n1p2 /mnt/nix/persist

# /var/log
mkdir -p /mnt/var/log
mount -o subvol=log,compress=zstd,noatime /dev/nvme0n1p2 /mnt/var/log

# /var/lib
mkdir -p /mnt/var/lib
# Confirmed: The subvolume named &apos;lib&apos; is mounted to /var/lib
mount -o subvol=lib,compress=zstd,noatime /dev/nvme0n1p2 /mnt/var/lib
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note: If you get ‚Äúsubvolume not found,‚Äù check the subvolume names with
&lt;code&gt;btrfs subvol list /mnt&lt;/code&gt;.&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Mount the EFI Partition&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir -p /mnt/boot mount /dev/nvme0n1p1 /mnt/boot
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;(Optional) Mount Virtual Filesystems&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mount --bind /dev /mnt/dev mount --bind /proc /mnt/proc mount --bind /sys
/mnt/sys mount --bind /run /mnt/run
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;Chroot&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;chroot /mnt /run/current-system/sw/bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or, if using a non-NixOS live system:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nixos-enter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(You may need to install nixos-enter with nix-shell -p nixos-enter.) 8. You‚Äôre
In!&lt;/p&gt;
&lt;p&gt;You can now run nixos-rebuild, reset passwords, or fix configs as needed. üîé&lt;/p&gt;
&lt;p&gt;üìì Notes&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Adjust &lt;code&gt;compress=zstd,noatime&lt;/code&gt; if your config uses different mount options.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For impermanence, make sure to mount all persistent subvolumes you need.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you use swap, you may want to enable it too (e.g., swapon /dev/zram0 if
relevant).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can now recover, repair, or maintain your NixOS system as needed!&lt;/p&gt;
&lt;h4&gt;Related Material&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.nixos.org/wiki/Change_root&quot;&gt;Change root (chroot&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mankier.com/8/nixos-enter&quot;&gt;nixos-enter&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://grahamc.com/blog/erase-your-darlings/&quot;&gt;erase your darlings&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://haseebmajid.dev/posts/2024-07-30-how-i-setup-btrfs-and-luks-on-nixos-using-disko/&quot;&gt;Guide for Btrfs with LUKS&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://notashelf.dev/posts/impermanence&quot;&gt;notashelf impermanence&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.nixos.org/wiki/Impermanence&quot;&gt;NixOS wiki Impermanence&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nix-community/impermanence&quot;&gt;nix-community impermanence module&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><title>NixOS Containers</title><id>https://saylesss88.github.io/nixos_containers.html</id><updated>2025-11-22T00:00:00+00:00</updated><link href="https://saylesss88.github.io/nixos_containers.html" rel="alternate"/><content type="html">&lt;h1&gt;NixOS Containers&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;p&gt;&lt;img src=&quot;images/boxes.cleaned.png&quot; alt=&quot;boxes&quot; /&gt;&lt;/p&gt;
&lt;p&gt;NixOS containers are lightweight &lt;code&gt;systemd-nspawn&lt;/code&gt; containers managed
declaratively through your NixOS configuration. They allow you to run separate,
minimal NixOS instances on the same machine, each with its own services,
packages, and (optionally) network stack.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ùó NixOS‚Äô containers do not provide full security out of the box (just like
docker). They do give you a separate chroot, but a privileged user (root) in a
container can escape the container and become root on the host system.
‚Äì&lt;a href=&quot;https://blog.beardhatcode.be/2020/12/Declarative-Nixos-Containers.html&quot;&gt;beardhatcode Declarative-Nixos-Containers&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Common Use Cases&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Isolating services&lt;/strong&gt;: Run a web server, database, or any service in its own
container, so it can‚Äôt interfere with the main system or other services&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Testing and development&lt;/strong&gt;: Try out new configurations, packages, or services
in a sandboxed environment.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reproducible deployments&lt;/strong&gt;: Because containers are defined declaratively,
you can reproduce the exact same environment anywhere.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Running multiple versions of a service&lt;/strong&gt;: For example, testing different
versions of Git or HTTP servers side by side.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Hosting mdbook&lt;/h2&gt;
&lt;p&gt;Let‚Äôs say you want to host your mdBook. You can define a NixOS container that
runs only the necessary service, isolated from your main system:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{
  config,
  lib,
  ...
}: {
  containers.mdbook-host = {
    autoStart = true;
    ephemeral = true;
    privateNetwork = false;  # Use the hosts network

    bindMounts.&quot;/var/www/mdbook&quot; = {
      hostPath = &quot;/home/jr/nix-book/book&quot;;
      isReadOnly = true;
    };

    config = {containerPkgs, ...}: {
      networking.useDHCP = lib.mkDefault true;

      services.httpd = {
        enable = true;
        adminAddr = &quot;yourEmail.com&quot;;
        virtualHosts.&quot;localhost&quot; = {
          documentRoot = &quot;/var/www/mdbook&quot;;
          serverAliases = [];
        };
      };

      networking.firewall.allowedTCPPorts = [80];
      environment.systemPackages = with containerPkgs; [];
      system.stateVersion = &quot;25.05&quot;;
    };
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ephemeral&lt;/code&gt;: if true, the container resets on each restart.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;autoStart&lt;/code&gt;: Ensures the container starts automatically at boot.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;config&lt;/code&gt;: Defines the containers NixOS configuration, just like a regular
NixOS system.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Mounts&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;    bindMounts.&quot;/var/www/mdbook&quot; = {
      hostPath = &quot;/home/jr/nix-book/book&quot;;
      isReadOnly = true;
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;bindMount&lt;/code&gt; settings above specify that &lt;code&gt;/var/www/mdbook&lt;/code&gt; in the container
should be linked to &lt;code&gt;/home/jr/nix-book/book&lt;/code&gt; on the host.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hostPath&lt;/code&gt; must exist, and &lt;code&gt;/var/www/mdbook&lt;/code&gt; must not exist for this to work.&lt;/p&gt;
&lt;p&gt;The above container is fairly simple because its &lt;code&gt;ReadOnly&lt;/code&gt;, things get more
complicated when you need HTTPD to have write privileges.&lt;/p&gt;
&lt;p&gt;When you create and run a NixOS container like &lt;code&gt;mdbook-host&lt;/code&gt;. NixOS stores the
container‚Äôs root filesystem and related container state data under:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ls /var/lib/nixos-containers/
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ empty list ‚îÇ  # It&apos;s empty because we set ephemeral to true
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This directory holds the container‚Äôs own filesystem image, including system
files, installed packages, configuration, and any data internal to the
container.&lt;/p&gt;
&lt;h2&gt;Check Container Status&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nixos-container list
mdbook-host
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo systemctl status container@mdbook-host
 Main PID: 32938 (systemd-nspawn)
     Status: &quot;Container running: Ready.&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Test HTTP server inside the container&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We configured Apache (&lt;code&gt;httpd&lt;/code&gt;) to serve &lt;code&gt;/var/www/mdbook&lt;/code&gt; at &lt;code&gt;localhost&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Let‚Äôs check if Apache is running:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nixos-container run mdbook-host -- systemctl status httpd
‚óè httpd.service - Apache HTTPD
     Loaded: loaded (/etc/systemd/system/httpd.service; enabled; preset: ignored)
     Active: active (running) since Fri 2025-08-15 10:14:39 EDT; 2min 18s ago
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check the Bind Mount:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nixos-container run mdbook-host -- ls -l /var/www/mdbook
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;You should see an &lt;code&gt;index.html&lt;/code&gt; and any other files from &lt;code&gt;~/nix-book/book&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Test the Web Server:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;curl http://localhost
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;You should see your book in HTTP format as raw HTML.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Test on the web, in your browser visit:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;http://localhost/
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;You should see your book fully served&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Troubleshooting&lt;/h3&gt;
&lt;p&gt;Make sure your book has the correct permissions to allow &lt;code&gt;hostPath&lt;/code&gt; to read it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo chmod -R o+rX ~/nix-book/book
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If needed restart the container:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nixos-container stop mdbook-host
sudo nixos-container start mdbook-host
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ensure that &lt;code&gt;/var/www/mdbook&lt;/code&gt; is being populated:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nixos-container run mdbook-host -- ls -l /var/www/mdbook
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should see an &lt;code&gt;index.html&lt;/code&gt; and more&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nixos-container run mdbook-host -- systemctl status httpd
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;You should see &lt;code&gt;enabled&lt;/code&gt; &amp;amp; &lt;code&gt;active (running)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check the containers status:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nixos-container status mdbook-host
up
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Why Bother Serving your book to localhost?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Real-time updates without rebuilding the container&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Files added, changed, or removed from &lt;code&gt;~/nix-book/book&lt;/code&gt; on the host are
immediately reflected inside the container. This allows for:
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Rapid iteration and testing of your books content without rebuilding&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Easier debugging and fixing content or config issues on the fly.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Keeps container images small and immutable&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Instead of baking book files into the container image (which requires
rebuilding every change), the container image remains clean and generic.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Separation of concerns&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;The container focuses on running the service, while the content is managed
independently on the host. This separation improves maintainability and more.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Data persistence&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Since the files live on the host, they persist independently of the containers
lifecycle: restarting, recreating, or destroying the container won‚Äôt lose your
content.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Security Control&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;You can carefully set permissions on the host directory, control read/write
access, and isolate the container runtime from sensitive data.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Removing the State&lt;/h2&gt;
&lt;p&gt;To remove &lt;code&gt;/var/lib/nixos-containers/mdbook-host&lt;/code&gt;, you need to remove the
container configuration, rebuild, and then run the following commands to remove
the immutable sticky bits that prevent deletion.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# Forcibly remove all attributes
sudo chattr -R -i mdbook-host/
sudo rm -rf mdbook-host/
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><title>Comparing Flakes and Traditional Nix</title><id>https://saylesss88.github.io/Comparing_Flakes_and_Traditional_Nix_8.html</id><updated>2025-11-22T00:00:00+00:00</updated><link href="https://saylesss88.github.io/Comparing_Flakes_and_Traditional_Nix_8.html" rel="alternate"/><content type="html">&lt;h1&gt;Chapter 8&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;!-- ![nixWinter](images/nixWinter.png) --&gt;
&lt;h2&gt;Comparing Flakes and Traditional Nix&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;This post is based on notes from Nix-Hour #4, comparing Traditional Nix and
Flakes, focusing on achieving pure build results. See the
&lt;a href=&quot;https://www.youtube.com/watch?v=atmoYyBAhF4&quot;&gt;YouTube video&lt;/a&gt; for the original
content. This guide adapts the information for clarity and ease of
understanding.&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;summary&gt; What is Purity in Nix? (click here) &lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A key benefit of Nix Flakes is their &lt;em&gt;default&lt;/em&gt; enforcement of &lt;strong&gt;pure
evaluation&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In Nix, an &lt;strong&gt;impure operation&lt;/strong&gt; depends on something &lt;em&gt;outside&lt;/em&gt; its explicit
inputs. Examples include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;User‚Äôs system configuration&lt;/li&gt;
&lt;li&gt;Environment variables&lt;/li&gt;
&lt;li&gt;Current time&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Impurity leads to unpredictable builds that may differ across systems or time.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;h2&gt;Building a Simple ‚Äúhello‚Äù Package: Flakes vs. Traditional Nix&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;We‚Äôll demonstrate building a basic ‚Äúhello‚Äù package using both Flakes and
Traditional Nix to highlight the differences in handling purity.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Using Nix Flakes&lt;/h2&gt;
&lt;details&gt;
&lt;summary&gt; Building Hello with Flakes (click here) &lt;/summary&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Setup:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir hello &amp;amp;&amp;amp; cd hello/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Create &lt;code&gt;flake.nix&lt;/code&gt; (Initial Impure Example):&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# flake.nix
{
  outputs = { self, nixpkgs }: {
    myHello = (import nixpkgs {}).hello;
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Note: Flakes don‚Äôt have access to &lt;code&gt;builtins.currentSystem&lt;/code&gt; directly.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Impure Build (Fails):&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix build .#myHello
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This fails because Flakes enforce purity by default.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Force Impure Build:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix build .#myHello --impure
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Making the Flake Pure:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# flake.nix
{
  inputs = {
    nixpkgs.url = &quot;github:NixOS/nixpkgs&quot;;
    flake-utils.url = &quot;github:numtide/flake-utils&quot;;
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
      in {
        packages.myHello = pkgs.hello;
      }
    );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;flake-utils&lt;/code&gt; simplifies making flakes system-agnostic and provides the
&lt;code&gt;system&lt;/code&gt; attribute.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Pure Build (Success):&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix build .#myHello
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
  &lt;/details&gt;
&lt;h2&gt;Using Traditional Nix&lt;/h2&gt;
&lt;details&gt;
&lt;summary&gt; Building hello with Traditional Nix &lt;/summary&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Setup:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir hello2 &amp;amp;&amp;amp; cd hello2/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Create &lt;code&gt;default.nix&lt;/code&gt; (Initial Impure Example):&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# default.nix
{ myHello = (import &amp;lt;nixpkgs&amp;gt; { }).hello; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Build (Impure):&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build -A myHello
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Impurity Explained:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix repl
nix-repl&amp;gt; &amp;lt;nixpkgs&amp;gt;
/nix/var/nix/profiles/per-user/root/channels/nixos
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;nixpkgs&amp;gt;&lt;/code&gt; depends on the user‚Äôs environment (Nixpkgs channel), making it
impure. Even with channels disabled, it relies on a specific Nixpkgs
version in the store.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Achieving Purity: Using &lt;code&gt;fetchTarball&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GitHub allows downloading repository snapshots at specific commits,
crucial for reproducibility.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Get Nixpkgs Revision from &lt;code&gt;flake.lock&lt;/code&gt; (from the Flake example):&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# flake.lock
&quot;nixpkgs&quot;: {
  &quot;locked&quot;: {
    &quot;lastModified&quot;: 1746372124,
    &quot;narHash&quot;: &quot;sha256-n7W8Y6bL7mgHYW1vkXKi9zi/sV4UZqcBovICQu0rdNU=&quot;,
    &quot;owner&quot;: &quot;NixOS&quot;,
    &quot;repo&quot;: &quot;nixpkgs&quot;,
    &quot;rev&quot;: &quot;f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0&quot;,
    &quot;type&quot;: &quot;github&quot;
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Modify &lt;code&gt;default.nix&lt;/code&gt; for Purity:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# default.nix
let
  nixpkgs = fetchTarball {
    url = &quot;[https://github.com/NixOS/nixpkgs/archive/f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0.tar.gz](https://github.com/NixOS/nixpkgs/archive/f5cbfa4dbbe026c155cf5a9204f3e9121d3a5fe0.tar.gz)&quot;;
    sha256 = &quot;0000000000000000000000000000000000000000000000000000&quot;; # Placeholder
  };
in {
  myHello = (import nixpkgs {}).hello;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Replace &lt;code&gt;&amp;lt;nixpkgs&amp;gt;&lt;/code&gt; with &lt;code&gt;fetchTarball&lt;/code&gt; and a specific revision. A
placeholder &lt;code&gt;sha256&lt;/code&gt; is used initially.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Build (Nix provides the correct &lt;code&gt;sha256&lt;/code&gt;):&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build -A myHello
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Verification:&lt;/strong&gt; Both Flake and Traditional Nix builds now produce the same
output path.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Remaining Impurities in Traditional Nix:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Default arguments to &lt;code&gt;import &amp;lt;nixpkgs&amp;gt; {}&lt;/code&gt; can introduce impurity:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;overlays&lt;/code&gt;: &lt;code&gt;~/.config/nixpkgs/overlays&lt;/code&gt; (user-specific)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config&lt;/code&gt;: &lt;code&gt;~/.config/nixpkgs/config.nix&lt;/code&gt; (user-specific)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;system&lt;/code&gt;: &lt;code&gt;builtins.currentSystem&lt;/code&gt; (machine-specific)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Making Traditional Nix Fully Pure:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# default.nix
{system ? builtins.currentSystem}:
let
  nixpkgs = fetchTarball {
    url =
      &quot;[https://github.com/NixOS/nixpkgs/archive/0243fb86a6f43e506b24b4c0533bd0b0de211c19.tar.gz](https://github.com/NixOS/nixpkgs/archive/0243fb86a6f43e506b24b4c0533bd0b0de211c19.tar.gz)&quot;;
    sha256 = &quot;1qvdbvdza7hsqhra0yg7xs252pr1q70nyrsdj6570qv66vq0fjnh&quot;;
  };
in {
  myHello = (import nixpkgs {
    overlays = [];
    config = {};
    inherit system;
  }).hello;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Override impure defaults for &lt;code&gt;overlays&lt;/code&gt;, &lt;code&gt;config&lt;/code&gt;, and make &lt;code&gt;system&lt;/code&gt; an
argument.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Building with a Specific System:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build -A myHello --argstr system x86_64-linux
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Pure Evaluation Mode in Traditional Nix:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate --eval --pure-eval --expr &apos;fetchGit { url = ./.; rev = &quot;b4fe677e255c6f89c9a6fdd3ddd9319b0982b1ad&quot;; }&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Example of using &lt;code&gt;--pure-eval&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build --pure-eval --expr &apos;(import (fetchGit { url = ./.; rev = &quot;b4fe677e255c6f89c9a6fdd3ddd9319b0982b1ad&quot;; }) { system = &quot;x86_64-linux&quot;; }).myHello&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Building with a specific revision and system.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
  &lt;/details&gt;
&lt;h3&gt;Updating Nixpkgs&lt;/h3&gt;
&lt;details&gt;
&lt;summary&gt; Updating Nixpkgs with Flakes &lt;/summary&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix flake update
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;nix build .#myHello --override-input nixpkgs github:NixOS/nixpkgs/nixos-24.11
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3&gt;Updating Traditional Nix (using &lt;code&gt;niv&lt;/code&gt;)&lt;/h3&gt;
&lt;details&gt;
&lt;summary&gt; Updating with niv &lt;/summary&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;nix-shell -p niv
niv init
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# default.nix
{ system ? builtins.currentSystem,
  sources ? import nix/sources.nix,
  nixpkgs ? sources.nixpkgs,
  pkgs ? import nixpkgs {
    overlays = [ ];
    config = { };
    inherit system;
  }, }: {
  myHello = pkgs.hello;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And build it with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build -A myHello
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;niv update nixpkgs --branch=nixos-unstable
nix-build -A myHello
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt; Adding Home-Manager with Flakes (click here) &lt;/summary&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# flake.nix
{
  inputs = {
    nixpkgs.url = &quot;github:NixOS/nixpkgs&quot;;
    flake-utils.url = &quot;github:numtide/flake-utils&quot;;
    home-manager.url = &quot;github:nix-community/home-manager&quot;;
  };

  outputs = { self, nixpkgs, flake-utils, home-manager, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let pkgs = nixpkgs.legacyPackages.${system};
      in {
        packages.myHello = pkgs.hello;
        packages.x86_64-linux.homeManagerDocs =
          home-manager.packages.x86_64-linux.docs-html;
      });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix flake update
nix flake show github:nix-community/home-manager
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;home-manager.inputs.follows = &quot;nixpkgs&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h4&gt;Adding Home-Manager with Traditional Nix&lt;/h4&gt;
&lt;details&gt;
&lt;summary&gt; Adding Home-Manager with Traditional Nix (click here) &lt;/summary&gt;
```nix
niv add nix-community/home-manager
```
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;nix repl
nix-repl&amp;gt; s = import ./nix/sources.nix
nix-repl&amp;gt; s.home-manager
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{ system ? builtins.currentSystem, sources ? import nix/sources.nix
  , nixpkgs ? sources.nixpkgs, pkgs ? import nixpkgs {
    overlays = [ ];
    config = { };
    inherit system;
  }, }: {
  homeManagerDocs = (import sources.home-manager { pkgs = pkgs; }).docs;

  myHello = pkgs.hello;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build -A homeManagerDocs
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;In this chapter, we‚Äôve explored the key differences between traditional Nix and
Nix Flakes, particularly focusing on how each approach handles purity,
dependency management, and project structure. We‚Äôve seen that while traditional
Nix can achieve purity with careful configuration, Flakes enforce it by default,
offering a more robust and standardized way to build reproducible environments.
Flakes also streamline dependency management and provide a more structured
project layout compared to the often ad-hoc nature of traditional Nix projects.&lt;/p&gt;
&lt;p&gt;However, regardless of whether you‚Äôre working with Flakes or traditional Nix,
understanding how to debug and trace issues within your Nix code is crucial.
When things go wrong, you‚Äôll need tools and techniques to inspect the evaluation
process, identify the source of errors, and understand how your modules and
derivations are being constructed.&lt;/p&gt;
&lt;p&gt;In our next chapter,
&lt;a href=&quot;https://saylesss88.github.io/Debugging_and_Tracing_NixOS_Modules_9.html&quot;&gt;Debugging and Tracing Modules&lt;/a&gt;,
we will delve into the world of Nix debugging. We‚Äôll explore various techniques
and tools that can help you understand the evaluation process, inspect the
values of expressions, and trace the execution of your Nix code, enabling you to
effectively troubleshoot and resolve issues in both Flake-based and traditional
Nix projects.&lt;/p&gt;
</content></entry><entry><title>Local Nixpkgs</title><id>https://saylesss88.github.io/Working_with_Nixpkgs_Locally_10.html</id><updated>2025-11-22T00:00:00+00:00</updated><link href="https://saylesss88.github.io/Working_with_Nixpkgs_Locally_10.html" rel="alternate"/><content type="html">&lt;h1&gt;Chapter 10&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;p&gt;&lt;img src=&quot;images/server_rack.cleaned.png&quot; alt=&quot;server_rack&quot; /&gt;&lt;/p&gt;
&lt;!-- ![gruv18](images/gruv18.png) --&gt;
&lt;h2&gt;Working with Nixpkgs Locally: Benefits and Best Practices&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Nixpkgs, the package repository for NixOS, is a powerful resource for building
and customizing software.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Working with a local copy enhances development, debugging, and contribution
workflows.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This post covers setting up a local Nixpkgs repository, searching for
dependencies, and leveraging its advantages, incorporating tips from the Nix
community.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;I. Why Work with Nixpkgs Locally?&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A local Nixpkgs repository offers significant advantages for Nix developers:&lt;/p&gt;
&lt;h2&gt;A. Faster Development Cycle&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Local searches for packages and dependencies are significantly quicker than
querying remote repositories or channels.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This speedup is crucial for efficient debugging and rapid prototyping of Nix
expressions.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;B. Enhanced Version Control&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;By pinning your local repository to specific commits or branches (e.g.,
&lt;code&gt;nixos-unstable&lt;/code&gt;), you ensure build reproducibility.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This prevents unexpected issues arising from upstream changes in Nixpkgs.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;C. Flexible Debugging Capabilities&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;You can directly test and modify package derivations within your local copy.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This allows for quick fixes to issues like missing dependencies without
waiting for upstream updates or releases.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;D. Streamlined Contribution Workflow&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Developing and testing new packages or patches locally is essential before
submitting them as pull requests to Nixpkgs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A local setup provides an isolated environment for experimentation.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;E. Up-to-Date Documentation Source&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The source code and comments within the Nixpkgs repository often contain the
most current information about packages.&lt;/li&gt;
&lt;li&gt;This can sometimes be more up-to-date than official, external documentation.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;F. Optimized Storage and Performance&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Employing efficient cloning strategies (e.g., shallow clones) and avoiding
unnecessary practices (like directly using Nixpkgs as a flake for local
development) minimizes disk usage and build times.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;II. Flake vs. Non-Flake Syntax for Local Nixpkgs&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;When working with Nixpkgs locally, the choice between Flake and non-Flake
syntax has implications for performance and storage:&lt;/p&gt;
&lt;h2&gt;A. Flake Syntax (&lt;code&gt;nix build .#&amp;lt;package&amp;gt;&lt;/code&gt;)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Treats the current directory as a flake, requiring evaluation of
&lt;code&gt;flake.nix&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For local Nixpkgs, this evaluates the flake definition in the repository
root.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Performance and Storage Overhead:&lt;/strong&gt; Flakes copy the entire working
directory (including Git history if present) to &lt;code&gt;/nix/store&lt;/code&gt; for evaluation.
This can be slow and storage-intensive for large repositories like Nixpkgs.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;B. Non-Flake Syntax (&lt;code&gt;nix-build -f . &amp;lt;package&amp;gt;&lt;/code&gt; or &lt;code&gt;nix build -f . &amp;lt;package&amp;gt;&lt;/code&gt;)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-f .&lt;/code&gt; specifies the Nix expression (e.g., &lt;code&gt;default.nix&lt;/code&gt; or a specific file)
in the current directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Efficiency:&lt;/strong&gt; Evaluates the Nix expression directly &lt;em&gt;without&lt;/em&gt; copying the
entire worktree to &lt;code&gt;/nix/store&lt;/code&gt;. This is significantly faster and more
storage-efficient for local development on large repositories.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;III. Setting Up a Local Nixpkgs Repository Efficiently&lt;/h2&gt;
&lt;details&gt;
&lt;summary&gt;Click To See How to set up Nixpkgs Locally&lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;Cloning Nixpkgs requires careful consideration due to its size.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;A.a Initial Clone: Shallow Cloning&lt;/h2&gt;
&lt;p&gt;It is common to place your local clone in the &lt;code&gt;/src&lt;/code&gt; directory:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir src &amp;amp;&amp;amp; cd src
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ùó Warning, A shallow clone (&lt;code&gt;--depth 1&lt;/code&gt;) is not recommended for general
development or contributing changes back to Nixpkgs via pull requests. It‚Äôs
primarily suitable for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Quick checks or builds: If you only need to verify a package‚Äôs current state
or build a specific version without needing historical context.&lt;/li&gt;
&lt;li&gt;CI/CD environments: Where disk space and clone time are critical, and only
the latest commit is needed for automated tests or builds.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;With that said, to avoid downloading the entire history, perform a shallow
clone:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git clone [https://github.com/NixOS/nixpkgs](https://github.com/NixOS/nixpkgs) --depth 1
cd nixpkgs
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;A.b A few Examples exploring Nixpkgs&lt;/h2&gt;
&lt;p&gt;While in the &lt;code&gt;nixpkgs&lt;/code&gt; directory, you can check the version of a package:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate --eval -A openssl.version
&quot;3.4.1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or to directly edit the file you can use &lt;code&gt;nix edit&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix edit nixpkgs#openssl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It uses the nix registry and &lt;code&gt;openssl.meta.position&lt;/code&gt; to locate the file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;man nix3 registry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above command will open the &lt;code&gt;openssl/default.nix&lt;/code&gt; in your &lt;code&gt;$EDITOR&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;A.1 Full Fork and Clone of Nixpkgs&lt;/h2&gt;
&lt;p&gt;If you want to contribute to Nixpkgs, you need to set up a local version
following the
&lt;a href=&quot;https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md&quot;&gt;Contributing guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You‚Äôll need to, this is directly from the &lt;code&gt;Contributing.md&lt;/code&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo#forking-a-repository&quot;&gt;Fork&lt;/a&gt;
the &lt;a href=&quot;https://github.com/nixos/nixpkgs/&quot;&gt;Nixpkgs repository&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo#cloning-your-forked-repository&quot;&gt;Clone the forked repo&lt;/a&gt;
into a local &lt;code&gt;nixpkgs&lt;/code&gt; directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo#configuring-git-to-sync-your-fork-with-the-upstream-repository&quot;&gt;Configure the upstream Nixpkgs repo&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;B. Managing Branches with Worktrees&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Use Git worktrees to manage different branches efficiently:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git fetch --all --prune --depth=1
git worktree add -b nixos-unstable nixos-unstable # For just unstable
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Explanation of &lt;code&gt;git worktree&lt;/code&gt;:&lt;/strong&gt; Allows multiple working directories
attached to the same &lt;code&gt;.git&lt;/code&gt; directory, sharing history and objects but with
separate checked-out files.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git worktree add&lt;/code&gt;: Creates a new working directory for the specified branch
(&lt;code&gt;nixos-unstable&lt;/code&gt; in this case).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;h1&gt;IV. Debugging Missing Dependencies: A Practical Example&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; Click to see icat Example &lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;Let‚Äôs say you‚Äôre trying to build &lt;code&gt;icat&lt;/code&gt; locally and encounter a missing
dependency error:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;nix-build -A icat
# ... (Error log showing &quot;fatal error: X11/Xlib.h: No such file or directory&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The error &lt;code&gt;fatal error: X11/Xlib.h: No such file or directory&lt;/code&gt; indicates a
missing X11 dependency.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;A. Online Search with &lt;code&gt;search.nixos.org&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Nixpkgs package search website
(&lt;a href=&quot;https://search.nixos.org/packages&quot;&gt;https://search.nixos.org/packages&lt;/a&gt;) is a
valuable first step.&lt;/li&gt;
&lt;li&gt;However, broad terms like ‚Äúx11‚Äù can yield many irrelevant results.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tip:&lt;/strong&gt; Utilize the left sidebar to filter by package sets (e.g., ‚Äúxorg‚Äù).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;B. Local Source Code Search with &lt;code&gt;rg&lt;/code&gt; (ripgrep)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Familiarity with searching the Nixpkgs source code is crucial for finding
dependencies.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Navigate to your local &lt;code&gt;nixpkgs/&lt;/code&gt; directory and use &lt;code&gt;rg&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rg &quot;x11 =&quot; pkgs # Case-sensitive search
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pkgs/tools/X11/primus/default.nix
21:  primus = if useNvidia then primusLib_ else primusLib_.override { nvidia_x11 = null; };
22:  primus_i686 = if useNvidia then primusLib_i686_ else primusLib_i686_.override { nvidia_x11 = null; };

pkgs/applications/graphics/imv/default.nix
38:    x11 = [ libGLU xorg.libxcb xorg.libX11 ];
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Refining the search (case-insensitive):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rg -i &quot;libx11 =&quot; pkgs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ... (Output showing &quot;xorg.libX11&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The key result is &lt;code&gt;xorg.libX11&lt;/code&gt;, which is likely the missing dependency.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
 &lt;/details&gt;
&lt;h1&gt;V. Local Derivation Search with &lt;code&gt;nix-locate&lt;/code&gt;&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; Click to Expand nix-locate command Example&lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;nix-locate&lt;/code&gt; (from the &lt;code&gt;nix-index&lt;/code&gt; package) allows searching for derivations
on the command line.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Install &lt;code&gt;nix-index&lt;/code&gt; and run &lt;code&gt;nix-index&lt;/code&gt; to create the initial
index.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-locate libx11
# ... (Output showing paths related to libx11)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Combining online and local search tools (&lt;code&gt;search.nixos.org&lt;/code&gt;, &lt;code&gt;rg&lt;/code&gt;,
&lt;code&gt;nix-locate&lt;/code&gt;) provides a comprehensive approach to finding dependencies.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;h1&gt;VI. Key Benefits of Working with Nixpkgs Locally (Recap)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Speed:&lt;/strong&gt; Faster searches and builds compared to remote operations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Control:&lt;/strong&gt; Full control over the Nixpkgs version.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Up-to-Date Information:&lt;/strong&gt; Repository source often has the latest details.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;VII. Best Practices and Tips from the Community&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click To Expand Best Practices and Tips from the community&lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Rebasing over Merging:&lt;/strong&gt; Never merge upstream changes into your local
branch. Always rebase your branch onto the upstream (e.g., &lt;code&gt;master&lt;/code&gt; or
&lt;code&gt;nixos-unstable&lt;/code&gt;) to avoid accidental large-scale pings in pull requests (Tip
from &lt;code&gt;soulsssx3&lt;/code&gt; on Reddit).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Tip from &lt;code&gt;ElvishJErrico&lt;/code&gt;:&lt;/strong&gt; Avoid using Nixpkgs directly as a flake for
local development due to slow copying to &lt;code&gt;/nix/store&lt;/code&gt; and performance issues
with garbage collection on large numbers of small files. Use
&lt;code&gt;nix build -f . &amp;lt;package&amp;gt;&lt;/code&gt; instead of &lt;code&gt;nix build .#&amp;lt;package&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Edge Cases for Flake Syntax:&lt;/strong&gt; Flake syntax might be necessary in specific
scenarios, such as NixOS installer tests where copying the Git history should
be avoided.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Base Changes on &lt;code&gt;nixos-unstable&lt;/code&gt;:&lt;/strong&gt; For better binary cache hits, base your
changes on the &lt;code&gt;nixos-unstable&lt;/code&gt; branch instead of &lt;code&gt;master&lt;/code&gt;. Consider the
merge-base for staging branches as well.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Consider &lt;code&gt;jujutsu&lt;/code&gt;:&lt;/strong&gt; Explore &lt;a href=&quot;https://github.com/jj-vcs/jj&quot;&gt;jj-vcs&lt;/a&gt;, a
Git-compatible alternative that can offer a more intuitive workflow,
especially for large monorepos like Nixpkgs. While it has a learning curve, it
can significantly improve parallel work and branch management.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://saylesss88.github.io/vcs/jujutsu.html&quot;&gt;Intro-To-Jujutsu&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
</content></entry><entry><title>Debugging NixOS modules</title><id>https://saylesss88.github.io/Debugging_and_Tracing_NixOS_Modules_9.html</id><updated>2025-11-22T00:00:00+00:00</updated><link href="https://saylesss88.github.io/Debugging_and_Tracing_NixOS_Modules_9.html" rel="alternate"/><content type="html">&lt;h1&gt;Chapter 11&lt;/h1&gt;
&lt;p&gt;This chapter covers debugging NixOS modules, focusing on tracing module options
and evaluating merges.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;h2&gt;Debugging and Tracing NixOS Modules&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;images/coding4.png&quot; alt=&quot;404&quot; /&gt;&lt;/p&gt;
&lt;!-- ![gruv17](images/gruv17.png) --&gt;
&lt;ul&gt;
&lt;li&gt;Other related post if you haven‚Äôt read my previous post on modules, that may
be helpful before reading this one:
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://saylesss88.github.io/posts/nix_modules_explained/&quot;&gt;nix-modules-explained&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This post is my notes following Nix Hour 40. If it seems a little chaotic,
try watching one. They are hard to follow if you‚Äôre not extremely familiar
with the concepts.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=aLy8id4wr-M&amp;amp;t=2120s&quot;&gt;Nix Hour 40&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Nix Code is particularly hard to &lt;strong&gt;debug&lt;/strong&gt; because of (e.g. lazy evaluation,
declarative nature, layered modules)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The following simple Nix code snippet illustrates a basic NixOS module
definition and how options are declared and configured. We‚Äôll use this example
to demonstrate fundamental debugging techniques using &lt;code&gt;nix-instantiate&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;let
  lib = import &amp;lt;nixpkgs/lib&amp;gt;;
in
lib.evalModules {
  modules = [
    ({ lib, ... }: {
      options.foo = lib.mkOption {
        # type = lib.types.raw;
        type = lib.types.anything;
        # default = pkgs;
      };
      config.foo = {
        bar = 10;
        list = [1 2 3 ];
        baz = lib.mkDefault &quot;baz&quot;;
      };
    })
    {
      foo.baz = &quot;bar&quot;;
    }
  ];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In the above code, adding &lt;code&gt;lib&lt;/code&gt; to the function arguments isn‚Äôt required but
if you were to move the module to another file it would fail without it
because &lt;code&gt;lib&lt;/code&gt; comes from outside of it. So it‚Äôs good practice to refer to
&lt;code&gt;lib&lt;/code&gt; in the modules themselves.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You should &lt;strong&gt;always&lt;/strong&gt; assign a type to your options, if you don‚Äôt know which
type to use you could use &lt;code&gt;raw&lt;/code&gt;. &lt;code&gt;raw&lt;/code&gt; is a type that doesn‚Äôt do any
processing. So if you were to assign the entire packages set to the option
e.g. &lt;code&gt;default = pkgs;&lt;/code&gt; it wouldn‚Äôt recurseinto all the packages and try to
evaluate them. There is also &lt;code&gt;anything&lt;/code&gt;, that is useful if you do want to
recurse into the values.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The following is an example of how you would run this inside vim/neovim, the
rest of the examples will be from the command line:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-vim&quot;&gt;:!nix-instantiate --eval -A config.foo --strict
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;:&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt; Click to Expand the Output &lt;/summary&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;{ bar = 10; baz = &quot;bar&quot;; list = [ 1 2 3 ]; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To show the difference you could uncomment the &lt;code&gt;raw&lt;/code&gt; type and comment the
&lt;code&gt;anything&lt;/code&gt; type and run the above command again you‚Äôll see that you get an
error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;error: The option &apos;foo&apos; is defined multiple times while it&apos;s expected to be
unique
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To execute this command on the command line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate --eval --strict -A config.foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It will show you the start of a trace. To get the full trace add:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate --eval --strict -A config.foo --show-trace
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2&gt;Example 2&lt;/h2&gt;
&lt;details&gt;
&lt;summary&gt; Click to Expand Example 2 &lt;/summary&gt;
&lt;p&gt;In the previous example, we looked at a simplified module. Now, let‚Äôs examine a
more realistic scenario involving a basic NixOS configuration file
(&lt;code&gt;configuration.nix&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;This example will demonstrate how to use &lt;code&gt;nix-instantiate&lt;/code&gt; to evaluate an entire
system configuration and how &lt;code&gt;--show-trace&lt;/code&gt; helps in diagnosing errors within
this context.&lt;/p&gt;
&lt;p&gt;Consider the following &lt;code&gt;configuration.nix&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# configuration.nix
{ lib, ... }: {
  boot.loader.grub.device = &quot;nodev&quot;;
  fileSystems.&quot;/&quot;.device = &quot;/devst&quot;;
  system.stateVersion = &quot;24.11&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This configuration snippet sets the GRUB bootloader device, defines a root
filesystem, and specifies the expected NixOS state version. To evaluate this
entire system configuration, you can use &lt;code&gt;nix-instantiate&lt;/code&gt; and point it to the
&lt;code&gt;&amp;lt;nixpkgs/nixos&amp;gt;&lt;/code&gt; entrypoint, providing our &lt;code&gt;configuration.nix&lt;/code&gt; file as an
argument. The &lt;code&gt;-A system&lt;/code&gt; flag selects the top-level &lt;code&gt;system&lt;/code&gt; attribute, which
represents the instantiated system configuration.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Run&lt;/strong&gt; it in with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate &apos;&amp;lt;nixpkgs/nixos&amp;gt;&apos; --arg configuration ./configuration.nix -A system
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;/nix/store/kfcwvvpdbsb3xcks1s76id16i1mc3l5k-nixos-system-nixos-25.05pre-git.drv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok, we can see that this successfully &lt;em&gt;instantiates&lt;/em&gt;. Let‚Äôs introduce an error
to trace:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{ lib, ... }: {
  boot.loader.grub.device = &quot;nodev&quot;;
  fileSystems.&quot;/&quot;.device = &quot;/devst&quot;;
  system.stateVersion = builtins.genList &quot;24.11&quot; null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;(stack trace truncated; use &apos;--show-trace&apos; to show the full, detailed trace)
error: expected an integer but found null: null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rerun the command with &lt;code&gt;--show-trace&lt;/code&gt; appended:&lt;/p&gt;
&lt;p&gt;Or on the command line&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate &apos;&amp;lt;nixpkgs/nixos&amp;gt;&apos; --arg configuration ./configuration.nix -A system --show-trace
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This outputs a much longer trace than the first example. It shows you the file
the error occured in and you can see that in this case they are a lot of
internal functions. (e.g.
&lt;code&gt;at /nix/store/ccfwxygjrarahgfv5865x2f828sjr5h0- source/lib/attrsets.nix:1529:14:&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To show your own error message you could do something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{lib, ...}: {
  boot.loader.grub.device = &quot;nodev&quot;;
  fileSystems.&quot;/&quot;.device = &quot;/devst&quot;;
  system.stateVersion = builtins.addErrorContext &quot;AAAAAAAAAAAAAAAAA&quot; (builtins.genList &quot;24.11&quot; null);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate &apos;&amp;lt;nixpkgs/nixos&amp;gt;&apos; --arg configuration ./configuration.nix -A system --show-trace`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; ‚Ä¶ while evaluating the attribute &apos;value&apos;
     at /nix/store/ccfwxygjrarahgfv5865x2f828sjr5h0-source/lib/modules.nix:770:21:
      769|             inherit (module) file;
      770|             inherit value;
         |                     ^
      771|           }) module.config

   ‚Ä¶ AAAAAAAAAAAAAAAAA

   ‚Ä¶ while calling the &apos;genList&apos; builtin
     at /home/jr/tests/configuration.nix:4:71:
        3|   fileSystems.&quot;/&quot;.device = &quot;/devst&quot;;
        4|   system.stateVersion = builtins.addErrorContext &quot;AAAAAAAAAAAAAAAAA&quot;
         (builtins.genList &quot;24.11&quot; null);
         |                                                                       ^
        5| }

   ‚Ä¶ while evaluating the second argument passed to builtins.genList

   error: expected an integer but found null: null
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;In the latest nix they actually inverted the error messages so the most
relevant parts will be at the bottom.&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;h2&gt;Example 3&lt;/h2&gt;
&lt;details&gt;
&lt;summary&gt; Click to Expand Example 3 &lt;/summary&gt;
&lt;p&gt;Let‚Äôs consider another example, this time demonstrating the definition of
configuration options using &lt;code&gt;lib.mkOption&lt;/code&gt; within a module structure.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# default.nix
let
  lib = import &amp;lt;nixpkgs/lib&amp;gt;;
in
lib.evalModules {
  modules = [
    ({ lib, ... }: {
      options.ints = lib.mkOption {
        type = lib.types.attrsOf lib.types.int;
      };
      options.strings = lib.mkOption {
        type = lib.types.string;
        # type = lib.types.attrsOf lib.types.string;
        default = &quot;foo&quot;;
      };
    })
  ];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Instantiate&lt;/strong&gt; this with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate --eval --strict -A config.strings
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;evaluation warning: The type `types.string` is deprecated.
See https://github.com/NixOS/nixpkgs/pull/66346 for better alternative types.
&quot;foo&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Unfortunately you won‚Äôt get the same depreciation warning from &lt;code&gt;lib.attrsOf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Below is an interesting way to provide nixpkgs run it on the command line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;export NIX_PATH=nixpkgs=channel:nixpkgs-unstable
echo $NIX_PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nixpkgs=channel:nixpkgs-unstable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The next two commands are to check that after using the above way to provide
&lt;code&gt;nixpkgs-unstable&lt;/code&gt; that they both point to the same store path, the following
command will fetch nixpkgs from the channel above:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate --find-file nixpkgs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt; 1Ô∏è‚É£&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;/nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate --eval channel:nixpkgs-unstable -A path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;: 2Ô∏è‚É£&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;/nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;As you can see both commands produce the same store path&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Example 4&lt;/h2&gt;
&lt;p&gt;In our previous example, we encountered a deprecation warning for
&lt;code&gt;lib.types.string&lt;/code&gt;. This next example delves deeper into why that type was
deprecated and demonstrates the consequences of its behavior, along with the
recommended fix.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# default.nix
let
  lib = import &amp;lt;nixpkgs/lib&amp;gt;;
in
  lib.evalModules {
    modules = [
      ({lib, ...}: {
        options.ints = lib.mkOption {
          type = lib.types.attrsOf lib.types.int;
        };
        options.strings = lib.mkOption {
          # type = lib.types.string;
          type = lib.types.attrsOf lib.types.string;
          default = {
            x = &quot;foo&quot;;
          };
        };
        config = {
          strings = lib.mkOptionDefault {
            x = &quot;bar&quot;;
          };
        };
      })
    ];
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Evaluate it with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate --eval --strict -A config.strings
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;types.string&lt;/code&gt; depricated because it silently concatenates strings&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The above command has two options with the same priority level and evaluates
to &lt;code&gt;{ x = &quot;foobar&quot;; }&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;evaluation warning: The type `types.string` is deprecated. See https://github.
com/NixOS/nixpkgs/pull/66346 for better alternative types.
{ x = &quot;foobar&quot;; }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;types.str&lt;/code&gt; was the replacement for the depricated &lt;code&gt;types.string&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# default.nix
let
  lib = import &amp;lt;nixpkgs/lib&amp;gt;;
in
  lib.evalModules {
    modules = [
      ({lib, ...}: {
        options.ints = lib.mkOption {
          type = lib.types.attrsOf lib.types.int;
        };
        options.strings = lib.mkOption {
          # type = lib.types.string;
          type = lib.types.attrsOf lib.types.str;
          # Sets the value with a lower priority: lib.mkOptionDefault
          default = {
            x = &quot;foo&quot;;
          };
        };
        config = {
          strings = lib.mkOptionDefault {
            x = &quot;bar&quot;;
          };
        };
      })
    ];
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;error:
‚Ä¶ while evaluating the attribute &apos;x&apos;

‚Ä¶ while evaluating the attribute &apos;value&apos;
 at /nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source/lib/modules.nix:1148:41:
 1147|
 1148|     optionalValue = if isDefined then { value = mergedValue; } else { };
     |                                         ^
 1149|   };

‚Ä¶ while calling the &apos;foldl&apos;&apos; builtin
 at /nix/store/ydrgwsibghsyx884qz97zbs1xs93yk11-source/lib/options.nix:508:8:
  507|     else
  508|       (foldl&apos; (
     |        ^
  509|         first: def:

(stack trace truncated; use &apos;--show-trace&apos; to show the full, detailed trace)

error: The option `strings.x&apos; has conflicting definition values:
- In `&amp;lt;unknown-file&amp;gt;&apos;: &quot;foo&quot;
- In `&amp;lt;unknown-file&amp;gt;&apos;: &quot;bar&quot;
Use `lib.mkForce value` or `lib.mkDefault value` to change the priority on any of these definitions.

shell returned 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;So types in the module system aren‚Äôt just types in the conventional sense but
they also specify the emerging behavior of these values.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If we switch the type in the above example to &lt;code&gt;types.lines&lt;/code&gt; you get this
returned, &lt;code&gt;{ x = &quot;foo\nbar&quot;; }&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mkOptionDefault&lt;/code&gt; isn‚Äôt typically something you should generally use, instead
options have a &lt;code&gt;default&lt;/code&gt; setting&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you want to make sure that you set a default but if the user specifies it,
it shouldn‚Äôt get overridden. You should not set it in the following:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;options.strings = lib.mkOption {
  type = lib.types.attrsOf lib.types.lines;
  default = {
    x = &quot;foo&quot;;
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because the above uses &lt;code&gt;mkOptionDefault&lt;/code&gt; but instead in under the &lt;code&gt;config&lt;/code&gt;
attribute like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# ...snip...
options.strings = lib.mkOption {
  type = lib.types.attrsOf lib.types.lines;
  # default = {
    # x = &quot;foo&quot;;
  # };
};
config = {
  strings = {
    x = lib.mkDefault &quot;foo&quot;;
  };
};
# ...snip...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;let
  lib = import &amp;lt;nixpkgs/lib&amp;gt;;
in
  lib.evalModules {
    modules = [
      ({lib, ...}: {
        options.ints = lib.mkOption {
          type = lib.types.attrsOf lib.types.int;
        };
        options.strings = lib.mkOption {
          # type = lib.types.string;
          type = lib.types.attrsOf lib.types.str;
          # Sets the value with a lower priority: lib.mkOptionDefault
          #default = {
          #  x = &quot;foo&quot;;
          #};
        };
        config.strings = {
          x = &quot;foo&quot;;
        };
      })
      {
        config.strings = {
          y = &quot;bar&quot;;
        };
      }
    ];
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This works now because there‚Äôs no difference between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;{ x = &quot;foo&quot;; y = &quot;bar&quot;; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;More Functionality between modules&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;let
  lib = import &amp;lt;nixpkgs/lib&amp;gt;;
in
  lib.evalModules {
    modules = [
      ({lib, ...}: {
        options.ints = lib.mkOption {
          type = lib.types.attrsOf lib.types.int;
        };
        options.strings = lib.mkOption {
          # type = lib.types.string;
          type = lib.types.attrsOf lib.types.str;
          # Sets the value with a lower priority: lib.mkOptionDefault
          #default = {
          #  x = &quot;foo&quot;;
          #};
        };
        config.strings = {
          x = lib.mkDefault &quot;foo&quot;;
        };
      })
      {
        config.strings = {
          x = &quot;x&quot;;
          y = &quot;bar&quot;;
        };
      }
    ];
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The above command would cause a conflict without the &lt;code&gt;x = lib.mkDefault foo&lt;/code&gt;
And this is typically what you want to do for defaults and modules in things
like nested configuration.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;{ x = &quot;x&quot;; y = &quot;bar&quot;; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Infinite recursion error&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;A common pitfall is to introduce a hard to debug error &lt;code&gt;infinite recursion&lt;/code&gt;
when shadowing a name. The simplest example for this is:&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;let a = 1; in rec { a = a; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;üí°&lt;strong&gt;TIP&lt;/strong&gt;: Avoid &lt;code&gt;rec&lt;/code&gt;. Use &lt;code&gt;let ... in&lt;/code&gt; Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;let
 a = 1;
in {
 a = a;
 b = a + 2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;details&gt;
&lt;summary&gt; Click to Expand a more involved infinite recursion error &lt;/summary&gt;
&lt;p&gt;We‚Äôll separate the logic for this example, this will be the &lt;code&gt;default.nix&lt;/code&gt; this
is where having &lt;code&gt;lib&lt;/code&gt; defined in your inline modules is helpful because you can
just delete the section and paste it into your &lt;code&gt;modules.nix&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# default.nix
let
  lib = import &amp;lt;nixpkgs/lib&amp;gt;;
in
  lib.evalModules {
    modules = [
      ./module.nix
    ];
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in the &lt;code&gt;module.nix&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# module.nix
{ lib, pkgs, ...}: {
  options.etc = lib.mkOption {
    type = lib.types.attrsOf lib.types.path;
    default = { };
    description = &apos;&apos;
      Specifies which paths are is /etc/
    &apos;&apos;;
  };

  config._module.args.pkgs = import &amp;lt;nixpkgs&amp;gt; {
    config = {};
    overlays = [];
  };
  config.etc.foo = pkgs.writeText &quot;foo&quot; &apos;&apos;
    foo configuration
  &apos;&apos;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;If you evaluate this with the following you will get an infinite recursion
error.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate --eval --strict -A config.etc
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This happens because &lt;code&gt;--strict&lt;/code&gt; evaluates the &lt;code&gt;etc&lt;/code&gt;, then it goes into the
&lt;code&gt;attrsOf&lt;/code&gt;, and the &lt;code&gt;path&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix repl
nix-repl&amp;gt; :l &amp;lt;nixpkgs&amp;gt;
nix-repl&amp;gt; hello.out.out.out
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:l &amp;lt;nixpkgs&amp;gt;&lt;/code&gt; loads the Nixpkgs library into the repl environment, making its
definitions available.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;hello&lt;/code&gt; refers to the &lt;code&gt;hello&lt;/code&gt; package definition within Nixpkgs. Packages in
Nixpkgs are defined as &lt;em&gt;derivations&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.out&lt;/code&gt; is a common attribute name for the &lt;em&gt;main output&lt;/em&gt; of a derivation (e.g.,
the installed package). Some packages, especially those with complex build
processes or multiple outputs, might have nested output attributes. In the
case of &lt;code&gt;hello&lt;/code&gt;, accessing &lt;code&gt;.out.out.out&lt;/code&gt; ultimately leads us to the
&lt;em&gt;derivation&lt;/em&gt; itself.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The key takeaway here is that when you evaluate a package in the &lt;code&gt;nix repl&lt;/code&gt;,
you‚Äôre often interacting with its derivation or one of its output paths in the
Nix store. The &lt;code&gt;¬´derivation ...¬ª&lt;/code&gt; indicates that &lt;code&gt;hello.out.out.out&lt;/code&gt; evaluates
to a derivation ‚Äì the blueprint for building the &lt;code&gt;hello&lt;/code&gt; package. This is in
contrast to &lt;code&gt;--eval --strict&lt;/code&gt;, which tries to fully evaluate values, potentially
leading to infinite recursion if it encounters a derivation that refers back to
itself indirectly during attribute evaluation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;¬´derivation /nix/store/b1vcpm321dwbwx6wj4n13l35f4y2wrfv-hello-2.12.1.drv¬ª
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;So it recurses through the entire thing and tries to evaluate its string.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So we want to change the command from &lt;code&gt;--eval --strict&lt;/code&gt; which is only based on
evaluation to at least &lt;code&gt;nix-instantiate&lt;/code&gt; which is based on derivations:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate -A config.etc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;warning: you did not specify &apos;--add-root&apos;; the result might be removed by the garbage collector
/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;We don‚Äôt really have a derivation yet for example:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# module.nix
{
  lib,
  pkgs,
  ...
}: {
  options.etc = lib.mkOption {
    type = lib.types.attrsOf (lib.types.attrsOf lib.types.path);
    default = {};
    description = &apos;&apos;
      Specifies which paths are in /etc/
    &apos;&apos;;
  };

  config._module.args.pkgs = import &amp;lt;nixpkgs&amp;gt; {
    config = {};
    overlays = [];
  };
  config.etc.foo.bar = pkgs.writeText &quot;foo&quot; &apos;&apos;
    foo configuration
  &apos;&apos;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Try to evaluate the above command with &lt;code&gt;nix-instantiate -A config.etc&lt;/code&gt; and Nix
doesn‚Äôt even try to build it. With nested &lt;code&gt;attrsOf&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix repl -f default.nix
nix-repl&amp;gt; config.etc
{
  foo = { ... };
}
nix-repl&amp;gt; config.etc.foo
{
  bar = ¬´derivation /nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv¬ª;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;So &lt;code&gt;config.foo&lt;/code&gt; is an attribute set and &lt;code&gt;config.etc.foo&lt;/code&gt; is also an attribute
set but it‚Äôs not a derivation by itself. So &lt;code&gt;nix-instantiate&lt;/code&gt; does this one
level of recursion here and it would have built &lt;code&gt;foo&lt;/code&gt; value if it were a
derivation.&lt;/li&gt;
&lt;/ul&gt;
&lt;/details&gt;
&lt;h3&gt;Example 5&lt;/h3&gt;
&lt;details&gt;
&lt;summary&gt; Click to Expand Example 5 &lt;/summary&gt;
&lt;p&gt;We‚Äôll use the same &lt;code&gt;module.nix&lt;/code&gt; and &lt;code&gt;default.nix&lt;/code&gt; from the previous example.&lt;/p&gt;
&lt;p&gt;Building More Complex Configurations with Modules In this next example, we‚Äôll
focus on a common task in system configuration: managing files within the
&lt;code&gt;/etc/&lt;/code&gt; directory. We‚Äôll define a module that allows us to specify the content
of arbitrary files in &lt;code&gt;/etc/&lt;/code&gt; and then use a special Nix function to combine
these individual file definitions into a single, manageable entity.&lt;/p&gt;
&lt;p&gt;We‚Äôll introduce a new option, &lt;code&gt;options.etc&lt;/code&gt;, which will allow us to define the
content of files within &lt;code&gt;/etc/&lt;/code&gt;. Then, we‚Äôll use &lt;code&gt;pkgs.linkFarm&lt;/code&gt; to create a
derivation that represents the entire &lt;code&gt;/etc/&lt;/code&gt; directory as a collection of
symbolic links pointing to the individual file contents we‚Äôve defined. This
demonstrates how modules can abstract away the details of creating complex
system configurations, providing a declarative and reproducible way to manage
even fundamental aspects of the operating system.&lt;/p&gt;
&lt;p&gt;Let‚Äôs show how we can use Nix modules to declaratively manage the &lt;code&gt;/etc/&lt;/code&gt;
directory&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# default.nix
let
  lib = import &amp;lt;nixpkgs/lib&amp;gt;;
in
  lib.evalModules {
    modules = [
      ./module.nix
    ];
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# module.nix
{
  lib,
  pkgs,
  config,
  ...
}: {
  options.etc = lib.mkOption {
    type = lib.types.attrsOf (lib.types.attrsOf lib.types.path);
    default = {};
    description = &apos;&apos;
      Specifies which paths are in /etc/
    &apos;&apos;;
  };
  options.etcCombined = lib.mkOption {
    type = lib.types.package;
    default =
      pkgs.linkFarm &quot;etc&quot;
      (lib.mapAttrsToList (name: value: {
        name = name;
        path = value;
      }) config.etc);
  };

  config._module.args.pkgs = import &amp;lt;nixpkgs&amp;gt; {
    config = {};
    overlays = [];
  };
  config.etc.foo = pkgs.writeText &quot;foo&quot; &apos;&apos;
    foo configuration
  &apos;&apos;;
  config.etc.bar = pkgs.writeText &quot;bar&quot; &apos;&apos;
    bar configuration
  &apos;&apos;;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run it with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate -A config.etcCombined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;So we can see that it will instantiate, lets see if it will build:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build -A config.etcCombined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;these 3 derivations will be built:
/nix/store/41yfxq4af1vrs0rrgfk5gc36kmjc7270-bar.drv
/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv
/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv
building &apos;/nix/store/41yfxq4af1vrs0rrgfk5gc36kmjc7270-bar.drv&apos;...
building &apos;/nix/store/abyfp1rxk73p0n5kfilv7pawxwvc7hsg-foo.drv&apos;...
building &apos;/nix/store/3da61nmfk546qn2zpxsm57mq6vz6fjx8-etc.drv&apos;...
/nix/store/ca3wyk5m3qhy8n1nbn0181m29qvp1klp-etc
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build -A config.etcCombined &amp;amp;&amp;amp; ls result/ -laa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;/nix/store/ca3wyk5m3qhy8n1nbn0181m29qvp1klp-etc
dr-xr-xr-x - root 31 Dec  1969 Óóø .
drwxrwxr-t - root 16 May 15:13 Óóø ..
lrwxrwxrwx - root 31 Dec  1969 ÔÄñ bar -&amp;gt; /nix/store/1fsjyc2hmilab1qw6jfkf6cb767kz858-bar
lrwxrwxrwx - root 31 Dec  1969 ÔÄñ foo -&amp;gt; /nix/store/wai5dycp0zx1lxg0rhpdxnydhiadpk05-foo
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We can see that &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; link to different derivations&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When trying to figure out which &lt;code&gt;default&lt;/code&gt; to use for &lt;code&gt;etcCombined&lt;/code&gt; infinisil
went to the Nixpkgs Reference Manual. Make sure to go to the correct version.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://nixos.org/manual/nixpkgs/stable/&quot;&gt;24.11pre-git&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://nixos.org/manual/nixpkgs/unstable/&quot;&gt;25.05pre-git&lt;/a&gt; (i.e. unstable)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Once at the website press &lt;code&gt;Ctrl+f&lt;/code&gt; and type &lt;code&gt;symlinkjoin&lt;/code&gt; and hit enter.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Or in your local copy of Nixpkgs you could go to
&lt;code&gt;nixpkgs/pkgs/build-support/ trivial-builders/default.nix&lt;/code&gt;. Then use your
editors search feature, with nvim and helix you press &lt;code&gt;/symlinkjoin&lt;/code&gt; or
&lt;code&gt;/linkFarm&lt;/code&gt; hit enter then press &lt;code&gt;n&lt;/code&gt; to cycle to the next match. It will bring
you to comments and up to date information.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# linkFarm &quot;myexample&quot; [ { name = &quot;hello-test&quot;; path = pkgs.hello; }
# { name = &quot;foobar&quot;; path = pkgs.stack; } ]
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3&gt;Tests&lt;/h3&gt;
&lt;details&gt;
&lt;summary&gt; Click to Expand Test Example &lt;/summary&gt;
&lt;ul&gt;
&lt;li&gt;How to create a Derivation with &lt;code&gt;passthru.tests&lt;/code&gt; outside of Nixpkgs and then
run tests available to your package set?&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir passthru-tests &amp;amp;&amp;amp; cd passthru-tests
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create a &lt;code&gt;default.nix&lt;/code&gt; with the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# default.nix
let
  pkgs = import &amp;lt;nixpkgs&amp;gt; {};

  package = pkgs.runCommand &quot;foo&quot; {
    passthru.tests.simple = pkgs.runCommand &quot;foo-test&quot; {} &apos;&apos;
      if [[ &quot;$(cat ${package})&quot; != &quot;foo&quot; ]]; then
        echo &quot;Result is not foo&quot;
        exit 1
      fi
      touch $out
  &apos;&apos;;
  } &apos;&apos;
    echo foo &amp;gt; $out
  &apos;&apos;;
in
package
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See if it will build:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Try running the test:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build -A passthru.tests
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;this derivation will be built:
/nix/store/pqpqq9x1wnsabzbsb52z4g4y4zy6p7yx-foo-test.drv
building &apos;/nix/store/pqpqq9x1wnsabzbsb52z4g4y4zy6p7yx-foo-test.drv&apos;...
/nix/store/7bbw2ban0mgkh4d59yz3cnai4aavwvb6-foo-test
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Test 2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;passthru.tests&lt;/code&gt; is the convention for defining tests associated with a
derivation. The attributes in &lt;code&gt;passthru&lt;/code&gt; are preserved and accessible after
the derivation is built.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;let
  pkgs = import &amp;lt;nixpkgs&amp;gt; {};

  package =
    pkgs.runCommand &quot;foo&quot; {
      passthru.tests.simple = pkgs.runCommand &quot;foo-test&quot; {} &apos;&apos;
        if [[ &quot;$(cat ${package})&quot; != &quot;foo&quot; ]]; then
          echo &quot;Result is not foo&quot;
          exit 1
        fi
        touch $out
      &apos;&apos;;

      passthru.tests.version = pkgs.testers.testVersion {
         package = package;
         version = &quot;1.2&quot;;
     };

      # pkgs.writeShellApplication
      script = &apos;&apos;
        #!${pkgs.runtimeShell}
        echo &quot;1.2&quot;
      &apos;&apos;;
      passAsFiles = [ &quot;script&quot; ];

    } &apos;&apos;
      cp &quot;$scriptPath&quot; &quot;$out&quot;
    &apos;&apos;;
in
  package
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Try to build it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build -A passthru.tests
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;testers.testVersion&lt;/code&gt; checks if an executable outputs a specific version
string.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;nix-build -A passthru.tests&lt;/code&gt; specifically targets the derivations defined
within the tests attribute of the main derivation.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;these 3 derivations will be built:
  /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv
  /nix/store/s4iawjy5zpv89dbkc3zz7z3ngz4jq2cv-foo-test.drv
  /nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z-foo-test-version.drv
building &apos;/nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv&apos;...
cp: cannot stat &apos;&apos;: No such file or directory
error: builder for &apos;/nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv&apos;
 failed with exit code 1;
     last 1 log lines:
     &amp;gt; cp: cannot stat &apos;&apos;: No such file or directory
     For full logs, run:
       nix log /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv
error: 1 dependencies of derivation &apos;/nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z
-foo-test-version.drv&apos; failed to build
error: build of &apos;/nix/store/s4iawjy5zpv89dbkc3zz7z3ngz4jq2cv-foo-test.drv&apos;,
 &apos;/nix/store/z3gi4pb8jn2h9rvk4dhba85fiphp5g4z-foo-test-version.drv&apos; failed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run &lt;code&gt;nix-build&lt;/code&gt; with no arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq &apos;.[].env&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;__structuredAttrs&quot;: &quot;&quot;,
  &quot;buildCommand&quot;: &quot;cp \&quot;$scriptPath\&quot; \&quot;$out\&quot;\n&quot;,
  &quot;buildInputs&quot;: &quot;&quot;,
  &quot;builder&quot;: &quot;/nix/store/xg75pc4yyfd5n2fimhb98ps910q5lm5n-bash-5.2p37/bin/bash&quot;,
  &quot;cmakeFlags&quot;: &quot;&quot;,
  &quot;configureFlags&quot;: &quot;&quot;,
  &quot;depsBuildBuild&quot;: &quot;&quot;,
  &quot;depsBuildBuildPropagated&quot;: &quot;&quot;,
  &quot;depsBuildTarget&quot;: &quot;&quot;,
  &quot;depsBuildTargetPropagated&quot;: &quot;&quot;,
  &quot;depsHostHost&quot;: &quot;&quot;,
  &quot;depsHostHostPropagated&quot;: &quot;&quot;,
  &quot;depsTargetTarget&quot;: &quot;&quot;,
  &quot;depsTargetTargetPropagated&quot;: &quot;&quot;,
  &quot;doCheck&quot;: &quot;&quot;,
  &quot;doInstallCheck&quot;: &quot;&quot;,
  &quot;enableParallelBuilding&quot;: &quot;1&quot;,
  &quot;enableParallelChecking&quot;: &quot;1&quot;,
  &quot;enableParallelInstalling&quot;: &quot;1&quot;,
  &quot;mesonFlags&quot;: &quot;&quot;,
  &quot;name&quot;: &quot;foo&quot;,
  &quot;nativeBuildInputs&quot;: &quot;&quot;,
  &quot;out&quot;: &quot;/nix/store/9mcrnddb6lf1md14v4lj6s089i99l5k7-foo&quot;,
  &quot;outputs&quot;: &quot;out&quot;,
  &quot;passAsFile&quot;: &quot;buildCommand&quot;,
  &quot;passAsFiles&quot;: &quot;script&quot;,
  &quot;patches&quot;: &quot;&quot;,
  &quot;propagatedBuildInputs&quot;: &quot;&quot;,
  &quot;propagatedNativeBuildInputs&quot;: &quot;&quot;,
  &quot;script&quot;: &quot;#!/nix/store/xg75pc4yyfd5n2fimhb98ps910q5lm5n-bash-5.2p37/bin/bash\necho \&quot;1.2\&quot;\n&quot;,
  &quot;stdenv&quot;: &quot;/nix/store/lgydi1gl5wqcw6k4gyjbaxx7b40zxrsp-stdenv-linux&quot;,
  &quot;strictDeps&quot;: &quot;&quot;,
  &quot;system&quot;: &quot;x86_64-linux&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq
 &apos;.[].env.buildCommand&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;&quot;cp \&quot;$scriptPath\&quot; \&quot;$out\&quot;\n&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;raw mode below&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix derivation show /nix/store/lyz86bd78p7f3yjy1qky6annmggymcwd-foo.drv | jq
 &apos;.[].env.buildCommand&apos; -r
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cp &quot;$scriptPath&quot; &quot;$out&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;It turns out the correct command was &lt;code&gt;passAsFile&lt;/code&gt; not &lt;code&gt;passAsFiles&lt;/code&gt; but that
change wasn‚Äôt enough to fix it. &lt;code&gt;passAsFiles&lt;/code&gt; expects a list of files, not a
single file path. Running &lt;code&gt;nix-build -A passthru.tests&lt;/code&gt; failed saying
&lt;code&gt;&amp;gt; foo --version returned a non-zero exit code.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;let
  pkgs = import &amp;lt;nixpkgs&amp;gt; {};

  package =
    pkgs.runCommand &quot;foo&quot; {
      #passthru.tests.simple = pkgs.runCommand &quot;foo-test&quot; {} &apos;&apos;
      #  if [[ &quot;$(cat ${package})&quot; != &quot;foo&quot; ]]; then
      #    echo &quot;Result is not foo&quot;
      #    exit 1
      #  fi
      #  touch $out
      #&apos;&apos;;

      passthru.tests.version = pkgs.testers.testVersion {
        package = package;
        version = &quot;1.2&quot;;
      };

      # pkgs.writeShellApplication
      script = &apos;&apos;
        #!${pkgs.runtimeShell}
        echo &quot;1.2&quot;
      &apos;&apos;;
      passAsFile = [&quot;script&quot;];
    } &apos;&apos;
      mkdir -p &quot;$out/bin&quot;
      cp &quot;$scriptPath&quot; &quot;$out/bin/foo&quot;
      chmod +x &quot;$out/bin/foo&quot;
    &apos;&apos;;
in
  package
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build -A passthru.tests
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;these 2 derivations will be built:
  /nix/store/lqrlcd64dmpzkggcfzlnsnwjd339czd3-foo.drv
  /nix/store/c3kw4xbdlrig08jrdm5wis1dmv2gnqsd-foo-test-version.drv
building &apos;/nix/store/lqrlcd64dmpzkggcfzlnsnwjd339czd3-foo.drv&apos;...
building &apos;/nix/store/c3kw4xbdlrig08jrdm5wis1dmv2gnqsd-foo-test-version.drv&apos;...
1.2
/nix/store/zsbk5zawak68ailvkwi2gad2bqbqmdz9-foo-test-version
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;h3&gt;Key Takeaways for Debugging NixOS Modules&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;nix-instantiate&lt;/code&gt; is Your Friend:&lt;/strong&gt; Use &lt;code&gt;nix-instantiate&lt;/code&gt; to evaluate your
NixOS modules and pinpoint errors.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Unlock Details with &lt;code&gt;--show-trace&lt;/code&gt;:&lt;/strong&gt; When errors occur, always append
&lt;code&gt;--show-trace&lt;/code&gt; to get a comprehensive stack trace, revealing the origin of the
problem. Remember that in newer Nix versions, the most relevant parts of the
trace are often at the bottom.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Understand Option Types:&lt;/strong&gt; Nix option types (&lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;anything&lt;/code&gt;,
&lt;code&gt;string&lt;/code&gt;/&lt;code&gt;str&lt;/code&gt;, &lt;code&gt;lines&lt;/code&gt;, &lt;code&gt;attrsOf&lt;/code&gt;) are not just about data types; they also
dictate how values are merged and processed within the module system.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Be Mindful of &lt;code&gt;mkOptionDefault&lt;/code&gt;:&lt;/strong&gt; While useful in specific scenarios,
&lt;code&gt;mkOptionDefault&lt;/code&gt; sets a lower priority default. For standard defaults that
can be overridden by user configuration, define them directly within the
&lt;code&gt;config&lt;/code&gt; attribute using &lt;code&gt;lib.mkDefault&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Use &lt;code&gt;builtins.addErrorContext&lt;/code&gt;:&lt;/strong&gt; Enhance your custom error messages by
providing specific context relevant to your module‚Äôs logic using
&lt;code&gt;builtins.addErrorContext&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Derivations vs. Evaluation:&lt;/strong&gt; Be aware of the difference between evaluating
expressions (&lt;code&gt;--eval --strict&lt;/code&gt;) and instantiating derivations
(&lt;code&gt;nix-instantiate&lt;/code&gt;). Strict evaluation can trigger infinite recursion if it
encounters unevaluated derivations with cyclic dependencies during attribute
access.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Explore with &lt;code&gt;nix repl&lt;/code&gt;:&lt;/strong&gt; The &lt;code&gt;nix repl&lt;/code&gt; allows you to interactively
explore Nix expressions and the outputs of derivations, providing insights
into the structure and values within Nixpkgs.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;This chapter has equipped you with essential techniques for debugging and
tracing NixOS modules. We‚Äôve explored how to use &lt;code&gt;nix-instantiate&lt;/code&gt; and
&lt;code&gt;--show-trace&lt;/code&gt; to pinpoint errors, how to interpret Nix‚Äôs often-verbose error
messages, and how to leverage the &lt;code&gt;nix repl&lt;/code&gt; for interactive exploration.
Understanding option types and the nuances of &lt;code&gt;mkOptionDefault&lt;/code&gt; is crucial for
writing robust and predictable modules. We‚Äôve also touched upon the distinction
between evaluation and instantiation, and how that impacts debugging.&lt;/p&gt;
&lt;p&gt;While these tools and techniques are invaluable for understanding and
troubleshooting your own Nix configurations, they also become essential when you
want to contribute to or modify the vast collection of packages and modules
within &lt;strong&gt;Nixpkgs&lt;/strong&gt; itself. Nixpkgs is where the majority of Nix packages and
NixOS modules reside, and learning how to navigate and contribute to it opens up
a whole new level of control and customization within the Nix ecosystem.&lt;/p&gt;
&lt;p&gt;In the next chapter,
&lt;a href=&quot;https://saylesss88.github.io/Working_with_Nixpkgs_Locally_10.html&quot;&gt;Working with Nixpkgs Locally&lt;/a&gt;,
we‚Äôll shift our focus to exploring and modifying Nixpkgs. We‚Äôll cover how to
clone Nixpkgs, how to make changes to package definitions, and how to test those
changes locally before contributing them back upstream. This chapter will
empower you to not just use existing Nix packages, but also to customize and
extend them to fit your specific needs.&lt;/p&gt;
</content></entry><entry><title>Fork, Clone, Contribute</title><id>https://saylesss88.github.io/nixpkgs/fork_clone_contribute.html</id><updated>2025-11-22T00:00:00+00:00</updated><link href="https://saylesss88.github.io/nixpkgs/fork_clone_contribute.html" rel="alternate"/><content type="html">&lt;h1&gt;Fork, Clone, Contribute&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In the &lt;a href=&quot;https://github.com/NixOS/nixpkgs&quot;&gt;Nixpkgs&lt;/a&gt; Repository.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click Fork, then Create a new Fork.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Uncheck the box ‚ÄúOnly fork the &lt;code&gt;master&lt;/code&gt; branch‚Äù, for development we will need
more branches.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you only fork master, you won‚Äôt have the &lt;code&gt;nixos-XX.YY&lt;/code&gt; release branches
available on your fork when you later try to create a PR against them, or
when you want to create a feature branch from them on your fork.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Click &lt;code&gt;&amp;lt;&amp;gt; Code&lt;/code&gt; and Clone the Repo. &lt;code&gt;sayls8&lt;/code&gt; is the name of my GitHub, yours
will obviously be different.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git clone git@github.com:sayls8/nixpkgs.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Figure out the branch that should be used for this change by going through
&lt;a href=&quot;https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md#branch-conventions&quot;&gt;this section&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;When in doubt use &lt;code&gt;master&lt;/code&gt;, that‚Äôs where most changes should go. This can be
changed later by
&lt;a href=&quot;https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md#rebasing-between-branches-ie-from-master-to-staging&quot;&gt;rebasing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Add &lt;a href=&quot;https://github.com/NixOS/nixpkgs&quot;&gt;Nixpkgs&lt;/a&gt; as your upstream:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd nixpkgs

git remote add upstream https://github.com/NixOS/nixpkgs.git
# Make sure you have the latest changes from upstream Nixpkgs
git fetch upstream
# Show currently configured remote repository
git remote -v
origin  git@github.com:sayls8/nixpkgs.git (fetch)
origin  git@github.com:sayls8/nixpkgs.git (push)
upstream        https://github.com/NixOS/nixpkgs.git (fetch)
upstream        https://github.com/NixOS/nixpkgs.git (push)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Understanding Your Remotes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This output confirms that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;origin&lt;/code&gt; is your personal fork on GitHub (&lt;code&gt;sayls8/nixpkgs.git&lt;/code&gt;). When you
&lt;code&gt;git push origin ...&lt;/code&gt;, your changes go here.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;upstream&lt;/code&gt; is the official Nixpkgs repository (&lt;code&gt;NixOS/nixpkgs.git&lt;/code&gt;). When you
&lt;code&gt;git fetch upstream&lt;/code&gt;, you‚Äôre getting the latest updates from the main project.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This setup ensures you can easily pull updates from the original project and
push your contributions to your own fork.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# Shows a ton of remote branches
git branch -r | grep upstream
# Narrow it down
git branch -r | grep upstream | grep nixos-
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next Steps for Contributing&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ensure &lt;code&gt;master&lt;/code&gt; is up to date with &lt;code&gt;upstream&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git checkout master
git pull upstream master
git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git pull upstream master&lt;/code&gt; is equivalent to running &lt;code&gt;git fetch upstream&lt;/code&gt;
followed by &lt;code&gt;git merge upstream/master&lt;/code&gt; into your current branch (&lt;code&gt;master&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git push origin master&lt;/code&gt; updates your forks remote with the fetched changes.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This keeps your fork in sync to avoid conflicts.&lt;/p&gt;
&lt;p&gt;If targeting another branch, replace &lt;code&gt;master&lt;/code&gt; with &lt;code&gt;nixos-24.11&lt;/code&gt; for example.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Create a Feature Branch&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git checkout master
git checkout -b my-feature-branch # name should represent the feature
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Make and Test Changes&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NixOS/nixpkgs/blob/master/pkgs/README.md#conventions&quot;&gt;Packaging Conventions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;New package&lt;/strong&gt;: Add to
&lt;code&gt;pkgs/by-name/&amp;lt;first-two-letters&amp;gt;/&amp;lt;package-name&amp;gt;/default.nix&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example structure&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{ lib, stdenv, fetchFromGitHub }: stdenv.mkDerivation {
pname = &quot;xyz&quot;; version = &quot;1.2.3&quot;; src = fetchFromGitHub { ... }; ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Update package&lt;/strong&gt;: Edit version and &lt;code&gt;sha256&lt;/code&gt; in the package‚Äôs &lt;code&gt;default.nix&lt;/code&gt;.
Use &lt;code&gt;nix-prefetch-url&lt;/code&gt; to update hashes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-prefetch-url &amp;lt;source-url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Fix a bug&lt;/strong&gt;: Modify files in &lt;code&gt;pkgs/&lt;/code&gt;, &lt;code&gt;nixos/modules/&lt;/code&gt;, or elsewhere.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Test locally&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Build:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build -A &amp;lt;package-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Test in a shell&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-shell -p &amp;lt;package-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For NixOS modules:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nixos-rebuild test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Follow the Nixpkgs Contributing Guide.&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;&lt;strong&gt;Commit and Push&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Commit with a clear message, make sure to follow
&lt;a href=&quot;https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md#commit-conventions&quot;&gt;commit conventions&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Commit Conventions&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a commit for each logical unit.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check for unnecessary whitespace with &lt;code&gt;git diff --check&lt;/code&gt; before committing.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you have commits &lt;code&gt;pkg-name: oh, forgot to insert whitespace&lt;/code&gt;: squash
commits in this case. Use &lt;code&gt;git rebase -i&lt;/code&gt;. See
&lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History#_squashing&quot;&gt;Squashing Commits&lt;/a&gt;
for additional information.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For consistency, there should not be a period at the end of the commit
message‚Äôs summary line (the first line of the commit message).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When adding yourself as maintainer in the same pull request, make a separate
commit with the message maintainers: &lt;code&gt;add &amp;lt;handle&amp;gt;&lt;/code&gt;. Add the commit before
those making changes to the package or module. See
&lt;a href=&quot;https://github.com/NixOS/nixpkgs/blob/master/maintainers/README.md&quot;&gt;Nixpkgs Maintainers&lt;/a&gt;
for details.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Format the commit messages in the following way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;(pkg-name): (from -&amp;gt; to | init at version | refactor | etc)

(Motivation for change. Link to release notes. Additional information.)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;a) For example, for the &lt;code&gt;airshipper&lt;/code&gt; package:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git add pkgs/by-name/ai/airshipper/
git commit -m &quot;airshipper: init at 0.1.0&quot;

Adds the airshipper tool for managing game assets.
Upstream homepage: https://github.com/someuser/airshipper&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b) Updating &lt;code&gt;airshipper&lt;/code&gt; to a new version&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git add pkgs/by-name/ai/airshipper/
git commit -m &quot;airshipper: 0.1.0 -&amp;gt; 0.2.0

Updated airshipper to version 0.2.0. This release includes:
- Improved asset fetching logic
- Bug fixes for network errors

Release notes: https://github.com/someuser/airshipper/releases/tag/v0.2.0&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c) Fixing a bug in &lt;code&gt;airshipper&lt;/code&gt;‚Äôs package definition&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git add pkgs/by-name/ai/airshipper/
git commit -m &quot;airshipper: fix: build with latest glibc

Resolved build failures on unstable channel due to changes in glibc.
Patched source to use updated API calls.
&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;nginx: init at 2.0.1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;firefox: 122.0 -&amp;gt; 123.0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vim: fix build with gcc13&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Push:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git push origin my-feature-branch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you push your feature branch, it will output a link that you can follow to
complete the PR on GitHub.&lt;/p&gt;
&lt;p&gt;If you have the &lt;code&gt;gh-cli&lt;/code&gt; set up you can also do this from the command line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gh pr create --repo NixOS/nixpkgs --base master --head sayls8:feat/my-package
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Create a Pull Request&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Go to &lt;a href=&quot;https://github.com/sayls8/nixpkgs&quot;&gt;https://github.com/sayls8/nixpkgs&lt;/a&gt;. (your fork) Click the PR prompt for
my-feature-branch. Set the base branch to &lt;code&gt;NixOS/nixpkgs:master&lt;/code&gt; (or
&lt;code&gt;nixos-24.11&lt;/code&gt;). Write a PR description: Purpose of the change. Related issues
(e.g., Fixes #1234). Testing steps (e.g., &lt;code&gt;nix-build -A &amp;lt;package-name&amp;gt;&lt;/code&gt;). Submit
and respond to feedback.&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;Handle Updates&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For reviewer feedback or upstream changes:&lt;/p&gt;
&lt;p&gt;Edit, commit, and push:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git add . git commit -m &quot;&amp;lt;package-name&amp;gt;: address feedback&quot; git push origin my-feature-branch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rebase if needed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git fetch upstream
git rebase upstream/master  # or upstream/nixos-24.11
git push origin my-feature-branch --force
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;Cleanup&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After PR merge:&lt;/p&gt;
&lt;p&gt;Delete branch:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git push origin --delete my-feature-branch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sync master:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git checkout master
git pull upstream master
git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Addressing the Many Branches&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;No need to manage all branches: The &lt;code&gt;nixos-branches&lt;/code&gt; are just metadata from
upstream. You only check out the one you need (e.g., &lt;code&gt;master&lt;/code&gt; or
&lt;code&gt;nixos-24.11&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Focus on relevant branches: The filter (&lt;code&gt;grep nixos-&lt;/code&gt;) shows the key release
branches. Ignore -small branches and older releases unless specifically
required. Confirm latest stable: If you‚Äôre targeting a stable branch,
&lt;code&gt;nixos-24.11&lt;/code&gt; is likely the latest (or &lt;code&gt;nixos-25.05&lt;/code&gt; if it‚Äôs active). Verify
via NixOS status.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><title>Local Nixpkgs</title><id>https://saylesss88.github.io/nixpkgs/local_package.html</id><updated>2025-11-22T00:00:00+00:00</updated><link href="https://saylesss88.github.io/nixpkgs/local_package.html" rel="alternate"/><content type="html">&lt;h1&gt;Creating and Building a Local Package within a Nixpkgs Clone&lt;/h1&gt;
&lt;p&gt;This chapter demonstrates the fundamental pattern for creating a package. Every
package recipe is a file that declares a function. This function takes the
packages dependencies as argument.&lt;/p&gt;
&lt;p&gt;In this example we‚Äôll make a simple package with &lt;code&gt;coreutils&lt;/code&gt; and build it.
Demonstrating the process of building and testing a local package.&lt;/p&gt;
&lt;p&gt;This chapter will assume you have already have a cloned fork of Nixpkgs. I
choose to clone mine to the &lt;code&gt;~/src/&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;You can check out the &lt;code&gt;nixpkgs/pkgs/README.md&lt;/code&gt;
&lt;a href=&quot;https://github.com/NixOS/nixpkgs/tree/master/pkgs&quot;&gt;Here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The Nixpkgs Contributing Guide can be found
&lt;a href=&quot;https://github.com/NixOS/nixpkgs/blob/master/CONTRIBUTING.md&quot;&gt;Here&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Create your Package directory and a &lt;code&gt;default.nix&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;For this example, we‚Äôll create a package called &lt;code&gt;testPackage&lt;/code&gt; and will place it
in the &lt;code&gt;nixpkgs/pkgs/misc&lt;/code&gt; directory.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd ~/src/nixpkgs/pkgs/misc
mkdir testPackage &amp;amp;&amp;amp; cd testPackage
hx default.nix
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# default.nix
{
  runCommand,
  coreutils,
}:
runCommand &quot;testPackage&quot; {
  nativeBuildInputs = [
    coreutils
  ];
} &apos;&apos;

  echo &apos;This is a Test&apos; &amp;gt; $out
&apos;&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we need to add our &lt;code&gt;testPackage&lt;/code&gt; to &lt;code&gt;all-packages.nix&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd pkgs/top-level
hx all-packages.nix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;all-packages.nix&lt;/code&gt; is a centralized module that defines all available package
expressions.&lt;/p&gt;
&lt;p&gt;We‚Äôll add our package in the list alphabetically:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# all-packages.nix
# `/msc` # editor search inside file
# Scroll down to t&apos;s
# snip ...
termusic = callPackage ../applications/autio/termusic { };

# we add our package here
testPackage = callPackage ../misc/testPackage { };

tfk8s = callPackage ../applications/misc/tfk8s { };
# snip ...
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;callPackage&lt;/code&gt; is a core utility in Nixpkgs. It takes a Nix expression (like
our &lt;code&gt;default.nix&lt;/code&gt; file, which defines a function) and automatically provides
the function with any arguments it declares, by looking them up within the
&lt;code&gt;pkgs&lt;/code&gt; set (or the scope where &lt;code&gt;callPackage&lt;/code&gt; is invoked). This means you only
need to list the dependencies your package needs in its &lt;code&gt;default.nix&lt;/code&gt; function
signature, and &lt;code&gt;callPackage&lt;/code&gt; will ‚Äúinject‚Äù the correct versions of those
packages. This is what the &lt;code&gt;callPackage&lt;/code&gt; Nix Pill demonstrates at a lower
level.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Understanding &lt;code&gt;pkgs/by-name/&lt;/code&gt; and other locations&lt;/h2&gt;
&lt;p&gt;Nixpkgs uses different conventions for package placement:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Older categories (e.g., &lt;code&gt;pkgs/misc/&lt;/code&gt;, &lt;code&gt;pkgs/applications/&lt;/code&gt;):&lt;/strong&gt; Packages
within these directories typically use &lt;code&gt;default.nix&lt;/code&gt; as their definition file
(e.g., &lt;code&gt;pkgs/misc/testPackage/default.nix&lt;/code&gt;). &lt;strong&gt;These packages are NOT
automatically included&lt;/strong&gt; in the top-level &lt;code&gt;pkgs&lt;/code&gt; set; they &lt;em&gt;must&lt;/em&gt; be This
chapter will assume you have already have a cloned fork of Nixpkgs. explicitly
added via a &lt;code&gt;callPackage&lt;/code&gt; entry in &lt;code&gt;pkgs/top-level/all-packages.nix&lt;/code&gt;. This is
the method demonstrated in this chapter for our &lt;code&gt;testPackage&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The new &lt;code&gt;pkgs/by-name/&lt;/code&gt; convention:&lt;/strong&gt; This is the &lt;em&gt;preferred location for
new packages&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Packages here are placed in a directory structure like
&lt;code&gt;pkgs/by-name/&amp;lt;first-two-letters&amp;gt;/&amp;lt;package-name&amp;gt;/&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Crucially, their main definition file is named &lt;code&gt;package.nix&lt;/code&gt; (e.g.,
&lt;code&gt;pkgs/by-name/te/testPackage/package.nix&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Packages placed within &lt;code&gt;pkgs/by-name/&lt;/code&gt; are automatically discovered and
exposed&lt;/strong&gt; by Nixpkgs‚Äô top-level &lt;code&gt;pkgs&lt;/code&gt; set. They &lt;strong&gt;do not&lt;/strong&gt; require a manual
&lt;code&gt;callPackage&lt;/code&gt; entry in &lt;code&gt;all-packages.nix&lt;/code&gt;. This results in a more modular
and scalable approach, reducing manual maintenance.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ùó : While this example uses &lt;code&gt;pkgs/misc/&lt;/code&gt; to demonstrate explicit
&lt;code&gt;callPackage&lt;/code&gt; usage, when contributing a &lt;em&gt;new&lt;/em&gt; package to Nixpkgs, you should
nearly always place it within &lt;code&gt;pkgs/by-name/&lt;/code&gt; and name its definition file
&lt;code&gt;package.nix&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NixOS/nixpkgs/blob/master/pkgs/by-name/README.md&quot;&gt;pkgs/by-name/README&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There are some
&lt;a href=&quot;https://github.com/NixOS/nixpkgs/blob/master/pkgs/by-name/README.md#limitations&quot;&gt;Limitations&lt;/a&gt;
to this approach.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NixOS/nixpkgs-vet&quot;&gt;nixpkgs-vet&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Previously, packages were manually added to &lt;code&gt;all-packages.nix&lt;/code&gt;. While this is no
longer needed in most cases, understanding the old method provides useful
context for troubleshooting legacy configurations or custom integrations.&lt;/p&gt;
&lt;h2&gt;Try Building the Package&lt;/h2&gt;
&lt;p&gt;Move to the root directory of Nixpkgs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd ~/src/nixpkgs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Try building it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build -A testPackage
this derivation will be built:
this derivation will be built:
  /nix/store/yrbjsxmgzkl24n75sqjfxbpv5cs3b9hc-testPackage.drv
building &apos;/nix/store/yrbjsxmgzkl24n75sqjfxbpv5cs3b9hc-testPackage.drv&apos;...
/nix/store/3012zlv30vn6ifihr1jxbg5z3ysw0hl3-testPackage
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;runCommand&lt;/code&gt; is a simple builder, it takes 3 arguments. The first is the package
name the second is the derivation attributes, and the third is the script to
run.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cat ~/src/nixpkgs/result
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       ‚îÇ File: result
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1   ‚îÇ This is a Test
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-instantiate --eval -A testPackage.meta.position
&quot;/home/jr/src/nixpkgs/pkgs/misc/testPackage/default.nix:6&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tools like &lt;code&gt;nix search&lt;/code&gt; and the Nixpkgs website use the &lt;code&gt;meta&lt;/code&gt; information for
documentation and discoverability. It can also be useful for debugging and helps
to provide better error messages. The above command shows that the
&lt;code&gt;meta.position&lt;/code&gt; attribute points to the file and line where the package
definition begins, which is very useful for debugging.&lt;/p&gt;
&lt;p&gt;Typically a file will have a &lt;code&gt;meta&lt;/code&gt; attribute that looks similar to the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;meta = with lib; {
    homepage = &quot;https://www.openssl.org/&quot;;
    description = &quot;A cryptographic library that implements the SSL and TLS protocols&quot;;
    license = licenses.openssl;
    platforms = platforms.all;
} // extraMeta;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For example, the following shows how Nix is able to discover different parts of
your configuration:&lt;/p&gt;
&lt;p&gt;Launch the &lt;code&gt;nix repl&lt;/code&gt; and load your local flake:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd /src
nix repl
nix-repl&amp;gt; :lf nixpkgs
nix-repl&amp;gt; outputs.legacyPackages.x86_64-linux.openssl.meta.position
&quot;/nix/store/syvnmj3hhckkbncm94kfkbl76qsdqqj3-source/pkgs/development/libraries/openssl/default.nix:303&quot;
nix-repl&amp;gt; builtins.unsafeGetAttrPos &quot;description&quot; outputs.legacyPackages.x86_64-linux.openssl.meta
{
  column = 9;
  file = &quot;/nix/store/syvnmj3hhckkbncm94kfkbl76qsdqqj3-source/pkgs/development/libraries/openssl/default.nix&quot;;
  line = 303;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lets create just the &lt;code&gt;meta.description&lt;/code&gt; for demonstration purposes.&lt;/p&gt;
&lt;h2&gt;Adding the meta attribute&lt;/h2&gt;
&lt;p&gt;Since we don‚Äôt have a &lt;code&gt;meta&lt;/code&gt; attribute this points to a default value that‚Äôs
incorrect.&lt;/p&gt;
&lt;p&gt;Let‚Äôs add the &lt;code&gt;meta&lt;/code&gt; attribute and try it again:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# default.nix
{
  runCommand,
  coreutils,
}:
runCommand &quot;testPackage&quot; {
  nativeBuildInputs = [
    coreutils
  ];

  meta = {
    description = &quot;test package&quot;;
};
} &apos;&apos;

  echo &apos;This is a Test&apos; &amp;gt; $out
&apos;&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;nix-instantiate --eval -A testPackage.meta.position
&quot;/home/jr/src/nixpkgs/pkgs/misc/testPackage/default.nix:11&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now it points us to the 11‚Äôth line, right where our &lt;code&gt;meta.description&lt;/code&gt; is.&lt;/p&gt;
&lt;p&gt;Let‚Äôs stage our package so nix recognises it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd ~/nixpkgs
git add pkgs/misc/testPackage/
nix edit .#testPackage
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I used &lt;code&gt;nix edit&lt;/code&gt; here to ensure it was picked up properly.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;default.nix&lt;/code&gt; that we‚Äôve been working on should open in your &lt;code&gt;$EDITOR&lt;/code&gt;&lt;/p&gt;
</content></entry><entry><title>Nixpkgs Overlays</title><id>https://saylesss88.github.io/nixpkgs/overlay.html</id><updated>2025-11-22T00:00:00+00:00</updated><link href="https://saylesss88.github.io/nixpkgs/overlay.html" rel="alternate"/><content type="html">&lt;h1&gt;Nixpkgs Overlays&lt;/h1&gt;
&lt;p&gt;The following is done with a local clone of Nixpkgs located at &lt;code&gt;~/src/nixpkgs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In this example, we will create an overlay to override the version of
&lt;code&gt;btrfs-progs&lt;/code&gt;. In the root directory of our local clone of Nixpkgs
(i.e.&lt;code&gt;~/src/nixpkgs&lt;/code&gt;) we can run the following command to locate &lt;code&gt;btrfs-progs&lt;/code&gt;
within Nixpkgs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;fd &apos;btrfs-progs&apos; .
./pkgs/by-name/bt/btrfs-progs/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Open the &lt;code&gt;package.nix&lt;/code&gt; in the above directory and copy the &lt;code&gt;src&lt;/code&gt; block within
the &lt;code&gt;stdenv.mkDerivation&lt;/code&gt; block like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# package.nix
  version = &quot;6.14&quot;;

  src = fetchurl {
    url = &quot;mirror://kernel/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v${version}.tar.xz&quot;;
    hash = &quot;sha256-31q4BPyzbikcQq2DYfgBrR4QJBtDvTBP5Qzj355+PaE=&quot;;
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we use the above &lt;code&gt;src&lt;/code&gt; block in our overlay we‚Äôll need to add
&lt;code&gt;src = self.fetchurl&lt;/code&gt; for our overlay to have access to &lt;code&gt;fetchurl&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We will replace the version with our desired version number. To find another
version that actually exists we need to check their github repos
&lt;a href=&quot;https://github.com/kdave/btrfs-progs/releases&quot;&gt;btrfs-progs Releases&lt;/a&gt;. I can see
that the previous version was &lt;code&gt;v6.13&lt;/code&gt;, lets try that.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd ~/src/nixpkgs
hx overlay.nix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will change the version to &lt;code&gt;6.13&lt;/code&gt; for demonstration purposes. All that is
really required is changing the version and 1 character in the &lt;code&gt;hash&lt;/code&gt; which
would cause a refetch and recalculation of the hash. We will use an empty string
to follow convention:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# overlay.nix
self: super: {
  btrfs-progs = super.btrfs-progs.overrideAttrs (old: rec {
      version = &quot;6.13&quot;;

      # Notice the `self` added here
      src = self.fetchurl {
        url = &quot;mirror://kernel/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v${version}.tar.xz&quot;;
        hash = &quot;&quot;;
      };
    };
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To build this with the file right from the root of the local Nixpkgs (i.e.
&lt;code&gt;~/src/nixpkgs&lt;/code&gt;) you could run the following. Running the command this way
avoids the impurity of looking it up in the &lt;code&gt;~/.config&lt;/code&gt; directory:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build -A btrfs-progs --arg overlays &apos;[ (import ./overlay.nix) ]&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The compiler will give you back the correct &lt;code&gt;hash&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
got:    sha256-ZbPyERellPgAE7QyYg7sxqfisMBeq5cTb/UGx01z7po=
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Replace the empty &lt;code&gt;hash&lt;/code&gt; with the new hash value we just got from the compiler
so the &lt;code&gt;overlay.nix&lt;/code&gt; would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;self: super: {
  btrfs-progs = super.btrfs-progs.overrideAttrs (old: rec {
    version = &quot;6.13&quot;;

    src = self.fetchurl {
      url = &quot;mirror://kernel/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v${version}.tar.xz&quot;;
      hash = &quot;sha256-ZbPyERellPgAE7QyYg7sxqfisMBeq5cTb/UGx01z7po=&quot;;
    };
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Try building it again:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build -A btrfs-progs --arg overlays &apos;[ (import ./overlay.nix) ]&apos;
checking for references to /build/ in /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13...
gzipping man pages under /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/share/man/
patching script interpreter paths in /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13
/nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/bin/fsck.btrfs: interpreter directive changed from &quot;#!/bin/sh -f&quot; to &quot;/nix/store/xy4jjgw87sbgwylm5kn047d9gkbhsr9x-bash-5.2p37/bin/sh -f&quot;
stripping (with command strip and flags -S -p) in  /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/lib /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/bin
/nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can inspect it with the repl:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd ~/src/nixpkgs
nix repl
nix-repl&amp;gt; :a import ./. { overlays = [ (import ./overlay.nix) ]; }
nix-repl&amp;gt; btrfs-progs
¬´derivation /nix/store/6yxhj84cwcsnrd87rcxbd6w08l9ikc6p-btrfs-progs-6.13.drv¬ª
nix-repl&amp;gt; btrfs-progs.drvAttrs.buildInputs
[
  ¬´derivation /nix/store/yg4llzkcla5rppv8r1iikyamfxg3g4sg-acl-2.3.2.drv¬ª
  ¬´derivation /nix/store/vqczbcwjnid6bs4cv3skl7kyd6kkzcfx-attr-2.5.2.drv¬ª
  ¬´derivation /nix/store/xrvx0azszpdh2x0lnldakqx25vfxab19-e2fsprogs-1.47.2.drv¬ª
  ¬´derivation /nix/store/iil4b8adk615zhp6wmzjx16z1v2f8f4j-util-linux-minimal-2.41.drv¬ª
  ¬´derivation /nix/store/wwld8wp91m26wz69gp8vzh090sh5ygxd-lzo-2.10.drv¬ª
  ¬´derivation /nix/store/w4ncw24gdfkbx9779xpgjli5sagi506m-systemd-minimal-libs-257.5.drv¬ª
  ¬´derivation /nix/store/dmh4lvmq6n8hy56q93kplvnfnlwqzzv5-zlib-1.3.1.drv¬ª
  ¬´derivation /nix/store/h8iwhnr636dwb72qqcyzp111ajjxgzr2-zstd-1.5.7.drv¬ª
]
nix-repl&amp;gt; btrfs-progs.drvAttrs.version
&quot;6.13&quot;
nix-repl&amp;gt; btrfs-progs.drvAttrs.src
¬´derivation /nix/store/y5nkz1xczxha4xl93qq3adndyc46dcvf-btrfs-progs-v6.13.tar.xz.drv¬ª
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using &lt;code&gt;:a&lt;/code&gt; adds the attributes from the resulting set into scope and avoids
bringing the entire &lt;code&gt;nixpkgs&lt;/code&gt; set into scope.&lt;/p&gt;
&lt;p&gt;To see whats available, you can for example type &lt;code&gt;btrfs-progs.drvAttrs.&lt;/code&gt; then
hit &lt;code&gt;TAB&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Another way to do this is to move our overlay to the
&lt;code&gt;~/.config/nixpkgs/overlays&lt;/code&gt; directory and rename the file like the following,
agian this adds an impurity because it relies on your &lt;code&gt;~/.config&lt;/code&gt; directory
which is different from user to user:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mv overlay.nix ~/.config/nixpkgs/overlays/btrfs-progs.nix
cd ~/src/nixpkgs
nix-build -A btrfs-progs
checking for references to /build/ in /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13...
gzipping man pages under /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/share/man/
patching script interpreter paths in /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13
/nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/bin/fsck.btrfs: interpreter directive changed from &quot;#!/bin/sh -f&quot; to &quot;/nix/store/xy4jjgw87sbgwylm5kn047d9gkbhsr9x-bash-5.2p37/bin/sh -f&quot;
stripping (with command strip and flags -S -p) in  /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/lib /nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13/bin
/nix/store/szd6lizahidjniz85a0g1wsrfknirhwb-btrfs-progs-6.13
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Overlays with Flakes&lt;/h2&gt;
&lt;p&gt;In a flake, overlays are defined in the &lt;code&gt;outputs.overlays&lt;/code&gt; attribute set of the
&lt;code&gt;flake.nix&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;They are then applied to &lt;code&gt;nixpkgs&lt;/code&gt; inputs using
&lt;code&gt;inputs.nixpkgs.follows = &quot;nixpkgs&quot;;&lt;/code&gt; (or similar) and the overlays attribute on
the input.&lt;/p&gt;
&lt;p&gt;Example of flake usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# flake.nix
{
  description = &quot;My NixOS flake with custom overlays&quot;;

  inputs = {
    nixpkgs.url = &quot;github:NixOS/nixpkgs/nixos-unstable&quot;;
  };

  outputs = { self, nixpkgs, ... }: {

    overlays.myCustomOverlay = final: prev: {
      btrfs-progs = prev.btrfs-progs.overrideAttrs (old: rec {
        version = &quot;6.13&quot;;
        src = self.fetchurl {
          url = &quot;mirror://kernel/linux/kernel/people/kdave/btrfs-progs/btrfs-progs-v${version}.tar.xz&quot;;
          hash = &quot;sha256-ZbPyERellPgAE7QyYg7sxqfisMBeq5cTb/UGx01z7po=&quot;;
        };
      });
    };

    nixosConfigurations.my-system = nixpkgs.lib.nixosSystem {
      system = &quot;x86_64-linux&quot;;
      modules = [
        # Apply the overlay
        { nixpkgs.overlays = [ self.overlays.myCustomOverlay ]; }
        ./configuration.nix
      ];
    };
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix flake show
path:/home/jr/btrfs-progs?lastModified=1749655369&amp;amp;narHash=sha256-ln6dLiqo7TxStQSXgcIwfbdt7STGw4ZHftZRfWpY/JQ%3D
‚îú‚îÄ‚îÄ‚îÄnixosConfigurations
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄmy-system: NixOS configuration
‚îî‚îÄ‚îÄ‚îÄoverlays
    ‚îî‚îÄ‚îÄ‚îÄmyCustomOverlay: Nixpkgs overlay
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><title>Encrypted Impermanence</title><id>https://saylesss88.github.io/nix/encrypted_impermanence.html</id><updated>2025-11-22T00:00:00+00:00</updated><link href="https://saylesss88.github.io/nix/encrypted_impermanence.html" rel="alternate"/><content type="html">&lt;h1&gt;Encrypted Impermanence&lt;/h1&gt;
&lt;details&gt;
&lt;summary&gt; ‚úîÔ∏è Click to Expand Table of Contents&lt;/summary&gt;
&lt;!-- toc --&gt;
&lt;/details&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ùó Important Note: This guide details a setup involving encrypted partitions
and impermanent NixOS. While powerful, such configurations require careful
attention to detail. Incorrect steps, especially concerning encryption keys or
persistent data paths, can lead to &lt;strong&gt;permanent data loss&lt;/strong&gt;. Please read all
instructions thoroughly before proceeding and consider backing up any critical
data beforehand. This has only been tested with the disk layout described in
&lt;a href=&quot;https://saylesss88.github.io/installation/encrypted_manual.html&quot;&gt;Encrypted Setups&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Getting Started&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Add impermanence to your &lt;code&gt;flake.nix&lt;/code&gt;. You will change the &lt;code&gt;hostname&lt;/code&gt; in the
flake to match your &lt;code&gt;networking.hostName&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# flake.nix
{
  description = &quot;NixOS configuration&quot;;

  inputs = {
    nixpkgs.url = &quot;github:nixos/nixpkgs/nixos-unstable&quot;;
    disko.url = &quot;github:nix-community/disko/latest&quot;;
    disko.inputs.nixpkgs.follows = &quot;nixpkgs&quot;;
    impermanence.url = &quot;github:nix-community/impermanence&quot;;
  };

  outputs = inputs@{ nixpkgs, ... }: {
    nixosConfigurations = {
      hostname = nixpkgs.lib.nixosSystem {
        system = &quot;x86_64-linux&quot;;
        modules = [
          ./configuration.nix
          inputs.disko.nixosModules.disko
          inputs.impermanence.nixosModules.impermanence
        ];
      };
    };
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Discover where your root subvolume is located with &lt;code&gt;findmnt&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you followed the
&lt;a href=&quot;https://saylesss88.github.io/installation/encrypted_manual.html&quot;&gt;Encrypted Setups&lt;/a&gt;
guide, your encrypted subvolume should be located at:
&lt;code&gt;/dev/mapper/cryptroot /mnt&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Your encrypted Btrfs partition, once unlocked by LUKS, will be available at
&lt;code&gt;/dev/mapper/cryptroot&lt;/code&gt; as configured here in the &lt;code&gt;disk-config.nix&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# disk-config2.nix
# ... snip ...
            luks = {
              size = &quot;100%&quot;;
              label = &quot;luks&quot;;
              content = {
                type = &quot;luks&quot;;
                name = &quot;cryptroot&quot;;
                content = {
# ... snip ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Double check that the paths exist:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd /dev/mapper/crypt&amp;lt;TAB&amp;gt;  # autocomplete should fill out /dev/mapper/cryptroot
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Create an &lt;code&gt;impermanence.nix&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now, create a new file named &lt;code&gt;impermanence.nix&lt;/code&gt; in your configuration directory
(i.e. your flake directory). This file will contain all the specific settings
for your impermanent setup, including BTRFS subvolume management and persistent
data locations. Since this file is right next to your &lt;code&gt;configuration.nix&lt;/code&gt;,
you‚Äôll just add an &lt;code&gt;imports = [ ./impermanence.nix ]&lt;/code&gt; to your
&lt;code&gt;configuration.nix&lt;/code&gt; apply it to your configuration.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;{
  config,
  lib,
  ...
}: {
  boot.initrd.postDeviceCommands = lib.mkAfter &apos;&apos;
    echo &quot;Rollback running&quot; &amp;gt; /mnt/rollback.log
     mkdir -p /mnt
     mount -t btrfs /dev/mapper/cryptroot /mnt

     # Recursively delete all nested subvolumes inside /mnt/root
     btrfs subvolume list -o /mnt/root | cut -f9 -d&apos; &apos; | while read subvolume; do
       echo &quot;Deleting /$subvolume subvolume...&quot; &amp;gt;&amp;gt; /mnt/rollback.log
       btrfs subvolume delete &quot;/mnt/$subvolume&quot;
     done

     echo &quot;Deleting /root subvolume...&quot; &amp;gt;&amp;gt; /mnt/rollback.log
     btrfs subvolume delete /mnt/root

     echo &quot;Restoring blank /root subvolume...&quot; &amp;gt;&amp;gt; /mnt/rollback.log
     btrfs subvolume snapshot /mnt/root-blank /mnt/root

     umount /mnt
  &apos;&apos;;

  environment.persistence.&quot;/persist&quot; = {
    directories = [
      &quot;/etc&quot;
      &quot;/var/spool&quot;
      &quot;/root&quot;
      &quot;/srv&quot;
      &quot;/etc/NetworkManager/system-connections&quot;
      &quot;/var/lib/bluetooth&quot;
    ];
    files = [
      # &quot;/etc/machine-id&quot;
      # Add more files you want to persist
    ];
  };

# optional quality of life setting
  security.sudo.extraConfig = &apos;&apos;
    Defaults lecture = never
  &apos;&apos;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/mnt/rollback.log&lt;/code&gt;: this log will be available during the boot process for
debugging if the rollback fails, but won‚Äôt persist.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With the above impermanence script, the btrfs subvolumes are deleted recursively
and replaced with the &lt;code&gt;root-blank&lt;/code&gt; snapshot we took during the install.&lt;/p&gt;
&lt;p&gt;I have commented out &lt;code&gt;&quot;/etc/machine-id&quot;&lt;/code&gt; because we already copied over all of
the files to their persistent location and the above setting would work once and
then cause a conflict.&lt;/p&gt;
&lt;h2&gt;configuration.nix changes&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# configuration.nix
  boot.initrd.luks.devices = {
    cryptroot = {
      device = &quot;/dev/disk/by-partlabel/luks&quot;;
      allowDiscards = true;
      preLVM = true;
    };
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;This defines how your system‚Äôs initial ramdisk (&lt;code&gt;initrd&lt;/code&gt;) should handle a
specific encrypted disk during the boot process. It helps with timing and is a
more robust way of telling Nix that we are using an encrypted disk.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following is optional to enable &lt;code&gt;autoScrub&lt;/code&gt; for btrfs, the wiki shows
&lt;code&gt;interval = &quot;monthly&quot;;&lt;/code&gt; FYI.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;# configuration.nix
  services.btrfs.autoScrub = {
    enable = true;
    interval = &quot;weekly&quot;;
    fileSystems = [&quot;/&quot;];
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Remember to ensure that your &lt;code&gt;hostname&lt;/code&gt; in your &lt;code&gt;configuration.nix&lt;/code&gt; matches
the &lt;code&gt;hostname&lt;/code&gt; in your &lt;code&gt;flake.nix&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Applying Your Impermanence Configuration&lt;/h3&gt;
&lt;p&gt;Once you have completed all the steps and created or modified the necessary
files (&lt;code&gt;flake.nix&lt;/code&gt;, &lt;code&gt;impermanence.nix&lt;/code&gt;), you need to apply these changes to your
NixOS system.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Navigate to your NixOS configuration directory (where your &lt;code&gt;flake.nix&lt;/code&gt; is
located).&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd /path/to/your/flake
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Rebuild and Switch: Execute the &lt;code&gt;nixos-rebuild switch&lt;/code&gt; command. This command
will:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Evaluate your &lt;code&gt;flake.nix&lt;/code&gt; and the modules it imports (including your new
&lt;code&gt;impermanence.nix&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Build a new NixOS system closure based on your updated configuration.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Activate the new system configuration, making it the current running system.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo nixos-rebuild switch --flake .#hostname # Replace &apos;hostname&apos; with your actual system hostname
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Perform an Impermanence Test (Before Reboot):&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Before you reboot, create a temporary directory and file in a non-persistent
location. Since you haven‚Äôt explicitly added &lt;code&gt;/imperm_test&lt;/code&gt; to your
&lt;code&gt;environment.persistence.&quot;/persist&quot;&lt;/code&gt; directories, this file should not survive
a reboot.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir /imperm_test
echo &quot;This should be Gone after Reboot&quot; | sudo tee /imperm_test/testfile
ls -l /imperm_test/testfile # Verify the file exists
cat /imperm_test/testfile # Verify content
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Reboot Your System: For the impermanence setup to take full effect and for
your root filesystem to be reset for the first time, you must reboot your
machine.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Verify Impermanence (After Reboot):&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;After the system has rebooted, check if the test directory and file still
exist:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ls -l /imperm_test/testfile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should see an output like &lt;code&gt;ls: cannot access &apos;/imperm_test/testfile&apos;&lt;/code&gt;: No
such file or directory. This confirms that the &lt;code&gt;/imperm_test&lt;/code&gt; directory and its
contents were indeed ephemeral and were removed during the reboot process,
indicating your impermanence setup is working correctly!&lt;/p&gt;
&lt;p&gt;Your system should now come up with a fresh root filesystem, and only the data
specified in your &lt;code&gt;environment.persistence.&quot;/persist&quot;&lt;/code&gt; configuration will be
persistent.&lt;/p&gt;
</content></entry></feed>